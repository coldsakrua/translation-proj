Paragraph ID,Sentence Index,English Sentence,Chinese Sentence
chap1_para1,1,"In which we try to explain why we consider artificial intelligence to be a subject most worthy of study, and in which we try to decide what exactly it is, this being a good thing to decide before embarking.",在本章中，我们将解释为什么我们认为人工智能是一个最值得研究的课题，并试图定义人工智能究竟是什么。
chap1_para1,2,,这是开启人工智能学习之旅之前不错的准备。
chap1_para10,1,•natural language processing to communicate successfully in a human language;,
chap1_para100,1,"The development of brain-machine interfaces (Lebedev and Nicolelis, 2006) for both sensing and motor control not only promises to restore function to disabled individuals, but also sheds light on many aspects of neural systems.",
chap1_para100,2,"A remarkable finding from this work is that the brain is able to adjust itself to interface successfully with an external device, treating it in effect like another sensory organ or limb.",
chap1_para1000,1,,"● 预测（prediction）阶段与无传感器问题相同，计算由动作所导致的信念状态，Result(b, a)。"
chap1_para1000,2,,"为了强调这是一个预测，我们将其记为bˆ = Result(b, a)，其中b上方的“hat”表示“估计值”，我们还可以使用Predict(b, a)代替Result(b, a)。"
chap1_para1001,1,,● 可能感知（possible percept）阶段计算在预测的信念状态下可以观测到的感知集合（用字母o表示观测到的感知）：
chap1_para1002,1,,● 更新（update）阶段为每个可能感知计算其可能得到的信念状态。
chap1_para1002,2,,更新后的信念状态bo是bˆ中可能产生这一感知的状态集合：
chap1_para1003,1,,● 智能体需要在规划阶段处理可能的感知，因为在执行规划之前它不知道实际的感知。
chap1_para1003,2,,注意，在预测阶段，物理环境中的非确定性会扩大信念状态，但每个更新后的信念状态bo不会大于预测的信念状态bˆ；观测到的感知只能帮助减少不确定性。
chap1_para1003,3,,此外，对于确定性感知，不同感知的信念状态是不相交的，从而形成原始预测信念状态的一个划分。
chap1_para1004,1,,图4-15　局部感知真空吸尘器世界中的两个转移实例。
chap1_para1004,2,,"（a）确定性世界中，在初始信念状态下执行Right动作，所得到的新的预测信念状态有两个可能的物理状态；对于这些状态，可能的感知是[R, Dirty]和[R, Clean]，从而得到两种信念状态，每种都只包含一个物理状态。"
chap1_para1004,3,,"（b）光滑世界中，在初始信念状态下执行Right动作，所得到的新的信念状态具有4个物理状态；对于这些状态，可能的感知是[L, Dirty]、[R, Dirty]和[R, Clean]，从而得到图中所示的3种信念状态"
chap1_para1005,1,,综合这3个阶段，我们可以得到由给定动作及后续的可能感知所产生的可能信念状态：
chap1_para1007,1,,4.4.3　求解部分可观测问题
chap1_para1008,1,,4.4.2节介绍了在给定Percept函数的情况下，如何从底层物理问题推导出非确定性信念状态问题的Results函数。
chap1_para1008,2,,使用这一形式化，可以直接应用图4-11的与或搜索算法得到问题的解。
chap1_para1008,3,,"图4-16为局部感知真空吸尘器世界的部分搜索树，假定初始感知为[L, Dirty]。"
chap1_para1008,4,,它的解是一个条件规划：
chap1_para1009,1,,注意，因为我们是在信念状态问题中应用与或搜索算法，所以它返回的条件规划所测试的是信念状态，而非实际状态。
chap1_para1009,2,,这是应该的：在部分可观测环境中，智能体并不知道实际状态。
chap1_para101,1,Brains and digital computers have somewhat different properties.,● 我们应该如何根据自己的偏好做出决定？
chap1_para101,2,Figure 1.,
chap1_para101,3,2 shows that computers have a cycle time that is a million times faster than a brain.,
chap1_para101,4,"The brain makes up for that with far more storage and interconnection than even a high-end personal computer, although the largest supercomputers match the brain on some metrics.",
chap1_para101,5,"Futurists make much of these numbers, pointing to an approaching singularity at which computers reach a superhuman level of performance (Vinge, 1993; Kurzweil, 2005; Doctorow and Stross, 2012), and then rapidly improve themselves even further.",
chap1_para101,6,But the comparisons of raw numbers are not especially informative.,
chap1_para101,7,"Even with a computer of virtually unlimited capacity, we still require further conceptual breakthroughs in our understanding of intelligence (see Chapter 29).",
chap1_para101,8,"Crudely put, without the right theory, faster machines just give you the wrong answer faster.",
chap1_para1010,1,,图4-16　局部感知真空吸尘器世界问题的第一层与或搜索树，Suck是解序列中的第一个动作
chap1_para1011,1,,与标准搜索算法应用于无传感器问题的情况一样，与或搜索算法将信念状态看作和任何其他问题状态一样的黑盒。
chap1_para1011,2,,可以通过检查先前生成的信念状态——它们是当前状态的子集或超集——来改进这一点，就像求解无传感器问题一样。
chap1_para1011,3,,同样可以推导出与无传感器问题中描述的那些算法类似的增量搜索算法。
chap1_para1011,4,,与黑盒方法相比，它们提供了显著的加速。
chap1_para1012,1,,4.4.4　部分可观测环境中的智能体
chap1_para1013,1,,部分可观测环境中的智能体先对问题形式化，接着调用搜索算法（例如And-Or-Search）求解，然后执行解步骤。
chap1_para1013,2,,这种智能体和完全可观测确定性环境中的智能体之间有两个主要区别。
chap1_para1013,3,,首先，问题的解将是一个条件规划而不是一个序列；为了执行if-then-else表达式，智能体需要测试if语句中的条件并执行正确的条件分支。
chap1_para1013,4,,其次，智能体需要在执行动作和接收感知时维护其信念状态。
chap1_para1013,5,,这一过程类似于式（4-5）中的预测-观测-更新过程，但更加简单，因为感知是由环境给出的，而不是由智能体自己计算的。
chap1_para1013,6,,给定初始信念状态b、动作a、感知o，则新的信念状态为
chap1_para1015,1,,考虑一个类幼儿园真空吸尘器世界，智能体只能感知当前方格的状态，任一方格在任一时刻都有可能变脏，除非智能体恰好在那一时刻主动清理该方格。
chap1_para1015,2,,[7]图4-17为此环境中所维护的信念状态。
chap1_para1017,1,,[7]　向那些不熟悉幼儿对环境影响的人表示歉意。
chap1_para1018,1,,在部分可观测环境中——涵盖绝大多数真实世界环境——维护自身的信念状态是任何智能系统的核心功能。
chap1_para1018,2,,这一功能有很多不同的名称，包括监视（monitoring）、过滤（filtering）和状态评估（state estimation）。
chap1_para1018,3,,式（4-6）称为递归状态评估器，因为它根据前一状态计算新的信念状态，而不是检查整个感知序列。
chap1_para1018,4,,如果智能体不想“落后”，计算速度必须和感知进入的速度一样快。
chap1_para1018,5,,随着环境越来越复杂，智能体将只有时间计算近似信念状态，它可能重点关注感知对当前感兴趣的环境方面的影响。
chap1_para1018,6,,关于这一问题的大部分工作都是用概率论的工具处理随机的连续状态的环境，详见第14章。
chap1_para1019,1,,图4-17　在局部感知的类幼儿园真空吸尘器世界中，信念状态维护的两个预测-更新周期
chap1_para102,1,"Description The blocks are rectangular, pyramidal, and square in shape.",● 当其他人可能不支持时，我们应该怎么做？
chap1_para102,2,A thin-walled transparent box with its top open is shown.,
chap1_para102,3,The largest rectangular and pyramidal blocks are kept inside the transparent box.,
chap1_para102,4,"A small square block, two blocks of similar sizes, and a rectangular block that is slightly larger than the two square blocks are kept outside the transparent box.",
chap1_para102,5,A pyramidal block is kept on the small square block and another pyramidal block is kept on one of the two similar-sized blocks.,
chap1_para1020,1,,在本节中，我们将展示一个离散环境中的实例，其传感器是确定性的，动作是非确定性的。
chap1_para1020,2,,这个实例中涉及的机器人具有特定的状态评估任务，该任务称为定位（localization）：即在给定世界地图和一系列感知及行动的情况下，找到自己的位置。
chap1_para1020,3,,机器人放置在图4-18所示的迷宫环境中。
chap1_para1020,4,,它配备了4个声呐传感器，可以判断在4个罗盘方向上是否存在障碍物——外墙或者图中的深色阴影方格。
chap1_para1020,5,,感知以位向量的形式出现，每一位依次代表北、东、南、西方向，所以1011表示北、南、西方向有障碍物。
chap1_para1021,1,,图4-18　机器人的可能位置，⊙，（a）一次观测E1 = 1011后。
chap1_para1021,2,,（b）移动一个方格并进行第二次观测E2 = 1010后。
chap1_para1021,3,,如果传感器没有噪声且转移模型是准确的，那么只有一个可能位置与这两个观测序列一致
chap1_para1022,1,,我们假设传感器所提供的数据完全正确，而且机器人拥有正确的环境地图。
chap1_para1022,2,,但遗憾的是，机器人的导航系统发生故障，所以当它执行Right动作时，会随机移动到一个相邻方格。
chap1_para1022,3,,机器人的任务是确定它的当前位置。
chap1_para1023,1,,假设机器人刚刚启动，并不知道自己的位置——那么它的初始信念状态b为包含所有位置的集合。
chap1_para1023,2,,接着机器人接收到感知1011，并使用公式bo = Update(1011)进行更新，得到如图4-18a所示的4个位置。
chap1_para1023,3,,查看整个迷宫你会发现这是仅有的4个可以产生感知1011的位置。
chap1_para1024,1,,接下来，机器人执行Right动作，但结果是非确定性的。
chap1_para1024,2,,"新的信念状态，ba = Predict(bo, Right)，包含了与bo中的位置相邻的所有位置。"
chap1_para1024,3,,"当接收到第二个感知1010时，机器人执行Update(ba, 1010)，此时信念状态已经只剩图4-18b所示的一个位置。"
chap1_para1024,4,,这是下式得到的唯一位置：
chap1_para1025,1,,对于非确定性动作，Predict阶段信念状态增加，但是Update阶段信念状态又减少回去——只要感知提供了有用的识别信息。
chap1_para1025,2,,有时感知对定位帮助不大：如果存在一个或多个很长的东西向走廊，那么机器人可能会接收到一个很长的1010感知序列，但它永远不会知道它在走廊的哪一位置。
chap1_para1025,3,,但对于地理上存在合理差异的环境，定位往往会迅速收敛到单个点，即使动作是非确定性的。
chap1_para1026,1,,如果传感器发生故障怎么办？
chap1_para1026,2,,如果我们只能用布尔逻辑进行推理，那么我们就无法判断每个传感器位的正误，相当于没有任何感知信息。
chap1_para1026,3,,但我们将看到，概率推理（第12章）允许我们从故障传感器中提取有用信息，只要它出错的时间不超过一半。
chap1_para1027,1,,4.5　在线搜索智能体和未知环境
chap1_para1028,1,,到目前为止，我们主要关注使用离线搜索（offline search）算法的智能体。
chap1_para1028,2,,它们在执行第一个动作之前就已经计算出一个完整的解。
chap1_para1028,3,,相比之下，在线搜索（online search）[8]智能体则交替进行计算和动作：它首先执行一个动作，然后观测环境并计算下一个动作。
chap1_para1028,4,,在线搜索适用于动态或半动态环境，因为在这些环境中停止不动或计算时间太长都要付出代价。
chap1_para1028,5,,在线搜索在非确定性领域也很有用，因为它允许智能体将计算精力集中在实际发生的偶然事件上，而不是那些也许会发生但很可能不会发生的事件。
chap1_para103,1,Figure 1.,● 当收益可能在很遥远的未来时，我们应该怎么做？
chap1_para103,2,"2A crude comparison of a leading supercomputer, Summit (Feldman, 2017); a typical personal computer of 2019; and the human brain.",
chap1_para103,3,"Human brain power has not changed much in thousands of years, whereas supercomputers have improved from megaFLOPs in the 1960s to gigaFLOPs in the 1980s, teraFLOPs in the 1990s, petaFLOPs in 2008, and exaFLOPs in 2018 (1 exaFLOP = 1018 floating point operations per second).",
chap1_para1030,1,,[8]　这里的“在线”指的是必须在接收到输入时立即进行处理的算法，而不是等待整个输入数据集都可用时再进行处理。
chap1_para1030,2,,“在线”的这种用法与“因特网连接”的概念无关。
chap1_para1031,1,,当然，这里需要权衡：智能体提前规划得越多，发现自己陷入困境的频率越低。
chap1_para1031,2,,在未知环境中，智能体不清楚存在什么状态或者动作会产生什么结果，必须使用自身的动作作为实验来了解环境。
chap1_para1032,1,,在线搜索的一个典型实例是地图构建问题（mapping problem）：机器人放置在一个未知建筑中，它必须进行探索以绘制一个从A到B的地图。
chap1_para1032,2,,逃离迷宫的方法——有抱负的古代英雄所需的知识——也是在线搜索算法的实例。
chap1_para1032,3,,然而，空间探索并不是在线探索的唯一形式。
chap1_para1032,4,,以一个新生儿为例：它可能可以做许多举动，却不知道这些动作的后果，而且它只体验过少数几个它能达到的可能状态。
chap1_para1033,1,,4.5.1　在线搜索问题
chap1_para1034,1,,求解在线搜索问题需要交替进行计算、感知和动作。
chap1_para1034,2,,我们首先假设环境是确定性的和完全可观测的（第17章放宽了这些假设），并规定智能体只知道以下内容。
chap1_para1035,1,,● Actions(s)，状态s下的合法动作。
chap1_para1036,1,,"● c(s, a, s')，在状态s下执行动作a到达状态s'的代价。"
chap1_para1036,2,,注意，前提是智能体知道s'是结果。
chap1_para1037,1,,● Is-Goal(s)，目标测试。
chap1_para1038,1,,"特别要注意的是，智能体不能确定Result(s, a)的值，除非它确实在s中执行了a。"
chap1_para1038,2,,"例如，在图4-19所示的迷宫问题中，智能体并不知道从(1, 1)执行Up动作会到达(1, 2)；也不知道再执行Down动作会回到(1, 1)。"
chap1_para1038,3,,在某些应用中可以减少这种无知——例如，机器人探测器可能知道它是如何移动的，只是不知道障碍物的位置。
chap1_para1039,1,,最后，智能体可能可以访问一个可容许的启发式函数h(s)，该函数对从当前状态到目标状态的距离进行估计。
chap1_para1039,2,,例如，在图4-19中，智能体可能知道目标的位置，从而可以使用曼哈顿距离启发式函数（3.6节）。
chap1_para104,1,1.,经济学起源于1776年，当时亚当·斯密（Adam Smith，1723—1790）发表了《国富论》（全名为《国民财富的性质和原因的研究》，An Inquiry into the Nature and Causes of the Weallth of Nations）。
chap1_para104,2,2.,斯密建议将经济视为由许多关注自身利益的独立主体组成，但他并不主张将金融贪婪作为道德立场。
chap1_para104,3,5Psychology,"他在较早的著作《道德情操论》（The Theory of Moral Sentiments）（Smith, 1759）开篇就指出，对他人福祉的关注是每个个体利益的重要组成部分。"
chap1_para1040,1,,图4-19　一个简单的迷宫问题。
chap1_para1040,2,,智能体必须从S出发到达G，但它对环境一无所知
chap1_para1041,1,,通常，智能体的目标是以最小代价到达目标状态。
chap1_para1041,2,,（另一个可能目标是简单地探索整个环境。
chap1_para1041,3,,）代价是智能体在移动过程中产生的总的路径代价。
chap1_para1041,4,,通常将它与智能体事先知道搜索空间时所产生的路径代价（即已知环境中的最优路径）进行比较。
chap1_para1041,5,,在在线算法的术语中，这种比较被称为竞争比（competitive ratio），我们希望它尽可能地小。
chap1_para1042,1,,在线探索器很容易陷入死胡同（dead-end）：无法到达任何目标状态的状态。
chap1_para1042,2,,如果智能体不知道每个动作的后果，它可能会“跳进陷阱”，因此永远无法到达目标。
chap1_para1042,3,,一般来说，没有一种算法能在所有状态空间中都避免进入死胡同。
chap1_para1042,4,,以图4-20a中的两个死胡同状态空间为例。
chap1_para1042,5,,对已经访问过状态S和A的在线搜索算法来说，它无法分辨自己是处于顶部的状态还是底部的状态；根据智能体观测到的感知信息，这两个状态看起来是相同的。
chap1_para1042,6,,因此，它不可能知道如何在两个状态空间中选择正确的动作。
chap1_para1042,7,,这是一个对手论证（adversary argument）的实例——想象对手在智能体探索状态空间时构建状态空间，并将目标和死胡同放在它所选择的任何地方，如图4-20b所示。
chap1_para1043,1,,图4-20　（a）两个可能将在线搜索智能体引入死胡同的状态空间。
chap1_para1043,2,,任何给定智能体都会在至少一个空间中失败。
chap1_para1043,3,,（b）二维环境实例，将导致在线搜索智能体沿着一条任意低效的路线到达目标。
chap1_para1043,4,,无论智能体做出何种选择，对手都会用另一堵很长很薄的墙来阻挡这条路线，这样智能体所走的路径就会比最优可能路径长得多
chap1_para1044,1,,死胡同是机器人探索中的一个真正的难点——楼梯、斜坡、悬崖、单行道甚至自然地形中都存在从它出发某些动作不可逆（irreversible）的状态——没有办法回到之前的状态。
chap1_para1044,2,,我们提出的探索算法只保证在可安全探索（safely explorable）的状态空间中是有效的，也就是说，从每个可达状态出发都存在可以到达的目标状态。
chap1_para1044,3,,所有动作都可逆的状态空间，如迷宫和8数码，显然是可安全探索的（如果它们有解的话）。
chap1_para1044,4,,我们将在22.3.2节中更深入地讨论安全探索的话题。
chap1_para1045,1,,即使在可安全探索的环境中，如果存在代价无界的路径，也不能保证竞争比有界。
chap1_para1045,2,,在动作不可逆的环境中，很容易发现上述结论，但事实上，可逆情况下也是如此，如图4-20b所示。
chap1_para1045,3,,因此，通常会根据整个状态空间的大小来描述在线搜索算法的性能，而不是仅仅根据最浅层目标的深度。
chap1_para1046,1,,4.5.2　在线搜索智能体
chap1_para1047,1,,可观测环境中的在线智能体在每个动作之后都会接收到一个感知，告诉它目前到达了哪一状态，通过这些信息，智能体可以更新它的环境地图。
chap1_para1047,2,,更新后的地图将用于规划下一步。
chap1_para1047,3,,规划和动作交替进行意味着在线搜索算法与之前介绍的离线搜索算法有很大不同：离线算法探索其状态空间模型，而在线算法探索真实世界。
chap1_para1047,4,,例如，A*可以在空间的某部分扩展一个节点，然后马上在空间的另一相距很远的部分扩展另一个节点，因为节点扩展设计的是模拟动作而非真实动作。
chap1_para1048,1,,另外，在线算法只能找到其实际占据的状态的后继。
chap1_para1048,2,,为了避免长途跋涉到一个相距较远的状态来扩展下一个节点，按照局部顺序扩展节点似乎更好。
chap1_para1048,3,,深度优先搜索恰好具有这一性质，因为（如果算法不用回溯）下一个扩展节点是前一个扩展节点的子节点。
chap1_para1049,1,,图4-21为在线深度优先探索智能体（动作是确定性但未知的）。
chap1_para1049,2,,"智能体将它的地图存储在一个result[s, a]表中，记录了在状态s下执行动作a所产生的状态。"
chap1_para1049,3,,"（对于非确定性动作，智能体可以在results[s, a]中记录状态集合。"
chap1_para1049,4,,）只要当前状态存在未探索过的动作，智能体就会尝试其中一个动作。
chap1_para1049,5,,当智能体尝试完某个状态下的所有动作时，问题就来了。
chap1_para1049,6,,在离线深度优先搜索中，我们只是将状态从队列中删除；而在线搜索中，智能体必须在物理世界中回溯。
chap1_para1049,7,,在深度优先搜索中，这意味着回溯到智能体进入当前状态前的最近状态。
chap1_para1049,8,,为了实现这一点，算法需要维护另一个表，表中列出了每个状态尚未回溯到的前驱状态。
chap1_para1049,9,,如果智能体已经没有可回溯的状态，那么搜索就完成了。
chap1_para105,1,•How do humans and animals think and act?,"大多数人认为经济学就是关于钱的，而实际上第一个对不确定性下的决策进行数学分析的是安托万·阿尔诺（Arnauld, 1662）的最大期望值公式，而这一分析也的确是与赌注的货币价值相关。"
chap1_para105,2,,"丹尼尔·伯努利（Bernoulli, 1738）注意到，这个公式似乎不适用于更大规模的金钱，例如对海上贸易远征的投资。"
chap1_para105,3,,于是，他提出了基于期望效用最大化的原则，并指出额外货币的边际效用会随着一个人获得更多货币而减少，从而解释了大众的投资选择。
chap1_para1050,1,,图4-21　使用深度优先探索的在线搜索智能体。
chap1_para1050,2,,智能体只有在每个动作都可以被其他动作“撤消”的状态空间中才能安全地探索
chap1_para1051,1,,我们建议读者在求解图4-19中的迷宫问题时跟踪Online-DFS-Agent的进度。
chap1_para1051,2,,很容易看到，最坏情况下，智能体最终恰好要遍历状态空间中的每个连接两次。
chap1_para1051,3,,对探索来说，这是最优的；但是，对寻找目标来说，如果在初始状态旁边恰好有一个目标状态，智能体的竞争比将变得无限差。
chap1_para1051,4,,在线迭代加深算法可以解决这一问题；对于均衡树环境，这样一个智能体的竞争比是一个很小的常数。
chap1_para1052,1,,由于其回溯方法，Online-DFS-Agent只在动作可逆的状态空间中有效。
chap1_para1052,2,,在一般的状态空间中，有一些更复杂的算法，但是这类算法的竞争比都不是有界的。
chap1_para1053,1,,4.5.3　在线局部搜索
chap1_para1054,1,,与深度优先搜索一样，爬山搜索在节点扩展上也有局部性。
chap1_para1054,2,,事实上，因为爬山搜索在内存中只保存一个当前状态，它已经是在线搜索算法！
chap1_para1054,3,,遗憾的是，基础算法并不适用于探索，因为智能体会陷入局部极大值而无路可走。
chap1_para1054,4,,此外，不能使用随机重启，因为智能体无法将自己瞬移到一个新的初始状态。
chap1_para1055,1,,相比于随机重启，我们可以考虑使用随机游走（random walk）来探索环境。
chap1_para1055,2,,随机游走只是从当前状态中随机选择一个可用动作，可以优先考虑尚未尝试的动作。
chap1_para1055,3,,容易证明，当空间有限且可安全探索时，随机游走最终会找到一个目标或完成探索。
chap1_para1055,4,,[9]但是，这一过程可能非常慢。
chap1_para1055,5,,图4-22为一个环境实例，在这个环境中，随机游走将耗费指数级的步骤来寻找目标，因为对于第一行除S之外的每个状态，后退的可能性是前进的两倍。
chap1_para1055,6,,当然，这个例子是人为设计的，但是真实世界中许多状态空间的拓扑结构都会导致这类随机游走“陷阱”。
chap1_para1057,1,,[9]　随机游走在无限的一维和二维网格上是完备的。
chap1_para1057,2,,"在三维网格上，游走返回起点的概率只有大约0.3405（Hughes, 1995）。"
chap1_para1058,1,,图4-22　环境实例，随机游走需要耗费指数级的步骤来寻找目标
chap1_para1059,1,,事实证明，增加爬山法的内存而非随机性是一种更有效的方法。
chap1_para1059,2,,基本思想是，存储从已访问的每个状态出发到达目标所需代价的“当前最佳估计”H(s)。
chap1_para1059,3,,H(s)开始时只是启发式估计，然后根据智能体在状态空间中获得的经验不断更新。
chap1_para106,1,"The origins of scientific psychology are usually traced to the work of the German physicist Hermann von Helmholtz (1821–1894) and his student Wilhelm Wundt (1832–1920). Helmholtz applied the scientific method to the study of human vision, and his Handbook of Physiological Optics has been described as “the single most important treatise on the physics and physiology of human vision” (Nalwa, 1993, p.15). In 1879, Wundt opened the first laboratory of experimental psychology, at the University of Leipzig. Wundt insisted on carefully controlled experiments in which his workers would perform a perceptual or associative task while introspecting on their thought processes. The careful controls went a long way toward making psychology a science, but the subjective nature of the data made it unlikely that experimenters would ever disconfirm their own theories.",里昂·瓦尔拉斯（Léon Walras，1834—1910）为效用理论提供了一个更为普适的基础，即对任何结果（不仅仅是货币结果）的投机偏好。
chap1_para106,2,,"弗兰克·拉姆齐（Frank Ramsey）（Ramsey, 1931）以及后来约翰·冯·诺伊曼（John von Neumann）和奥斯卡·摩根斯特恩（Oskar Morgenstern）在他们的著作《博弈论与经济行为》（The Theory of Games and Economic Behavior）（Neumann and Morgenstern, 1944）中对这一理论进一步改进。"
chap1_para106,3,,经济学不再是研究金钱的学科，而是对欲望和偏好的研究。
chap1_para1060,1,,图4-23为一维状态空间中的一个简单示例。
chap1_para1060,2,,在图4-23a中，智能体似乎陷入了位于红色状态的局部极小值。
chap1_para1060,3,,智能体不应该停留在原地，而应该根据其邻居节点的当前代价估计值选择到达目标的最优路径。
chap1_para1060,4,,"经由邻居节点s'到达目标的估计代价等于到达s'的代价加上从s'到达目标的估计代价，即c(s, a, s') + H(s')。"
chap1_para1060,5,,在这个示例中，有2个动作，估计代价分别为向左1 + 9，向右1 + 2，因此最好向右移动。
chap1_para1061,1,,在图4-23b中，显然，将图4-23a中红色状态的代价估计为2是过于乐观的。
chap1_para1061,2,,因为最佳移动的代价为1，而且其结果状态离目标状态至少还有2步，所以红色状态离目标一定至少还有3步，所以应该相应地更新红色状态的H，如图4-23b所示。
chap1_para1061,3,,继续上述过程，智能体将再来回移动两次，每次都会更新H并“拉平”局部极小值，直到它逃逸到右侧。
chap1_para1062,1,,能够实现上述方案的智能体称为实时学习A*（learning real-time A*，LRTA*）智能体，如图4-24所示。
chap1_para1062,2,,同Online-DFS-Agent一样，它用result表构建环境地图。
chap1_para1062,3,,它首先更新刚刚离开的状态的代价估计值，然后根据当前的代价估计值选择“显然最佳”移动。
chap1_para1062,4,,一个重要的细节是，在状态s下尚未尝试的动作总是被假定为以最少的可能代价，即h(s)直接到达目标。
chap1_para1062,5,,这种不确定性下的乐观主义（optimism under uncertainty）鼓励智能体去探索新的、可能更有希望的路径。
chap1_para1063,1,,图4-23　一维状态空间上LRTA*的5次迭代。
chap1_para1063,2,,每个状态都标有H(s)，即到达目标的当前代价估计值，每个连接的动作代价为1。
chap1_para1063,3,,红色状态表示智能体的位置，每次迭代所更新的代价估计值以双圈标记
chap1_para1064,1,,图4-24　LRTA*-Agent根据相邻状态的值选择动作，智能体在状态空间中移动时更新状态值
chap1_para1065,1,,LRTA* 智能体保证在任何有限的、可安全探索的环境中都能找到目标。
chap1_para1065,2,,然而，不同于A*，LRTA*在无限状态空间中是不完备的——在某些情况下，它可能被无限地引入歧途。
chap1_para1065,3,,在最坏情况下，探索状态数为n的环境可能需要O(n2)步，但通常情况下会比这种情况好得多。
chap1_para1065,4,,LRTA* 智能体只是一个庞大的在线智能体家族中的一员，可以通过以不同方式指定动作选择规则和更新规则来定义。
chap1_para1065,5,,我们将在第22章中详细讨论这一发源于随机环境的在线智能体家族。
chap1_para1066,1,,4.5.4　在线搜索中的学习
chap1_para1067,1,,在线搜索智能体初始时对环境的无知为我们提供了一些学习的机会。
chap1_para1067,2,,首先，智能体通过记录它们的每一次经验来学习环境“地图”——更准确地说，学习每种状态下每个动作的结果。
chap1_para1067,3,,其次，当智能体以正确的方式探索状态空间时，局部搜索智能体可以利用局部更新规则获得每个状态代价更准确的估计值。
chap1_para1067,4,,一旦知道代价的准确值，只需移动到代价最低的后继状态就能实现最优决策，也就是说，纯粹的爬山法就是一个最优策略。
chap1_para1068,1,,如果按照我们的建议在图4-19的环境中跟踪Online-DFS-Agent的行为，你会注意到智能体不是非常聪明。
chap1_para1068,2,,"例如，在它已经知道Up动作能够从(1, 1)到达(1, 2)后，它仍然不知道Down动作能回到(1, 1)，或者Up动作还能从(2, 1)到(2, 2)，从(2, 2)到(2, 3)，等等。"
chap1_para1068,3,,一般来说，我们希望智能体能够学到，Up在不遇到墙的情况下使得y坐标值增加，Down则使得y坐标值降低，等等。
chap1_para1069,1,,要实现这一点，我们需要做两件事。
chap1_para1069,2,,首先，需要对这类一般规则有一个形式的、可显式操纵的表示；到目前为止，信息都被隐藏在名为Result函数的黑盒中。
chap1_para1069,3,,第8～11章将专门讨论这个问题。
chap1_para1069,4,,其次，需要能够根据智能体所得到的具体观测信息构造合适的一般规则的算法。
chap1_para1069,5,,这些内容将在第19章中讨论。
chap1_para107,1,"Biologists studying animal behavior, on the other hand, lacked introspective data and developed an objective methodology, as described by H. S. Jennings (1906) in his influential work Behavior of the Lower Organisms. Applying this viewpoint to humans, the behaviorism movement, led by John Watson (1878–1958), rejected any theory involving mental processes on the grounds that introspection could not provide reliable evidence. Behaviorists insisted on studying only objective measures of the percepts (or stimulus) given to an animal and its resulting actions (or response). Behaviorism discovered a lot about rats and pigeons but had less success at understanding humans.",决策论（decision theory）结合了概率论和效用理论，为在不确定性下做出个体决策（经济的或其他的）提供了一个形式化完整的框架，也就是说，概率适当地描述了决策者所处的环境。
chap1_para107,2,,这适用于“大型”经济体，在这种经济体中，每个主体都无须关注其他独立主体的行为。
chap1_para107,3,,对“小型”经济体而言更像是一场博弈（game）：一个参与者的行为可以显著影响另一个参与者的效用（积极或消极的）。
chap1_para107,4,,"冯·诺依曼和摩根斯特恩对博弈论（game theory）的发展［也可以参考（Luce and Raiffa, 1957）］得出了令人惊讶的结果，即对于某些博弈，理性智能体应该采用随机（或至少看起来是随机）的策略。"
chap1_para107,5,,与决策论不同，博弈论并没有为行为的选择提供明确的指示。
chap1_para107,6,,人工智能中涉及多个智能体的决策将在多智能体系统（multiagent system）的主题下探讨（第18章）。
chap1_para1070,1,,如果我们预计将来会被要求求解多个类似问题，那么投入时间（和内存）使得这些未来搜索更容易是有意义的。
chap1_para1070,2,,有几种方法可以做到这一点，它们都属于增量搜索（incremental search）的范畴。
chap1_para1070,3,,我们可以将搜索树保留在内存中，并复用在新问题中未发生改变的部分。
chap1_para1070,4,,我们可以保留启发式代价函数h的值，并在获得新信息时更新它们——要么是因为世界发生改变，要么是因为我们计算出了更好的估计值。
chap1_para1070,5,,或者我们可以保留最优路径的g值，用它们拼凑出一个新的解，并在世界发生改变时对它们进行更新。
chap1_para1072,1,,本章讨论了部分可观测的、非确定性的、未知的和连续的环境中问题的搜索算法。
chap1_para1073,1,,● 局部搜索算法，如爬山法，在内存中只保留少量状态。
chap1_para1073,2,,这些方法已被应用于优化问题，其思想是找到一个高分值的状态，而不考虑进入该状态的路径。
chap1_para1073,3,,研究人员已经开发了一些随机局部搜索算法，包括模拟退火，当给定适当的冷却方案时它能返回最优解。
chap1_para1074,1,,● 许多局部搜索方法同样适用于连续空间中的问题。
chap1_para1074,2,,线性规划和凸优化问题服从状态空间形状和目标函数性质上的某些限制，并且允许多项式时间算法，这些算法在实践中往往非常高效。
chap1_para1074,3,,对于一些数学上合式的问题，我们可以使用微积分找到梯度为零的最大值；对于其他问题，我们必须使用经验梯度，即测量两个邻近点间的适应度差值。
chap1_para1075,1,,● 进化算法是一种维护状态种群的随机爬山搜索。
chap1_para1075,2,,通过突变和杂交（结合状态对）产生新状态。
chap1_para1076,1,,● 在非确定性环境中，智能体可以应用与或搜索算法生成应变规划，无论执行过程中出现何种结果，它都能实现目标。
chap1_para1077,1,,● 如果环境是部分可观测的，信念状态表示智能体可能位于的可能状态的集合。
chap1_para1078,1,,● 标准搜索算法可以直接应用于信念状态空间求解无传感器问题，而信念状态与或搜索算法可以求解一般的部分可观测问题。
chap1_para1078,2,,在一个信念状态中逐状态构造解的增量算法通常效率更高。
chap1_para1079,1,,● 探索问题发生在智能体对环境的状态和动作一无所知时。
chap1_para1079,2,,对于可安全探索的环境，在线搜索智能体能够构建地图并找到目标（如果存在的话）。
chap1_para1079,3,,根据经验来更新启发式估计值提供了一种避免局部极小值的有效方法。
chap1_para108,1,"Cognitive psychology, which views the brain as an information-processing device, can be traced back at least to the works of William James (1842–1910). Helmholtz also insisted that perception involved a form of unconscious logical inference. The cognitive viewpoint was largely eclipsed by behaviorism in the United States, but at Cambridge’s Applied Psychology Unit, directed by Frederic Bartlett (1886–1969), cognitive modeling was able to flourish. The Nature of Explanation, by Bartlett’s student and successor Kenneth Craik (1943), forcefully reestablished the legitimacy of such “mental” terms as beliefs and goals, arguing that they are just as scientific as, say, using pressure and temperature to talk about gases, despite gasses being made of molecules that have neither.",经济学家（除了一些例外）没有解决上面列出的第三个问题：当行为的收益不是立即产生的，而是在几个连续的行为后产生时，应该如何做出理性的决策。
chap1_para108,2,,这个课题在运筹学（operations research）的领域探讨，运筹学出现在第二次世界大战期间英国对雷达安装的优化工作中，后来发展出了无数民用应用。
chap1_para108,3,,"理查德·贝尔曼（Richard Bellman）（Bellman, 1957）的工作将一类序贯决策问题进行了形式化，称为马尔可夫决策过程（Markov decision process），我们将在第17章研究该问题，并在第22章以强化学习（reinforcement learning）的主题研究该问题。"
chap1_para1082,1,,第5章　对抗搜索和博弈
chap1_para1083,1,,在本章中，我们将探索有其他智能体计划与我们对抗时的环境。
chap1_para1084,1,,在本章中，我们将讨论竞争环境（competitive environment），在这种环境中，两个或两个以上的智能体具有互相冲突的目标，这引出了对抗搜索（adversarial search）问题。
chap1_para1084,2,,我们将专注于讨论博弈[1]，如国际象棋、围棋和扑克，而不是处理真实世界中的混乱冲突。
chap1_para1084,3,,对人工智能研究人员来说，这些博弈的简化特性是一个优势：博弈状态很容易表示，智能体通常仅能执行少数几个动作，而且动作的效果由明确的规则定义。
chap1_para1084,4,,对于体育比赛（如槌球和冰球），描述更加复杂，可能动作的范围更大，而且定义动作合法性的规则也不够明确。
chap1_para1084,5,,除足球机器人外，体育比赛并没有引起人工智能社区的很大兴趣。
chap1_para1086,1,,[1]　对应英文game在博弈论中译为“博弈”，但在本书中不同语境下会根据具体情况使用博弈、游戏、比赛等。
chap1_para1086,2,,——译者注
chap1_para1088,1,,对于多智能体环境，我们至少可以有3种观点。
chap1_para1088,2,,第一种观点适用于智能体数量非常大的情况，即把它们看作一个经济（economy）整体来考虑，这让我们可以做出例如“需求增长会导致价格上涨”这样的预测，而不需要预测任何个体智能体的动作。
chap1_para1089,1,,第二种观点是，我们可以认为对抗智能体只是环境的一部分——这一部分让环境变成非确定性的。
chap1_para1089,2,,但如果我们以对雨建模一样的方式（例如，雨有时下，有时不下）对对手进行建模，我们就会忽略对手正在积极地尝试击败我们这一事实，而雨没有这样的意图。
chap1_para109,1,"Craik specified the three key steps of a knowledge-based agent: (1) the stimulus must be translated into an internal representation, (2) the representation is manipulated by cognitive processes to derive new internal representations, and (3) these are in turn retranslated back into action.",经济学和运筹学的工作对理性智能体的概念做出了很大贡献，但是多年来的人工智能研究是沿着完全独立的道路发展的。
chap1_para109,2,He clearly explained why this was a good design for an agent:,原因之一是做出理性决策显然是复杂的。
chap1_para109,3,,"人工智能的先驱赫伯特·西蒙（Herbert Simon, 1916—2001）凭借其早期工作在1978年获得了诺贝尔经济学奖，他指出基于满意度（satisficing）的决策模型（做出“够好”的决策，而不是费力地计算最优决策）可以更好地描述实际的人类行为（Simon, 1947）。"
chap1_para109,4,,自20世纪90年代以来，人工智能的决策理论技术重新引起了人们的兴趣。
chap1_para1090,1,,第三种观点是用对抗博弈树搜索技术显式地对对抗智能体建模。
chap1_para1090,2,,这就是本章所涵盖的内容。
chap1_para1090,3,,我们从一类受限的博弈开始，定义最优移动并寻找最优移动的算法——极小化极大搜索（minimax search），它是与或搜索的一种推广（见图4-11）。
chap1_para1090,4,,我们指出，剪枝（pruning）通过忽略搜索树中对最优移动没有影响的部分来提高搜索效率。
chap1_para1090,5,,对于非平凡博弈，我们通常没有足够的时间以确保找到最优移动（即使使用剪枝），我们不得不在某个时刻停止搜索。
chap1_para1091,1,,对于每一个我们选择在那里停止搜索的状态，我们都需要知道谁是获胜者。
chap1_para1091,2,,要回答这个问题，有一个选择：可以基于状态特征应用启发式评价函数来估计谁是获胜者（5.3节），或者可以从该状态开始快速模拟至博弈结束，再取多次模拟结果的平均值（5.4节）。
chap1_para1092,1,,5.5节讨论了包含机会因素（通过掷骰子或洗牌）的博弈，5.6节讨论了不完美信息（imperfect information）博弈（如扑克和桥牌，即并非所有牌对所有玩家都可见）。
chap1_para1094,1,,人工智能领域中最常研究的博弈（例如国际象棋和围棋）是博弈论学者所称的确定性、双人、轮流、完美信息（perfect information）的零和博弈（zero-sum game）。
chap1_para1094,2,,“完美信息”是“完全可观测”的同义词[2]，“零和”意味着对一方有利的东西将对另一方同等程度有害：不存在“双赢”结果。
chap1_para1094,3,,在博弈论中，我们通常用移动（move）作为“动作”（action）的同义词，用局面（position）作为“状态”（state）的同义词。
chap1_para1096,1,,[2]　对应英文player在博弈论中为“参与者”，但在本书中不同语境下会根据具体情况使用参与者、玩家、选手等。
chap1_para1096,2,,——译者注
chap1_para1097,1,,我们将两个参与者[3]分别称为max和min，这么命名的原因稍后解释。
chap1_para1097,2,,max先移动，然后两个参与者轮流移动，直到博弈结束。
chap1_para1097,3,,博弈结束时，获胜者得分，而失败者受到惩罚。
chap1_para1097,4,,可以使用以下元素对博弈进行形式化定义。
chap1_para1099,1,,[3]　一些作者对此进行了区分，用“不完美信息博弈”指扑克之类的游戏，其中玩家将获得其他玩家没有的关于自己手牌的私人信息，而用“部分可观测博弈”指《星际争霸II》之类的游戏，其中每个玩家可以看到其附近的环境，但看不到远处的环境。
chap1_para11,1,•knowledge representation to store what it knows or hears;,[2]　我们并不是在暗示人类是“非理性的”，不是像字典上所说的“被剥夺了正常的心智清晰度”。
chap1_para11,2,,我们只是承认人类的决策在数学上并不总是完美的。
chap1_para110,1,"If the organism carries a “small-scale model” of external reality and of its own possible actions within its head, it is able to try out various alternatives, conclude which is the best of them, react to future situations before they arise, utilize the knowledge of past events in dealing with the present and future, and in every way to react in a much fuller, safer, and more competent manner to the emergencies which face it. (Craik, 1943)",1.2.4　神经科学
chap1_para1100,1,,● S0：初始状态，指定博弈开始时如何设置。
chap1_para1101,1,,● To-Move(s)：在状态s下，轮到其移动的参与者。
chap1_para1102,1,,● Actions(s)：在状态s下，全体合法移动的集合
chap1_para1103,1,,"● Result(s, a)：转移模型，定义状态s下执行动作a所产生的结果状态。"
chap1_para1104,1,,● Is-Terminal(s)：终止测试（terminal test），博弈结束时返回真，否则返回假。
chap1_para1104,2,,博弈结束时的状态称为终止状态（terminal state）。
chap1_para1105,1,,"● Utility(s, p)：效用函数（也称为目标函数或收益函数），定义博弈结束时终止状态s下参与者p得到的最终的数值收益。"
chap1_para1105,2,,在国际象棋中，结果为赢、输或平局，收益分别为1、0或1/2。
chap1_para1105,3,,[4]一些博弈存在更大范围的可能结果，例如，西洋双陆棋的收益范围为0～192。
chap1_para1107,1,,[4]　国际象棋被认为是一种“零和”游戏，尽管两个选手每局游戏的结果之和为+1，而不是0。
chap1_para1107,2,,“常量和”是一个更准确的术语，但“零和”更传统，你可以将其看作每个选手被收取了1/2的入场费。
chap1_para1108,1,,同第3章一样，初始状态、Actions函数和Result函数定义了状态空间图（state space graph）——在图中，顶点表示状态，边表示移动，一个状态可以通过多条路径到达。
chap1_para1108,2,,如第3章所述，我们可以在图的一部分上叠加搜索树（search tree）以确定下一步移动。
chap1_para1108,3,,我们将完整的博弈树（game tree）定义为搜索树，它会记录每个一直到终止状态的移动序列。
chap1_para1108,4,,如果状态空间本身是无界的，或者博弈规则允许局面可以无限次重复，那么博弈树可能是无限的。
chap1_para1109,1,,图5-1为井字棋（圈叉游戏tic-tac-toe）的部分博弈树。
chap1_para1109,2,,从初始状态开始，max有9种可能的移动。
chap1_para1109,3,,游戏交替进行，max放x，min放o，直到到达对应于终止状态的叶节点，即一个玩家占据某一行，或者所有方格都被填满。
chap1_para1109,4,,每个叶节点上的数字是对max来说该终止状态的效用值，值越高对max越有利，对min越不利（这也是玩家名字的由来）。
chap1_para111,1,"After Craik’s death in a bicycle accident in 1945, his work was continued by Donald Broadbent, whose book Perception and Communication (1958) was one of the first works to model psychological phenomena as information processing. Meanwhile, in the United States, the development of computer modeling led to the creation of the field of cognitive science. The field can be said to have started at a workshop in September 1956 at MIT—just two months after the conference at which AI itself was “born.”",● 大脑如何处理信息？
chap1_para1110,1,,对井字棋来说，博弈树相对较小——不超过9!= 362 880个终止节点（只有5478个不同状态）。
chap1_para1110,2,,但是对国际象棋来说，节点数超过1040，所以博弈树被认为是一个在物理世界中无法实现的理论结构。
chap1_para1111,1,,图5-1　井字棋的（部分）博弈树。
chap1_para1111,2,,最上面的节点是初始状态，max先移动，在某个空位上放一个x。
chap1_para1111,3,,我们展示了树的一部分，给出min(o)和max(x)的交替移动，直到最终到达终止状态，根据博弈规则为终止状态分配效用值
chap1_para1112,1,,5.2　博弈中的优化决策
chap1_para1113,1,,max想要找到通往胜利的动作序列，但min不希望max获胜。
chap1_para1113,2,,这意味着max的策略必须是一个条件规划——一个随机应变策略，指定对min的每个可能移动的响应。
chap1_para1113,3,,在具有二元结果（赢或输）的博弈中，我们可以使用与或搜索（4.3.2节）生成条件规划。
chap1_para1113,4,,事实上，对于这类博弈，博弈的获胜策略的定义与非确定性规划问题的解的定义相同：在这两种情况下，无论“另一方”做什么，都必须保证己方能获得理想结果。
chap1_para1113,5,,对于具有多个结果分数的博弈，我们需要一种更一般的算法，即极小化极大搜索。
chap1_para1114,1,,考虑图5-2中的简单博弈。
chap1_para1114,2,,根节点上max的可能移动被标记为a1、a2和a3。
chap1_para1114,3,,min对a1的可能响应为b1、b2、b3等。
chap1_para1114,4,,这个特殊游戏在max和min各移动一次后结束。
chap1_para1114,5,,（注意，在某些游戏中，“move”一词意味着双方都执行了一次移动，因此，ply一词被用来明确表示一个玩家的一次移动，即我们在博弈树中又深入了一层。
chap1_para1114,6,,）博弈中终止状态的效用值范围为2～14。
chap1_para1115,1,,图5-2　二层博弈树。
chap1_para1115,2,,△节点为“max节点”，即轮到max移动，节点为“min节点”。
chap1_para1115,3,,终止节点显示max的效用值，其他节点标记有它们的极小化极大值。
chap1_para1115,4,,max在根节点的最佳移动是a1，因为它指向极小化极大值最高的状态，而min的最佳响应是b1，因为它指向极小化极大值最低的状态
chap1_para1116,1,,给定博弈树，可以通过计算树中每个状态的极小化极大值（minimax value）确定最优策略，记为Minimax(s)。
chap1_para1116,2,,某一状态的极小化极大值是指，假设从该状态到博弈结束两个参与者都以最优策略行动，到达的终止状态对于max的效用值。
chap1_para1116,3,,终止状态的极小化极大值就是它的效用值。
chap1_para1116,4,,在非终止状态下，轮到max移动时，max倾向于移动到极小化极大值最大的状态，而min倾向于移动到极小化极大值最小的状态（对max来说值最小，因此对min来说值最大）。
chap1_para1116,5,,所以有：
chap1_para1117,1,,让我们将上述定义应用于图5-2中的博弈树。
chap1_para1117,2,,底层的终止节点从Utility函数中获取它们的效用值。
chap1_para1117,3,,第一个min节点，标记为B，存在3个后继状态，值分别为3、12和8，因此它的极小化极大值为3。
chap1_para1117,4,,类似地，另外两个min节点的极小化极大值都为2。
chap1_para1117,5,,根节点为max节点，它的后继状态的极小化极大值分别为3、2和2，因此，它的极小化极大值为3。
chap1_para1117,6,,我们还可以在根节点处确定极小化极大决策（minimax decision）：动作a1是max的最优选择，因为它指向极小化极大值最大的状态。
chap1_para1118,1,,max的最优策略假设min也是按照最优策略动作。
chap1_para1118,2,,如果min不按照最优策略动作呢？
chap1_para1118,3,,那么max至少会表现得与它面对最优对手时一样好，甚至可能更好。
chap1_para1118,4,,然而，这并不意味着，面对次优对手时选择极小化极大最优移动总是最好的。
chap1_para1118,5,,考虑这样一种情况，双方均按照最优策略行动，结果为平局，但max有一种冒险的走法，在这种走法导致的状态下，min有10种可能的响应，这些响应似乎都是合理的，但其中9种都会使min输掉游戏，只有1种会使max输掉游戏。
chap1_para1118,6,,如果max认为min没有足够的计算能力找到最优移动，那么max可能会尝试这种冒险的走法，因为9/10的获胜机会要比一个确定的平局好。
chap1_para1119,1,,5.2.1　极小化极大搜索算法
chap1_para112,1,"At the workshop, George Miller presented The Magic Number Seven, Noam Chomsky presented Three Models of Language, and Allen Newell and Herbert Simon presented The Logic Theory Machine. These three influential papers showed how computer models could be used to address the psychology of memory, language, and logical thinking, respectively. It is now a common (although far from universal) view among psychologists that “a cognitive theory should be like a computer program” (Anderson, 1980); that is, it should describe the operation of a cognitive function in terms of the processing of information.",神经科学（neuroscience）是对神经系统（尤其是对大脑）的研究。
chap1_para112,2,,尽管大脑进行思考的确切方式是科学的奥秘之一，但大脑确实是能思考的现实已经被人们接受了数千年，因为有证据表明，对头部的强烈打击会导致精神丧失。
chap1_para112,3,,人们也早就知道人的大脑在某种程度上是不同的，大约在公元前335年，亚里士多德写道：“在所有动物中，人类的大脑与身体大小的比例最大。
chap1_para112,4,,”[10]然而，直到18世纪中叶，大脑才被广泛认为是意识的所在地。
chap1_para112,5,,在此之前，意识所在地的候选位置包括心脏和脾脏。
chap1_para1120,1,,现在我们来计算Minimax(s)，我们可以将其转化为一个搜索算法，即尝试所有动作然后选择其结果状态的Minimax值最大的动作作为max的最佳移动。
chap1_para1120,2,,算法如图5-3所示。
chap1_para1120,3,,这是一种递归算法，它一直向下进行到叶节点，然后随着递归的展开通过搜索树倒推极小化极大值。
chap1_para1120,4,,例如，图5-2中的算法，首先递归到左下角的3个节点，并对它们调用Utility函数，发现它们的值分别为3、12和8。
chap1_para1120,5,,然后选择其中的最小值，3，并将其返回，作为节点B的倒推值。
chap1_para1120,6,,同理可得，C和D的倒推值都为2。
chap1_para1120,7,,最后，我们选择3、2和2中的最大值3作为根节点的倒推值。
chap1_para1121,1,,极小化极大算法对博弈树进行完整的深度优先探索。
chap1_para1121,2,,如果树的最大深度为m，并且在每个点都有b种合法移动，那么极小化极大算法的时间复杂度为O(bm)。
chap1_para1121,3,,对于一次生成所有动作的算法，空间复杂度为O(bm)，对于一次只生成一个动作的算法，空间复杂度为O(m)（见3.4.3节）。
chap1_para1121,4,,指数级的复杂度使得Minimax无法应用于复杂博弈。
chap1_para1121,5,,例如，国际象棋的分支因子约为35，平均深度约为80层，搜索个状态显然是不可行的。
chap1_para1121,6,,然而，Minimax确实是对博弈进行数学分析的基础。
chap1_para1121,7,,通过以各种方式近似极小化极大分析，我们可以推导出更实用的算法。
chap1_para1122,1,,图5-3　使用极小化极大计算最优移动的算法。
chap1_para1122,2,,最优移动是指，在假定对手移动是为了使效用值最小的前提下，使终止状态效用值最大的移动。
chap1_para1122,3,,函数Max-Value和Min-Value遍历整个博弈树直到叶节点，以确定每个状态的倒推值以及如何移动以到达该状态
chap1_para1123,1,,5.2.2　多人博弈中的最优决策
chap1_para1124,1,,许多流行游戏都允许多个玩家参与。
chap1_para1124,2,,让我们来看看如何将极小化极大思想推广到多人博弈中。
chap1_para1124,3,,从技术角度来看，这很自然，但是也产生了一些有趣的新的概念上的问题。
chap1_para1125,1,,首先，我们需要将每个节点的单一值替换为值向量。
chap1_para1125,2,,例如，在玩家A、B和C参与的3人博弈中，每个节点都与一个向量相关联。
chap1_para1125,3,,对于终止状态，这一向量表示每个玩家各自在该状态得到的效用值。
chap1_para1125,4,,（在双人零和博弈中，二元向量可以简化为一个值，因为两个值总是互为相反数。
chap1_para1125,5,,）最简单的实现方法是让Utility函数返回效用值向量。
chap1_para1126,1,,现在我们要考虑非终止状态。
chap1_para1126,2,,考虑图5-4的博弈树中标为X的节点。
chap1_para1126,3,,此时，轮到玩家C选择如何移动。
chap1_para1126,4,,两种选择产生了效用值向量分别为和的两种终止状态，因为6大于3，所以C应该选择第一种移动。
chap1_para1126,5,,这意味着，如果到达状态X，后续的博弈将产生效用值为的终止状态。
chap1_para1126,6,,因此，这个向量就是X的倒推值。
chap1_para1126,7,,一般地，节点n的倒推值是对在该点进行选择的玩家来说效用值最大的后继状态的效用值向量。
chap1_para1127,1,,任何参与多人博弈（如Diplomacy或Settlers of Catan游戏）的参与者都会很快意识到，比起双人博弈，多人博弈要复杂得多。
chap1_para1127,2,,多人博弈通常涉及参与者之间的正式或非正式联盟（alliance）。
chap1_para1127,3,,联盟会随着博弈的发展建立和瓦解。
chap1_para1127,4,,我们如何理解这种行为？
chap1_para1127,5,,联盟是多人博弈中每个参与者都按照最优策略行动的自然结果吗？
chap1_para1127,6,,事实证明的确如此。
chap1_para1128,1,,例如，假设现在A和B处于弱势，而C处于强势。
chap1_para1128,2,,那么，对A和B来说，最理想的做法往往是一起攻击C，而不是彼此攻击，以免C对它们逐个消灭。
chap1_para1128,3,,这样的话，合作其实产生于纯粹的自私行为。
chap1_para1128,4,,当然，一旦C在联合攻击下被削弱，联盟就失去了价值，A或B都有可能违反协议。
chap1_para1129,1,,图5-4　三人博弈的博弈树的前三层，3个玩家为A、B、C。
chap1_para1129,2,,每个节点都标有3个玩家各自的效用值。
chap1_para1129,3,,最佳移动标示在根节点上
chap1_para113,1,"For purposes of this review, we will count the field of human–computer interaction (HCI) under psychology. Doug Engelbart, one of the pioneers of HCI, championed the idea of intelligence augmentation—IA rather than AI. He believed that computers should augment human abilities rather than automate away human tasks. In 1968, Engelbart’s “mother of all demos” showed off for the first time the computer mouse, a windowing system, hypertext, and video conferencing—all in an effort to demonstrate what human knowledge workers could collectively accomplish with some intelligence augmentation.",
chap1_para1130,1,,在某些情况下，显式联盟只是将无论如何都会发生的事情具体化。
chap1_para1130,2,,而在其他情况下，破坏联盟会被记录为社会污点，所以参与者必须权衡破坏联盟所带来的即时优势和失去信任所造成的长期劣势。
chap1_para1130,3,,有关这些复杂问题的更多讨论，详见18.2节。
chap1_para1131,1,,如果博弈不是零和博弈，那么在只有两个参与者时，合作也可能发生。
chap1_para1131,2,,例如，假设存在一个效用值为的终止状态，并且每个参与者最高的可能效用值也是1000。
chap1_para1131,3,,那么最优策略是双方都尽一切可能到达该状态，也就是说，参与者会自动合作以实现共同的期望目标。
chap1_para1133,1,,博弈的状态数关于树的深度是指数量级的。
chap1_para1133,2,,没有一种算法可以完全消除指数项，但有时可以将它减半，即通过剪枝（见3.5.3节）消除对结果没有影响的树的大部分，从而不需要检查所有状态就能计算出正确的极小化极大决策。
chap1_para1133,3,,这种技术称为剪枝（alpha-beta pruning）。
chap1_para1134,1,,再次考虑图5-2中的双层博弈树。
chap1_para1134,2,,让我们再进行一次最优决策的计算，这一次要仔细观察在这个过程中的每个点上都获得了什么信息。
chap1_para1134,3,,步骤如图5-5所示。
chap1_para1134,4,,结果是，我们可以在无须评估其中两个叶节点的情况下就能确定极小化极大决策。
chap1_para1135,1,,另一种考虑这一问题的方式是将Minimax公式简化。
chap1_para1135,2,,假设图5-5中节点C的两个未评估的后继节点的值分别为x和y，则根节点的值为
chap1_para1136,1,,也就是说，根节点的值以及极小化极大决策与叶节点x和y的值无关，因此可以将它们剪枝。
chap1_para1137,1,,剪枝可以应用于任何深度的树，而且通常可以将整个子树而不只是叶节点剪枝。
chap1_para1137,2,,一般原则是：考虑树中某个位置的节点n（见图5-6），玩家可以选择移动到n。
chap1_para1137,3,,如果玩家在树中同一层（如图5-6中的m'）或更上层的任何位置（如图5-6中的m）有更好的选择，那么玩家永远都不愿移动到n。
chap1_para1137,4,,所以，一旦我们对n有了足够的了解（通过检查它的某些后继）来得出上述结论，就可以将它剪枝。
chap1_para1138,1,,图5-5　图5-2中博弈树的最优决策计算过程。
chap1_para1138,2,,每一步都标有每个节点可能的值的范围。
chap1_para1138,3,,（a）B下面的第一个叶节点值为3。
chap1_para1138,4,,因此，作为min节点，B的值最多为3。
chap1_para1138,5,,（b）B下面的第二个叶节点值为12，min将避免移动到该节点，所以B的值仍然最多为3。
chap1_para1138,6,,（c）B下面的第三个叶节点值为8，此时我们已经检查完了B的所有后继状态，所以B的值就是3。
chap1_para1138,7,,现在我们可以推断根节点的值至少是3，因为max在根节点处有值为3的选择。
chap1_para1138,8,,（d）C下面的第一个叶节点值为2。
chap1_para1138,9,,因此，作为min节点，C的值最多为2。
chap1_para1138,10,,但是我们知道B的值为3，所以max永远不会选择C。
chap1_para1138,11,,因此，没有必要再去检查C的其他后继状态。
chap1_para1138,12,,这是剪枝的一个实例。
chap1_para1138,13,,（e）D下面的第一个叶节点值为14，所以D的值最多为14。
chap1_para1138,14,,这仍然高于max的最佳选择（即3），所以我们需要继续探索D的后继状态。
chap1_para1138,15,,注意，此时根节点的所有后继都有界，所以根节点的值也最多为14。
chap1_para1138,16,,（f）D的第二个后继值为5，所以我们又需要继续探索。
chap1_para1138,17,,第三个后继值为2，所以D的值就是2。
chap1_para1138,18,,最终，max在根节点处的决策是移动到值为3的节点B
chap1_para1139,1,,图5-6　剪枝的一般情况。
chap1_para1139,2,,如果对玩家来说m或m'要好于n，那么我们永远都不会在博弈中到达n
chap1_para114,1,"Today we are more likely to see IA and AI as two sides of the same coin, with the former emphasizing human control and the latter emphasizing intelligent behavior on the part of the machine.",[10]　后来人们发现树鼩和一些鸟类的脑体比超过了人类的脑体比。
chap1_para114,2,Both are needed for machines to be useful to humans.,
chap1_para1140,1,,记住，极小化极大搜索是深度优先的，所以在任何时候我们只需考虑树中单个路径上的节点。
chap1_para1140,2,,"剪枝得名于Max-Value(state, , )（见图5-7）中的两个额外参数，它们分别是路径上任何位置的倒推值的下界和上界。"
chap1_para1141,1,,= 到目前为止，路径上发现的max的任一选择点中最佳（即最大值）选择的值。
chap1_para1141,2,,也就是 说， = “至少”。
chap1_para1142,1,,= 到目前为止，路径上发现的min的任一选择点中最佳（即最小值）选择的值。
chap1_para1142,2,,也就是 说， = “至多”。
chap1_para1143,1,,搜索不断更新和的值，并且一旦当前节点的值比此时的（对于max）或（对于min）值更差，就剪掉该节点的剩余分支（即终止递归调用）。
chap1_para1143,2,,完整算法如图5-7所示。
chap1_para1143,3,,图5-5跟踪了博弈树上的算法进程。
chap1_para1144,1,,图5-7　搜索算法。
chap1_para1144,2,,注意，这些函数与图5-3中的Minimax-Search函数相同，除了需要维护变量和，以及在值超出边界时截断搜索
chap1_para1145,1,,5.2.4　移动顺序
chap1_para1146,1,,剪枝的有效性很大程度上依赖于状态的检查顺序。
chap1_para1146,2,,例如，在图5-5e和图5-5f中，根本不能剪掉D的任何后继，因为最差的后继（从min的角度来看）是最先生成的。
chap1_para1146,3,,如果最先生成D的第三个后继，它的值为2，那么我们就可以剪掉另外两个后继。
chap1_para1146,4,,这表明，应该先检查有可能是最佳选择的后继节点。
chap1_para1147,1,,如果能够完美地实现这一点，搜索算法只需要检查个节点就能选出最佳移动，而极小化极大算法需要O(bm)。
chap1_para1147,2,,这意味着有效分支因子从b变为了，对国际象棋来说，大约从35变为了6。
chap1_para1147,3,,换句话说，在相同时间内，拥有完美移动顺序的剪枝可以求解的树的深度大约是极小化极大算法的两倍。
chap1_para1147,4,,如果移动顺序随机，对于适当大小的b，需要检查的节点总数约为。
chap1_para1147,5,,显然我们现在无法实现完美移动顺序，否则，在这种情况下，可以用排序函数玩一个完美的游戏！
chap1_para1147,6,,但通常我们可以非常接近完美。
chap1_para1147,7,,对国际象棋来说，一个非常简单的排序函数（例如，先尝试吃子，然后是威胁，再后是前进和后退）就能让检查的节点数减少到不超过最好情况的大约2倍。
chap1_para1148,1,,增加动态的移动排序方案，例如先尝试之前发现的最佳移动，能让我们非常接近理论极限。
chap1_para1148,2,,“之前”可能指上一次移动（通常面临同样的威胁），也可能来自之前通过迭代加深（见3.4.4节）过程对当前移动的探索。
chap1_para1148,3,,首先，搜索一层并根据它们的评估结果记录这些移动的排名。
chap1_para1148,4,,然后再深入搜索一层，利用之前的排名指导移动顺序，以此类推。
chap1_para1148,5,,由于迭代加深过程而增加的搜索时间可以通过更好的移动顺序来弥补。
chap1_para1148,6,,这些最佳移动称为绝招（killer move），首先尝试绝招称为绝招启发式评价函数。
chap1_para1149,1,,在3.3.3节中，我们指出通往重复状态的冗余路径会导致搜索代价呈指数级增长，而维护一个先前到达状态的表可以解决这个问题。
chap1_para1149,2,,在博弈树搜索中，重复状态的产生是由于换位（transposition）——移动序列的不同排列最终导致相同的局面，这个问题可以通过换位表（transposition table）解决，它将缓存状态的启发式值。
chap1_para115,1,1.,1861年，保罗·布罗卡（Paul Broca，1824—1880）对脑损伤患者中的失语症（语言缺陷）进行了调查研究，他在大脑左半球发现一个局部区域（现在被称为布罗卡氏区域）负责语音的产生，从而开始了对大脑功能组织的研究。
chap1_para115,2,2.,[11]那时，人们已经知道大脑主要由神经细胞或神经元（neuron）组成，但直到1873年，卡米洛·高尔基（Camillo Golgi，1843—1926）才发明了一种可以观察单个神经元的染色技术（见图1-1）。
chap1_para115,3,6Computer engineering,圣地亚哥·拉蒙-卡哈尔（Santiago Ramon y Cajal，1852—1934）在神经组织的开创性研究中使用了该技术。
chap1_para115,4,,[12]现在人们普遍认为认知功能是由这些结构的电化学反应产生的。
chap1_para115,5,,也就是说，一组简单的细胞就可以产生思维、行为和意识。
chap1_para115,6,,"如约翰·希尔勒（John Searle）（Searle, 1992）的精辟名言所说：大脑产生思想。"
chap1_para1150,1,,"例如，假设白方进行了移动w1，而黑方用b1应对，在棋盘的另一边有一个不相关的移动w2，黑方可以用b2应对，我们搜索移动序列[w1, b1, w2, b2]，将其结果状态记为s。"
chap1_para1150,2,,在探索了s下面一棵较大的子树之后，我们找到了它的倒推值，并将其存储在换位表中。
chap1_para1150,3,,"当我们之后搜索移动序列[w2, b2, w1, b1]时，我们再次到达s，这时我们可以在表中查找它的值而无须重复搜索。"
chap1_para1150,4,,在国际象棋中，换位表非常有效，在相同时间内能到达的搜索深度将扩大一倍。
chap1_para1151,1,,即使采用剪枝和精巧的移动顺序，极小化极大算法也不适用于国际象棋和围棋这样的游戏，因为在可用时间内仍然有太多状态需要探索。
chap1_para1151,2,,"在关于计算机博弈的第一篇论文“Programming a Computer for Playing Chess”（Shannon, 1950）中，克劳德·香农意识到这一问题，并提出了两种策略。"
chap1_para1151,3,,A型策略（Type A strategy）考虑搜索树中某一深度的所有可能的移动，然后使用启发式评价函数估计该深度下状态的效用值。
chap1_para1151,4,,它探索了树的宽但浅的部分。
chap1_para1151,5,,B型策略（Type B strategy）舍弃了那些看起来就很差的移动，“尽可能”走那些更有可能的路线。
chap1_para1151,6,,它探索了树的深但窄的部分。
chap1_para1152,1,,历史上，大多数国际象棋程序都是A型策略（我们将在5.3节讨论），而围棋程序通常是B型策略（将在5.4节讨论），因为围棋的分支因子要高得多。
chap1_para1152,2,,"最近，B型程序在各种游戏中都达到了世界冠军级水平，包括国际象棋（Silver et al., 2018）。"
chap1_para1153,1,,5.3　启发式树搜索
chap1_para1154,1,,为了充分利用有限的计算时间，我们可以提前截断搜索，并对状态应用启发式评价函数，从而有效地将非终止节点转变为终止节点。
chap1_para1154,2,,换句话说，我们用Eval函数代替Utility函数，Eval对状态效用值进行估计。
chap1_para1154,3,,用截断测试（cutoff test）代替终止测试，对于终止状态，截断测试必定返回真，但是它可以根据搜索深度和当前状态的任意属性自由决定何时终止搜索。
chap1_para1154,4,,"这样我们得到了搜索深度d处状态s的启发式极小化极大值的计算公式H-Minimax(s, d)："
chap1_para1155,1,,5.3.1　评价函数
chap1_para1156,1,,"就像第3章的启发式函数返回到目标距离的估计值一样，启发式评价函数Eval(s, p)向参与者p返回状态s的期望效用的估计值。"
chap1_para1156,2,,"对于终止状态，一定是Eval(s, p) = Utility(s, p)，而对于非终止状态，估计值必须介于输和赢之间：。"
chap1_para1157,1,,除了满足这些需求之外，一个好的评价函数是由什么组成的？
chap1_para1157,2,,首先，计算时间不能太长！
chap1_para1157,3,,（重点是加快搜索速度。
chap1_para1157,4,,）其次，评价函数应与实际的获胜机会密切相关。
chap1_para1157,5,,你可能会对“获胜机会”一词感到疑惑。
chap1_para1157,6,,毕竟，国际象棋并不是一种碰运气的游戏：我们确定地知道当前的状态，博弈没有任何随机性；如果双方都没有犯错，结果是预先确定的。
chap1_para1157,7,,但是，如果搜索必须在非终止状态截断，那么算法对这些状态的最终结果必然是不确定的（即使这种不确定性可以通过提供无限的计算资源来解决）。
chap1_para1158,1,,让我们把这一思想进一步具体化。
chap1_para1158,2,,大多数评价函数需要计算状态的各种特征（feature），例如，在国际象棋中，我们将拥有白兵数目、黑兵数目、白后数目、黑后数目等特征。
chap1_para1158,3,,这些特征合在一起，定义了状态的各种类别或等价类：同一类别中的状态，对所有特征都具有相同值。
chap1_para1158,4,,例如，某一类别包含所有的“两兵对一兵”残局。
chap1_para1158,5,,任何给定类别都可能包含一些通往（以完美玩法）胜利的状态，一些通往平局的状态和一些通往失败的状态。
chap1_para1159,1,,评价函数不知道到底是处于哪种状态，但它可以返回一个值来估计每个结果的状态比例。
chap1_para1159,2,,例如，假设我们的经验表明，在“两兵对一兵”类中，82%的状态通向胜利（效用值+1），2%导致失败（效用值0），16%为平局（效用值1/2）。
chap1_para1159,3,,那么，该类别中状态的合理评估为期望值（expected value）：(0.82×+1) + (0.02×0) + (0.16×1/2) = 0.90。
chap1_para1159,4,,原则上，可以为每一个状态类确定一个期望值，这样我们就得到了适用于任何状态的评价函数。
chap1_para116,1,•How can we build an efficient computer?,
chap1_para1160,1,,在实践中，这种方法需要分析太多类别，因此需要非常多的经验去估计所有的可能性。
chap1_para1160,2,,与上述方法不同，大多数评价函数会分别计算每个特征的数值贡献，将它们结合起来得到总数值。
chap1_para1160,3,,几个世纪以来，国际象棋棋手们已经提出了一些使用这一思想评估局面价值的方法。
chap1_para1160,4,,例如，国际象棋入门书籍给出了各个棋子的子力价值（material value）估计：兵值1分，马或象值3分，车值5分，后值9分。
chap1_para1160,5,,其他特征，如“好的兵阵”和“王的安全”可能值半个兵。
chap1_para1160,6,,这些特征值简单地相加即可得到局面的评估值。
chap1_para1161,1,,数学上，这种评价函数称为加权线性函数（weighted linear function），因为它可以表示为如下形式：
chap1_para1162,1,,其中fi是局面的某一特征（例如“白象数目”），wi是其权重（表明该特征的重要性）。
chap1_para1162,2,,权重需要归一化，使总和始终保持在输（0）到赢（+1）的范围内。
chap1_para1162,3,,如图5-8a所示，一个兵的确定优势提供了很大的获胜可能性，而3个兵的确定优势则几乎必胜。
chap1_para1162,4,,之前提到，评价函数应与实际的获胜机会密切相关，但并不需要线性相关：如果状态s获胜的可能性是状态s'的两倍，并不意味着Eval(s)必须是Eval(s')的两倍，只需要Eval(s) Eval(s')。
chap1_para1163,1,,将特征的值相加似乎是合理的，但实际上它涉及一个很强的假设：每个特征的贡献独立于其他特征的值。
chap1_para1163,2,,因此，目前的国际象棋和其他游戏程序也会使用特征的非线性组合。
chap1_para1163,3,,例如，一对象的价值可能比单个象价值的两倍还要大，并且在残局时，象比之前价值更大，即当移动数这一特征很大或剩余棋子数这一特征很小时。
chap1_para1164,1,,如何得到特征和权重？
chap1_para1164,2,,它们不属于国际象棋规则，而是来自人类下棋的经验。
chap1_para1164,3,,在没有这种经验的游戏中，评价函数的权重可以通过第22章的机器学习技术来估计。
chap1_para1164,4,,将这些技术应用到国际象棋中，结果表明一个象确实相当于大约3个兵，而且似乎几个世纪的人类经验都可以在短短几小时的机器学习中被复制。
chap1_para1165,1,,图5-8　两个国际象棋局面，只有右下角车的位置不同。
chap1_para1165,2,,在（a）中，黑方有一个马两个兵的优势，这足以取胜。
chap1_para1165,3,,在（b）中，白方将吃掉对方的皇后，这几乎是必胜的优势
chap1_para1166,1,,5.3.2　截断搜索
chap1_para1167,1,,下一步是修改Alpha-Beta-Search，让它在合适的时候调用启发式Eval函数截断搜索。
chap1_para1167,2,,我们把图5-7中提到Is-Terminal的两行代码替换为下面这行代码：
chap1_para1168,1,,我们还必须记录一些信息，这样在每一次递归调用时可以逐渐增加当前的depth。
chap1_para1168,2,,"控制搜索量最直接的方法是设置一个固定的深度限制，这样的话，对所有大于固定深度d的depth（以及所有终止状态），Is-Cutoff(state, depth)都返回true。"
chap1_para1168,3,,深度d的选择取决于分配时间内所选择的移动。
chap1_para1168,4,,更稳健的方法是使用迭代加深（见第3章）。
chap1_para1168,5,,当时间耗尽时，程序将返回最深的已完成搜索所选择的移动。
chap1_para1168,6,,如果在每一轮迭代加深中，我们都维护换位表中的条目，那么作为奖励，后续轮次的速度将加快，我们可以使用评估值改进移动顺序。
chap1_para1169,1,,由于评价函数只是一种近似，这些简单方法可能导致误差。
chap1_para1169,2,,重新考虑象棋中基于子力优势的简单评价函数。
chap1_para1169,3,,假设程序搜索到达了深度限制，例如到达图5-8b中的局面，即黑方多了一个马、两个兵。
chap1_para1169,4,,程序会将其报告为该状态的启发式值，从而认为该状态很可能导致黑方获胜。
chap1_para1169,5,,但其实白方下一步就可以不留退路地吃掉黑方的皇后。
chap1_para1169,6,,因此，这个局面实际上对白方有利，但这只有通过向前看才能知道。
chap1_para117,1,"The modern digital electronic computer was invented independently and almost simultaneously by scientists in three countries embattled in World War II. The first operational computer was the electromechanical Heath Robinson,9 built in 1943 by Alan Turing’s team for a single purpose: deciphering German messages. In 1943, the same group developed the Colossus, a powerful general-purpose machine based on vacuum tubes.10 The first operational programmable computer was the Z-3, the invention of Konrad Zuse in Germany in 1941. Zuse also invented floating-point numbers and the first high-level programming language, Plankalkül. The first electronic computer, the ABC, was assembled by John Atanasoff and his student Clifford Berry between 1940 and 1942 at Iowa State University. Atanasoff’s research received little support or recognition; it was the ENIAC, developed as part of a secret military project at the University of Pennsylvania by a team including John Mauchly and J. Presper Eckert, that proved to be the most influential forerunner of modern computers.","[11]　许多人引用亚历山大·胡德（Alexander Hood）（Hood, 1824）的论文作为可能的先验资料。"
chap1_para1170,1,,评价函数只能应用于静态（quiescent）局面，也就是说，在这些局面中不存在会使评估值大幅度摇摆变化的待定移动（例如吃掉皇后）。
chap1_para1170,2,,对于非静态局面，Is-Cutoff将返回false，并继续搜索直到到达静态局面。
chap1_para1170,3,,这种额外的静态搜索（quiescence search）有时会被进一步限制为只考虑特定类型的移动（例如吃子），它能快速消除当前局面的不确定性。
chap1_para1171,1,,视野效应（horizon effect）则更难消除。
chap1_para1171,2,,它是指程序面临一个将给我方造成严重损失而且基本无法避免的对方移动，但可以使用拖延战术暂时避开。
chap1_para1171,3,,考虑图5-9中的国际象棋局面。
chap1_para1171,4,,很明显，黑象已经无路可逃。
chap1_para1171,5,,例如，白车可以通过依次移动到h1、a1、a2吃掉黑象，在第6步完成吃子。
chap1_para1172,1,,但黑方确实可以采取一系列移动，将象被吃掉这一结果推向“视野”以外。
chap1_para1172,2,,假设黑方搜索深度为8层。
chap1_para1172,3,,黑方的大多数出招都会导致象最终被吃掉，因此被标记为“坏招”。
chap1_para1172,4,,但黑棋也会考虑这样的移动序列，即先用兵来阻挡王，引诱王去吃兵。
chap1_para1172,5,,然后黑方可以同样地处理第二个兵。
chap1_para1172,6,,上述过程占用了太多步，在剩余的搜索步数内，象不会被吃掉。
chap1_para1172,7,,黑方自认为这一策略用两个兵保住了象，但实际上它所做的只是白白浪费了兵，象被吃掉是不可避免的，只是被推到了黑方能搜索到的视野之外。
chap1_para1173,1,,缓解视野效应的一种策略是允许单步延伸（singular extension），该策略是说，即使搜索本应在此状态截断，但是，如果在给定局面中有比其他所有移动都“明显更好”的一种移动，我们就允许算法继续沿着这个移动延伸搜索。
chap1_para1173,2,,在我们的例子中，搜索将发现白车的3次移动——h2到h1，h1到a1，从a1吃掉a2处的象——依次都是明显更好的移动，因此，即使兵的某个移动序列将搜索推到视野之外，这些明显更好的移动将有机会被延伸搜索。
chap1_para1173,3,,这会使树变得更深，但由于单步延伸通常很少，这一策略并不会增加很多节点，在实践中，它已被证明是有效的。
chap1_para1174,1,,图5-9　视野效应。
chap1_para1174,2,,黑方移动后，黑象注定难逃厄运。
chap1_para1174,3,,但是黑方可以用兵来阻挡白方的王，引诱王去吃掉兵。
chap1_para1174,4,,这会将不可避免的象的损失推到视野之外，因此，搜索算法将牺牲兵的这一步看作“好招”
chap1_para1175,1,,5.3.3　前向剪枝
chap1_para1176,1,,剪枝将剪掉对最终评估没有影响的树的分支，但前向剪枝（forward pruning）将剪掉那些看上去很糟糕但也可能实际很好的移动。
chap1_para1176,2,,因此，这一策略以出错风险增大的代价节省了计算时间。
chap1_para1176,3,,用香农的话说，这是B型策略。
chap1_para1176,4,,显然，大多数人类棋手都会这么做，仅考虑每个局面的几步移动（至少是潜意识地）。
chap1_para1177,1,,前向剪枝的一种方法是束搜索（见4.1.3节）：在每一层，只考虑一“束”n个最佳移动（根据评价函数），而不是所有可能的移动。
chap1_para1177,2,,遗憾的是，这种方法相当危险，因为无法保证最佳移动不被剪枝。
chap1_para1178,1,,"ProbCut（概率截断，probabilistic cut）算法（Buro, 1995）是搜索的前向剪枝版本，它使用从先前经验中获得的统计数据来减少最佳移动被剪除的概率。"
chap1_para1178,2,,搜索将剪除所有可证明位于当前窗口之外的节点。
chap1_para1178,3,,ProbCut算法则剪除有可能位于窗口之外的节点。
chap1_para1178,4,,它通过执行浅层搜索计算某个节点的倒推值v，然后利用过去的经验估计树中深度为d的节点的值v位于范围之外的可能性。
chap1_para1178,5,,布罗（Buro）将这种技术应用到了他的黑白棋程序Logistello，发现即使常规版本的黑白棋程序拥有两倍的可用时间，ProbCut版本依然以64%的获胜率击败了常规版本。
chap1_para1179,1,,另一种技术，即后期移动缩减（late move reduction）技术，假设移动顺序已经调整好，因此在可能的移动的列表中后期才出现的移动不太可能是好的移动。
chap1_para1179,2,,这一技术没有将后期的移动完全删除，只是减少了搜索这些移动的深度，从而节省了时间。
chap1_para1179,3,,如果缩减后的搜索返回的值高于当前值，我们可以重新运行全深度搜索。
chap1_para118,1,"Since that time, each generation of computer hardware has brought an increase in speed and capacity and a decrease in price—a trend captured in Moore’s law. Performance doubled every 18 months or so until around 2005, when power dissipation problems led manufacturers to start multiplying the number of CPU cores rather than the clock speed. Current expectations are that future increases in functionality will come from massive parallelism—a curious convergence with the properties of the brain. We also see new hardware designs based on the idea that in dealing with an uncertain world, we don’t need 64 bits of precision in our numbers; just 16 bits (as in the bfloat16 format) or even 8 bits will be enough, and will enable faster processing.",[12]　卡哈尔提出了“神经元学说”，高尔基则坚持他的信念，认为大脑的功能主要是在神经元嵌入的连续介质中发挥的。
chap1_para118,2,,虽然两人共同获得1906年的诺贝尔奖，但发表的获奖感言却是相互对立的。
chap1_para1180,1,,结合本章介绍的所有技术，可以得到一个国际象棋（或其他游戏）程序。
chap1_para1180,2,,我们假设，已经实现了一个国际象棋评价函数——一个使用静态搜索的合理截断测试。
chap1_para1180,3,,我们还假设，经过几个月的努力，可以在最新的个人计算机上每秒生成并评估大约100万个节点。
chap1_para1180,4,,国际象棋的分支因子平均约为35，而355约等于5000万，因此，如果我们使用极小化极大搜索，在大约1分钟的计算时间内只能向前搜索5层。
chap1_para1180,5,,按照比赛规则，我们没有足够的时间去搜索第6层。
chap1_para1180,6,,平均水平的人类棋手就可以击败这样的程序，因为他们偶尔会向前规划6～8步。
chap1_para1181,1,,通过搜索和大型换位表，我们可以向前搜索大约14层，已经到达了专家级水平。
chap1_para1181,2,,我们可以将个人计算机换成一台拥有8个GPU的工作站，每秒可以计算超过10亿个节点，但如果要达到大师级水平，还需要一个经过精心调整的评价函数和一个存储残局招式的大型数据库。
chap1_para1181,3,,像Stockfish这样的顶级国际象棋程序拥有所有这些功能，它在搜索树中通常能达到超过30的深度，远远超过任何一个人类棋手的能力。
chap1_para1182,1,,5.3.4　搜索和查表
chap1_para1183,1,,对一个国际象棋程序来说，开局就考虑一个包含10亿个博弈状态的树似乎有些过犹不及：漫长的搜索得出的结论仅仅是将兵放到e4（最常见的第一步）。
chap1_para1183,2,,"一个世纪以来，许多国际象棋书籍都介绍了如何下好开局和残局（Tattersall, 1911）。"
chap1_para1183,3,,因此，许多游戏程序使用查表而非搜索来处理开局和残局也就不足为奇了
chap1_para1184,1,,对于开局，计算机主要依靠人类的专业知识。
chap1_para1184,2,,可以从书中复制人类专家关于如何打好每个开局的最佳建议并将其输入表中供计算机使用。
chap1_para1184,3,,此外，计算机还可以从以前玩过的游戏的数据库中收集统计数据，以判断哪种开局最容易取胜。
chap1_para1184,4,,最开始的几步可能的局面很少，大多数局面都能存储在表中。
chap1_para1184,5,,通常，移动10～15步后，我们会到达一个很少见到的局面，程序必须从查表切换到搜索。
chap1_para1185,1,,在游戏接近结束时，可能的局面又变少，因此更容易查表。
chap1_para1185,2,,这是计算机的专长：计算机对残局的分析能力远远超过了人类。
chap1_para1185,3,,新手玩家按照一些简单的规则就能在王、车对王（KRK）残局中获胜。
chap1_para1185,4,,而其他残局，例如王、象、马对王（KBNK），则很难掌握，也不存在简明的策略。
chap1_para1186,1,,另外，计算机可以通过生成一种策略完全解决残局问题，这一策略是从每种可能状态到该状态下最佳移动的映射。
chap1_para1186,2,,这样计算机就可以在这个表中查到正确移动从而完美完成棋局。
chap1_para1186,3,,这个表由逆向（retrograde）极小化极大搜索构建：首先考虑在棋盘上放置KBNK的所有方法。
chap1_para1186,4,,有些局面是白方获胜，将它们标为“赢”。
chap1_para1186,5,,然后反转国际象棋规则，做逆向移动。
chap1_para1186,6,,无论黑方的应对是什么，白方的任何一步最终位于“赢”局面的移动，都标为“赢”。
chap1_para1186,7,,继续上述搜索，直到所有可能局面都被解析为赢、输或平局，这样就得到了一个包含所有KBNK残局的准确无误的查询表。
chap1_para1186,8,,这种做法不仅适用于KBNK残局，也适用于所有棋子数不超过7的残局，这样的表格包含400万亿个状态。
chap1_para1186,9,,棋子数为8的表则包含40 000万亿个状态。
chap1_para1187,1,,5.4　蒙特卡罗树搜索
chap1_para1188,1,,对围棋来说，启发式树搜索有两个主要缺点：首先，围棋的分支因子开始时为361，这意味着搜索被限制在4～5层。
chap1_para1188,2,,其次，很难为围棋定义一个好的评价函数，因为子力价值并不是一个强有力的指标，而且大多数状态直到最后阶段都在不断变化。
chap1_para1188,3,,为了应对这两个挑战，现代围棋程序已经放弃了搜索，而是使用一种称为蒙特卡罗树搜索（Monte Carlo tree search，MCTS）的策略。
chap1_para1188,4,,[5]
chap1_para119,1,"We are just beginning to see hardware tuned for AI applications, such as the graphics processing unit (GPU), tensor processing unit (TPU), and wafer scale engine (WSE). From the 1960s to about 2012, the amount of computing power used to train top machine learning applications followed Moore’s law. Beginning in 2012, things changed: from 2012 to 2018 there was a 300,000-fold increase, which works out to a doubling every 100 days or so (Amodei and Hernandez, 2018). A machine learning model that took a full day to train in 2014 takes only two minutes in 2018 (Ying et al., 2018). Although it is not yet practical, quantum computing holds out the promise of far greater accelerations for some important subclasses of AI algorithms.",图1-1　神经细胞或神经元的部分。
chap1_para119,2,,每个神经元都由一个包含神经核的细胞体或体细胞组成。
chap1_para119,3,,许多从细胞体中分支出来的纤维状被称为树突，其中的长纤维被称为轴突。
chap1_para119,4,,轴突伸展的距离很长，比这张图上显示的要长得多。
chap1_para119,5,,轴突一般长1厘米（是细胞体直径的100倍），但也可以达到1米。
chap1_para119,6,,一个神经元在称为突触的连接处与其他10～100 000个神经元建立连接。
chap1_para119,7,,信号通过复杂的电化学反应从一个神经元传递到其他神经元。
chap1_para119,8,,这些信号可以在短期内控制大脑活动，还可以长期改变神经元的连通性。
chap1_para119,9,,这些机制被认为是大脑学习的基础。
chap1_para119,10,,大多数信息都在大脑皮质（大脑的外层）中处理的。
chap1_para119,11,,基本的组织单元似乎是直径约0.5毫米的柱状组织，包含约20 000个神经元，并延伸到整个皮质（人类皮质深度约4毫米）
chap1_para1190,1,,[5]　“蒙特卡罗”算法是以摩纳哥蒙特卡罗赌场命名的随机算法。
chap1_para1191,1,,基本的MCTS策略不使用启发式评价函数。
chap1_para1191,2,,相反，状态值是根据从该状态开始的多次完整博奕模拟（simulation）的平均效用值估算的。
chap1_para1191,3,,一次模拟（也被称为一个playout或rollout）先为一个参与者选择移动，接着为另一个参与者选择，重复上述操作直到到达某个终止局面。
chap1_para1191,4,,这时，博弈规则（而非不可靠的启发式）决定输赢以及比分。
chap1_para1191,5,,对于那些只有输赢两种结果的博弈，“平均效用值”为“获胜百分比”。
chap1_para1192,1,,在模拟中我们如何选择要采取的移动？
chap1_para1192,2,,如果只是随机选择，那么多次模拟之后，我们仅能得到“如果两个参与者都随机选择，那么最佳移动是什么？
chap1_para1192,3,,”这一问题的答案。
chap1_para1192,4,,对于一些简单游戏，这恰好与“如果两名参与者都玩得很好，那么最佳移动是什么？
chap1_para1192,5,,”的答案相同，但对大多数游戏却并非如此。
chap1_para1192,6,,为了从模拟中获得有用信息，我们需要一个模拟策略（playout policy），使其偏向于好的行动。
chap1_para1192,7,,对围棋和其他游戏来说，人们已经使用神经网络成功地从自我对弈中学习到了模拟策略。
chap1_para1192,8,,有时还会根据游戏的不同，使用不同的启发式方法，如国际象棋中的“考虑吃子”，或黑白棋中的“占据角落”。
chap1_para1193,1,,给定了模拟策略，我们接下来需要决定两件事：从什么局面开始模拟，以及分配给每个局面多少次模拟？
chap1_para1193,2,,最简单的答案是纯蒙特卡罗搜索（pure Monte Carlo search），即从博弈当前状态开始做N次模拟，并记录从当前局面开始哪一种可能移动胜率最高。
chap1_para1194,1,,对于一些随机游戏，随着N的增加，这一策略会收敛到最优策略，但对大多数博弈来说，这还不够——我们需要一个选择策略（selection policy），有选择地将计算资源集中在博弈树的重要部分上。
chap1_para1194,2,,选择策略需要平衡两个因素以做出更准确的估计：对那些模拟次数很少的状态的探索（exploration），以及对那些在过去的模拟中表现良好的状态的利用（exploitation）。
chap1_para1194,3,,（有关探索/利用权衡的更多信息，请参阅17.3节。
chap1_para1194,4,,）蒙特卡罗树搜索维护一个搜索树，它在每次迭代（包含以下4个步骤）中不断增长，如图5-10所示。
chap1_para1195,1,,图5-10　使用蒙特卡罗树搜索（MCTS）选择移动的算法的一次迭代，该算法使用“应用于树搜索的置信上界”法（UCT）作为选择度量，此时已完成了100次迭代。
chap1_para1195,2,,（a）选择移动，沿着树一直向下，到标记为27/35（35次模拟中黑方赢了27次）的叶节点结束。
chap1_para1195,3,,（b）扩展所选节点并进行模拟，最终黑方获胜。
chap1_para1195,4,,（c）将模拟结果沿树反向传播
chap1_para1196,1,,● 选择：从搜索树的根节点开始，选择一个移动（在选择策略的指导下），到达一个后继节点，然后重复该过程，沿着树向下移动到叶节点。
chap1_para1196,2,,图5-10a为一棵搜索树，根表示白方刚刚移动的状态，到目前为止，白方已经在100次模拟中赢了37次。
chap1_para1196,3,,粗箭头表示黑方选择的移动，在它指向的节点上黑方赢了60/79次。
chap1_para1196,4,,这是3种移动中最高的胜率，所以选择它是一次利用。
chap1_para1196,5,,但为了探索，选择2/11节点也是合理的——只有11次模拟，该节点的估值仍有很高的不确定性，如果我们获得更多相关信息，它最终可能是最好的。
chap1_para1196,6,,继续选择直到到达标有27/35的叶节点。
chap1_para1197,1,,● 扩展：我们通过为所选节点生成一个新的子节点的方式增长搜索树，图5-10b中展示了标记为0/0的新节点。
chap1_para1197,2,,（一些版本在这一步中会生成多个子节点。
chap1_para1197,3,,）
chap1_para1198,1,,● 模拟：我们从新生成的子节点开始执行一次模拟，根据模拟策略为两个参与者选择移动。
chap1_para1198,2,,这些移动不会记录在搜索树中。
chap1_para1198,3,,在图中，模拟结果为黑方获胜。
chap1_para1199,1,,● 反向传播：我们现在使用模拟结果自底向上地更新所有搜索树节点。
chap1_para1199,2,,因为这次模拟的结果是黑方获胜，所以黑方节点的获胜次数和模拟次数都会增加，27/35变为28/36，60/79变为61/80。
chap1_para1199,3,,因为白方失败，其节点只增加模拟次数，所以16/53变为16/54，根节点的37/100变为37/101。
chap1_para12,1,•automated reasoning to answer questions and to draw new conclusions;,1.1.1　类人行为：图灵测试方法
chap1_para120,1,"Of course, there were calculating devices before the electronic computer. The earliest automated machines, dating from the 17th century, were discussed on page 24. The first programmable machine was a loom, devised in 1805 by Joseph Marie Jacquard (1752–1834), that used punched cards to store instructions for the pattern to be woven.",现在，我们有了一些关于大脑区域和身体部位之间映射关系的数据，这些部位是受大脑控制或者是接收感官输入的。
chap1_para120,2,,这样的映射可以在几周内发生根本性的变化，而有些动物似乎具有多个映射。
chap1_para120,3,,此外，我们还没有完全理解当一个区域受损时其他区域是如何接管其功能的。
chap1_para120,4,,而且，关于个人记忆是如何存储的，或者更高层次的认知功能是如何运作的，目前几乎没有任何相关理论。
chap1_para1200,1,,我们在固定次数的迭代中重复这4个步骤，或者迭代到所分配的时间耗尽，然后返回模拟次数最多的移动。
chap1_para1201,1,,一种非常有效的选择策略称为“应用于树搜索的置信上界”，即UCT。
chap1_para1201,2,,它根据称为UCB1的置信上界公式对每个可能的移动排序。
chap1_para1201,3,,（详见17.3.3节。
chap1_para1201,4,,）对节点n来说，公式为
chap1_para1202,1,,其中U(n)为经过节点n的所有模拟的总效用值，N(n)是经过节点n的模拟次数，Parent(n)是树中n的父节点。
chap1_para1202,2,,因此为利用项，即节点n的平均效用值。
chap1_para1202,3,,带有平方根的项是探索项：分母为N(n)，这意味着对只探索过几次的节点来说，这一项的值比较高；分子记录了我们对n的父节点的探索次数，这意味着，如果我们选择n的概率不是0，那么随着计数的增加，探索项会趋于零，最终模拟次数将被分配给平均效用值最高的节点。
chap1_para1203,1,,C是一个平衡利用和探索的常数。
chap1_para1203,2,,有一种理论认为C应该是，但在实践中，程序员会尝试多个C值，从中选择一个表现最好的。
chap1_para1203,3,,（有些程序则使用一些稍微不同的公式。
chap1_para1203,4,,例如，AlphaZero增加了一个行动概率项，由根据之前的自我对弈训练得到的神经网络计算。
chap1_para1203,5,,）当C = 1.4时，图5-10中60/79节点的UCB1值最高，而当C = 1.5时，2/11节点分值最高。
chap1_para1204,1,,图5-11给出了完整的UCT MCTS算法。
chap1_para1204,2,,当迭代终止时，算法返回模拟次数最多的移动。
chap1_para1204,3,,你可能认为应该返回平均效用值最高的节点，但算法的思想是获胜65/100次的节点优于获胜2/3次的节点，因为后者有很多不确定性。
chap1_para1204,4,,在任何情况下，UCB1公式确保模拟次数最多的节点几乎总是拥有最高的获胜概率，因为随着模拟次数的增加，选择过程将越来越偏向获胜概率。
chap1_para1205,1,,图5-11　蒙特卡罗树搜索算法。
chap1_para1205,2,,首先，初始化博弈树tree，然后重复Select/Expand/Simulate/Back-Propagate的循环，直到时间耗尽，最后返回指向模拟次数最多的节点的移动
chap1_para1206,1,,计算一次模拟结果的时间对博弈树的深度来说是线性的，而不是指数级的，因为在每个选择点上只采用一个移动。
chap1_para1206,2,,这样我们就有足够的时间进行多次模拟。
chap1_para1206,3,,例如，假设有一个分支因子为32的博弈，博弈平均持续100步。
chap1_para1206,4,,如果我们有足够的计算能力可以在执行移动前考虑10亿个博弈状态，那么极小化极大算法可以搜索6层深度，具有完美行动顺序的算法可以搜索12层深度，蒙特卡罗搜索算法可以搜索1000万次模拟。
chap1_para1206,5,,哪种方法更好呢？
chap1_para1206,6,,这取决于所用的启发式函数与选择策略、模拟策略的准确性的高下。
chap1_para1207,1,,传统观点认为，对于围棋这种分支因子非常高（因此搜索不够深）或者很难定义一个好的评价函数的游戏，蒙特卡罗搜索要优于搜索。
chap1_para1207,2,,考虑到对手的目标是最小化得分，搜索将选择指向可实现评价函数得分最高的节点的路径。
chap1_para1207,3,,因此，如果评价函数不准确，搜索也会不准确。
chap1_para1207,4,,对单个节点的错误计算可能导致搜索错误地选择（或避开）指向该节点的路径。
chap1_para1207,5,,而蒙特卡罗搜索依赖于多次模拟的聚合，因此不容易受到单次错误的影响。
chap1_para1207,6,,我们也可以将MCTS和评价函数结合起来：对一定数量的移动进行模拟，然后截断模拟，并在截断的节点上应用评价函数。
chap1_para1208,1,,也可以将搜索和蒙特卡罗搜索结合。
chap1_para1208,2,,例如，在可以持续很多步的博弈中，我们可能希望提前终止模拟（early playout termination），即终止持续太多步的模拟，并使用启发式评价函数对其进行评估，或者干脆宣布平局。
chap1_para1209,1,,蒙特卡罗搜索可以应用于没有任何经验可以用来定义评价函数的全新博弈。
chap1_para1209,2,,只要我们知道博弈规则，蒙特卡罗搜索不需要任何附加信息。
chap1_para1209,3,,选择和模拟策略可以充分利用人工制定的专家知识，也可以通过仅仅使用自我对弈训练得到的神经网络来学习好的策略。
chap1_para121,1,"In the mid-19th century, Charles Babbage (1792–1871) designed two computing machines, neither of which he completed. The Difference Engine was intended to compute mathematical tables for engineering and scientific projects. It was finally built and shown to work in 1991 (Swade, 2000). Babbage’s Analytical Engine was far more ambitious: it included addressable memory, stored programs based on Jacquard’s punched cards, and conditional jumps. It was the first machine capable of universal computation.",1929年，汉斯·伯杰（Hans Berger）发明脑电图仪（EEG），开启了对完整大脑活动的测量。
chap1_para121,2,,"功能磁共振成像（fMRI）的发展（Ogawa et al., 1990; Cabeza and Nyberg, 2001）为神经科学家提供了前所未有的大脑活动的详细图像，从而使测量能够以有趣的方式与正在进行的认知过程相对应。"
chap1_para121,3,,"神经元活动的单细胞电记录技术和光遗传学（optogenetics）方法的进展（Crick, 1999; Zemelman et al., 2002; Han and Boyden, 2007）增强了这些功能，从而可以测量和控制被修改为对光敏感的单个神经元。"
chap1_para1210,1,,当单步移动可以改变游戏进程时，蒙特卡罗搜索存在缺陷，因为蒙特卡罗搜索的随机性意味着它可能不会考虑这一移动。
chap1_para1210,2,,换句话说，蒙特卡罗搜索中的B型剪枝意味着它可能根本没有探索关键路线。
chap1_para1210,3,,当博弈状态“明显”是一方或另一方获胜时（根据人类的知识和评价函数），蒙特卡罗搜索也存在缺陷，它仍然需要模拟很多步来验证获胜者。
chap1_para1210,4,,长期以来，人们一直认为，在国际象棋等具有较低分支因子和较好评价函数的游戏中，搜索更好。
chap1_para1210,5,,但最近，蒙特卡罗方法在国际象棋及其他游戏中也取得了成功。
chap1_para1211,1,,模拟未来的行动，观测结果，并根据结果来确定哪些行动是好的，这样的一般思想其实就是一种强化学习思想，我们将在第22章中介绍。
chap1_para1213,1,,包含随机因素（例如掷骰子）的随机博弈（stochastic game）使我们更接近现实生活的不可预测性。
chap1_para1213,2,,西洋双陆棋是一种典型的运气和技巧相结合的随机游戏。
chap1_para1213,3,,在图5-12的西洋双陆棋局面中，黑方掷出“6-5”，有4种可能走法［每种走法将一个棋子向前（顺时针）移动5步，另一个棋子向前移动6步］。
chap1_para1214,1,,图5-12　一个典型的西洋双陆棋局面。
chap1_para1214,2,,游戏的目标是把自己的所有棋子移出棋盘。
chap1_para1214,3,,黑方向25顺时针移动，白方向0逆时针移动。
chap1_para1214,4,,一个棋子可以移动到任何位置，除非那里有多个对方棋子；如果只有一个对方棋子，对方棋子就会被吃掉，然后必须从起点重新开始。
chap1_para1214,5,,"图中所示的局面，黑棋已经掷出了6-5，必须从(5−11, 5−10)、(5−11, 19−24)、(5−10, 10−16)和(5−11, 11−16)这4种合法移动中选择，其中符号(5−11, 11−16)表示将一个棋子从位置5移动到位置11，另一个棋子从位置11移动到位置16"
chap1_para1215,1,,此时，黑方知道可以走什么棋，但不知道白方会掷出什么，因此也不知道白方的合法移动会是什么。
chap1_para1215,2,,这意味着黑方无法构建我们在国际象棋和井字棋中看到的那种标准博弈树。
chap1_para1215,3,,西洋双陆棋的博弈树除了max和min节点外，还必须包括机会节点（chance node）。
chap1_para1215,4,,机会节点如图5-13中的圆圈所示。
chap1_para1215,5,,从每个机会节点引出的分支表示可能掷出的骰子点数，每个分支都标有掷出的点数及其概率。
chap1_para1215,6,,两个骰子有36种组合，每一种都是等可能的，但是，因为6-5和5-6是一样的，所以只有21种不同的点数组合。
chap1_para1215,7,,6个点数相同的组合（1-1到6-6）的概率都是1/36，即P(1−1) = 1/36。
chap1_para1215,8,,其他15种不同组合的概率都是1/18。
chap1_para1216,1,,图5-13　西洋双陆棋局面的博弈树图解
chap1_para1217,1,,下一步是了解如何做出正确决策。
chap1_para1217,2,,显然，我们仍然想选择能够到达最佳局面的那一步棋。
chap1_para1217,3,,然而，局面没有明确的极小化极大值。
chap1_para1217,4,,我们只能计算局面的期望值（expected value）：机会节点所有可能结果的平均值。
chap1_para1218,1,,可以将确定性博弈的极小化极大值推广为包含机会节点的博弈的期望极小化极大值（expectiminimax value）。
chap1_para1218,2,,终止节点、max节点和min节点的工作方式与之前完全相同（注意，max和min的合法移动取决于前一个机会节点的掷骰子结果）。
chap1_para1218,3,,对于机会节点，我们则计算期望值，即用每个机会动作的概率加权的所有结果的值之和：
chap1_para1219,1,,"其中，r表示可能的掷骰子结果（或其他概率事件），而Result(s, r)仍表示状态s，附加了掷骰子结果r。"
chap1_para122,1,"Babbage’s colleague Ada Lovelace, daughter of the poet Lord Byron, understood its potential, describing it as “a thinking or ... a reasoning machine,” one capable of reasoning about “all subjects in the universe” (Lovelace, 1843). She also anticipated AI’s hype cycles, writing, “It is desirable to guard against the possibility of exaggerated ideas that might arise as to the powers of the Analytical Engine.” Unfortunately, Babbage’s machines and Lovelace’s ideas were largely forgotten.","用于传感和运动控制的脑机接口（brain-machine interface）的发展（Lebedev and Nicolelis, 2006）不仅有望恢复残疾人的功能，还揭示了神经系统许多方面的奥秘。"
chap1_para122,2,,这项工作的一项重要发现是，大脑能够自我调整，使自己成功与外部设备进行交互，就像对待另一个感觉器官或肢体一样。
chap1_para1221,1,,和极小化极大算法一样，可以通过在某点截断搜索并对每个叶节点应用评价函数来近似估计期望极小化极大值。
chap1_para1221,2,,有人可能会认为，西洋双陆棋等游戏的评价函数应该与国际象棋的评价函数类似——更好的局面得分更高。
chap1_para1221,3,,但事实上，机会节点的存在意味着我们必须更加仔细地定义这些值。
chap1_para1222,1,,"图5-14表明：如果评价函数给叶节点分配的值为[1, 2, 3, 4]，那么移动a1是最佳的；如果值为[1, 20, 30, 400]，移动a2是最佳的。"
chap1_para1222,2,,因此，如果我们更改一些评估值，即使优先顺序保持不变，程序的选择也会完全不同。
chap1_para1223,1,,图5-14　在保持叶节点值排序不变的情况下，不同的叶节点赋值改变了最佳移动
chap1_para1224,1,,为了避免这一问题，评价函数应该返回获胜概率（对于结果非输或赢的博弈返回的是期望效用值）的正线性变换值。
chap1_para1224,2,,这是在不确定性下非常重要和普遍的性质，将在第16章进一步讨论。
chap1_para1225,1,,如果程序事先知道游戏接下来的所有掷骰子结果，那么求解有骰子的游戏和求解没有骰子的游戏是一样的，即极小化极大算法的时间复杂度为O(bm)，其中b为分支因子，m为博弈树的最大深度。
chap1_para1225,2,,因为期望极小化极大值还要考虑所有可能的掷骰子序列，它的时间复杂度为O(bmnm)，其中n是掷骰子的不同结果的数目。
chap1_para1226,1,,即使将搜索深度限制在某个很小的值d内，与极小化极大算法相比，额外代价的存在也使得在大多数机会博弈中向前看很远是不现实的。
chap1_para1226,2,,在西洋双陆棋中，n是21，b通常是20左右，但在某些情况下，骰子数翻倍，b可能高达4000。
chap1_para1226,3,,我们大概只能搜索3层。
chap1_para1227,1,,换一种方式考虑这一问题：搜索的优势在于，在采取最佳玩法的情况下它忽略了那些未来不可能发生的情况。
chap1_para1227,2,,因此，它将精力集中于可能发生的情况。
chap1_para1227,3,,但在一个每次移动前都要掷两个骰子的游戏中，没有可能的移动序列，即使是最有可能的移动也只在2/36的情况下出现，因为执行移动的前提是，骰子点数是正确的组合从而使该移动合法。
chap1_para1227,4,,这是不确定性下的一个普遍问题：可能性急剧增多，制定详细的动作规划变得毫无意义，因为世界可能不会朝你规划的方向发展。
chap1_para1228,1,,你可能会想到像剪枝这样的方法也可以应用于包含机会节点的博弈树。
chap1_para1228,2,,事实证明的确可以。
chap1_para1228,3,,对min和max节点的分析不变，但可以用一点聪明才智对机会节点剪枝。
chap1_para1228,4,,考虑图5-13中的机会节点C，以及在计算其子节点时它的值发生了什么变化。
chap1_para1228,5,,在我们检查完C的所有子节点之前是否有可能找到C的上界？
chap1_para1228,6,,（回想一下，这是剪枝剪除某个节点及其子树时需要的。
chap1_para1228,7,,）
chap1_para1229,1,,乍一看，这似乎是不可能的，因为C的值是它子节点值的平均，为了计算一组数字的平均值，我们必须查看所有的数字。
chap1_para1229,2,,但如果限制效用函数的可能值的范围，那么就可以得到平均值的范围而不需要查看每一个数字。
chap1_para1229,3,,例如，假设所有效用值都在−2和+2之间，那么叶节点的值是有界的，反过来，我们就可以在不检查所有子节点的情况下为机会节点的值设置上界。
chap1_para123,1,"AI also owes a debt to the software side of computer science, which has supplied the operating systems, programming languages, and tools needed to write modern programs (and papers about them).",大脑和数字计算机有不同的特性。
chap1_para123,2,"But this is one area where the debt has been repaid: work in AI has pioneered many ideas that have made their way back to mainstream computer science, including time sharing, interactive interpreters, personal computers with windows and mice, rapid development environments, the linked-list data type, automatic storage management, and key concepts of symbolic, functional, declarative, and object-oriented programming.",如图1-2所示，计算机的周期时间比大脑快一百万倍。
chap1_para123,3,,虽然与高端个人计算机相比，大脑拥有更多的存储和互连，但最大的超级计算机在某些指标上已经与大脑相当。
chap1_para123,4,,"未来主义者充分利用这些数字，指出了一个即将到来的奇点（singularity），在这个奇点上计算机达到了超越人类的性能水平（Vinge, 1993; Kurzweil, 2005; Doctorow and Stross, 2012），然后会进一步迅速提高。"
chap1_para123,5,,但是比较原始数字并不是特别有用。
chap1_para123,6,,即使计算机的容量到达无限也无济于事，在理解智能方面仍然需要进一步的概念突破（见第28章）。
chap1_para123,7,,粗略地说，如果没有正确的理论，更快的机器只会更快地给出错误的答案。
chap1_para1230,1,,在机会节点分支因子较高的博弈中——考虑Yahtzee这样的游戏，即每回合掷5个骰子——你可能要考虑前向剪枝，即采样少数几个可能的机会分支。
chap1_para1230,2,,或者，你可能想要完全避免使用评价函数，而选择蒙特卡罗树搜索，其中每次模拟都包含随机掷骰子。
chap1_para1231,1,,5.6　部分可观测博弈
chap1_para1232,1,,博比·费希尔（Bobby Fischer）认为“国际象棋就是战争”，但国际象棋缺少真实战争的一个主要特征——部分可观测性。
chap1_para1232,2,,在《战争之雾》（Fog of War）游戏中，敌人的行踪往往是未知的，除非与他直接接触。
chap1_para1232,3,,因此，战争中常常使用侦察兵和间谍来收集信息，用隐匿处和虚张声势来迷惑敌人。
chap1_para1233,1,,部分可观测游戏也具有这些特征，因此与前文提到的游戏有本质不同。
chap1_para1233,2,,像《星际争霸》这样的电子游戏尤其具有挑战性，因为它是部分可观测、多智能体、非确定性、动态且未知的。
chap1_para1234,1,,在确定性部分可观测博弈中，关于棋盘状态的不确定性完全来自无法获知对手做出的选择。
chap1_para1234,2,,这类博弈包括Battleship（每个玩家战舰的放置位置都对敌人隐藏）和Stratego（棋子的位置已知，但种类隐藏）这样的儿童游戏。
chap1_para1234,3,,我们考虑四国军棋（Kriegspiel）游戏，它是国际象棋的部分可观测变体，即完全看不到对方的棋子。
chap1_para1234,4,,其他游戏也有部分可观测版本：幻影围棋、幻影井字棋和Screen Shogi。
chap1_para1235,1,,5.6.1　四国军棋：部分可观测的国际象棋
chap1_para1236,1,,四国军棋的规则如下：白方和黑方各自只能看到自己一方的棋子。
chap1_para1236,2,,裁判可以看到所有棋子，他对比赛进行判定并定期向双方宣布。
chap1_para1236,3,,首先，白方向裁判提出合法移动（只要位置上没有黑方）。
chap1_para1236,4,,如果该位置有黑方占位，裁判会宣布移动“非法”，白方不断向裁判提出下一步的走法，直到找到一个合法移动——在这个过程中也了解到了黑方的位置。
chap1_para1237,1,,一旦提出了一个合法移动，裁判会宣布以下一项或多项内容：如果在X处有吃子则宣布“在X上吃子”，如果黑王被将军，则宣布“被D将军”，其中D是将军的方向，可以是“马”“行”“列”“长对角线”或“短对角线”。
chap1_para1237,2,,如果黑方被将死或陷入僵局，裁判也会宣布；否则，轮到黑方行棋。
chap1_para1238,1,,四国军棋看起来非常难处理，但人类可以很好地掌握它，计算机程序也开始迎头赶上。
chap1_para1238,2,,回顾4.4节和图4-14中介绍的信念状态的概念——在给定目前为止所有历史感知的情况下，所有逻辑可能的棋盘状态的集合。
chap1_para1238,3,,初始时，白方的信念状态只有一个元素，因为黑方还没有移动。
chap1_para1238,4,,白方下了一步且黑方做出应对后，白方的信念状态就包含了20种局面，因为黑方对白方的任意一种开局都存在20种回应。
chap1_para1239,1,,在游戏过程中跟踪信念状态正是状态评估问题，4.4.4节中的式（4-6）给出了更新步骤。
chap1_para1239,2,,如果我们把对手看作不确定性的来源，那么可以把四国军棋的状态评估直接映射到4.4节的部分可观测的、非确定性的框架中；也就是说，白方所选移动的Results由白方自身移动带来的（可预测）结果和黑方回应给出的不可预测结果组成。
chap1_para1239,3,,[6]
chap1_para124,1,1.,"图1-2　领先的超级计算机Summit（Feldman, 2017）、2019年的典型个人计算机和人类大脑的粗略对比。"
chap1_para124,2,2.,数千年来，人类大脑的能力并没有发生太大变化，而超级计算机的计算能力已经从20世纪60年代的百万次浮点运算（MFLOP）提高到了20世纪80年代的十亿次浮点运算（GFLOP）、20世纪90年代的万亿次浮点运算（TFLOP）、2008年的千万亿次浮点运算（PFLOP）以及2018年的百亿亿次浮点运算（exaFLOP，1 exaFLOP = 1018次浮点运算/秒）
chap1_para124,3,7Control theory and cybernetics,
chap1_para1241,1,,[6]　有时，信念状态会变得非常大以至于无法仅用棋盘状态列表表示，但我们将暂时忽略这个问题，第7章和第8章将介绍大型信念状态的紧凑表示方法。
chap1_para1242,1,,给定当前的信念状态，白方可能会问：“我能赢吗？
chap1_para1242,2,,”对于部分可观测游戏，策略的概念会发生改变，我们不需要规定如何回应对手的每个可能移动，而是需要规定如何回应玩家可能接收到的每种可能感知序列。
chap1_para1243,1,,对四国军棋来说，必胜策略或确保将死（guaranteed checkmate）是指，对于每种可能感知序列和当前信念状态中的每种可能棋盘状态，不管对手如何移动，该策略都会取胜。
chap1_para1243,2,,在这种定义下，对手的信念状态无关紧要——即使对手能看到所有棋子，这一策略也必须奏效。
chap1_para1243,3,,这大大简化了计算。
chap1_para1243,4,,图5-15为KRK（王车对王）残局必胜策略的一部分。
chap1_para1243,5,,在这种情况下，黑方只有一个棋子（王），所以可以通过在单个棋盘上标记黑王的所有可能位置来表示白方的信念状态。
chap1_para1244,1,,如4.4节中所述，可以将一般的与或搜索算法应用于信念状态空间来寻找必胜策略。
chap1_para1244,2,,4.4.2节提到的增量信念状态算法通常能在中盘找到深度高达9的必胜策略——这远远超过了大多数人类棋手的能力。
chap1_para1245,1,,除确保将死之外，四国军棋还存在一个在完全可观测游戏中毫无意义的全新概念：概率将死（probabilistic checkmate）。
chap1_para1245,2,,在信念状态中的每一种棋盘状态下，这种将死都要奏效，而概率一词则来源于获胜玩家移动的随机性。
chap1_para1245,3,,要了解它的基本思想，可以考虑只用白王来捉住黑王的问题。
chap1_para1245,4,,通过简单地随机移动，白王最终一定会吃掉黑王，这是因为，即使黑王总是设法逃跑，它也不可能永远都猜对正确的逃跑方向。
chap1_para1245,5,,在概率论的术语中，这一事件以概率1发生。
chap1_para1246,1,,在这种意义上，KBNK残局——王、象、马对王——一定会赢，白方为黑方提供一个无限的随机选择序列，黑方总是会猜错其中一个，因此暴露自己的位置，然后被将死。
chap1_para1246,2,,另外，KBBK残局的获胜概率是。
chap1_para1246,3,,白方要想获胜，只能移动象（此时这个象不受保护）。
chap1_para1246,4,,如果黑方碰巧在正确的位置上并吃掉了象（如果象是受保护的，那么这步棋就是非法的），游戏就会变成平局。
chap1_para1246,5,,白方可以在一段很长的序列中随机选择一点来走这步险棋，这样会使减小到一个任意小的常数，但无法将减小到零。
chap1_para1247,1,,有时将死策略只对当前信念状态中的某些棋盘状态有效，而对其他状态无效。
chap1_para1247,2,,尝试这种策略可能会成功，导致意外将死（accidental checkmate）。
chap1_para1247,3,,这里的意外是指，如果黑方刚好在特定的位置，白方不会知道自己将会将死对方。
chap1_para1247,4,,（在人类博弈中，大多数将死都是偶然的。
chap1_para1247,5,,）这个想法自然引出了一个问题，给定策略有多大可能获胜，这又引出了一个问题，当前信念状态中的每种棋盘状态有多大可能是真正的棋盘状态。
chap1_para1248,1,,图5-15　KRK残局必胜策略的一部分，图中为缩减后的棋盘。
chap1_para1248,2,,在初始信念状态中，黑王位于3种可能位置之一。
chap1_para1248,3,,通过一系列探索移动，该策略将黑王的范围缩小到其中一种。
chap1_para1248,4,,将死策略的剩余部分留作习题
chap1_para1249,1,,人们的第一倾向可能认为当前信念状态中的所有棋盘状态都是等可能的——但这是错误的。
chap1_para1249,2,,例如，考虑黑方走第一步棋后白方的信念状态。
chap1_para1249,3,,根据定义（假设黑方遵循最优策略），黑方一定采取了最优移动，所以由次优移动产生的所有棋盘状态的概率应该为零。
chap1_para125,1,•How can artifacts operate under their own control?,
chap1_para1250,1,,这一论点也不完全正确，因为每个玩家的目标不仅仅是将棋子移动到正确的方格中，还需要最小化对手能掌握的关于自己位置的信息。
chap1_para1250,2,,遵循任何可预测的“最优”策略都能为对手提供信息。
chap1_para1250,3,,因此，在部分可观测博弈中，最佳玩法需要一定随机性。
chap1_para1250,4,,（这也是餐厅卫生检查员进行随机检查的原因。
chap1_para1250,5,,）这意味着他们偶尔要选择一些“本质上”较差的移动——但他们能从不可预测性上获益，因为对手不大可能为防御这些移动做好准备。
chap1_para1251,1,,从这些考虑来看，似乎只有在给定最优随机策略的情况下，才能计算出当前信念状态中各种棋盘状态的概率；反过来，计算这一策略似乎需要知道棋盘可能处于的各种状态的概率。
chap1_para1251,2,,这个难题可以利用博弈论中均衡解的概念解决，我们将在第17章中进一步探讨。
chap1_para1251,3,,均衡为每个玩家指定了一个最优随机策略。
chap1_para1251,4,,对四国军棋来说，计算均衡的代价太昂贵了。
chap1_para1251,5,,目前，一般四国军棋游戏的有效算法设计是一个开放的研究课题。
chap1_para1251,6,,大多数系统在自己的信念状态空间中执行有限深度的前瞻搜索，而不考虑对手的信念状态。
chap1_para1251,7,,评价函数与完全可观测博弈的评价函数类似，但包含一个新的组成部分，信念状态大小——越小越好！
chap1_para1251,8,,我们将在18.2节的博弈论主题下重新讨论部分可观测博弈。
chap1_para1252,1,,5.6.2　纸牌游戏
chap1_para1253,1,,桥牌、惠斯特牌、红心大战和扑克等纸牌游戏都具有随机的部分可观测性，即无法观测的信息是由随机发牌产生的。
chap1_para1254,1,,乍一看，这些纸牌游戏似乎很像掷骰子：纸牌是随机分配的，并且决定了每个玩家的可能移动，但所有的“掷骰子”都发生在游戏的开始！
chap1_para1254,2,,尽管将纸牌游戏类比为掷骰子是错误的，但它提出了一种算法：将游戏的开始视为一个机会节点，每一种可能的发牌视为一个结果，然后使用Expectiminimax公式选择最佳移动。
chap1_para1254,3,,注意，在这种方法中，唯一的机会节点是根节点；在那之后，游戏则是完全可观测的。
chap1_para1254,4,,这种方法有时被称为观测力平均，因为它假设，一旦发牌实际发生，游戏对双方都是完全可观测的。
chap1_para1254,5,,尽管这种策略在直观上具有吸引力，但有可能让人误入歧途。
chap1_para1254,6,,考虑下面这个故事。
chap1_para1255,1,,第一天：道路A通向一桶金子，道路B通向一个岔路口。
chap1_para1255,2,,你可以看到，岔路口左转是两桶金子，右转则会撞上一辆公共汽车。
chap1_para1256,1,,第二天：道路A通向一桶金子，道路B通向一个岔路口。
chap1_para1256,2,,你可以看到，岔路口右转是两桶金子，左转则会撞上一辆公共汽车。
chap1_para1257,1,,第三天：道路A通向一桶金子，道路B通向一个岔路口。
chap1_para1257,2,,你知道岔路口的一个分支通向两桶金子，另一个分支会撞上一辆公共汽车。
chap1_para1257,3,,遗憾地是，你不知道哪个分支通向金子。
chap1_para1258,1,,观测力平均会得出以下推论：第一天，B是正确选择；第二天，B也是正确选择；第三天，情况和第一天或第二天一样，所以B仍然是正确选择。
chap1_para1259,1,,现在我们可以看出观测力平均为什么会失败：它没有考虑智能体执行行动后所处的信念状态。
chap1_para1259,2,,完全忽略信念状态是不可取的，特别是当其中一种可能性是必死时。
chap1_para1259,3,,因为它假设每种未来状态都自动成为一个完美知识，观测力方法从不选择那些收集信息的行动（例如图5-15中的第一个移动），也不会选择那些向对手隐藏信息或向同伴提供信息的行动，因为它假定对方已经知道这些信息。
chap1_para1259,4,,在扑克游戏中，它永远不会虚张声势（bluff）[7]，因为它假设对手知道自己的牌。
chap1_para1259,5,,在第17章中，我们将介绍如何构造算法解决真正的部分可观测决策问题，得到最优均衡策略（见18.2节）。
chap1_para126,1,"Ktesibios of Alexandria (c. 250 BCE) built the first self-controlling machine: a water clock with a regulator that maintained a constant flow rate. This invention changed the definition of what an artifact could do. Previously, only living things could modify their behavior in response to changes in the environment. Other examples of self-regulating feedback control systems include the steam engine governor, created by James Watt (1736–1819), and the thermostat, invented by Cornelis Drebbel (1572–1633), who also invented the submarine. James Clerk Maxwell (1868) initiated the mathematical theory of control systems.",● 人类和动物是如何思考和行为的？
chap1_para1261,1,,[7]　虚张声势——即使自己的手牌很差，也要装作很好——是扑克策略的核心部分。
chap1_para1262,1,,尽管存在上述缺陷，观测力平均仍是一个有效策略，通过一些技巧可以使其更好地发挥作用。
chap1_para1262,2,,在大多数纸牌游戏中，可能的发牌结果数量都相当大。
chap1_para1262,3,,例如，在桥牌中，每个玩家只能看到四手牌中的两手，剩余两手各包含13张牌，所以可能的发牌结果有= 10 400 600种。
chap1_para1262,4,,即使求解一种发牌结果也是相当困难的，所以求解1000万种更是不可能的。
chap1_para1262,5,,处理这样巨大数目的一种方法是抽象（abstraction）：将相似的手牌视为相同手牌。
chap1_para1262,6,,例如，手牌中的A和K非常重要，但是4或5就不那么重要了，可以将其抽象。
chap1_para1263,1,,另一种处理方法是前向剪枝：只考虑一个小随机样本（样本数为N），再次计算Expectiminimax得分。
chap1_para1263,2,,即使是相当小的N （例如100～1000），这种方法也能提供很好的近似值。
chap1_para1263,3,,它也可以应用于确定性博弈，例如四国军棋（在四国军棋中，我们对游戏的可能的状态进行采样，而不是可能的发牌），只要我们有方法估计每个状态的可能性。
chap1_para1263,4,,除了搜索整个博弈树，使用深度截断进行启发式搜索也很有帮助。
chap1_para1264,1,,到目前为止，我们假设每种发牌结果的可能性相等。
chap1_para1264,2,,对于惠斯特牌和红心大战，这样的假设是有意义的。
chap1_para1264,3,,但是对于桥牌，比赛之前为叫牌阶段，在这个阶段中，每支队伍都会表明它要赢多少。
chap1_para1264,4,,由于玩家是根据自己持有的牌出价，因此其他玩家可以了解到每种发牌结果的概率P(s)。
chap1_para1264,5,,在决定如何玩这手牌时考虑这一点是很难的，原因就像我们在四国军棋的描述中所提到的：玩家在出价时，可能会尽量最小化传达给对手的信息。
chap1_para1265,1,,计算机在扑克牌上的表现已经超出了人类水平。
chap1_para1265,2,,在为期20天的无限注德州扑克比赛中，扑克程序Libratus与4位世界顶尖的扑克玩家展开较量，并果断地将他们全部击败。
chap1_para1265,3,,因为在扑克中存在很多可能状态，Libratus使用抽象法减少状态空间：它可能会认为手牌AAA72和AAA64是等价的（它们都是“3个A和一些小牌”），并且可能认为赌200美元与赌201美元是一样的。
chap1_para1265,4,,但是Libratus也会监视其他玩家，如果它发现他们正在使用抽象法，它会立即做一些额外的计算填补这个漏洞。
chap1_para1265,5,,总的来说，它在超级计算机上耗费了2500万CPU小时才取得胜利。
chap1_para1266,1,,Libratus的计算开销（以及AlphaZero和其他系统的开销）表明，预算有限的研究人员可能无法达到世界冠军水平。
chap1_para1266,2,,从某种程度上来说，这是正确的：就像你不能指望在你的车库里用零部件组装出一辆F1冠军赛车一样，拥有超级计算机或专业硬件（如TPU）是有优势的。
chap1_para1266,3,,训练一个系统时尤其如此，但训练也可以通过众包完成。
chap1_para1266,4,,例如，开源LeelaZero系统是AlphaZero的复现，它通过志愿参与者计算机上的自我对弈进行训练。
chap1_para1266,5,,一旦训练完成，实际比赛中的计算需求是适中的。
chap1_para1266,6,,AlphaStar在使用单个GPU的商用台式计算机上赢得了《星际争霸II》比赛，而AlphaZero也可以在这种模式下运行。
chap1_para1267,1,,5.7　博弈搜索算法的局限性
chap1_para1268,1,,计算复杂博弈中的最优决策是非常困难的，因此所有算法都必须做出一些假设和近似。
chap1_para1268,2,,搜索使用启发式评价函数作为近似，而蒙特卡罗搜索计算随机选择的模拟的近似平均值。
chap1_para1268,3,,选择哪种算法在一定程度上取决于每种博弈的特征：当分支因子较高或评价函数难以定义时，首选蒙特卡罗搜索。
chap1_para1268,4,,但这两种算法都存在其基本的局限性。
chap1_para1269,1,,搜索的一个局限性是它容易受到启发式函数的近似误差的影响。
chap1_para1269,2,,图5-16为一个二层博弈树，极小化极大搜索会选择右边的分支，因为100 99。
chap1_para1269,3,,如果所有的评估值都是精确的，那么这就是正确的选择。
chap1_para1269,4,,但假设每个节点的评估值都有一个独立于其他节点的随机分布的误差，其标准差为s。
chap1_para1269,5,,当s = 5时，实际上71%的情况下是左侧分支更好，当s = 2时，58%的情况下左侧分支更好（因为在这些情况下，右侧分支的4个叶节点之一可能小于99）。
chap1_para1269,6,,如果评价函数中的误差不是独立的，那么发生错误的可能性更大。
chap1_para1269,7,,这是很难避免的，因为我们没有一个很好的兄弟节点值之间依赖关系的模型。
chap1_para127,1,"A central figure in the post-war development of control theory was Norbert Wiener (1894–1964). Wiener was a brilliant mathematician who worked with Bertrand Russell, among others, before developing an interest in biological and mechanical control systems and their connection to cognition. Like Craik (who also used control systems as psychological models), Wiener and his colleagues Arturo Rosenblueth and Julian Bigelow challenged the behaviorist orthodoxy (Rosenblueth et al., 1943). They viewed purposive behavior as arising from a regulatory mechanism trying to minimize “error”—the difference between current state and goal state. In the late 1940s, Wiener, along with Warren McCulloch, Walter Pitts, and John von Neumann, organized a series of influential conferences that explored the new mathematical and computational models of cognition. Wiener’s book Cybernetics (1948) became a bestseller and awoke the public to the possibility of artificially intelligent machines.",科学心理学的起源通常可以追溯到德国物理学家赫尔曼·冯·赫尔姆霍茨（Hermann von Helmholtz，1821—1894）和他的学生威廉·温特（Wilhelm Wundt，1832—1920）的工作。
chap1_para127,2,,"赫尔姆霍茨将科学方法应用于人类视觉的研究，他的Handbook of Physiological Optics被描述为“关于人类视觉的物理学和生理学的最重要的专著”（Nalwa, 1993, p.15）。"
chap1_para127,3,,1879年，温特在莱比锡大学开设了第一个实验心理学实验室。
chap1_para127,4,,温特坚持严格控制的实验，他实验室的工作人员在进行感知或联想任务的同时，内省他们的思维过程。
chap1_para127,5,,严格的控制在很大程度上帮助心理学成为了一门科学，但是数据的主观性质使得实验者不太可能会推翻自己的理论。
chap1_para1270,1,,图5-16　启发式极小化极大算法可能出错的二层博弈树
chap1_para1271,1,,搜索和蒙特卡罗搜索的第二个局限性是，它们都是设计用于计算合法移动的（边界）值的。
chap1_para1271,2,,但有时其中一种移动显然是最佳的（例如，合法移动只有一种），在这种情况下，浪费时间计算它的值是没有意义的——最好是直接选择该移动。
chap1_para1271,3,,更好的搜索算法应该使用节点扩展的效用值的思想，选择效用值高的节点扩展，所谓高效用值的节点是指，有可能导致算法发现一个明显更好的移动。
chap1_para1271,4,,如果没有一个节点扩展的效用值高于它的代价（从时间上考虑），那么算法应该停止搜索并执行一个移动。
chap1_para1271,5,,这不仅适用于存在明显更好移动的情况，也适用于对称情况，在这种情况下，再多的搜索也无法证明一种移动比另一种更好。
chap1_para1272,1,,这种关于计算该做什么的推理叫作元推理（metareasoning）（关于推理的推理）。
chap1_para1272,2,,它不仅适用于博弈，也适用于任意一种推理。
chap1_para1272,3,,所有计算都是为了做出更好的决策，所有计算都有代价，并且都有可能导致决策质量的一定程度上的改进。
chap1_para1272,4,,蒙特卡罗搜索的确尝试进行元推理，将资源分配给树中最重要的部分，但不是以最优方式。
chap1_para1273,1,,第三个局限性是搜索和蒙特卡罗搜索都是在单步移动的层级上进行所有推理的。
chap1_para1273,2,,显然，这与人类玩游戏的方式不同：人类可以在更抽象的层级上进行推理，会考虑更高层级的目标（例如，诱捕对方的后），并使用该目标有选择地生成看似合理的规划。
chap1_para1273,3,,在第11章中，我们将学习这种类型的规划，在11.4节中，我们将介绍如何用从抽象表示到具体表示的层次结构进行规划。
chap1_para1274,1,,第四个问题是能否将机器学习融入博弈搜索过程。
chap1_para1274,2,,早期的游戏程序依靠人类的专业知识人为制定评价函数、开局库、搜索策略和高效技巧。
chap1_para1274,3,,"我们才刚刚开始看到像AlphaZero这样的程序（Silver et al., 2018），它依赖于自我对弈的机器学习，而非人类在特定游戏上的专业知识。"
chap1_para1274,4,,我们将从第19章开始深入探讨机器学习。
chap1_para1276,1,,我们探讨了各种各样的博弈，以理解什么是最佳玩法以及如何在实际中玩好游戏，还了解了智能体在任意类型的对抗性环境中应该如何行动。
chap1_para1276,2,,最重要的思想如下。
chap1_para1277,1,,● 博弈可以由初始状态（棋盘如何设置）、每个状态下的合法动作、每个动作的结果、终止测试（说明什么时候博弈结束）以及应用于终止状态表明输赢和最终比分的效用函数定义。
chap1_para1278,1,,● 在具有完美信息的离散、确定性、轮流的双人零和博弈中，极小化极大算法可以通过对博弈树的深度优先枚举选出最优移动。
chap1_para1279,1,,● 搜索算法可以计算出与极小化极大算法相同的最优移动，通过消除可证明与结果无关的子树来提高效率。
chap1_para128,1,"Meanwhile, in Britain, W. Ross Ashby pioneered similar ideas (Ashby, 1940). Ashby, Alan Turing, Grey Walter, and others formed the Ratio Club for “those who had Wiener’s ideas before Wiener’s book appeared.” Ashby’s Design for a Brain (1948, 1952) elaborated on his idea that intelligence could be created by the use of homeostatic devices containing appropriate feedback loops to achieve stable adaptive behavior.","另外，研究动物行为的生物学家缺乏内省的数据，于是发展了一种客观的方法，赫伯特·詹宁斯（Herbert S. Jennings）（Jennings, 1906）在他有影响力的著作Behavior of the Lower Organisms中对此进行了描述。"
chap1_para128,2,,约翰·沃森（John Watson，1878—1958）领导的行为主义（behaviorism）运动将这一观点应用于人类，以内省无法提供可靠证据为由，拒绝任何涉及心理过程的理论。
chap1_para128,3,,行为主义者坚持只研究施加动物的感知（或刺激）及其产生的行为（或反应）的客观度量。
chap1_para128,4,,行为主义发现了很多关于老鼠和鸽子的知识，但是在理解人类方面却不太成功。
chap1_para1280,1,,● 通常，考虑整个博弈树是不可行的（即使是搜索），所以我们需要在某个点截断搜索，然后应用启发式评价函数估计状态的效用值。
chap1_para1281,1,,● 蒙特卡罗树搜索（MCTS）则是另一种方法，它不是通过应用启发式函数来评估状态，而是通过将游戏模拟到结束使用游戏规则来判断输赢。
chap1_para1281,2,,因为在模拟过程中选择的移动可能不是最优移动，所以这个过程需要重复多次，对结果求平均值作为评估值。
chap1_para1282,1,,● 许多游戏程序会预先计算开局和残局的最佳移动表，这样它们就可以直接查表而不用搜索。
chap1_para1283,1,,● 机会博弈可以通过期望极小化极大算法（极小化极大算法的扩展）来处理，该算法通过计算所有子节点的平均效用值并按每个子节点的概率加权来估计机会节点的平均效用值。
chap1_para1284,1,,● 在不完美信息博弈中，例如四国军棋和扑克，最佳玩法需要对每个玩家当前和将来的信念状态进行推理。
chap1_para1284,2,,可以通过对缺失信息的每种可能配置上的动作值取平均得到一个简单的近似。
chap1_para1285,1,,● 在国际象棋、跳棋、黑白棋、围棋、扑克及许多其他游戏中，程序已经彻底击败了人类冠军选手。
chap1_para1285,2,,在一些不完美信息博弈中人类仍然保持优势，如桥牌和四国军棋。
chap1_para1285,3,,在像《星际争霸》和《刀塔2》这样的电子游戏中，程序可以与人类专家媲美，但它们的成功可能一部分要归功于它们可以快速执行许多动作的能力。
chap1_para1288,1,,第6章　约束满足问题
chap1_para1289,1,,在本章中，我们不把状态仅仅当作小黑盒，从而导出新的搜索方法和对问题结构的更深入理解。
chap1_para129,1,"Modern control theory, especially the branch known as stochastic optimal control, has as its goal the design of systems that minimize a cost function over time. This roughly matches the standard model of AI: designing systems that behave optimally. Why, then, are AI and control theory two different fields, despite the close connections among their founders? The answer lies in the close coupling between the mathematical techniques that were familiar to the participants and the corresponding sets of problems that were encompassed in each world view. Calculus and matrix algebra, the tools of control theory, lend themselves to systems that are describable by fixed sets of continuous variables, whereas AI was founded in part as a way to escape from these perceived limitations. The tools of logical inference and computation allowed AI researchers to consider problems such as language, vision, and symbolic planning that fell completely outside the control theorist’s purview.",认知心理学（cognitive psychology）认为大脑是一个信息处理设备，这至少可以追溯到威廉·詹姆斯（William James，1842—1910）的著作。
chap1_para129,2,,赫尔姆霍茨也坚持认为感知涉及一种无意识的逻辑推断形式。
chap1_para129,3,,在美国，认知观点在很大程度上被行为主义所掩盖，但在弗雷德里克·巴特利特（Frederic Bartlett，1886—1969）所领导的剑桥大学应用心理学系，认知模型得以蓬勃发展。
chap1_para129,4,,"巴特利特的学生和继任者肯尼斯·克雷克（Kenneth Craik）（Craik, 1943）所著的The Nature of Explanation强有力地重新确立了诸如信念和目标之类的“精神”术语的合法性，认为它们就像用压力和温度来讨论气体一样科学，尽管气体是由既不具有压力又不具有温度的分子组成。"
chap1_para1290,1,,第3章和第4章讨论了通过搜索状态空间进行问题求解的思想：状态空间是一个由节点表示状态，边表示动作的图。
chap1_para1290,2,,我们看到，领域特定的启发式算法可以估计从给定状态到达目标的代价，但从搜索算法的角度来看，每个状态都是原子的，即不可分割的——一个没有内部结构的黑盒。
chap1_para1290,3,,对于每个问题，我们需要领域特定的代码来描述状态之间的转移。
chap1_para1291,1,,在本章中，我们通过对每个状态使用因子化表示（factored representation）来打破黑盒：因子化表示为一组变量，每个变量都有自己的值。
chap1_para1291,2,,当每个变量的值都满足对该变量的所有约束时，问题就解决了。
chap1_para1291,3,,以上述方式描述的问题称为约束满足问题（constraint satisfaction problem，CSP）。
chap1_para1292,1,,CSP搜索算法利用了状态结构的优势，并且使用通用的而不是领域特定的启发式算法来求解复杂问题。
chap1_para1292,2,,其主要思想是，通过识别违反约束的变量/值组合来一次性消除大部分搜索空间。
chap1_para1292,3,,CSP的另一个优势是可以从问题描述中推导出行动和转移模型。
chap1_para1293,1,,6.1　定义约束满足问题
chap1_para1294,1,,约束满足问题由3个部分组成，即X、D和C。
chap1_para1296,1,,● D是域集合，，每个变量有一个域。
chap1_para1297,1,,● C是约束集合，用来规定允许的值的组合。
chap1_para1298,1,,域Di，由变量Xi的一组允许的值组成。
chap1_para1298,2,,例如，布尔变量的域为。
chap1_para1298,3,,不同变量可以有不同大小的域。
chap1_para1298,4,,每个约束Cj由对组成，其中scope是该约束中的变量元组，而rel定义了这些值应该满足的关系（relation）。
chap1_para1298,5,,关系可以表示为满足约束的所有元组值的显式集合，或者表示为判断一个元组是否为关系成员的函数。
chap1_para1298,6,,"例如，如果X1和X2的域都是{1, 2, 3}，那么约束“X1必须大于X2”可以表示为或。"
chap1_para1299,1,,CSP要处理变量赋值（assignment）问题，即。
chap1_para1299,2,,不违反任何约束的赋值称为一致（consistent）或合法赋值。
chap1_para1299,3,,完整赋值（complete assignment）是指每个变量都已被赋值；CSP的解（solution）是一致完整赋值。
chap1_para1299,4,,部分赋值（partial assignment）是指某些变量还未赋值，而部分解（partial solution）是一致部分赋值。
chap1_para1299,5,,一般来说，CSP求解是NP完全问题，尽管CSP的一些重要子类已经可以非常高效地求解。
chap1_para13,1,•machine learning to adapt to new circumstances and to detect and extrapolate patterns.,"图灵测试（Turing test）是由艾伦·图灵（Alan Turing）提出的（Turing, 1950），它被设计成一个思维实验，用以回避“机器能思考吗？"
chap1_para13,2,,”这个哲学上模糊的问题。
chap1_para13,3,,如果人类提问者在提出一些书面问题后无法分辨书面回答是来自人还是来自计算机，那么计算机就能通过测试。
chap1_para13,4,,在第27章中，我们会讨论图灵测试的细节，以及一台通过图灵测试的计算机是否真的具备智能。
chap1_para13,5,,目前，为计算机编程使其能够通过严格的应用测试尚有大量工作要做。
chap1_para13,6,,计算机需要具备下列能力：
chap1_para130,1,1.,克雷克指出了知识型智能体的3个关键步骤：（1）刺激必须转化为一种内在表示；（2）认知过程处理表示，从而产生新的内部表示；（3）这些过程反过来又被重新转化为行为。
chap1_para130,2,2.,他清晰地解释了为什么这是一个良好的智能体设计：
chap1_para130,3,8Linguistics,
chap1_para1300,1,,6.1.1　问题示例：地图着色
chap1_para1301,1,,也许你已经逛够了罗马尼亚，现在来看看澳大利亚地图（如图6-1a所示）[1]，地图显示了澳大利亚的州和地区，分别是：西澳大利亚州（Western Australia）、北部地区（North Territory）、昆士兰州（Queensland）、新南威尔士州（New South Wales）、维多利亚州（Victoria）、南澳大利亚州（South Australia）、塔斯马尼亚州（Tasmania）、澳大利亚首都直辖区（Australia Capital Territory）。
chap1_para1301,2,,我们的任务是给每个区域涂上红色、绿色或蓝色，要求相邻的两个区域颜色不能相同。
chap1_para1301,3,,[2]为了将其形式化为CSP，我们将图中的区域定义为变量，变量名为各区域的英文名缩写：
chap1_para1303,1,,[1]　本图系原书原图。
chap1_para1304,1,,[2]　本书未将澳大利亚首都直辖区作为一个待着色区域，这使该地图着色问题更简洁明晰。
chap1_para1304,2,,——编者注
chap1_para1305,1,,每个变量的域为集合。
chap1_para1305,2,,约束要求相邻区域颜色不同。
chap1_para1305,3,,由于相邻区域的边界线有9段，所以有9个约束：
chap1_para1306,1,,这里我们使用缩写。
chap1_para1306,2,,是的缩写，其中可以依次完整枚举为：
chap1_para1307,1,,这个问题有很多可能的解，例如：
chap1_para1308,1,,将CSP可视化为约束图（constraint graph）非常有用，如图6-1b所示。
chap1_para1308,2,,图的节点对应于问题的变量，图的边连接同一约束中的任意两个变量。
chap1_para1309,1,,为什么要将问题形式化为CSP呢？
chap1_para1309,2,,第一个原因是CSP可以自然地表示各种问题，将一个问题形式化为CSP通常很容易；第二个原因是多年的研究工作使得CSP求解器快速而高效；第三个原因是相比于原子的状态空间搜索器，CSP求解器可以快速消除大面积搜索空间。
chap1_para1309,3,,例如，一旦我们在澳大利亚问题中选择了，就可以得出结论，它的5个相邻变量都不能取值为blue。
chap1_para1309,4,,不使用约束的搜索过程必须考虑这5个相邻变量的35 = 243种赋值；有了约束，我们只需考虑25 = 32种赋值，计算量减少了87%。
chap1_para131,1,•How does language relate to thought?,如果有机体拥有一个“小规模的模型”，建模了外部现实及其在脑海中可能采取的行为，那么它就能够尝试各种选择，得出哪个是最好的，并在未来出现情况之前加以应对。
chap1_para131,2,,有机体可以利用过去的知识处理现在和未来的情况，并在各方面以更全面、更安全、更有力的方式应对紧急情况。
chap1_para131,3,,"（Craik, 1943）"
chap1_para1310,1,,图6-1　（a）澳大利亚的州和地区。
chap1_para1310,2,,对该地图着色可以看作约束满足问题（CSP）。
chap1_para1310,3,,目标是为每个区域分配颜色，使得相邻区域颜色不同。
chap1_para1310,4,,（b）用约束图表示地图着色问题
chap1_para1311,1,,在原子的状态空间搜索中，我们只能问：这个特定状态是目标状态吗？
chap1_para1311,2,,不是？
chap1_para1311,3,,那么这一个呢？
chap1_para1311,4,,使用CSP，一旦发现某个部分赋值违反了约束，我们可以马上放弃对该部分赋值的进一步改进。
chap1_para1311,5,,此外，我们可以看出为什么某个赋值不是解——可以看出哪些变量违反了约束——从而把注意力集中在关键变量上。
chap1_para1311,6,,因此，许多原子状态空间搜索难以求解的问题形式化为CSP后都可以快速求解。
chap1_para1312,1,,6.1.2　问题示例：车间作业调度
chap1_para1313,1,,工厂有很多日常工作调度问题，要满足各种约束。
chap1_para1313,2,,在实践中，使用CSP技术可以求解很多这样的问题。
chap1_para1313,3,,考虑汽车装配调度问题。
chap1_para1313,4,,整个作业由不同任务组成，我们可以将每个任务建模成一个变量，其中每个变量的值为任务开始时间，由整数分钟数表示。
chap1_para1313,5,,约束为“一个任务必须在另一个任务之前完成”（例如，安装车轮必须在安装轮毂盖之前完成）和“一次只能同时执行一定数量的任务”等断言。
chap1_para1313,6,,约束还可以指定任务完成所需的时间。
chap1_para1314,1,,我们考虑汽车装配的一小部分环节，包括15个任务：安装轮轴（axle）（前、后），固定4个车轮（wheel）（左和右、前和后），拧紧每个车轮的螺母（nuts），固定轮毂盖（cap），并检查（inspect）最终装配。
chap1_para1314,2,,我们可以将任务表示为15个变量：
chap1_para1315,1,,接着，我们需要表示各个任务间的优先约束（precedence constraint）。
chap1_para1315,2,,当任务T1必须在T2之前完成且任务T1所需时间为d1时，我们将添加一个如下形式的算术约束：
chap1_para1316,1,,在这个示例中，轮轴必须在车轮安装前到位，安装一个轮轴需要10分钟，所以有
chap1_para1317,1,,接下来，我们必须固定每个车轮（需要1分钟），拧紧螺母（2分钟），最后安装轮毂盖（1分钟，但暂未表示）：
chap1_para1318,1,,假设有4个工人来安装车轮，但他们必须共用一个工具来辅助安装轮轴。
chap1_para1318,2,,此时我们需要一个析取约束（disjunctive constraint）表示AxleF和AxleB在时间上不能重叠：要么先做AxleF，要么先做AxleB：
chap1_para1319,1,,这一约束看起来更加复杂，结合了算术约束和逻辑约束。
chap1_para1319,2,,但它仍可以简化为AxleF和AxleB可以取的一组值。
chap1_para132,1,"In 1957, B. F. Skinner published Verbal Behavior. This was a comprehensive, detailed account of the behaviorist approach to language learning, written by the foremost expert in the field. But curiously, a review of the book became as well known as the book itself, and served to almost kill off interest in behaviorism. The author of the review was the linguist Noam Chomsky, who had just published a book on his own theory, Syntactic Structures. Chomsky pointed out that the behaviorist theory did not address the notion of creativity in language—it did not explain how children could understand and make up sentences that they had never heard before. Chomsky’s theory—based on syntactic models going back to the Indian linguist Panini (c. 350 BCE)—could explain this, and unlike previous theories, it was formal enough that it could in principle be programmed.",继1945年克雷克死于自行车事故之后，唐纳德·布劳德本特（Donald Broadbent）继续从事这一工作。
chap1_para132,2,,"布劳德本特的Perception and Communication（Broadbent, 1958）是最早将心理现象建模为信息处理的著作之一。"
chap1_para132,3,,与此同时的美国，计算机建模的发展导致了认知科学（cognitive science）领域的诞生。
chap1_para132,4,,这个领域可以说是开始于1956年9月麻省理工学院的一次研讨会上，并且仅仅两个月后，人工智能本身就“诞生”了。
chap1_para1320,1,,我们还需要说明，检查是最后一项任务，需要3分钟。
chap1_para1320,2,,对于除Inspect外的每个变量，我们都需要添加一个形式的约束。
chap1_para1320,3,,最后，假设我们需要在30分钟内完成整个装配任务。
chap1_para1320,4,,因此，所有变量的域被限制为
chap1_para1321,1,,这一特定问题的求解非常琐碎，但CSP已经成功地应用于此类具有几千个变量的车间作业调度问题。
chap1_para1322,1,,6.1.3　CSP形式体系的变体
chap1_para1323,1,,"最简单的CSP所涉及的变量具有离散有限域（discrete, finite domain）。"
chap1_para1323,2,,地图着色问题和带有时间限制的调度问题都属于这类问题。
chap1_para1323,3,,8皇后问题（图4-3）也可以看作是一个有限域CSP，其中变量对应第1～8列中的皇后，每个变量的域为该列皇后可能的行号，。
chap1_para1323,4,,约束为不允许两个皇后在同一行或同一对角线上。
chap1_para1324,1,,离散域也可以是无限的（infinite），例如整数集或字符串集。
chap1_para1324,2,,（如果我们不对作业调度问题设置截止时间，那么每个变量的开始时间构成的域将是无限的。
chap1_para1324,3,,）对于无限域，我们必须使用类似这样的隐式约束，而不是显式的值元组。
chap1_para1324,4,,对于整数变量的线性约束（linear constraint）（像刚刚给出的约束一样，每个变量都只以线性形式出现）存在特殊的求解算法（在这里不讨论）。
chap1_para1324,5,,可以证明，不存在求解整数变量上一般非线性约束（nonlinear constraint）的算法——这个问题是不可判定的。
chap1_para1325,1,,连续域（continuous domain）约束满足问题是真实世界中的常见问题，在运筹学领域得到了广泛研究。
chap1_para1325,2,,例如，哈勃太空望远镜的实验调度需要非常精确的观测时间，每次观测和机动的开始时间、结束时间都是连续值变量，必须服从各种天文的、优先级的和电力的约束。
chap1_para1325,3,,最著名的一类连续域CSP是线性规划问题，其约束必须为线性等式或不等式。
chap1_para1325,4,,线性规划（linear programming）问题可以在关于变量个数的多项式时间内求解。
chap1_para1325,5,,此外人们还研究了具有不同类型约束和目标函数的问题——二次规划、二阶锥规划等。
chap1_para1325,6,,这些问题构成了应用数学的一个重要领域。
chap1_para1326,1,,除了检查CSP中变量的类型以外，检查约束的类型也是很有用。
chap1_para1326,2,,最简单的类型是一元约束（unary constraint），它限制单个变量的值。
chap1_para1326,3,,例如，在地图着色问题中，南澳大利亚州人可能不喜欢绿色，我们可以用一元约束表示。
chap1_para1326,4,,（变量的域的初始说明也可以看作一元约束。
chap1_para1326,5,,）
chap1_para1327,1,,二元约束（binary constraint）关系到两个变量。
chap1_para1327,2,,例如，是一个二元约束。
chap1_para1327,3,,二元CSP（binary CSP）只存在一元约束和二元约束，可以用如图6-1b所示的约束图表示。
chap1_para1328,1,,我们也可以定义高阶约束。
chap1_para1328,2,,"例如，三元约束Between(X, Y, Z)可以定义为。"
chap1_para1329,1,,包含任意个数变量的约束称为全局约束（global constraint）。
chap1_para1329,2,,（这个名称很传统，但容易混淆，因为它不需要包含问题中的所有变量）。
chap1_para1329,3,,最常见的全局约束之一是Alldiff，它表示约束中涉及的所有变量必须具有不同的值。
chap1_para1329,4,,在数独问题中（见6.2.6节），一行、一列或3×3框中的所有变量必须满足Alldiff约束。
chap1_para133,1,"Modern linguistics and AI, then, were “born” at about the same time, and grew up together, intersecting in a hybrid field called computational linguistics or natural language processing. The problem of understanding language turned out to be considerably more complex than it seemed in 1957. Understanding language requires an understanding of the subject matter and context, not just an understanding of the structure of sentences. This might seem obvious, but it was not widely appreciated until the 1960s. Much of the early work in knowledge representation (the study of how to put knowledge into a form that a computer can reason with) was tied to language and informed by research in linguistics, which was connected in turn to decades of work on the philosophical analysis of language.",在研讨会上，乔治·米勒（George Miller）发表了“The Magic Number Seven”，诺姆·乔姆斯基（Noam Chomsky）发表了“Three Models of Language”，艾伦·纽厄尔和赫伯特·西蒙发表了“The Logic Theory Machine”。
chap1_para133,2,,这3篇影响广泛的论文分别展示了如何使用计算机模型处理记忆、语言和逻辑思维的心理学问题。
chap1_para133,3,,"现在心理学家普遍认为“认知理论应该就像一个计算机程序”（Anderson, 1980），也就是说，认知理论应该从信息处理的角度来描述认知功能的运作。"
chap1_para1330,1,,另一个例子是密码算术（cryptarithmetic）谜题（图6-2a）。
chap1_para1330,2,,密码算术谜题中的每个字母代表一个不同数字。
chap1_para1330,3,,"图6-2a中的情况，将表示为全局约束Alldiff(F, T, U, W, R, O)。"
chap1_para1330,4,,4列上的加法约束可以写成如下n元约束：
chap1_para1331,1,,其中C1、C2和C3为辅助变量，表示十位、百位或千位上的进位数。
chap1_para1331,2,,这些约束可以用约束超图（constraint hypergraph）表示，如图6-2b所示。
chap1_para1331,3,,超图由普通节点（图中的圆圈）和表示n元约束的超节点（正方形）组成，n元约束为包含n个变量的约束。
chap1_para1332,1,,图6-2　（a）密码算术问题。
chap1_para1332,2,,不同字母表示不同数字，目的是找到使加法算式成立的代替字母的数字，附加约束为不允许前导零。
chap1_para1332,3,,（b）密码算术问题的约束超图，用来表示Alldiff约束（最上面的方框）以及每列的加法约束（中间的4个方框）。
chap1_para1332,4,,变量C1、C2和C3表示从右到左3列的进位数
chap1_para1333,1,,或者，正如习题6.NARY需要你证明的，如果引入足够多的辅助变量，每个有限域约束都可以简化为一组二元约束。
chap1_para1333,2,,这意味着我们可以将任意一个CSP转换为只有二元约束的CSP，这将使算法设计变得更加简单。
chap1_para1333,3,,将n元CSP转换为二元CSP的另一种方式是对偶图（dual graph）变换：创建一个新图，原图中的每个约束用新图中的一个变量表示，原图中的每对共享变量的约束用新图中的一个二元约束表示。
chap1_para1334,1,,例如，考虑变量为的CSP，每个变量的域为，带有两个约束和。
chap1_para1334,2,,对偶图的变量则为，对偶图中C1变量的域为原问题C1约束中的元组的集合，同样地，C2的域是元组的集合。
chap1_para1334,3,,对偶图具有二元约束，其中R1是定义C1和C2之间约束的新关系。
chap1_para1334,4,,在这种情况下，。
chap1_para1335,1,,然而，我们可能更喜欢Alldiff这样的全局约束，而不是一组二元约束，这有两个原因。
chap1_para1335,2,,首先，使用Alldiff描述问题更简单而且更不容易出错。
chap1_para1335,3,,其次，可以为全局约束设计相比于基元约束更有效的专用推理算法。
chap1_para1335,4,,我们将在6.2.5节介绍这些推理算法。
chap1_para1336,1,,到目前为止，我们所描述的约束都是绝对约束，违反这些约束的可能解将被排除。
chap1_para1336,2,,许多真实世界的CSP包含偏好约束（preference constraint），偏好约束规定哪些解是首选的。
chap1_para1336,3,,例如，在大学排课问题中，存在绝对约束，如一个教授不可以同时上两门课。
chap1_para1336,4,,但也可能存在偏好约束：R教授可能更喜欢在上午上课，而N教授更喜欢在下午上课。
chap1_para1336,5,,让R教授在下午2点上课仍是一个可行解（除非R教授碰巧是系主任），但不是最优解。
chap1_para1337,1,,偏好约束通常可以编码为个别变量赋值的代价。
chap1_para1337,2,,例如，为R教授分配一个下午时段相对于总体目标函数的代价为2分，而分配上午时段的代价为1分。
chap1_para1337,3,,通过这样的形式化，带偏好约束的CSP可以用基于路径的或局部的优化搜索方法求解。
chap1_para1337,4,,我们称这样的问题为约束优化问题（constrained optimization problem，COP）。
chap1_para1337,5,,线性规划是一类COP。
chap1_para1338,1,,6.2　约束传播：CSP中的推断
chap1_para1339,1,,原子的状态空间搜索算法只有一种方式：通过扩展节点来访问后继节点。
chap1_para1339,2,,CSP算法有不同选择。
chap1_para1339,3,,它可以通过选择一个新的变量赋值来生成后继，或者执行一种称为约束传播（constraint propagation）的特定类型推断：使用约束减少一个变量的合法值的数量，这反过来又可以减少另一个变量的合法值，以此类推。
chap1_para1339,4,,其思想是，通过这一过程，当我们选择下一个变量赋值时，需要考虑的选项会减少。
chap1_para1339,5,,约束传播可以与搜索交替进行，也可以作为搜索开始前的预处理步骤。
chap1_para1339,6,,有时这种预处理就可以求解整个问题，所以根本不需要搜索。
chap1_para134,1,1.,为了综述目的，我们将人机交互（human-computer interaction，HCI）领域归于心理学下。
chap1_para134,2,3The History of Artificial Intelligence,人机交互的先驱之一道格·恩格巴特（Doug Engelbart）倡导智能增强（intelligence augmentation）的理念（IA而非AI）。
chap1_para134,3,,他认为，计算机应该增强人类的能力，而不是完全自动化人类的任务。
chap1_para134,4,,1968年，在恩格巴特的“所有演示之母”（mother of all demos）上首次展示了计算机鼠标、窗口系统、超文本和视频会议，所有这些都是为了展示人类知识工作者可以通过某些智能增强来共同完成工作。
chap1_para1340,1,,约束传播的核心思想是局部一致性（local consistency）。
chap1_para1340,2,,如果我们将每个变量看作图中的一个节点（见图6-1b），将每个二元约束看作一条边，则增强图中每一部分局部一致性的过程会导致整个图中不一致的值被删除。
chap1_para1340,3,,局部一致性有几种不同类型，我们现在依次介绍。
chap1_para1341,1,,6.2.1　节点一致性
chap1_para1342,1,,如果单个变量的域中的所有值都满足该变量的一元约束，则该变量（对应于CSP图中的某个节点）是节点一致的。
chap1_para1342,2,,例如，在澳大利亚地图着色问题（图6-1）的变体中，南澳大利亚州人不喜欢绿色，变量SA的初始域为，可以通过删除green使其保持节点一致，SA的域缩减为。
chap1_para1342,3,,如果图中的每个变量都是节点一致的，那么整个图是节点一致的。
chap1_para1343,1,,在求解过程开始时，通过缩减具有一元约束的变量的域，可以很容易地消除CSP中的所有一元约束。
chap1_para1343,2,,如前文所述，还可以将所有n元约束转换为二元约束。
chap1_para1343,3,,因此，一些CSP求解器只处理二元约束，要求用户提前消除其他约束。
chap1_para1343,4,,除非特别说明，本章的剩余部分都基于这一假设。
chap1_para1344,1,,6.2.2　弧一致性
chap1_para1345,1,,如果CSP中某一变量的域内的所有值都满足该变量的二元约束，那么该变量就是弧一致的（arc consistent）[3]。
chap1_para1345,2,,"更正式地说，对于变量Xi、Xj，如果对于当前域Di中的每个值，Dj中都存在一些值满足弧(Xi, Xj)上的二元约束，则称Xi相对于Xj是弧一致的。"
chap1_para1345,3,,如果每个变量相对所有其他变量都是弧一致的，那么这个图就是弧一致的。
chap1_para1345,4,,例如，考虑约束Y = X2，其中X和Y的域都是十进制数字。
chap1_para1345,5,,我们可以将这一约束显式地写为。
chap1_para1345,6,,"为了使X相对于Y弧一致，我们将X的域缩减为{0, 1, 2, 3}。"
chap1_para1345,7,,"如果要使Y相对于X弧一致，那么Y的域为{0, 1, 4, 9}，此时整个CSP是弧一致的。"
chap1_para1345,8,,但是，弧一致性对澳大利亚地图着色问题没有任何帮助。
chap1_para1345,9,,"考虑(SA, WA)的如下不同色约束："
chap1_para1347,1,,[3]　我们一直使用的术语是“边”而不是“弧”，所以将其称为“边一致”会更合适，但历史上使用的术语是“弧一致”。
chap1_para1348,1,,无论为SA（或WA）选择哪个值，另一变量都存在一个有效值。
chap1_para1348,2,,所以应用弧一致性对两个变量的域都没有影响。
chap1_para1349,1,,最流行的增强弧一致性的算法为AC-3（见图6-3）。
chap1_para1349,2,,为了使每个变量保持弧一致，AC-3算法将维护一个弧队列。
chap1_para1349,3,,初始时，队列包含CSP中的所有弧。
chap1_para1349,4,,（每个二元约束都有两条弧，每个方向各一条。
chap1_para1349,5,,"）然后AC-3从队列中弹出任意一条弧(Xi, Xj)并使Xi相对于Xj弧一致。"
chap1_para1349,6,,如果Di保持不变，算法就会处理下一条弧。
chap1_para1349,7,,"但是如果Di得以修正（域变小），那么我们将所有的弧(Xk, Xi)添加到队列中，其中Xk是Xi的邻居。"
chap1_para1349,8,,这样做的原因是，即使之前已经处理过Xk，Di的变化也可能会进一步缩减Dk。
chap1_para1349,9,,如果Di变为空集，那么表示整个CSP不存在一致解，AC-3可以马上返回失败。
chap1_para1349,10,,否则，我们继续检查，不断尝试缩减变量的域，直到队列中没有弧。
chap1_para1349,11,,此时，我们得到了一个与原始CSP等价的CSP（它们的解相同），但弧一致CSP搜索起来会更快，因为它的变量的域更小。
chap1_para1349,12,,在某些情况下，它可以完全求解问题（通过将每个域的大小缩减为1），而在其他情况下，它可以证明解不存在（通过将某些域的大小缩减为0）。
chap1_para135,1,"One quick way to summarize the milestones in AI history is to list the Turing Award winners: Marvin Minsky (1969) and John McCarthy (1971) for defining the foundations of the field based on representation and reasoning; Allen Newell and Herbert Simon (1975) for symbolic models of problem solving and human cognition; Ed Feigenbaum and Raj Reddy (1994) for developing expert systems that encode human knowledge to solve real-world problems; Judea Pearl (2011) for developing probabilistic reasoning techniques that deal with uncertainty in a principled manner; and finally Yoshua Bengio, Geoffrey Hinton, and Yann LeCun (2019) for making “deep learning” (multilayer neural networks) a critical part of modern computing. The rest of this section goes into more detail on each phase of AI history.",今天，我们更倾向于将IA和AI视为同一枚硬币的两面，前者强调人类控制，而后者强调机器的智能行为，都是机器有利于人类所必需的。
chap1_para1350,1,,图6-3　弧一致性算法AC-3。
chap1_para1350,2,,应用AC-3算法后，要么每条弧都是弧一致的，要么某些变量的域为空集，说明该CSP无解。
chap1_para1350,3,,"“AC-3”这个名字来源于算法的发明者（Mackworth, 1977），因为他论文中用到的算法是开发的第三个版本"
chap1_para1351,1,,AC-3的算法复杂性可以如下分析。
chap1_para1351,2,,假设CSP有n个变量，每个变量的域大小不超过d，带有c个二元约束（弧）。
chap1_para1351,3,,"每个弧(Xk, Xi)最多只能插入队列d次，因为Xi最多有d个值要删除。"
chap1_para1351,4,,对弧一致性的检查可以在O(d2)时间内完成，因此最坏情况下的时间复杂性为O(cd3)。
chap1_para1352,1,,6.2.3　路径一致性
chap1_para1353,1,,假设我们要给澳大利亚地图涂上两种颜色，红色和蓝色。
chap1_para1353,2,,此时弧一致性不起作用，因为将弧的一端涂成红色，另一端涂成蓝色可以分别满足每个约束。
chap1_para1353,3,,但显然这个问题是无解的：因为西澳大利亚州、北领地和南澳大利亚州彼此相邻，仅仅是它们就需要至少3种颜色。
chap1_para1354,1,,弧一致性利用弧（二元约束）将域（一元约束）收紧。
chap1_para1354,2,,为了求解地图着色等问题，我们需要更强的一致性概念。
chap1_para1354,3,,路径一致性（path consistency）使用隐式约束（通过观测变量的三元组推断）将二元约束收紧。
chap1_para1355,1,,考虑两个变量的集合和第三个变量Xm，如果对于每个满足上约束（如果有的话）的赋值，都存在Xm的一个赋值满足和上的约束，则称相对于Xm是路径一致的。
chap1_para1355,2,,这一名称是指从Xi途经Xm到Xj的路径的整体一致性。
chap1_para1356,1,,让我们考虑用两种颜色为澳大利亚地图着色时的路径一致性。
chap1_para1356,2,,我们要使集合相对于NT路径一致。
chap1_para1356,3,,首先枚举集合的一致赋值。
chap1_para1356,4,,在这种情况下，只有两个一致赋值：和。
chap1_para1356,5,,可以看到，对于这两种赋值，NT不能是红色或蓝色（因为它会与WA或SA发生冲突）。
chap1_para1356,6,,因为NT不存在有效选择，所以我们消除了这两种赋值，最终不存在有效赋值。
chap1_para1356,7,,因此，我们知道了这个问题是无解的。
chap1_para1357,1,,6.2.4　k一致性
chap1_para1358,1,,可以用k一致性（k-consistency）的概念定义更强的传播形式。
chap1_para1358,2,,如果对于CSP的任意(k −1)个变量的集合以及这些变量的任意一致赋值，任意第k个变量都存在一个一致赋值，则称该CSP是k一致的。
chap1_para1358,3,,1一致性表示，给定空集，我们可以使任何单变量集合满足一致性，这就是我们所说的节点一致性。
chap1_para1358,4,,2一致性等价于弧一致性。
chap1_para1358,5,,对于二元约束图，3一致性等价于路径一致性。
chap1_para1359,1,,如果一个CSP是k一致的，也是(k −1)一致的，(k −2)一致的……一直到1一致的，则称它是强k一致的（strongly k-consistent）。
chap1_para1359,2,,现在假设我们有一个包含n个节点的CSP，并且是强n一致的(即当k = n时，强k一致)，那么可以这样求解该问题：首先，为X1选择一个一致值。
chap1_para1359,3,,然后因为图是2一致的，所以保证能为X2选出一个一致值，因为它是3一致的，所以能为X3选出一个值，以此类推。
chap1_para1359,4,,"对于每个变量Xi，我们只需在它的域的d个值中搜索，就可以找到一个与X1, …, Xi−1一致的值。"
chap1_para1359,5,,总运行时间只有O(n2d)。
chap1_para136,1,1.3.1The inception of artificial intelligence (1943–1956),1.2.6　计算机工程
chap1_para1360,1,,当然，世界上没有免费的午餐：约束满足问题通常是NP完全的，任何建立n一致性的算法在最坏情况下的时间复杂性都是n的指数级。
chap1_para1360,2,,更糟的是，n一致性所需的空间复杂性也是n的指数级。
chap1_para1360,3,,在实践中，确定适当的一致性检查层级基本上是一门经验科学。
chap1_para1360,4,,比较常见的是计算2一致性，其次是计算3一致性。
chap1_para1361,1,,6.2.5　全局约束
chap1_para1362,1,,前文提到，全局约束涉及任意个数的变量（但不一定是所有变量）。
chap1_para1362,2,,实际问题中经常出现全局约束，可以通过专用算法处理这些约束，这些算法比目前介绍的一般方法更加高效。
chap1_para1362,3,,例如，Alldiff约束规定所有相关变量必须取不同的值（如上文的密码算术问题和下文的数独问题）。
chap1_para1362,4,,对Alldiff约束进行不一致性检测的一种简单形式如下所示：如果约束中涉及m个变量，而且它们一共具有n个可能的不同值，且，那么约束不可能满足。
chap1_para1363,1,,这将导出以下简单算法。
chap1_para1363,2,,首先，删除约束中任意一个单值变量（域中只有一个值的变量），并且从其余变量的域中删除该变量的值。
chap1_para1363,3,,只要还存在单值变量，就重复上述过程。
chap1_para1363,4,,如果在任一点上产生了空集，或者存在比剩余取值数更多的变量，则检测到了不一致性。
chap1_para1364,1,,上述方法可以检测图6-1中赋值的不一致性。
chap1_para1364,2,,注意，变量SA、NT和Q是通过Alldiff约束有效连接的，因为每对都必须取两种不同颜色。
chap1_para1364,3,,将AC-3应用于这个部分赋值后，SA、NT和Q的域都缩减为。
chap1_para1364,4,,也就是说，我们有3个变量，但只有两种颜色，这违反了Alldiff约束。
chap1_para1364,5,,因此，对高阶约束进行简单一致性处理有时比对等价的二元约束集应用弧一致性更高效。
chap1_para1365,1,,另一种重要的高阶约束是资源约束（resource constraint），有时也称为Atmost约束。
chap1_para1365,2,,"例如，在一个调度问题中，设P1, …, P4分别表示分配给4个任务的人数。"
chap1_para1365,3,,分配总人数不超过10的约束写为。
chap1_para1365,4,,通过检验当前域的最小值之和可以检测不一致性。
chap1_para1365,5,,"例如，如果每个变量的域都是{3, 4, 5, 6}，则不可能满足Atmost约束。"
chap1_para1365,6,,另一个例子是，如果当前某个变量的域中的最大值加上所有其他变量的域的最小值超过约束，则可以通过删除该最大值来保持一致性。
chap1_para1365,7,,"因此，如果示例中的每个变量的域都是{2, 3, 4, 5, 6}，那么可以从每个域中删除5和6。"
chap1_para1366,1,,对于大规模的、具有整数值的资源有限问题（例如用几百辆车运送几千人的物流问题）将每个变量的域表示为一个大的整数集然后通过一致性检查方法逐渐缩减这个集合通常是不可能的。
chap1_para1366,2,,相反，域由上界和下界表示，通过边界传播（bound propagation）处理。
chap1_para1366,3,,例如，在航班调度问题中，假设存在两趟航班，F1和F2，其中飞机的容量分别为165和385。
chap1_para1366,4,,F1和F2航班上乘客数量的初始域为
chap1_para1368,1,,现在假设我们有附加约束，两趟航班所搭载的总乘客数必须是420：。
chap1_para1368,2,,通过传播边界约束，我们将域缩减为
chap1_para137,1,"The first work that is now generally recognized as AI was done by Warren McCulloch and Walter Pitts (1943). Inspired by the mathematical modeling work of Pitts’s advisor Nicolas Rashevsky (1936, 1938), they drew on three sources: knowledge of the basic physiology and function of neurons in the brain; a formal analysis of propositional logic due to Russell and Whitehead; and Turing’s theory of computation. They proposed a model of artificial neurons in which each neuron is characterized as being “on” or “off,” with a switch to “on” occurring in response to stimulation by a sufficient number of neighboring neurons. The state of a neuron was conceived of as “factually equivalent to a proposition which proposed its adequate stimulus.” They showed, for example, that any computable function could be computed by some network of connected neurons, and that all the logical connectives (AND, OR, NOT, etc.) could be implemented by simple network structures. McCulloch and Pitts also suggested that suitably defined networks could learn. Donald Hebb (1949) demonstrated a simple updating rule for modifying the connection strengths between neurons. His rule, now called Hebbian learning, remains an influential model to this day.",● 如何构建高效的计算机？
chap1_para1370,1,,如果对于任意变量X和它的上下界值，任意变量Y，都存在满足X和Y之间约束的Y的值，则称CSP是边界一致的（bounds-consistent）。
chap1_para1370,2,,这种边界传播在实际的约束问题中得到了广泛应用。
chap1_para1372,1,,数独（Sudoku）游戏非常流行，它将数百万人引入了约束满足问题，尽管他们可能没有意识到这一点。
chap1_para1372,2,,数独棋盘由81个方格组成，有些方格预先填有1到9的数字。
chap1_para1372,3,,谜题是将所有剩余方格填满，并且任意一行、一列或3×3方框中不存在相同数字（见图6-4）。
chap1_para1372,4,,一行、一列或一个方框称为一个单元（unit）。
chap1_para1373,1,,图6-4　（a）一个数独问题。
chap1_para1373,2,,（b）它的解
chap1_para1374,1,,报纸和益智书籍上的数独游戏都有一个特点，即有且只有一个解。
chap1_para1374,2,,尽管有些问题手动求解很难，需要花费几十分钟，但CSP求解器每秒可以处理几千个问题。
chap1_para1375,1,,可以将数独游戏看作含有81个变量的CSP，每个变量对应一个方格。
chap1_para1375,2,,用变量名A1到A9表示第一行（从左到右），I1到I9表示最后一行。
chap1_para1375,3,,"空方格的域为{1, 2, 3, 4, 5, 6, 7, 8, 9}，预先填好的方格的域只有一个值。"
chap1_para1375,4,,此外，还有27个不同的Alldiff约束，每个单元（行、列和含有9个方格的方框）各有一个Alldiff约束：
chap1_para1376,1,,"Alldiff (A1, A2, A3, A4, A5, A6, A7, A8, A9)"
chap1_para1377,1,,"Alldiff (B1, B2, B3, B4, B5, B6, B7, B8, B9)"
chap1_para1379,1,,"Alldiff (A1, B1, C1, D1, E1, F1, G1, H1, I1)"
chap1_para138,1,"Two undergraduate students at Harvard, Marvin Minsky (1927–2016) and Dean Edmonds, built the first neural network computer in 1950. The SNARC, as it was called, used 3000 vacuum tubes and a surplus automatic pilot mechanism from a B-24 bomber to simulate a network of 40 neurons. Later, at Princeton, Minsky studied universal computation in neural networks. His Ph.D. committee was skeptical about whether this kind of work should be considered mathematics, but von Neumann reportedly said, “If it isn’t now, it will be someday.”",现代数字电子计算机是由陷入第二次世界大战中的3个国家的科学家们独立且几乎同时发明的。
chap1_para138,2,,第一台可操作的计算机是由艾伦·图灵的团队于1943年建造的机电希思·罗宾逊（Heath Robinson[13]），它的唯一目的是破译德国的情报。
chap1_para138,3,,1943年，同一小组开发了Colossus，这是一款基于真空管的强大通用机器。
chap1_para138,4,,[14]第一台可操作的可编程计算机是Z-3，是德国工程师康拉德·楚泽（Konrad Zuse）在1941年发明的。
chap1_para138,5,,楚泽还发明了浮点数和第一个高级编程语言Plankalkül。
chap1_para138,6,,第一台电子计算机ABC是约翰·阿塔纳索夫（John Atanasoff）和他的学生克利福德·贝里（Clifford Berry）在1940年至1942年间在爱荷华州立大学组装的。
chap1_para138,7,,阿塔纳索夫的研究很少得到支持或认可，而ENIAC作为宾夕法尼亚大学秘密军事项目的一部分被证明是现代计算机最有影响力的先驱。
chap1_para138,8,,ENIAC的开发团队包括了约翰·莫奇利（John Mauchly）和约翰·普雷斯伯·埃克特（J. Presper Eckert）等工程师。
chap1_para1380,1,,"Alldiff (A2, B2, C2, D2, E2, F2, G2, H2, I2)"
chap1_para1382,1,,"Alldiff (A1, A2, A3, B1, B2, B3, C1, C2, C3)"
chap1_para1383,1,,"Alldiff (A4, A5, A6, B4, B5, B6, C4, C5, C6)"
chap1_para1385,1,,让我们看看弧一致性能带我们走多远。
chap1_para1385,2,,假设Alldiff约束已被扩展为二元约束（例如A1 A2），这样我们就可以直接应用AC-3算法。
chap1_para1385,3,,考虑图6-4a中的变量E6——正中间方框中2、8之间的空格。
chap1_para1385,4,,按照方框的约束，我们可以从E6的域中删除1、2、7和8。
chap1_para1385,5,,按照它所在列的约束，我们可以删除5、6、2、8、9和3（尽管2和8已经被删除）。
chap1_para1385,6,,此时E6的域是{4}；换句话说，我们知道了E6的解。
chap1_para1385,7,,现在考虑变量I6——最后一行中间方框中被1、3、3包围的空格。
chap1_para1385,8,,在它所在列应用弧一致性，可以删除5、6、2、4（因为我们现在知道E6一定是4）、8、9和3。
chap1_para1385,9,,我们利用它和I5的弧一致性删除1，此时I6的域中只剩下7。
chap1_para1385,10,,现在第6列中有8个已知值，所以根据弧一致性可以推出A6一定是1。
chap1_para1385,11,,沿着这样的思路继续推断，最终AC-3可以求解整个问题——所有变量的域都缩减为单个值，如图6-4b所示。
chap1_para1386,1,,当然，如果每个数独问题都可以通过机械地应用AC-3求解，那么它很快就会失去吸引力，实际上AC-3只适用于最简单的数独问题。
chap1_para1386,2,,稍微困难一点的问题可以用PC-2求解，但需要花费更大的计算代价：在一个数独问题中，需要考虑255 960个不同的路径约束。
chap1_para1386,3,,为了求解最困难的数独问题并取得高效进展，我们必须更聪明一些。
chap1_para1387,1,,事实上，数独对人类解谜者的吸引力在于，他们需要足智多谋地应用更复杂的推理策略。
chap1_para1387,2,,数独爱好者给这些策略取了各种有趣的名字，如“三链数删减法”。
chap1_para1387,3,,它的工作原理如下：在任一单元（行、列或方框）中，找到3个方格，它们的域包含相同的3个数字或这3个数字的子集。
chap1_para1387,4,,例如，这3个域可能是、和。
chap1_para1387,5,,我们并不知道哪个方格是1、3或8，但我们知道这3个数字一定分布在这3个方格中。
chap1_para1387,6,,因此，我们可以将1、3和8从该单元中所有其他方格的域中删除。
chap1_para1388,1,,有趣的是，这些方法并不只是专用于数独。
chap1_para1388,2,,对于数独，我们确实必须说它有81个变量，域是数字1～9，有27个Alldiff约束。
chap1_para1388,3,,但除此之外，所有策略（弧一致性、路径一致性等）普遍适用于所有CSP，而不仅仅是数独问题。
chap1_para1388,4,,即使是三链数删减法，也是一种加强Alldiff约束一致性的策略，而不是特定于数独本身。
chap1_para1388,5,,这就是CSP形式体系的作用：对于每个新问题域，我们只需按照约束定义问题，然后就可以使用一般的约束求解机制。
chap1_para1389,1,,6.3　CSP的回溯搜索
chap1_para139,1,"There were a number of other examples of early work that can be characterized as AI, including two checkers-playing programs developed independently in 1952 by Christopher Strachey at the University of Manchester and by Arthur Samuel at IBM. However, Alan Turing’s vision was the most influential. He gave lectures on the topic as early as 1947 at the London Mathematical Society and articulated a persuasive agenda in his 1950 article “Computing Machinery and Intelligence.” Therein, he introduced the Turing test, machine learning, genetic algorithms, and reinforcement learning. He dealt with many of the objections raised to the possibility of AI, as described in Chapter 28. He also suggested that it would be easier to create human-level AI by developing learning algorithms and then teaching the machine rather than by programming its intelligence by hand. In subsequent lectures he warned that achieving this goal might not be the best thing for the human race.",
chap1_para1390,1,,有时我们完成约束传播过程后仍存在具有多个可能值的变量。
chap1_para1390,2,,在这种情况下，我们必须通过搜索来求解问题。
chap1_para1390,3,,本节中我们将介绍用于部分赋值的回溯搜索算法，6.4节中我们将介绍用于完整赋值的局部搜索算法。
chap1_para1391,1,,考虑标准的深度受限搜索（第3章）是如何求解CSP的。
chap1_para1391,2,,状态可能是一个部分赋值，而动作将对该赋值进行扩展，例如，在澳大利亚地图着色问题中，添加赋值NSW = red或SA = blue。
chap1_para1391,3,,对于具有n个变量，域大小为d的CSP，我们最终将得到一个搜索树，所有的完整赋值（因此所有的解）都是深度为n的叶节点。
chap1_para1391,4,,但要注意，第一层的分支因子为nd，因为n个变量中的任意变量都可以取d个值中的任意值。
chap1_para1391,5,,下一层的分支因子是(n −1)d，以此类推n层。
chap1_para1391,6,,所以树总共有n! · dn个叶节点，即使可能的完整赋值只有dn种！
chap1_para1392,1,,如果意识到CSP具有的一个关键性质：可交换性（commutativity），我们就可以消去因子n!。
chap1_para1392,2,,如果任意给定的动作集合的应用顺序对结果没有影响，则称该问题是可交换的。
chap1_para1392,3,,在CSP中，不管我们先赋值NSW = red，再赋值SA = blue，还是交换顺序，都没有区别。
chap1_para1392,4,,因此，我们只需考虑搜索树中每个节点上的单个变量。
chap1_para1392,5,,在根节点上，我们可能需要在SA = red、SA = green和SA = blue之间做出选择，但我们永远不需要在NSW = red和SA = blue之间做出选择。
chap1_para1392,6,,在这一限制下，叶节点的数量减少到dn，这正是我们所希望的。
chap1_para1392,7,,在树的每一层中，我们都必须选择要处理哪个变量，但我们永远不需要回溯这一选择。
chap1_para1393,1,,图6-5为CSP的回溯搜索过程。
chap1_para1393,2,,它不断选择未赋值变量，然后依次尝试该变量的域中的所有值，试图通过递归调用将每个值扩展为一个解。
chap1_para1393,3,,如果调用成功，则返回解，如果调用失败，则将赋值恢复到前一状态，然后尝试下一个值。
chap1_para1393,4,,如果所有值都不成功，则返回失败。
chap1_para1393,5,,澳大利亚地图着色问题的部分搜索树如图6-6所示，其中我们按照WA、 NT、Q……的顺序为变量赋值。
chap1_para1394,1,,图6-5　约束满足问题的简单回溯算法。
chap1_para1394,2,,该算法以第3章的递归深度优先搜索为模型。
chap1_para1394,3,,函数Select-Unassigned- Variable和Order-Domain-Values实现了6.3.1节中讨论的通用启发式算法。
chap1_para1394,4,,函数Inference可以根据需要选择性地使用弧一致性、路径一致性或k一致性检测。
chap1_para1394,5,,如果一个赋值导致了失败（无论是在Inference还是在Backtrack中），那么该赋值（包括从Inference得到的值）将被撤销，然后重新尝试一个新的赋值
chap1_para1395,1,,图6-6　图6-1中地图着色问题的部分搜索树
chap1_para1396,1,,注意，Backtracking-Search只维护状态（赋值）的单个表示，然后对它进行修改，而不是创建一个新的表示（见3.4.3节）。
chap1_para1397,1,,第3章的无信息搜索算法只能通过提供领域特定的启发式算法来改进，然而，事实证明，回溯搜索可以使用领域无关的启发式算法进行改进，这些算法利用了CSP的因子化表示。
chap1_para1397,2,,在接下来的4节中，我们将介绍如何做到这一点。
chap1_para1398,1,,● （6.3.1节）下一步应该给哪个变量赋值（Select-Unassigned-Variable），以及应该以什么顺序尝试它的值（Order-Domain-Values）？
chap1_para1399,1,,● （6.3.2节）在每步搜索中应该执行怎样的推断（Inference）？
chap1_para14,1,Turing viewed the physical simulation of a person as unnecessary to demonstrate intelligence.,● 自然语言处理（natural language processing），以使用人类语言成功地交流；
chap1_para14,2,"However, other researchers have proposed a total Turing test, which requires interaction with objects and people in the real world.",
chap1_para14,3,"To pass the total Turing test, a robot will need",
chap1_para140,1,"In 1955, John McCarthy of Dartmouth College convinced Minsky, Claude Shannon, and Nathaniel Rochester to help him bring together U.",[13]　以一位英国漫画家的名字命名的复杂机器。
chap1_para140,2,S.,这位漫画家描绘了一些古怪而又荒唐的复杂装置来完成日常任务，如给面包涂黄油。
chap1_para140,3,"researchers interested in automata theory, neural nets, and the study of intelligence.",
chap1_para140,4,They organized a two-month workshop at Dartmouth in the summer of 1956.,
chap1_para140,5,"There were 10 attendees in all, including Allen Newell and Herbert Simon from Carnegie Tech,11 Trenchard More from Princeton, Arthur Samuel from IBM, and Ray Solomonoff and Oliver Selfridge from MIT.",
chap1_para140,6,The proposal states:12,
chap1_para1400,1,,● （6.3.3节）我们能在适当的时候回溯（Backtrack）不止一步吗？
chap1_para1401,1,,● （6.3.4节）我们可以保存和复用搜索的部分结果吗？
chap1_para1402,1,,6.3.1　变量排序和值排序
chap1_para1403,1,,回溯算法中包含这样一行：
chap1_para1404,1,,Select-Unassigned-Variable的最简单的策略是使用静态排序：按列表顺序选择变量。
chap1_para1404,2,,第二简单的策略是随机选择。
chap1_para1404,3,,这两种策略都不是最优的。
chap1_para1404,4,,例如，图6-6中，进行WA = red和NT = green赋值后，SA只有一个可能的值，因此接下来应该对SA赋值SA = blue而不是对Q赋值：事实上，对SA赋值后，Q、NSW和V的取值都是确定的。
chap1_para1405,1,,这种直观的想法——选择“合法”值最少的变量——称为最少剩余值（minimum-remaining-value，MRV）启发式算法，也被称为“最受约束变量”或“失败优先”启发式算法，后一个名字是因为它选择了最有可能马上导致失败的变量，从而可以对搜索树剪枝。
chap1_para1405,2,,如果某一变量X没有剩余合法值，那么MRV启发式算法将优先选择X然后马上检测到失败——避免遍历其他变量进行无意义地搜索。
chap1_para1405,3,,MRV启发式算法通常比随机或静态排序表现得更好，有时会带来数量级上的效率差异，尽管结果可能因问题而异。
chap1_para1406,1,,在选择澳大利亚地图的第一个着色区域时，MRV启发式算法完全不起作用，因为初始时每个区域都有3种合法颜色。
chap1_para1406,2,,在这种情况下，度启发式（degree heuristic）算法就派上用场了。
chap1_para1406,3,,它通过选择与其他未赋值变量的约束最多的变量来降低未来选择的分支因子。
chap1_para1406,4,,在图6-1中，SA的度最大，为5；除了变量T的度为0，其他变量的度为2或3。
chap1_para1406,5,,如果先赋值SA，我们就可以按顺时针或逆时针顺序访问5个陆地区域，并为每个区域赋予不同于SA和前一个区域的颜色。
chap1_para1406,6,,最少剩余值启发式算法通常效果更好，但度启发式算法可以打破僵局。
chap1_para1407,1,,一旦选择了一个变量，算法必须决定按什么顺序检验它的值。
chap1_para1407,2,,最少约束值（least-constraining-value）启发式算法对此非常有效。
chap1_para1407,3,,它优先选择那些为约束图中相邻变量留下最多选择的值。
chap1_para1407,4,,例如，假设在图6-1中，我们已经生成了部分赋值WA = red和NT = green，并且下一步是为Q选择赋值。
chap1_para1407,5,,此时蓝色是一个糟糕的选择，因为它消除了Q的邻居SA的最后一个可选的合法值。
chap1_para1407,6,,因此，最少约束值启发式算法会优先选择红色而不是蓝色。
chap1_para1407,7,,一般来说，启发式算法试图为后续变量赋值留下最大的灵活性。
chap1_para1408,1,,为什么变量选择是失败优先，而值选择是失败延后呢？
chap1_para1408,2,,每个变量最终都必须被赋值，因此通过选择那些有可能最先失败的变量，在统计意义上，需要通过回溯才能找到的成功赋值就会更少。
chap1_para1408,3,,对于值排序，关键在于我们只需要找到一个解；因此，先寻找最有可能的值是有意义的。
chap1_para1408,4,,如果我们的目标是枚举所有的解而不只是找到一个解，那么值排序就无关紧要了。
chap1_para1409,1,,6.3.2　交替进行搜索和推理
chap1_para141,1,"We propose that a 2 month, 10 man study of artificial intelligence be carried out during the summer of 1956 at Dartmouth College in Hanover, New Hampshire.","[14]　在第二次世界大战后，图灵想把这些计算机用于人工智能研究，例如，他创建了第一个国际象棋程序的框架（Turing et al., 1953），但英国政府阻止了这项研究。"
chap1_para141,2,The study is to proceed on the basis of the conjecture that every aspect of learning or any other feature of intelligence can in principle be so precisely described that a machine can be made to simulate it.,
chap1_para141,3,"An attempt will be made to find how to make machines use language, form abstractions and concepts, solve kinds of problems now reserved for humans, and improve themselves.",
chap1_para141,4,We think that a significant advance can be made in one or more of these problems if a carefully selected group of scientists work on it together for a summer.,
chap1_para1410,1,,我们已经讨论了AC-3算法如何在搜索前缩减变量的域。
chap1_para1410,2,,但在搜索过程中，推断的作用可能更大：每次我们为某个变量选择某个值时，都有一个全新的机会推断其相邻变量的新的域缩减。
chap1_para1411,1,,推断的最简单形式之一是前向检验（forward checking）。
chap1_para1411,2,,当变量X被赋值时，前向检验过程为其建立弧一致性：对于每个通过约束与X连接的未赋值变量Y，从它的域中删除与X的取值不一致的值。
chap1_para1412,1,,图6-7为在澳大利亚地图CSP上使用前向检验进行回溯搜索的过程。
chap1_para1412,2,,关于这一示例，有两点需要注意。
chap1_para1412,3,,首先，需要注意，在赋值WA = red和Q = green后，NT和SA的域缩减为单个值；通过从WA和Q传播信息，我们可以完全消除这些变量上的分支。
chap1_para1412,4,,其次，需要注意，赋值V= blue后，SA的域为空集。
chap1_para1412,5,,因此，前向检验检测到部分赋值与问题的约束不一致，算法立即回溯。
chap1_para1413,1,,图6-7　带前向检验的地图着色搜索过程。
chap1_para1413,2,,首先赋值WA = red；然后前向检验从其相邻变量NT和SA的域中删除red。
chap1_para1413,3,,赋值Q = green后，从NT、SA和NSW的域中删除green。
chap1_para1413,4,,赋值V = blue后，从NSW和SA的域中删除blue，此时SA没有合法值
chap1_para1414,1,,对许多问题来说，将MRV启发式算法与前向检验相结合，可以使搜索更有效。
chap1_para1414,2,,考虑图6-7中的赋值。
chap1_para1414,3,,直观上，这一赋值似乎对它的相邻变量NT和SA有所约束，所以接下来应该先处理这些变量，然后是所有其他变量。
chap1_para1414,4,,MRV正是这么做的：NT和SA各有两个值，所以先选择其中一个，接着是另一个，然后依次是Q、NSW和V。
chap1_para1414,5,,最后T仍然有3个可能的值，任意一个都是有效的。
chap1_para1414,6,,我们可以将前向检验看作一种以增量方式计算MRV启发式算法完成其工作所需信息的有效途径。
chap1_para1415,1,,尽管前向检验能够检测出许多不一致，但它无法检测到所有的不一致。
chap1_para1415,2,,问题在于，它向前看得不够远。
chap1_para1415,3,,例如，考虑图6-7中的Q = green一行。
chap1_para1415,4,,我们已经使WA和Q弧一致，但此时NT和SA的唯一可能的值都是蓝色，这违反了一致性，因为它们是相邻变量，相邻变量不能取相同的值。
chap1_para1416,1,,维护弧一致性（maintaining arc consistency，MAC）算法能检测出这类不一致性。
chap1_para1416,2,,"当变量Xi被赋值后，Inference程序调用AC-3，但我们开始时只考虑所有与Xi相邻的未赋值变量Xj的弧(Xj, Xi)，而不是CSP中的所有弧。"
chap1_para1416,3,,从这出发，AC-3以通常的方式进行约束传播，如果任何变量的域缩减为空集，则AC-3调用失败，并立即回溯。
chap1_para1416,4,,我们可以看到，MAC严格来说比前向检验更强大，因为前向检验所做的事情与MAC对其队列的初始弧所做的相同；但与MAC不同的是，当变量的域发生变化时，前向检验不会递归地传播约束。
chap1_para1417,1,,6.3.3　智能回溯：向后看
chap1_para1418,1,,当搜索的一个分支失败时，图6-5中的Backtracking-Search算法将采取一种非常简单的策略：退回到上一个变量，并为其尝试一个不同的值。
chap1_para1418,2,,这称为时序回溯（chronological backtracking），因为时间上最近的决策点会被重新访问。
chap1_para1418,3,,在本节中，我们考虑更好的可能策略。
chap1_para1419,1,,考虑一下，当我们按照固定的变量顺序Q、NSW、V、 T、SA、WA、NT应用图6-1中的简单回溯时会发生什么。
chap1_para1419,2,,假设我们已经生成了部分赋值。
chap1_para1419,3,,当我们尝试下一个变量SA时，发现所有值都违反了约束。
chap1_para1419,4,,我们退回到T，为塔斯马尼亚州尝试一种新颜色！
chap1_para1419,5,,显然，这种做法是愚蠢的——重新给塔斯马尼亚州着色并不能解决南澳大利亚州的问题。
chap1_para142,1,"Despite this optimistic prediction, the Dartmouth workshop did not lead to any breakthroughs. Newell and Simon presented perhaps the most mature work, a mathematical theorem-proving system called the Logic Theorist (LT). Simon claimed, “We have invented a computer program capable of thinking non-numerically, and thereby solved the venerable mind–body problem.”13 Soon after the workshop, the program was able to prove most of the theorems in Chapter 2 of Russell and Whitehead’s Principia Mathematica. Russell was reportedly delighted when told that LT had come up with a proof for one theorem that was shorter than the one in Principia. The editors of the Journal of Symbolic Logic were less impressed; they rejected a paper coauthored by Newell, Simon, and Logic Theorist.",从那时起，每一代计算机硬件更新都带来了速度和容量的提升以及价格的下降，这是摩尔定律（Moore’s law）所描述的趋势。
chap1_para142,2,,直到2005年之前，大约每18个月CPU的性能就会翻一番，但功耗问题导致制造商开始增加CPU的核数而不是提高CPU的时钟频率。
chap1_para142,3,,目前的预期是，未来性能的增加将来自于大量的并行性，这体现了与大脑特性奇妙的一致性。
chap1_para142,4,,在应对不确定的世界时，基于这一理念设计硬件：不需要64位的数字精度，只需16位（如bfloat16格式）甚至8位就足够了，这可以使处理速度更快。
chap1_para1420,1,,一种更智能的方法是回溯到有可能求解这一问题的变量——导致SA的某个可能值变成不可能值的变量。
chap1_para1420,2,,为此，我们将记录与SA的某些值冲突的赋值集合。
chap1_para1420,3,,该集合（在本例中为）称为SA的冲突集（conflict set）。
chap1_para1420,4,,回跳（backjumping）方法将回溯到冲突集中最近的赋值，在本例中，回跳将越过塔斯马尼亚州，为V尝试一个新的值。
chap1_para1420,5,,通过修改Backtrack算法，可以很容易地实现上述方法，即在检验合法值时，同时维护冲突集。
chap1_para1420,6,,如果找不到合法值，算法应该返回失败指示和冲突集中最近的元素。
chap1_para1421,1,,眼尖的读者可能已经注意到，前向检验不需要额外工作就能提供冲突集：当前向检验根据赋值X = x从Y的域中删除一个值时，它应该将X = x添加到Y的冲突集中。
chap1_para1421,2,,如果Y的域中的最后一个值也被删除，那么Y的冲突集中的赋值也要被添加到X的冲突集中。
chap1_para1421,3,,也就是说，我们现在知道X = x导致了（Y中的）矛盾，因此应该为X尝试不同赋值。
chap1_para1422,1,,有眼力的读者可能已经注意到一些奇怪的事情：当域中的每个值都与当前赋值冲突时就会发生回跳，但前向检验能检测出这个事件并阻止搜索到达这样的节点！
chap1_para1422,2,,事实上，可以证明，每个被回跳剪除的分支也会被前向检验剪枝。
chap1_para1422,3,,因此，在前向检验搜索中，或者在使用更强一致性检验的搜索（如MAC）中，简单的回跳是多余的——你只需执行其中一项。
chap1_para1423,1,,尽管存在上一段中的观测结果，回跳背后的思想仍然值得借鉴：基于失败原因进行回溯。
chap1_para1423,2,,当变量的域变为空集时，回跳发现失败，但在许多情况下，在很早之前分支就注定要失败。
chap1_para1423,3,,再次考虑部分赋值（从我们前面的讨论来看，它是不一致的）。
chap1_para1423,4,,假设我们下一步尝试T = red，然后对NT、Q、V和SA赋值。
chap1_para1423,5,,我们知道，最后这4个变量不存在有效赋值，所以最终在NT处终止。
chap1_para1423,6,,现在，问题是，回溯到哪儿？
chap1_para1423,7,,回跳是不可行的，因为NT确实存在与前面赋值过的变量一致的值——NT没有导致失败的前面变量的完整冲突集。
chap1_para1423,8,,然而，我们知道，NT、Q、V和SA这4个变量放在一起会失败，是因为前面的一组变量一定与这4个变量有直接冲突。
chap1_para1424,1,,这引出了（对于NT这样的变量的）一种不同的、更深层次的冲突集概念：正是前面一组变量共同导致了NT连同任何后续变量都不存在一致解。
chap1_para1424,2,,在本例中，该集合是WA和NSW，所以算法应该跳过塔斯马尼亚州回溯到NSW。
chap1_para1424,3,,使用以这种方式定义的冲突集的回跳算法称为冲突导向回跳（conflict-directed backjumping）。
chap1_para1425,1,,现在我们必须解释如何计算这些新的冲突集。
chap1_para1425,2,,方法其实很简单。
chap1_para1425,3,,搜索分支的“终端”失败总是因为某个变量的域变为空集，该变量对应一个标准冲突集。
chap1_para1425,4,,在我们的例子中，SA失败，它的冲突集是（例如）。
chap1_para1425,5,,我们回溯到Q，Q将SA的冲突集（当然要减去Q本身）吸收到它自己的直接冲突集，新的冲突集是。
chap1_para1425,6,,也就是说，给定前面对的赋值，从Q向前是没有解的。
chap1_para1425,7,,因此，我们回溯到最近的变量NT。
chap1_para1425,8,,NT将吸收到它自己的直接冲突集中，得到（如上一段所述）。
chap1_para1425,9,,现在算法回跳到NSW，这正是我们所希望的。
chap1_para1425,10,,总结一下：设Xj表示当前变量，conf(Xj)表示它的冲突集。
chap1_para1425,11,,如果Xj的每个可能值都失败了，则回跳到conf(Xj)中最近的变量Xi，并使用下列公式重新计算Xi的冲突集：
chap1_para1426,1,,6.3.4　约束学习
chap1_para1427,1,,当我们遇到矛盾时，回跳可以告诉我们要退回多远，这样我们就不会浪费时间去改变那些无法求解问题的变量。
chap1_para1427,2,,但我们也希望不要再遇到同样的问题。
chap1_para1427,3,,当搜索得出一个矛盾时，我们知道这是冲突集的某个子集引起的。
chap1_para1427,4,,约束学习（constraint learning）的思想是从冲突集中找出引起问题的最小变量集。
chap1_para1427,5,,这组变量及其相应值称为无用赋值（no-good）。
chap1_para1427,6,,如果想要记录无用赋值，要么通过向CSP中添加一个新的约束禁止这种赋值组合，要么通过维护一个单独的缓存。
chap1_para1428,1,,例如，考虑图6-6最下面一行中的状态。
chap1_para1428,2,,前向检验告诉我们这个状态是一个无用赋值，因为SA不存在有效赋值。
chap1_para1428,3,,在这种特定情况下，记录该无用赋值是没有意义的，因为一旦从搜索树中剪掉了这一分支，我们再也不会遇到这种组合。
chap1_para1428,4,,但假设图6-6中的搜索树实际上是更大的搜索树的一部分，该搜索树是从V和T的赋值开始的。
chap1_para1428,5,,那么将记录为无用赋值是有意义的，因为对于V和T的每一组可能赋值，我们都会再次遇到同样的问题。
chap1_para1429,1,,前向检验或回跳可以有效地利用无用赋值。
chap1_para1429,2,,约束学习是现代CSP求解器用以提高复杂问题求解效率的最重要技术之一。
chap1_para143,1,"1.3.2Early enthusiasm, great expectations (1952–1969)",已经出现了一些针对人工智能应用进行调整的硬件，如图形处理单元（GPU）、张量处理单元（TPU）和晶圆级引擎（WSE）。
chap1_para143,2,,从20世纪60年代到大约2012年，用于训练顶级机器学习应用的计算能力遵循了摩尔定律。
chap1_para143,3,,"从2012年开始，情况发生了变化：从2012年到2018年，这一数字增长了30万倍，大约每100天翻一番（Amodei and Hernandez, 2018）。"
chap1_para143,4,,"在2014年花一整天训练的机器学习模型在2018年只需两分钟就可以训练完成（Ying et al., 2018）。"
chap1_para143,5,,尽管量子计算（quantum computing）还不实用，但它有望为人工智能算法的一些重要子方向提供更显著的加速。
chap1_para1430,1,,6.4　CSP的局部搜索
chap1_para1431,1,,局部搜索算法（见4.1节）对于许多CSP的求解都非常有效。
chap1_para1431,2,,它们使用完整状态形式（见4.1.1节），即每一状态为所有变量赋值，搜索一次改变一个变量的值。
chap1_para1431,3,,例如，考虑6.1.3节中定义为CSP的8皇后问题。
chap1_para1431,4,,在图6-8中，我们从左边开始，对8个变量进行了完整赋值，通常该赋值会违反一些约束。
chap1_para1431,5,,然后我们随机选择一个发生冲突的变量，在此是最右边一列的Q8。
chap1_para1431,6,,我们希望改变它的值，从而更接近问题的解。
chap1_para1431,7,,最明显的方法是选择与其他变量冲突数最少的值——最少冲突（min-conflict）启发式算法。
chap1_para1432,1,,图6-8　使用最少冲突法求解8皇后问题的示例。
chap1_para1432,2,,每步选择一个皇后，在其所在列重新分配位置。
chap1_para1432,3,,每个方格标有冲突数（在本例中是互相攻击的皇后个数）。
chap1_para1432,4,,算法随机选择发生冲突的皇后，将皇后移动到冲突最少的方格
chap1_para1433,1,,在图6-8中，我们看到有两行都只违反了一个约束，我们选择让Q8 = 3（也就是说，我们将皇后移动到第8列、第3行）。
chap1_para1433,2,,下一次迭代，在图6-8的中间棋盘上，我们选择Q6作为要改变的变量，然后发现将该皇后移动到第8行不会发生冲突。
chap1_para1433,3,,此时不再有发生冲突的变量，所以我们找到了一个解。
chap1_para1433,4,,最少冲突算法如图6-9所示。
chap1_para1433,5,,[4]
chap1_para1435,1,,[4]　局部搜索可以很容易地扩展到约束优化问题（COP）。
chap1_para1435,2,,在这种情况下，爬山法和模拟退火的所有技术都可以用于优化目标函数。
chap1_para1436,1,,图6-9　CSP的Min-Conflicts局部搜索算法。
chap1_para1436,2,,初始状态可以随机选择，也可以通过基于贪心法的赋值过程依次为每个变量选择最少冲突值。
chap1_para1436,3,,在给定当前赋值的其余部分后，Conflicts函数统计特定值违反约束的数量
chap1_para1437,1,,对许多CSP来说，最少冲突法都相当有效。
chap1_para1437,2,,神奇的是，在n皇后问题上，如果不计入皇后的初始布局，最少冲突法的运行时间基本上与问题规模无关。
chap1_para1437,3,,它甚至可以在（初始赋值后）平均50步内求解百万皇后问题。
chap1_para1437,4,,这一不同寻常的现象是20世纪90年代大量研究局部搜索和难易问题间区别的动力，我们将在7.6.3节中讨论这些问题。
chap1_para1437,5,,粗略地说，用局部搜索求解n皇后问题非常简单，因为解密集地分布在整个状态空间上。
chap1_para1437,6,,最少冲突法也适用于困难问题。
chap1_para1437,7,,例如，它已经被用于哈勃太空望远镜的观测调度，安排一周的观测调度所花费的时间可以从3周减少到大约10分钟。
chap1_para1438,1,,4.1节中的所有局部搜索技术都可以应用于CSP，有些技术已被证实相当有效。
chap1_para1438,2,,最少冲突启发式算法下的CSP地形图通常存在一系列平台区。
chap1_para1438,3,,可能有数百万个变量赋值都只存在一个冲突。
chap1_para1438,4,,平台区搜索——允许横向移动到另一个得分相同的状态——可以帮助局部搜索走出平台区。
chap1_para1438,5,,这种在平台区的漫游可以由一种叫作禁忌搜索的技术导引：维护一个最近访问过的状态的列表，并禁止算法返回那些状态。
chap1_para1438,6,,模拟退火也可以用于逃离平台区。
chap1_para1439,1,,另一种技术称为约束加权（constraint weighting），旨在集中搜索重要约束。
chap1_para1439,2,,每个约束都有一个数值权重，初始时都为1。
chap1_para1439,3,,在每步搜索中，算法找出使其所违反的约束的总权重最低的变量，并修改其值。
chap1_para1439,4,,然后，增加当前赋值所违反的每个约束的权重。
chap1_para1439,5,,这种做法有两个好处：它为平台区增加了地形因素，确保从当前状态进行改进是有可能的；它还引入了学习策略，随着时间推移，难以求解的约束会被分配更高的权重。
chap1_para144,1,"The intellectual establishment of the 1950s, by and large, preferred to believe that “a machine can never do X.” (See Chapter 28 for a long list of X’s gathered by Turing.) AI researchers naturally responded by demonstrating one X after another. They focused in particular on tasks considered indicative of intelligence in humans, including games, puzzles, mathematics, and IQ tests. John McCarthy referred to this period as the “Look, Ma, no hands!” era.",毋庸置疑，在电子计算机出现之前计算设备就已经存在了。
chap1_para144,2,,最早的自动化机器可追溯到17世纪（见1.2.1节的讨论）。
chap1_para144,3,,第一台可编程机器是由约瑟夫·玛丽·雅卡尔（Joseph Marie Jacquard，1752—1834）于1805年发明的提花织布机，它使用打孔卡片来存储编织图案的指令。
chap1_para1440,1,,局部搜索的另一个优点是，当问题发生变化时，它可以用于在线设定的问题（见4.5节）。
chap1_para1440,2,,考虑一个航空公司每周航班调度问题。
chap1_para1440,3,,它可能涉及上千趟航班和上万名人员的分配，但机场的恶劣天气可能会打乱这一调度。
chap1_para1440,4,,我们希望以最少的改动修正日程表。
chap1_para1440,5,,这可以通过从当前调度开始的局部搜索算法轻松完成。
chap1_para1440,6,,使用新约束集的回溯搜索通常要花费更多时间，而且找到的解可能要对当前调度进行很多改动。
chap1_para1442,1,,在这一节中，我们将研究如何利用由约束图表示的问题的结构来快速找到解。
chap1_para1442,2,,这里的大多数方法也适用于CSP之外的其他问题，例如概率推理。
chap1_para1443,1,,处理复杂的真实世界问题的唯一可能方法是将其分解为若干子问题。
chap1_para1443,2,,回顾澳大利亚问题的约束图（图6-1b和图6-12a），可以发现一个问题：塔斯马尼亚州和大陆不相连。
chap1_para1443,3,,[5]直观上看，对塔斯马尼亚州着色和对大陆着色显然是两个独立子问题（independent subproblem）——任何对大陆着色的解和任何对塔斯马尼亚州着色的解相结合都能得到整个地图的解。
chap1_para1445,1,,[5]　细心的制图师或热爱塔斯马尼亚州的塔斯马尼亚人可能会反对将塔斯马尼亚州和离它最近的大陆邻域涂上相同的颜色，以免给人留下它可能是那个州的一部分的印象。
chap1_para1446,1,,可以简单地通过寻找约束图的连通分量（connected component）来确定独立性。
chap1_para1446,2,,每个连通分量对应一个子问题CSPi。
chap1_para1446,3,,如果赋值Si是CSPi的解，那么就是的解。
chap1_para1446,4,,为什么这很重要？
chap1_para1446,5,,假设每个CSPi具有所有n个变量中的c个变量，其中c是一个常数。
chap1_para1446,6,,那么共有n/c个子问题，求解每个子问题最多需要d c工作量，其中d是域的大小。
chap1_para1446,7,,因此，总的工作量为O(dcn/c)，关于n是线性的；如果不进行问题分解，总的工作量为O(d n)，关于n是指数级的。
chap1_para1446,8,,让我们更具体地说：将一个具有100个变量的布尔CSP分解为4个子问题，那么最坏情况下的求解时间将从宇宙生命周期减少到不到1秒。
chap1_para1447,1,,完全独立的子问题很好，但很少见。
chap1_para1447,2,,幸运的是，其他一些图结构也很容易求解。
chap1_para1447,3,,例如，当任意两个变量都只由一条路径连接时，约束图是一棵树。
chap1_para1447,4,,我们将证明任何树状结构的CSP都可以在变量个数的线性时间内求解。
chap1_para1447,5,,[6]这里的关键是一种新的一致性概念——定向弧一致性（directional arc consistency）或DAC。
chap1_para1447,6,,"变量顺序为X1, X2, …, Xn的CSP称为定向弧一致的，当且仅当，时，每个Xi相对于每个Xj都是弧一致的。"
chap1_para1449,1,,[6]　遗憾的是，除了苏拉威西岛（Sulawesi）的地图比较接近树状外，世界上几乎没有一个地区是树状结构的地图。
chap1_para145,1,"Newell and Simon followed up their success with LT with the General Problem Solver, or GPS. Unlike LT, this program was designed from the start to imitate human problem-solving protocols. Within the limited class of puzzles it could handle, it turned out that the order in which the program considered subgoals and possible actions was similar to that in which humans approached the same problems. Thus, GPS was probably the first program to embody the “thinking humanly” approach. The success of GPS and subsequent programs as models of cognition led Newell and Simon (1976) to formulate the famous physical symbol system hypothesis, which states that “a physical symbol system has the necessary and sufficient means for general intelligent action.” What they meant is that any system (human or machine) exhibiting intelligence must operate by manipulating data structures composed of symbols. We will see later that this hypothesis has been challenged from many directions.",19世纪中期，查尔斯·巴贝奇（Charles Babbage，1792—1871）设计了两台计算机，但都没有完成。
chap1_para145,2,,差分机的目的是为工程和科学项目计算数学表。
chap1_para145,3,,"它最终于1991年建成并投入使用（Swade, 2000）。"
chap1_para145,4,,巴贝奇的分析机更有雄心：它包括可寻址内存、基于雅卡尔打孔卡的存储程序以及有条件的跳转。
chap1_para145,5,,这是第一台能够进行通用计算的机器。
chap1_para1450,1,,为了求解树状结构的CSP，首先选择任一变量作为树的根节点，然后选择变量顺序，每个变量必须在其父节点之后。
chap1_para1450,2,,这种排序称为拓扑排序（topological sort）。
chap1_para1450,3,,图6-10a为一棵树，图6-10b为一种可能的排序。
chap1_para1450,4,,任何有n个节点的树都有n−1条边，所以可以在O(n)步内使得该图具有定向弧一致性，每一步都必须比较两个变量的最多d个可能的值，总时间为O(nd2)。
chap1_para1450,5,,一旦我们有了一个定向弧一致的图，就可以沿着变量列表选择任意剩余值。
chap1_para1450,6,,因为从父节点到其子节点的每条边都是弧一致的，所以，对于父节点选择的任何值，子节点都存在一个可选的有效值。
chap1_para1450,7,,这意味着我们不必回溯，可以沿着变量线性移动。
chap1_para1450,8,,完整算法如图6-11所示。
chap1_para1451,1,,图6-10　（a）树状结构CSP的约束图。
chap1_para1451,2,,（b）与以A为根节点的树一致的变量的线性排序。
chap1_para1451,3,,这称为变量的拓扑排序
chap1_para1452,1,,既然我们有了关于树的高效算法，可以考虑更一般的约束图是否可以以某种方式简化为树结构。
chap1_para1452,2,,有两种方法可以做到这一点：删除节点（6.5.1节）或合并节点（6.5.2节）。
chap1_para1453,1,,图6-11　用于求解树状结构CSP的Tree-CSP-Solver算法。
chap1_para1453,2,,如果CSP有解，我们可以在线性时间内找到它；如果无解，将检测到矛盾
chap1_para1454,1,,6.5.1　割集调整
chap1_para1455,1,,将约束图简化为树的第一种方法是为部分变量赋值使得剩余变量能够形成一棵树。
chap1_para1455,2,,考虑澳大利亚问题的约束图，如图6-12a所示。
chap1_para1455,3,,如果没有南澳大利亚州，这个图就会变成如图6-12b所示的一棵树。
chap1_para1455,4,,幸运的是，我们可以通过将SA固定为某个值并从其他变量的域中删除任何与SA取值不一致的值来从图中删除南澳大利亚州。
chap1_para1456,1,,图6-12　（a）图6-1中的原始约束图。
chap1_para1456,2,,（b）除去SA后，约束图变成由两棵树组成的森林
chap1_para1457,1,,现在，删除SA及其约束后，CSP的任意一个解都与SA的值一致。
chap1_para1457,2,,（这适用于二元CSP，在高阶约束下，情况会更加复杂。
chap1_para1457,3,,）因此，我们可以用上面给出的算法求解剩余的树，从而求解整个问题。
chap1_para1457,4,,当然，在一般情况下（与地图着色不同），为SA选择的值可能是错误的，因此我们需要尝试每个可能的值。
chap1_para1457,5,,一般算法如下。
chap1_para1458,1,,（1）选择CSP变量的一个子集S，使得约束图在删除S后成为一棵树。
chap1_para1458,2,,S称为环割集（cycle cutset）。
chap1_para1459,1,,（2）对于满足S上所有约束的S中变量的每种可能赋值，
chap1_para146,1,"At IBM, Nathaniel Rochester and his colleagues produced some of the first AI programs.","巴贝奇的同事埃达·洛芙莱斯（Ada Lovelace，诗人拜伦勋爵的女儿）理解了计算机的潜力，将其描述为“一种能思考或者……能推理的机器”，能够对“宇宙中所有事物”进行推理（Lovelace, 1843）。"
chap1_para146,2,"Herbert Gelernter (1959) constructed the Geometry Theorem Prover, which was able to prove theorems that many students of mathematics would find quite tricky.",她还预测到了人工智能的技术成熟度曲线，并提出：“我们最好防范可能夸大分析机能力的想法。
chap1_para146,3,This work was a precursor of modern mathematical theorem provers.,”遗憾的是，巴贝奇的机器和洛芙莱斯的思想已基本被遗忘了。
chap1_para1460,1,,a. 从剩余变量的域中删除任何与S赋值不一致的值，并且
chap1_para1461,1,,b. 如果剩余的CSP存在一个解，那么将其连同S的赋值一起返回。
chap1_para1462,1,,如果环割集的大小为c，那么总运行时间为：我们需要尝试S中变量的值的所有d c种组合，对于每种组合，我们需要求解一个大小为(n −c)的树问题。
chap1_para1462,2,,如果约束图“几乎是一棵树”，那么c将会非常小，相比于直接使用回溯法，将省掉巨大的开销——对100个布尔变量的示例来说，如果我们能找到一个大小为c = 20的割集，时间开销可以从宇宙生命周期缩短到几分钟。
chap1_para1462,3,,然而，在最坏情况下，c可能高达(n −2)。
chap1_para1462,4,,寻找最小环割集问题是NP困难的，但有一些高效的近似算法。
chap1_para1462,5,,算法的总体过程称为割集调整（cutset conditioning），我们将在第13章详细讨论，在那里它将用于概率推理。
chap1_para1464,1,,将约束图简化为树的第二种方法基于构建约束图的树分解（tree decomposition）：将原始图转换为树，树中的每个节点由一组变量组成，如图6-13所示。
chap1_para1464,2,,树分解必须满足以下3个要求。
chap1_para1465,1,,● 原始问题中的每个变量必须至少出现在一个树节点中。
chap1_para1466,1,,● 如果两个变量在原始问题中由一个约束连接，那么它们必须同时出现（连同约束）在至少一个树节点中。
chap1_para1467,1,,● 如果一个变量出现在两个树节点中，那么它必须出现在连接这两个节点的路径上的所有节点中。
chap1_para1468,1,,前两个条件保证了所有变量和约束在树分解中都有表示。
chap1_para1468,2,,第三个条件似乎更具技术性，但保证了原始问题的任何变量无论在哪出现都具有相同的值：树中的约束表明一个树节点中的变量必须与其相邻节点中的相应变量具有相同的值。
chap1_para1468,3,,例如，图6-13中SA出现在相连的所有4个节点中，因此树分解中的每条边都包含一个约束，一个节点中SA的值必须与下个节点中SA的值相同。
chap1_para1468,4,,你可以从图6-12中验证这种分解是有意义的。
chap1_para1469,1,,图6-13　图6-12a中约束图的一个树分解
chap1_para147,1,"Of all the exploratory work done during this period, perhaps the most influential in the long run was that of Arthur Samuel on checkers (draughts). Using methods that we now call reinforcement learning (see Chapter 23), Samuel’s programs learned to play at a strong amateur level. He thereby disproved the idea that computers can do only what they are told to: his program quickly learned to play a better game than its creator. The program was demonstrated on television in 1956, creating a strong impression. Like Turing, Samuel had trouble finding computer time. Working at night, he used machines that were still on the testing floor at IBM’s manufacturing plant. Samuel’s program was the precursor of later systems such as TD-GAMMON (Tesauro, 1992), which was among the world’s best backgammon players, and ALPHAGO (Silver et al., 2016), which shocked the world by defeating the human world champion at Go (see Chapter 6).",人工智能还得益于计算机科学软件方面的发展，后者提供了编写现代程序所需的操作系统、编程语言和工具（以及有关它们的论文）。
chap1_para147,2,,而这也是人工智能对其有回馈的领域：人工智能工作开创的许多想法正重归主流计算机科学，包括分时、交互式解释器、使用窗口和鼠标的个人计算机、快速开发环境、链表数据类型、自动存储管理，以及符号式编程、函数式编程、说明性编程和面向对象编程的关键概念。
chap1_para1470,1,,一旦我们有了一个树状结构图，我们可以应用Tree-CSP-Solver在O(nd 2)时间内得到解，其中n是树节点的个数，d是最大域的大小。
chap1_para1470,2,,但是要注意，在树中，域是一组值元组，而不只是单个值。
chap1_para1471,1,,例如，图6-13中的左上节点表示在原始问题层级上，变量为，域为，约束为、和的子问题。
chap1_para1471,2,,"而在树的层级上，节点表示单个变量，我们可以将其称为SANTWA，它的值必须是一个由颜色组成的三元组，如(red, green, blue)，但不能是(red, red, blue)，因为违反了原始问题中的约束。"
chap1_para1471,3,,"然后我们可以从这个节点移动到相邻节点，其变量为SANTQ，此时只有一个元组(red, green, blue)与SANTWA的选择一致。"
chap1_para1471,4,,对后两个节点重复完全相同的过程，但可以独立地为T作出任何选择。
chap1_para1472,1,,使用Tree-CSP-Solver算法可以在O(nd2)时间内求解任何树分解问题，只要d保持较小值，它都是高效的。
chap1_para1472,2,,回到100个布尔变量的示例，如果每个节点有10个变量，那么d = 210，我们可以在几秒内找到解。
chap1_para1472,3,,但如果有一个节点包含30个变量，则需要几个世纪的时间。
chap1_para1473,1,,一个给定的图允许多种树分解，在选择分解时，目标是使子问题尽可能小。
chap1_para1473,2,,（将所有变量放在同一个节点中在技术上也是一棵树，但对求解问题没有帮助。
chap1_para1473,3,,）图的树分解的树宽（tree width）为最大节点的大小减1，图本身的树宽定义为其所有树分解的最小宽度。
chap1_para1473,4,,如果一个图的树宽为w，那么给定相应的树分解，该问题可以在O(ndw+1)时间内求解。
chap1_para1473,5,,因此，如果CSP的约束图树宽有界，则该CSP在多项式时间内是可解的。
chap1_para1474,1,,遗憾的是，找出树宽最小的分解是 一个NP困难问题，但有一些启发式方法在实践中效果很好。
chap1_para1474,2,,时间为的割集分解和时间为O(ndw+1)的树分解哪个更好？
chap1_para1474,3,,每当有一个大小为c的环割集时，也会有一个大小为的树宽，并且在某些情况下它可能要小得多。
chap1_para1474,4,,所以从时间上考虑，应该选择树分解，但环割集方法的优点是，它可以在线性内存中执行，而树分解需要关于w的指数级内存。
chap1_para1476,1,,到目前为止，我们已经讨论了约束图的结构。
chap1_para1476,2,,在变量的值中，或在约束关系本身的结构中，也可能存在重要的结构。
chap1_para1476,3,,考虑有d种颜色的地图着色问题。
chap1_para1476,4,,对于每个一致解，实际上都有一组通过排列颜色名形成的d!个解。
chap1_para1476,5,,例如，在澳大利亚地图中，我们知道WA、NT和SA肯定具有不同颜色，但实际上，将3种颜色分配给3个区域有3! = 6种方法。
chap1_para1476,6,,这称为值对称（value symmetry）。
chap1_para1476,7,,我们希望通过打破这种赋值对称性将搜索空间缩小d!倍。
chap1_para1476,8,,可以通过引入对称性破缺约束（symmetry-breaking constraint）做到这一点。
chap1_para1476,9,,对于我们的例子，可以施加一个任意的排序约束，，即要求3个值按字母顺序排列。
chap1_para1476,10,,这个约束保证了d!个解中只有一个是可能解：。
chap1_para1477,1,,对于地图着色问题，很容易找到一个消除对称性的约束。
chap1_para1477,2,,一般来说，要消除所有的对称性是NP困难的，但打破值对称已被证明在许多问题上都是重要和有效的。
chap1_para1479,1,,● 约束满足问题（CSP）的状态为一组变量/值对，解的条件为一组变量约束。
chap1_para1479,2,,许多重要的真实问题都可以用CSP描述。
chap1_para148,1,"In 1958, John McCarthy made two important contributions to AI.",1.2.7　控制理论与控制论
chap1_para148,2,In MIT AI Lab Memo No.,
chap1_para148,3,"1, he defined the high-level language Lisp, which was to become the dominant AI programming language for the next 30 years.",
chap1_para148,4,"In a paper entitled Programs with Common Sense, he advanced a conceptual proposal for AI systems based on knowledge and reasoning.",
chap1_para148,5,"The paper describes the Advice Taker, a hypothetical program that would embody general knowledge of the world and could use it to derive plans of action.",
chap1_para148,6,The concept was illustrated with simple logical axioms that suffice to generate a plan to drive to the airport.,
chap1_para148,7,"The program was also designed to accept new axioms in the normal course of operation, thereby allowing it to achieve competence in new areas without being reprogrammed.",
chap1_para148,8,"The Advice Taker thus embodied the central principles of knowledge representation and reasoning: that it is useful to have a formal, explicit representation of the world and its workings and to be able to manipulate that representation with deductive processes.",
chap1_para148,9,The paper influenced the course of AI and remains relevant today.,
chap1_para1480,1,,● 许多推断技术利用约束排除某些变量赋值。
chap1_para1480,2,,这些约束包括节点一致性、弧一致性、路径一致性和k一致性。
chap1_para1481,1,,● 回溯搜索是深度优先搜索的一种形式，通常用于求解CSP。
chap1_para1481,2,,推断可以与搜索交替进行。
chap1_para1482,1,,● 最少剩余值启发式算法和度启发式算法是领域无关的方法，用于决定在回溯搜索中下一步选择哪个变量。
chap1_para1482,2,,最少约束值启发式算法有助于决定对于给定变量首先尝试哪个值。
chap1_para1482,3,,回溯发生在某个变量找不到合法赋值时。
chap1_para1482,4,,冲突导向回跳直接回溯到问题的根源。
chap1_para1482,5,,约束学习记录在搜索过程中遇到的冲突，以免在以后的搜索中出现相同的冲突。
chap1_para1483,1,,● 使用最少冲突启发式算法的局部搜索也已成功地应用于约束满足问题。
chap1_para1484,1,,● CSP求解的复杂性与其约束图的结构密切相关。
chap1_para1484,2,,树状结构问题可以在线性时间内求解。
chap1_para1484,3,,割集调整可以将一般的CSP简化为树状结构的CSP，如果能找到一个较小的割集，算法会非常高效（只需线性内存）。
chap1_para1484,4,,树分解技术将CSP转化为由子问题构成的树，当约束图的树宽较小时，算法是高效的；然而，它们需要约束图树宽的指数级的内存。
chap1_para1484,5,,将割集调整和树分解相结合可以更好地权衡所需内存和时间。
chap1_para1487,1,,第三部分　知识、推理和规划
chap1_para1489,1,,在本章中，我们设计能够表示复杂世界的智能体，它使用推断过程来获取关于这个世界的新表示，并使用这种表示来推导下一步该怎么做。
chap1_para149,1,"1958 also marked the year that Marvin Minsky moved to MIT. His initial collaboration with McCarthy did not last, however. McCarthy stressed representation and reasoning in formal logic, whereas Minsky was more interested in getting programs to work and eventually developed an anti-logic outlook. In 1963, McCarthy started the AI lab at Stanford. His plan to use logic to build the ultimate Advice Taker was advanced by J. A. Robinson’s discovery in 1965 of the resolution method (a complete theorem-proving algorithm for first-order logic; see Chapter 9). Work at Stanford emphasized general-purpose methods for logical reasoning. Applications of logic included Cordell Green’s question-answering and planning systems (Green, 1969b) and the Shakey robotics project at the Stanford Research Institute (SRI). The latter project, discussed further in Chapter 26, was the first to demonstrate the complete integration of logical reasoning and physical activity.",● 人造物如何在它们自己的控制下运行？
chap1_para1490,1,,人类似乎具有知识，人类的知识能够帮助他们做事。
chap1_para1490,2,,在人工智能中，基于知识的智能体（knowledge-based agent）对知识的内部表示（representation）进行推理（reasoning）来确定要采取的动作。
chap1_para1491,1,,第3章和第4章的问题求解智能体具有知识，但这种知识是非常有限且死板的。
chap1_para1491,2,,它们知道可以采取哪些动作，也知道在某个状态采取某个动作将得到哪种结果，但它们不知道一般事实。
chap1_para1491,3,,例如，寻路智能体不知道一条路的长度不可能是负数公里，而8数码智能体也不知道两块瓷砖无法放置在同一个空格当中。
chap1_para1491,4,,问题求解智能体具有的知识对寻找从起点到终点的路径这种问题非常有用，但也仅限于此。
chap1_para1492,1,,问题求解智能体所使用的原子表示也有很大的局限性。
chap1_para1492,2,,例如，在部分可观测的环境中，问题求解智能体表示它对当前状态的了解的唯一选项是列出所有可能的具体状态。
chap1_para1492,3,,我可以让一个人驱车前往一个人口不超过1万的美国小镇，但如果要让问题求解智能体来做这件事，我只能明确地将目标描述为大约1.6万个符合条件的小镇的集合。
chap1_para1493,1,,第6章引入了我们的第一个因子化表示，其中状态被表示为对变量的赋值。
chap1_para1493,2,,这是朝正确方向前进的一步，它能使智能体的某些部分以与领域无关的方式运作，并支持更高效的算法。
chap1_para1493,3,,在本章中，我们将这一步延伸到它的逻辑结论，可以说，我们将逻辑扩展为一类通用的表示，以支持基于知识的智能体。
chap1_para1493,4,,这些智能体可以组合或重组信息以适应各种用途。
chap1_para1493,5,,它可以与我们当下的需要毫不相关，就像数学家证明定理或天文学家计算地球的预期寿命一样。
chap1_para1493,6,,基于知识的智能体能够接受明确描述的目标作为任务，能够通过主动学习或被告知关于环境的新知识快速地获得完成任务的能力，也能够通过更新相关知识适应环境的变化。
chap1_para1494,1,,我们在7.1节开始介绍智能体的总体设计。
chap1_para1494,2,,7.2节新引入了一个名为wumpus世界的简单环境，以便在不涉及任何技术细节的前提下，阐明基于知识的智能体的运作方式。
chap1_para1494,3,,随后我们在7.3节解释逻辑的一般原理，在7.4节介绍命题逻辑的具体细节。
chap1_para1494,4,,命题逻辑是一种因子化表示，尽管它的表达能力不如一阶逻辑（第8章）这种标准的结构化表示，但却能够阐明逻辑的所有基本概念。
chap1_para1494,5,,命题逻辑还具有丰富的推断方法，我们将在7.5节和7.6节中描述这些内容。
chap1_para1494,6,,最后，7.7节将基于知识的智能体的概念与命题逻辑的技术结合起来，为wumpus世界构建了一个简单的智能体。
chap1_para1495,1,,7.1　基于知识的智能体
chap1_para1496,1,,基于知识的智能体的核心部件是它的知识库（knowledge base，KB）。
chap1_para1496,2,,知识库是一个语句集。
chap1_para1496,3,,（此处“语句”是一个术语。
chap1_para1496,4,,它与英语或其他自然语言的语句类似，但不完全相同。
chap1_para1496,5,,）这些语句用知识表示语言（knowledge representation language）表达，代表了关于世界的某种断言。
chap1_para1496,6,,如果一条语句是直接给出的，而不是从其他语句推导而来的，我们就称它为公理（axiom）。
chap1_para1497,1,,向知识库添加新语句以及从知识库查询已知语句的方法是必不可少的。
chap1_para1497,2,,这些操作的标准名称分别是Tell（告知）和Ask（询问）。
chap1_para1497,3,,这两个操作都可能涉及推断（inference），也就是从原有语句中推导出新语句。
chap1_para1497,4,,推断必须符合以下要求：当向知识库询问（Ask）时，答案应当遵循先前已经告知（Tell）知识库的内容而生成。
chap1_para1497,5,,我们将在本章后续部分仔细讲解何为“遵循”。
chap1_para1497,6,,现在，我们暂且将其理解为在推断过程中不能进行捏造。
chap1_para1498,1,,图7-1展示了基于知识的智能体程序。
chap1_para1498,2,,与所有的智能体一样，基于知识的智能体以一个感知作为输入，返回一个动作。
chap1_para1498,3,,该智能体维护一个知识库KB，这个知识库最初可能包括一些背景知识（background knowledge）。
chap1_para1499,1,,图7-1　通用的基于知识的智能体。
chap1_para1499,2,,给定一个感知，智能体将这一感知添加进知识库，向知识库询问最优动作，并告知知识库它已经采取了这一动作
chap1_para15,1,•computer vision and speech recognition to perceive the world;,● 知识表示（knowledge representation），以存储它所知道或听到的内容；
chap1_para150,1,"At MIT, Minsky supervised a series of students who chose limited problems that appeared to require intelligence to solve. These limited domains became known as microworlds. James Slagle’s SAINT program (1963) was able to solve closed-form calculus integration problems typical of first-year college courses. Tom Evans’s ANALOGY program (1968) solved geometric analogy problems that appear in IQ tests. Daniel Bobrow’s STUDENT program (1967) solved algebra story problems, such as the following:",居住在亚历山大城的古希腊工程师克特西比乌斯（Ktesibios，约公元前250年）建造了第一个自我控制的机器：一台水钟，其特点是拥有一个可以保持恒定水流速度的调节器。
chap1_para150,2,,这一发明改变了人造物可以做什么的定义。
chap1_para150,3,,在此之前，只有生物才能根据环境的变化来改变自己的行为。
chap1_para150,4,,其他自调节反馈控制系统的示例工作包括由詹姆斯·瓦特（James Watt，1736—1918）创建的蒸汽机调节器以及科内利斯·德雷贝尔（Cornelis Drebbel，1572—1633，潜艇发明者）发明的恒温器。
chap1_para150,5,,"詹姆斯·克拉克·麦克斯韦（James Clerk Maxwell）（Maxwell, 1868）开创了控制系统的数学理论。"
chap1_para1500,1,,每次调用智能体程序时，程序会做3件事。
chap1_para1500,2,,首先，它告知知识库它所感知到的东西。
chap1_para1500,3,,然后，它询问知识库它应当采取什么动作。
chap1_para1500,4,,在回答这一查询时，可能会对关于世界的当前状态、可能的动作序列的执行结果等进行大量推理。
chap1_para1500,5,,最后，智能体程序告知知识库它选择的动作，并返回这一动作以便执行。
chap1_para1501,1,,表示语言的细节隐藏在3个函数中，这3个函数一方面实现了传感器与执行器之间的接口，另一方面又实现了核心表示与推理系统的接口。
chap1_para1501,2,,Make-Percept-Sentence构建了一个语句，断言智能体在给定时间接收到给定的感知。
chap1_para1501,3,,Make-Action-Query构建了一个语句，询问当前时刻应当采取何种动作。
chap1_para1501,4,,最后，Make-Action-Sentence构建了一个语句，断言选定的动作已经执行。
chap1_para1501,5,,推断机制的细节隐藏在Tell与Ask中。
chap1_para1501,6,,后续章节将阐明这些细节。
chap1_para1502,1,,图7-1所示的基于知识的智能体看起来与第2章所述的具有内部状态的智能体非常相似。
chap1_para1502,2,,而由于Tell和Ask的定义，基于知识的智能体并不仅是普通的用来计算动作的程序。
chap1_para1502,3,,它受到位于知识层面（knowledge level）的描述的操控，我们只需要在知识层面明确智能体所具有的知识和它的目标，就可以决定它的行为。
chap1_para1503,1,,例如，一辆自动驾驶出租车的任务是将一名乘客从旧金山送往马林县，它或许知道金门大桥是两地间的唯一通路。
chap1_para1503,2,,因此，我们可以猜测出租车将驶过金门大桥，因为它知道这样能达成目标。
chap1_para1503,3,,注意，这一分析与出租车在实现层面（implementation level）的工作原理毫无关系。
chap1_para1503,4,,不论它是用链表或点阵图来实现地理知识，还是通过操纵寄存器中的符号串或在神经元网络中传递有噪声的信号来进行推理，都与我们的分析无关。
chap1_para1504,1,,我们可以仅通过告知智能体必需的知识来构建基于知识的智能体。
chap1_para1504,2,,智能体设计者可以从空知识库开始，逐条告知智能体语句，直到它明白如何在它的环境中运作。
chap1_para1504,3,,我们称之为陈述性（declarative）系统构建方法。
chap1_para1504,4,,相对地，过程性（procedural）方法将所需的行为直接编码为程序代码。
chap1_para1504,5,,在20世纪70年代和80年代，两种方法的提倡者进行了激烈的辩论。
chap1_para1504,6,,我们现在明白，成功的智能体在设计中常常需要将陈述性和过程性这两种方法的元素结合起来，而陈述性的知识也往往能够被编译成更有效的过程性代码。
chap1_para1505,1,,我们还可以给基于知识的智能体赋予自主学习的机制，我们将在第19章讲解的这些机制。
chap1_para1505,2,,智能体能够利用这些机制从一系列感知中创建关于环境的一般知识。
chap1_para1505,3,,进行学习的智能体可以是完全自主的。
chap1_para1506,1,,7.2　wumpus世界
chap1_para1507,1,,本节我们将描述一个能够体现基于知识的智能体的价值的环境。
chap1_para1507,2,,wumpus世界（wumpus world）是一个洞穴，其中有许多房间，房间之间有走廊连接。
chap1_para1507,3,,在洞穴的某处潜伏着可怕的wumpus，这是一只会吃掉任何进入其房间的人的怪兽。
chap1_para1507,4,,智能体可以射杀wumpus，但智能体只有一支箭。
chap1_para1507,5,,一些房间有无底洞，能困住任何漫游到这些房间中的人（wumpus除外，它体型大得无法落入无底洞）。
chap1_para1507,6,,这个阴森环境的唯一回报是可能找到的金块。
chap1_para1507,7,,尽管以现代电子游戏的眼光来看，wumpus世界相当乏味，但它却能展示出智能的一些重要属性。
chap1_para1508,1,,图7-2展示了一个简单的wumpus世界示例。
chap1_para1508,2,,任务环境的精确定义用2.3节所述的PEAS描述法给出。
chap1_para1509,1,,图7-2　一个典型的wumpus世界。
chap1_para1509,2,,智能体位于左下角，面朝东（向右）
chap1_para151,1,"If the number of customers Tom gets is twice the square of 20 percent of the number of advertisements he runs, and the number of advertisements he runs is 45, what is the number of customers Tom gets?",第二次世界大战后，控制理论（control theory）发展的核心人物是诺伯特·维纳（Norbert Wiener，1894—1964）。
chap1_para151,2,,维纳是一位杰出的数学家，在对生物和机械控制系统及其与认知的联系产生兴趣之前，曾与伯特兰·罗素等人合作。
chap1_para151,3,,"像克雷克（把控制系统作为心理模型）一样，维纳和他的同事阿图罗·罗森布鲁斯（Arturo Rosenblueth）以及朱利安·毕格罗（Julian Bigelow）挑战了行为主义正统派（Rosenblueth et al., 1943）。"
chap1_para151,4,,他们认为具有目的的行为源于试图最小化“错误”的调节机制，即当前状态和目标状态之间的差异。
chap1_para151,5,,20世纪40年代后期，维纳与沃伦·麦卡洛克（Warren McCulloch）、沃尔特·皮茨（Walter Pitts）和约翰·冯·诺伊曼一起组织了一系列有影响力的会议，探索关于认知的新数学和计算模型。
chap1_para151,6,,"维纳的《控制论》（Cybernetics）（Wiener, 1948）成为畅销书，使大众意识到了人工智能机器的可能性。"
chap1_para1510,1,,● 性能度量：带着金块从洞穴爬出+1000，跌入无底洞或被wumpus吞食−1000，每采取一个动作−1，用尽箭支−10。
chap1_para1510,2,,如果智能体死亡或爬出洞穴，游戏结束。
chap1_para1511,1,,● 环境：一个4×4的房间网格，网格四周环绕着围墙。
chap1_para1511,2,,"智能体始终从标为[1, 1]的方格开始，面向东方。"
chap1_para1511,3,,金块和wumpus的位置是根据均匀分布从除了起始方格的所有方格中随机选定的。
chap1_para1511,4,,另外，除起始方格外的每个方格都可能是无底洞，出现的概率为0.2。
chap1_para1512,1,,● 执行器：智能体可以向前（Forward）、左转（TurnLeft）90°和右转（TurnRight）90°。
chap1_para1512,2,,如果智能体进入有活着的wumpus或者有无底洞的方格，它将悲惨地死去。
chap1_para1512,3,,（但进入有死掉的wumpus的方格是安全的，尽管气味会很臭。
chap1_para1512,4,,）如果智能体试图前进并撞到墙，则智能体会原地不动。
chap1_para1512,5,,如果智能体与金块在同一个方格，抓取（Grab）动作可以用于捡起金块。
chap1_para1512,6,,射击（Shoot）动作可以用于向智能体面对的方向笔直地发射一支箭，这支箭会一直飞行，直到它命中wumpus（此时wumpus将被杀死）或击中墙壁。
chap1_para1512,7,,智能体只有一支箭，因此只有第一次射击动作有效。
chap1_para1512,8,,"最后，攀爬（Climb）动作可以用于爬出洞穴，但智能体仅能从方格[1, 1]爬出。"
chap1_para1513,1,,● 传感器：该智能体有5个传感器，每个传感器给出一个单一信息。
chap1_para1514,1,,❏ 在与wumpus直接（非对角）相邻的方格中，智能体会感知到臭味（Stench）。
chap1_para1514,2,,[1]
chap1_para1516,1,,[1]　wumpus所在的方格恐怕也有臭味，但任何进入该方格的智能体在能够进行感知前就会被吞食。
chap1_para1517,1,,❏ 在与无底洞直接相邻的方格中，智能体会感知到微风（Breeze）。
chap1_para1518,1,,❏ 在金块所在的方格中，智能体会感知到闪光（Glitter）。
chap1_para1519,1,,❏ 智能体走向墙壁会感知到碰撞（Bump）。
chap1_para152,1,"The most famous microworld is the blocks world, which consists of a set of solid blocks placed on a tabletop (or more often, a simulation of a tabletop), as shown in Figure 1.","与此同时，英国控制论专家罗斯·艾什比（W. Ross Ashby）开创了类似的思想（Ashby, 1940）。"
chap1_para152,2,3.,艾什比、图灵、沃尔特和其他一些学者为“那些在维纳的书出现之前就有维纳想法的人”组织了推理俱乐部[15]。
chap1_para152,3,"A typical task in this world is to rearrange the blocks in a certain way, using a robot hand that can pick up one block at a time.","艾什比在《大脑设计》（Design for a Brain）（Ashby, 1948, 1952）一书中详细阐述了他的想法，即可以通过自我平衡（homeostatic）设备来实现智能，该设备使用恰当的反馈回路来实现稳定的自适应行为。"
chap1_para152,4,"The blocks world was home to the vision project of David Huffman (1971), the vision and constraint-propagation work of David Waltz (1975), the learning theory of Patrick Winston (1970), the natural-language-understanding program of Terry Winograd (1972), and the planner of Scott Fahlman (1974).",
chap1_para1520,1,,❏ 如果wumpus被杀死，它将发出惨叫（Scream），智能体可以在洞穴的任意位置感知到。
chap1_para1521,1,,感知将以由5个符号组成的列表的形式传给智能体程序。
chap1_para1521,2,,"例如，如果有臭味和微风，但没有闪光、碰撞和惨叫，智能体程序将收到[Stench, Breeze, None, None, None]。"
chap1_para1522,1,,我们可以在第2章所述的多个维度上描述wumpus环境。
chap1_para1522,2,,显然，它是确定性的、离散的、静态的且单智能体的。
chap1_para1522,3,,（好在wumpus不移动。
chap1_para1522,4,,）它是序贯的，因为只有采取很多动作后才可能得到奖励。
chap1_para1522,5,,它是部分可观测的，因为状态的一些方面是无法直接感知到的，如智能体的位置、wumpus的健康状况以及是否还有箭支可用。
chap1_para1522,6,,对于无底洞和wumpus的位置，我们可以将其看作状态中没有观测到的部分，在这种情况下，环境的转移模型是完全已知的，找出无底洞和wumpus的位置就能补全智能体对状态的知识；抑或，我们也可以说转移模型本身是未知的，因为智能体不知道哪些向前动作是致命的，在这种情况下，找出无底洞和wumpus的位置能够补全智能体对于转移模型的知识。
chap1_para1523,1,,对于环境中的智能体，主要的挑战是它起初并不知道环境的配置。
chap1_para1523,2,,克服这种无知似乎需要逻辑推理。
chap1_para1523,3,,在wumpus世界的大多数情况中，智能体是有可能安全地拾取金块的。
chap1_para1523,4,,但智能体偶尔也需要在空手而归和冒死寻宝之间做出选择。
chap1_para1523,5,,大约21%的环境是极不公平的，因为这时金块位于无底洞中，或被无底洞包围。
chap1_para1524,1,,我们来看一个基于知识的智能体是如何探索图7-2所示的wumpus世界的环境的。
chap1_para1524,2,,此处使用一种非形式化的知识表示语言，在网格中写下符号来表示（如图7-3和图7-4所示）。
chap1_para1525,1,,图7-3　智能体在wumpus世界迈出的第一步。
chap1_para1525,2,,"（a）在感知到[None, None, None, None, None]后的初始状态。"
chap1_para1525,3,,"（b）在移动到[2, 1]后感知到[None, Breeze, None, None, None]"
chap1_para1526,1,,智能体的初始知识库包括前述的环境规则。
chap1_para1526,2,,"具体来说，智能体知道自己位于[1, 1]且[1, 1]是安全的方格。"
chap1_para1526,3,,"我们在方格[1, 1]中用“A”和“OK”分别进行表示。"
chap1_para1527,1,,"第一个感知是[None, None, None, None, None]，据此智能体可以认定它的相邻方格[1, 2]和[2, 1]是安全的——它们是“OK”的。"
chap1_para1527,2,,图7-3a展示了此时智能体的知识状态。
chap1_para1528,1,,图7-4　智能体运作时的两个后续状态。
chap1_para1528,2,,"（a）回到[1, 1]再移动到[1, 2]后，感知到[Stench, None, None, None, None]。"
chap1_para1528,3,,"（b）来到[2, 2]再移动到[2, 3]，感知到[Stench, Breeze, Glitter, None, None]"
chap1_para1529,1,,一个谨慎的智能体只会移动到它所知的OK方格。
chap1_para1529,2,,"我们假设智能体决定前进到[2, 1]。"
chap1_para1529,3,,"这个智能体在[2, 1]感受到微风（用“B”表示），因此在相邻方格中必然存在无底洞。"
chap1_para1529,4,,"根据游戏规则，无底洞不可能在[1, 1]，因此[2, 2]和[3, 1]其中之一必然有无底洞或二者都有。"
chap1_para1529,5,,图7-3b中的记号“P?”表示这些方格中可能存在无底洞。
chap1_para1529,6,,此时，仅有一个已知的且未访问过的“OK”方格。
chap1_para1529,7,,"因此这个心思缜密的智能体将扭头，回到[1, 1]，然后移步[1, 2]。"
chap1_para153,1,"Figure 1.3A scene from the blocks world. SHRDLU (Winograd, 1972) has just completed the command “Find a block which is taller than the one you are holding and put it in the box.”",
chap1_para1530,1,,"智能体在[1, 2]感知到臭味，导致知识状态变为图7-4a所示的状况。"
chap1_para1530,2,,"[1, 2]有臭味表明附近肯定有wumpus。"
chap1_para1530,3,,"但根据游戏规则wumpus不可能在[1, 1]，也不在[2, 2]（否则智能体先前在[2, 1]时会探测到臭味）。"
chap1_para1530,4,,"因此，智能体可以推断出wumpus在[1, 3]。"
chap1_para1530,5,,记号“W!”表示这一推断。
chap1_para1530,6,,"而[1, 2]没有微风表明[2, 2]没有无底洞。"
chap1_para1530,7,,"考虑到智能体先前已经推断出[2, 2]或[3, 1]中必然有无底洞，因此无底洞必然位于[3, 1]。"
chap1_para1530,8,,这是一次相当复杂的推断，因为它结合了在不同时间、不同地点获取的信息，并在缺乏感知的情况下迈出了关键的一步。
chap1_para1531,1,,"现在智能体已经证明了[2, 2]中既没有无底洞也没有wumpus，因此可以移动到那里。"
chap1_para1531,2,,"我们没有展示智能体在[2, 2]的知识状态，姑且假设智能体转向并移动到[2,3]，形成了图7-4b所示的情况。"
chap1_para1531,3,,"在[2, 3]中，智能体探测到闪光，因此它应该抓取金块然后回家。"
chap1_para1532,1,,注意，在智能体从可用信息中得出结论的每个情形下，如果可用信息是正确的，则可以保证结论都是正确的。
chap1_para1532,2,,这是逻辑推理的一个重要性质。
chap1_para1532,3,,本章剩余部分将描述如何构建能够表示信息并得出类似前述的结论的逻辑智能体。
chap1_para1534,1,,本节综述逻辑表示和推理的基本概念。
chap1_para1534,2,,这些漂亮的想法独立于逻辑的具体形式。
chap1_para1534,3,,因此，我们将形式的技术细节推后到7.4节介绍，本节代之以熟悉的普通算术问题作为示例。
chap1_para1535,1,,在7.1节，我们说过知识库由语句组成。
chap1_para1535,2,,这些语句是根据表示语言的语法（syntax）表达的，语法规定了所有的合规语句。
chap1_para1535,3,,用简单的算术就能清晰地说明语法这个概念：“x + y = 4”是合规的语句，而“x4y+=”不是。
chap1_para1536,1,,一种逻辑还必须定义语句的语义，或者说语句的含义。
chap1_para1536,2,,语义定义每条语句在每个可能世界中的真值。
chap1_para1536,3,,例如，算术的语义指明“x + y = 4”在一个x为2且y为2的世界为真，但在一个x为1且y为1的世界中为假。
chap1_para1536,4,,在标准的逻辑学中，每个可能世界中的每条语句要么为真，要么为假——没有中间地带。
chap1_para1536,5,,[2]
chap1_para1538,1,,[2]　第13章讨论的模糊逻辑（fuzzy logic）允许存在不同程度的真值。
chap1_para1539,1,,当需要精确描述时，我们用模型来代替“可能世界”。
chap1_para1539,2,,可能世界可以被认为是（潜在的）真实环境，智能体可能在也可能不在其中，而模型是数学抽象，对于每个相关的语句，每个模型都有固定的真值（真或假）。
chap1_para1539,3,,非正式地举个例子：我们可以认为一个可能世界是让x个男士和y个女士坐在一张桌子边上玩桥牌，如果总共有4个人，则语句x+y=4为真。
chap1_para1539,4,,正式地说，可能的模型是对变量x和y进行非负整数赋值的所有可能。
chap1_para1539,5,,每个这样的赋值都确定了任何一个变量为x和y的算术语句的真值。
chap1_para1539,6,,如果语句在模型m中为真，我们说m满足，有时也可以说m是的一个模型。
chap1_para1539,7,,我们使用记号来代表的所有模型的集合。
chap1_para154,1,"Early work building on the neural networks of McCulloch and Pitts also flourished. The work of Shmuel Winograd and Jack Cowan (1963) showed how a large number of elements could collectively represent an individual concept, with a corresponding increase in robustness and parallelism. Hebb’s learning methods were enhanced by Bernie Widrow (Widrow and Hoff, 1960; Widrow, 1962), who called his networks adalines, and by Frank Rosenblatt (1962) with his perceptrons. The perceptron convergence theorem (Block et al.,1962) says that the learning algorithm can adjust the connection strengths of a perceptron to match any input data, provided such a match exists.",[15]　推理俱乐部（Ratio Club）。
chap1_para154,2,,Ratio取自推理演算器（calculus ratiocinator），因此此处翻译为“推理俱乐部”。
chap1_para154,3,,——编者注
chap1_para1540,1,,有了真值的概念，我们就可以讨论逻辑推理了。
chap1_para1540,2,,这涉及语句之间的逻辑蕴含（entailment），即一个语句逻辑上引发另一语句。
chap1_para1540,3,,数学上，我们用
chap1_para1541,1,,来表示语句蕴含语句。
chap1_para1541,2,,蕴含的形式化定义是：当且仅当在为真的每个模型中也为真。
chap1_para1541,3,,用刚才介绍的记法，我们可以将其写作
chap1_para1543,1,,（注意此处⊆的方向：若，则是比更强的断言，它排除了更多的可能世界。
chap1_para1543,2,,）蕴含关系用算术来说明会更为亲切一些：我们很容易理解语句x=0蕴含语句xy=0。
chap1_para1543,3,,显然，在任一x为0的模型中，xy也必然为0（而无论y的值是多少）。
chap1_para1544,1,,我们可以将同样的分析应用于7.2节所述的wumpus世界推理的例子。
chap1_para1544,2,,"考虑图7-3b所示的情形：智能体在[1, 1]中什么都没有探测到，在[2, 1]中探测到微风。"
chap1_para1544,3,,这些感知与智能体所具有的wumpus世界规则的知识一同构成了知识库。
chap1_para1544,4,,"智能体所感兴趣的是相邻的方格[1, 2]、[2, 2]和[3, 1]是否有无底洞。"
chap1_para1544,5,,这3个方格中的每一个都可能有或没有无底洞，因此（暂且忽略这个世界的其他方面），总共有23=8个可能的模型。
chap1_para1544,6,,图7-5展示了这8个模型。
chap1_para1544,7,,[3]
chap1_para1546,1,,"[3]　尽管该图用部分wumpus世界来表示模型，但模型实际上只是对类似“[1, 2]中有无底洞”这样的语句进行真或假的赋值。"
chap1_para1546,2,,从数学的角度来看，模型中并不需要有可怕的长毛wumpus。
chap1_para1547,1,,"图7-5　方格[1, 2]、[2, 2]和[3, 1]中无底洞存在性的可能的模型。"
chap1_para1547,2,,"在[1, 1]中没有观测到任何东西且在[2, 1]中观测到微风的知识库用实线表示。"
chap1_para1547,3,,"（a）虚线表示的模型（[1, 2]中没有无底洞）。"
chap1_para1547,4,,"（b）虚线表示的模型（[2, 2]中没有无底洞）"
chap1_para1548,1,,KB可以理解为一个语句的集合，或断言了所有单个语句的单个语句。
chap1_para1548,2,,在与智能体已知相矛盾的模型中，KB为假。
chap1_para1548,3,,"例如，在所有[1, 2]含有无底洞的模型中，KB都为假，因为[1, 1]中没有微风。"
chap1_para1548,4,,实际上，使KB为真的模型只有3个，这些模型在图7-5中用实线包围。
chap1_para1548,5,,我们现在考虑两个可能的结论：
chap1_para1549,1,,"=“[1, 2]中没有无底洞”　=“[2, 2]中没有无底洞”"
chap1_para155,1,1.3.3A dose of reality (1966–1973),现代控制理论，特别是被称为随机最优控制的分支，其目标是设计随时间最小化代价函数（cost function）的系统。
chap1_para155,2,,这与人工智能的标准模型——设计性能最优的系统大致相符。
chap1_para155,3,,尽管人工智能和控制理论的创始人之间有着密切的联系，为什么它们却是两个不同的领域呢？
chap1_para155,4,,答案在于参与者所熟悉的数学技术与每种世界观所包含的对应问题是紧密结合的。
chap1_para155,5,,微积分和矩阵代数是控制理论的工具，它们适用于固定的连续变量集描述的系统，而人工智能的建立在一定程度上是为了避开这些可感知的局限性。
chap1_para155,6,,逻辑推理和计算工具使人工智能研究人员能够考虑语言、视觉和符号规划等问题，而这些问题完全超出了控制理论家的研究范围。
chap1_para1550,1,,在图7-5a和图7-5b中分别用虚线包围了和的模型。
chap1_para1550,2,,仔细观察后，我们可以得出
chap1_para1551,1,,在所有KB为真的模型中，也为真
chap1_para1552,1,,"因此，，即[1,2]中没有无底洞。"
chap1_para1552,2,,我们还可以得出
chap1_para1553,1,,在一些KB为真的模型中，为假
chap1_para1554,1,,"因此，KB不蕴含，即智能体无法断定[2,2]中没有无底洞。"
chap1_para1554,2,,"（也无法断定[2,2]中有无底洞。"
chap1_para1554,3,,）[4]
chap1_para1556,1,,"[4]　智能体可以计算[2,2]中有无底洞的概率，第12章将介绍如何计算。"
chap1_para1557,1,,前述的例子不仅阐明了什么是蕴含，还展示了如何用蕴含的定义来推导出结论，即进行逻辑推断。
chap1_para1557,2,,图7-5所示的推断算法被称为模型检验，因为这个示例枚举了所有可能的模型来检验在所有KB为真的模型中都为真，即。
chap1_para1558,1,,将KB的所有推论的集合比作干草堆而将比做一根针或许有助于理解蕴含和推断。
chap1_para1558,2,,蕴含正如草堆中的针一样，而推断就像找到这根针的过程。
chap1_para1558,3,,一些形式化记法体现了这种区别：如果一个推断算法i可以从KB中推导出，则记为
chap1_para1559,1,,读作“是由i从KB中推得的”或“i从KB推得”。
chap1_para156,1,"From the beginning, AI researchers were not shy about making predictions of their coming successes.",
chap1_para156,2,The following statement by Herbert Simon in 1957 is often quoted:,
chap1_para1560,1,,一个仅推导蕴含语句的推断算法被称为是可靠的或保真的。
chap1_para1560,2,,可靠性是极为重要的属性。
chap1_para1560,3,,一个不可靠的推断过程在运作时本质上会编造事实——它会声称发现了并不存在的针。
chap1_para1560,4,,我们很容易看出，模型检验在适用时[5]是一个可靠的程序。
chap1_para1562,1,,[5]　如果模型空间是有限的，则模型检验是有效的，例如，在固定大小的wumpus世界中。
chap1_para1562,2,,而对算术来说，模型空间是无限的：即使我们局限于整数范围，语句x+y=4中x和y的值也是有无限多对的。
chap1_para1563,1,,完备性也是很重要的属性：如果一个推断算法能够推导出所有蕴含的语句，则它是完备的。
chap1_para1563,2,,真正的草堆大小是有限的，对其进行全面仔细的检查就一定能确定针在不在草堆里，这似乎是很显然的道理。
chap1_para1563,3,,然而，对许多知识库来说，推论的草堆是无限的，因而完备性就成了一个重大问题。
chap1_para1563,4,,[6]幸运的是，逻辑学中有完备的推断过程，其表达能力足以处理许多知识库。
chap1_para1565,1,,[6]　比如说，在第3章的无限搜索空间的情形中，深度优先搜索就是不完备的。
chap1_para1566,1,,我们已经描述了一个推理过程，在前提为真的任何世界中都保证结论为真。
chap1_para1566,2,,具体来说，如果KB在真实世界中为真，则用可靠的推断过程从KB中推出的所有语句在真实世界中也为真。
chap1_para1566,3,,因此，当推断过程在“语法”（例如，寄存器中的位或大脑中的电信号模式这样的内部物理结构）上进行操作时，这个过程对应于一个真实世界的关系，即真实世界的某个部分为真是因为真实世界的其他一些部分为真。
chap1_para1566,4,,[7]这种世界与表示的对应如图7-6所示。
chap1_para1568,1,,"[7]　正如路德维希•维特根斯坦（Ludwig Wittgenstein）在其著名的《逻辑哲学论》（Tractatus）（Wittgenstein, 1922）中所述：“世界就是所有为真的一切。"
chap1_para1568,2,,”
chap1_para1569,1,,最后要考虑的问题是落地，也就是逻辑推理过程与智能体所存在的真实环境的联系。
chap1_para1569,2,,尤其是，我们如何知道KB在真实世界中为真？
chap1_para1569,3,,（毕竟KB只是存在于智能体头脑中的“语法”。
chap1_para1569,4,,）这是一个哲学问题，众多的书籍都对此进行了讨论（见第27章）。
chap1_para1569,5,,一个简单的回答是，智能体的传感器创建了这个联系。
chap1_para1569,6,,例如，我们的wumpus世界智能体有嗅觉传感器。
chap1_para1569,7,,一旦有气味，智能体程序就会创建一条合适的语句。
chap1_para1569,8,,因此，一旦这条语句被包含在知识库中，就意味着它在真实世界中也为真。
chap1_para1569,9,,这样，感知语句的含义和真值就是由产生这些语句的感知过程和语句构建过程定义的。
chap1_para1569,10,,那么智能体知识的其他部分呢？
chap1_para1569,11,,例如，它对于“wumpus相邻的方格有臭味”这件事的信念呢？
chap1_para1569,12,,这不是单个感知的直接表示，而是一项一般规则，它可能是从感知的经验推导出的，却与经验陈述并不完全相同。
chap1_para1569,13,,这种一般规则是通过被称为学习的语句构建过程产生的，这是第五部分的主题。
chap1_para1569,14,,学习是难免会出错的。
chap1_para1569,15,,一种可能的情况是，wumpus有臭味但闰年2月29日这一天除外，因为这一天它要洗澡。
chap1_para1569,16,,因此，KB在真实世界中可能并不为真，但因为有很好的学习过程，我们对此就有理由乐观。
chap1_para157,1,"It is not my aim to surprise or shock you—but the simplest way I can summarize is to say that there are now in the world machines that think, that learn and that create. Moreover, their ability to do these things is going to increase rapidly until—in a visible future—the range of problems they can handle will be coextensive with the range to which the human mind has been applied.",● 语言是如何与思维联系的？
chap1_para1570,1,,图7-6　语句是智能体的物理结构，而推理是从旧结构构建新结构的过程。
chap1_para1570,2,,逻辑推理应当确保新结构所表示的部分世界确实能够从旧结构所表示的部分世界推得
chap1_para1571,1,,7.4　命题逻辑：一种非常简单的逻辑
chap1_para1572,1,,本节讲解命题逻辑（propositional logic）。
chap1_para1572,2,,我们将阐述其语法（即语句的结构）和语义（确定语句真值的方法）。
chap1_para1572,3,,由此，我们将推导出一个简单的、语法的逻辑推断算法，它能够实现蕴含的语义概念。
chap1_para1572,4,,当然，这一切都仍将发生在wumpus世界中。
chap1_para1574,1,,命题逻辑的语法定义合法的语句。
chap1_para1574,2,,原子语句（atomic sentence）由单个命题符号（proposition symbol）构成。
chap1_para1574,3,,每个这样的符号代表一个为真或假的命题。
chap1_para1574,4,,"我们使用以大写字母开头的、可能包含其他字母或下标的符号来表示，例如P、Q、R、W1,3以及FacingEast等。"
chap1_para1574,5,,"我们可以任意地进行命名，但通常选择一些有助记功能的名字，例如，使用W1,3代表“wumpus位于[1, 3]”。"
chap1_para1574,6,,"请记住，像W1,3这样的符号是原子的，也就是说分开的W、1、3并非符号的有意义的部分。"
chap1_para1574,7,,）有两个命题符号有固定的含义：True是永真命题，False是永假命题。
chap1_para1574,8,,使用括号和被称作逻辑联结词（logical connective）的运算符可以将简单语句构造成复合语句（complex sentence）。
chap1_para1574,9,,常用的联结词有5个。
chap1_para1575,1,,● （非）。
chap1_para1575,2,,"类似这样的语句称为W1,3的否定。"
chap1_para1575,3,,一个文字要么是原子语句，即正文字，要么是原子语句的否定，即负文字。
chap1_para1576,1,,● ∧（与）。
chap1_para1576,2,,主要联结词是∧的语句称为合取式，例如，其各部分称为合取子句。
chap1_para1576,3,,（∧看起来像是“And”中的“A”。
chap1_para1576,4,,）
chap1_para1577,1,,● ∨（或）。
chap1_para1577,2,,"主要联结词是∨的语句称为析取式，例如，其各部分为析取子句，本例中分别为和W2,2。"
chap1_para1578,1,,● （蕴涵）。
chap1_para1578,2,,如这样的语句称为蕴涵式（implication）或条件式，其前提（premise）或前件（antecedent）是，其结论（conclusion）或后件（consequent）是。
chap1_para1578,3,,蕴涵式也被称为规则（rule）或if-then声明。
chap1_para1578,4,,有时，蕴涵符号在一些书籍中写作或。
chap1_para1579,1,,● （当且仅当）。
chap1_para1579,2,,语句是双向蕴涵式（biconditional）。
chap1_para158,1,"The term “visible future” is vague, but Simon also made more concrete predictions: that within 10 years a computer would be chess champion and a significant mathematical theorem would be proved by machine. These predictions came true (or approximately true) within 40 years rather than 10. Simon’s overconfidence was due to the promising performance of early AI systems on simple examples. In almost all cases, however, these early systems failed on more difficult problems.",1957年，斯金纳（B. F. Skinner）发表了Verbal Behavior，包含该领域最著名的专家对语言学习的行为主义方法的全面详细的描述。
chap1_para158,2,,但奇怪的是，一篇对这本书的评述也像这本书一样广为人知，几乎扼杀了大众对行为主义的兴趣。
chap1_para158,3,,评述的作者是语言学家诺姆·乔姆斯基，彼时他刚刚出版了一本关于他自己理论的书《句法结构》（Syntactic Structure）。
chap1_para158,4,,乔姆斯基指出，行为主义理论并没有解决语言创造力的概念，它没有解释孩子们如何理解并造出他们从未听过的句子。
chap1_para158,5,,乔姆斯基以句法模型为基础的理论可以追溯到古印度语言学家波你尼（Panini，约公元前350年）。
chap1_para158,6,,该理论可以解释语言创造力，而且与以前的理论不同，它足够形式化，原则上可以被程序化。
chap1_para1580,1,,图7-7给出了命题逻辑的形式文法。
chap1_para1580,2,,［附录B将会介绍巴克斯-诺尔范式（Backus-Naur form，BNF）的概念。
chap1_para1580,3,,］我们在BNF文法上附加了运算符优先级，以避免在使用多个运算符时出现歧义。
chap1_para1580,4,,“非”运算符的优先级最高，这意味着在语句中，的结合力更强，因此它等价于而不是。
chap1_para1580,5,,（这与普通算术一样：−2+4等于2而不是−6。
chap1_para1580,6,,）我们也会适时地使用圆括号和方括号来明确语句结构，以改善可读性。
chap1_para1581,1,,图7-7　命题逻辑中语句的BNF文法以及从高到低排列的运算符优先级
chap1_para1583,1,,了解了命题逻辑的语法后，我们来说明其语义。
chap1_para1583,2,,语义定义了用于判定特定模型中语句真值的规则。
chap1_para1583,3,,命题逻辑中，模型就是对每个命题符号设定真值，即真（true）或假（false）。
chap1_para1583,4,,"例如，如果知识库中的语句使用了命题符号P1,2、P2,2和P3,1，则一个可能模型为"
chap1_para1584,1,,由于含有3个命题符号，因此有23=8种可能的模型，与图7-5所示的完全相同。
chap1_para1584,2,,但要注意，这些模型是纯粹的数学对象，不必与wumpus世界有关。
chap1_para1584,3,,"P1,2只是符号，它可能代表“[1, 2]中有无底洞”，也可能代表“我今天和明天都在巴黎”。"
chap1_para1585,1,,命题逻辑的语义必须指定在给定模型下如何计算任一语句的真值。
chap1_para1585,2,,这是以递归的方式实现的。
chap1_para1585,3,,所有语句都是由原子语句和5个联结词构建的。
chap1_para1585,4,,因此，我们需要指定如何计算原子语句的真值和用5个联结词构建的语句的真值。
chap1_para1585,5,,对原子语句来说这很简单。
chap1_para1586,1,,● true在每个模型里都为真，false在每个模型里都为假。
chap1_para1587,1,,● 其余命题符号的真值必须在模型中直接指定。
chap1_para1587,2,,"例如，在先前给出的模型m1中，P1,2为假。"
chap1_para1588,1,,对于复合语句，有5条规则，它们对任一模型m中的任一子句P和Q（原子语句或复合语句）都成立。
chap1_para1589,1,,● 为真，当且仅当在m中P为假。
chap1_para159,1,"There were two main reasons for this failure. The first was that many early AI systems were based primarily on “informed introspection” as to how humans perform a task, rather than on a careful analysis of the task, what it means to be a solution, and what an algorithm would need to do to reliably produce such solutions.",现代语言学和人工智能几乎同时“诞生”，并一起成长，交叉于一个称为计算语言学（computational linguistics）或自然语言处理（natural language processing）的混合领域。
chap1_para159,2,,相比1957年，理解语言复杂了许多。
chap1_para159,3,,理解语言需要理解主题和上下文，而不仅仅是理解句子结构。
chap1_para159,4,,这似乎是显而易见的，但直到20世纪60年代才得到广泛认可。
chap1_para159,5,,知识表示（knowledge representation）（关于如何将知识转化为计算机可以推理的形式的研究）的大部分早期工作与语言相关联，并受到语言学研究的启发，而语言学研究反过来又与数十年的语言哲学分析工作有关联。
chap1_para1590,1,,● 为真，当且仅当在m中P和Q都为真。
chap1_para1591,1,,● 为真，当且仅当在m中P或Q中至少一个为真。
chap1_para1592,1,,● 为真，除非在m中P为真而Q为假。
chap1_para1593,1,,● 为真，当且仅当在m中P和Q都为真或都为假。
chap1_para1594,1,,这些规则也可以用真值表表示。
chap1_para1594,2,,真值表指明在对复合语句的组成部分进行每种可能的真值赋值后，该复合语句的真值。
chap1_para1594,3,,图7-8给出了5个联结词的真值表。
chap1_para1594,4,,任一语句s关于任一模型m的真值都可以用简单的递归求值来计算。
chap1_para1594,5,,例如，在模型m1中求语句的值，得到。
chap1_para1594,6,,"习题7.TRUV要求写出算法PL-True?(s, m)，用于计算命题逻辑语句s在模型m中的真值。"
chap1_para1595,1,,图7-8　5个逻辑联结词的真值表。
chap1_para1595,2,,若要使用真值表计算在P为真、Q为假时的值，首先在左边找到P为true而Q为false的行（第3行），然后找到该行位于列处的值，得到结果true
chap1_para1596,1,,“与”“或”“非”的真值表与我们对这些词的直观认识非常接近。
chap1_para1596,2,,可能会混淆的关键点是当P为真或Q为真，或者二者同时为真时，为真。
chap1_para1596,3,,而另一个联结词“排他或”（简称“异或”）则会在两个子句都为真时为假。
chap1_para1596,4,,[8]排他或没有公认的符号，有些人选择使用、或者⊕。
chap1_para1598,1,,[8]　在拉丁语中，“或”用两个词表示：“vel”是相容或，“aut”是排他或。
chap1_para1599,1,,⇒的真值表可能不太符合人们对“P蕴涵Q”或“若P则Q”的直观理解。
chap1_para1599,2,,一种解释是，命题逻辑并不要求P和Q之间有任何因果关系或相关性。
chap1_para1599,3,,（在一般的理解下）语句“5是奇数蕴涵东京是日本的首都”是命题逻辑中的真语句，尽管这句话相当奇怪。
chap1_para1599,4,,另一个容易混淆之处在于前件为假的所有蕴涵式都为真。
chap1_para1599,5,,例如，“5是偶数蕴涵Sam很聪明”为真，而不论Sam是否聪明。
chap1_para1599,6,,这似乎很怪异，但如果你将“”当作“如果P为真，则我可以断言Q为真，否则我无法断言”的话，就可以理解了。
chap1_para1599,7,,这条语句为假的唯一情形是当P为真而Q为假时。
chap1_para16,1,•robotics to manipulate objects and move about.,● 自动推理（automated reasoning），以回答问题并得出新的结论；
chap1_para160,1,"The second reason for failure was a lack of appreciation of the intractability of many of the problems that AI was attempting to solve. Most of the early problem-solving systems worked by trying out different combinations of steps until the solution was found. This strategy worked initially because microworlds contained very few objects and hence very few possible actions and very short solution sequences. Before the theory of computational complexity was developed, it was widely thought that “scaling up” to larger problems was simply a matter of faster hardware and larger memories. The optimism that accompanied the development of resolution theorem proving, for example, was soon dampened when researchers failed to prove theorems involving more than a few dozen facts. The fact that a program can find a solution in principle does not mean that the program contains any of the mechanisms needed to find it in practice.",1.3　人工智能的历史
chap1_para1600,1,,当与均为真时，双向蕴涵式为真，英语中常写作“P if and only if Q”（P当且仅当Q）。
chap1_para1600,2,,wumpus世界的大部分规则都可以用很好地表示。
chap1_para1600,3,,例如，当一个方格的相邻方格中有无底洞，该方格有微风，而且，仅当一个方格的某个相邻方格中有无底洞，该方格有微风。
chap1_para1600,4,,因此，我们需要使用双向蕴涵式
chap1_para1601,1,,"其中B1, 1代表[1, 1]有微风。"
chap1_para1602,1,,7.4.3　一个简单的知识库
chap1_para1603,1,,我们已经定义了命题逻辑的语义，现在可以为wumpus世界构建一个知识库了。
chap1_para1603,2,,首先关注wumpus世界的不变部分，后面章节再处理其可变部分。
chap1_para1603,3,,"对于每个位置[x, y]，需要用到下列符号："
chap1_para1604,1,,"当[x, y]有无底洞，Px, y为真。"
chap1_para1605,1,,"当wumpus在[x, y]，不论其死活Wx, y都为真。"
chap1_para1606,1,,"当[x, y]有微风，Bx, y为真。"
chap1_para1607,1,,"当[x, y]处有臭味，Sx, y为真。"
chap1_para1608,1,,"当智能体位于位置[x, y]，Lx, y为真。"
chap1_para1609,1,,"我们写下的语句将足以推得（[1, 2]中没有无底洞），正如7.3节用非形式化的方法所做的那样。"
chap1_para1609,2,,我们用Ri代表每个语句，以便推导。
chap1_para161,1,The illusion of unlimited computational power was not confined to problem-solving programs.,总结人工智能历史里程碑的快速方法是列出图灵奖得主：马文·明斯基（Marvin Minsky）（1969年图灵奖得主）和约翰·麦卡锡（John McCarthy）（1971年图灵奖得主）定义了基于表示和推理的领域基础；艾伦·纽厄尔（Allen Newell）和赫伯特·西蒙（Herbert Simon）（1975年图灵奖得主）提出了关于问题求解和人类认知的符号模型；爱德华·费根鲍姆（Ed Feigenbaum）和劳伊·雷迪（Raj Reddy）（1994年图灵奖得主）开发了通过对人类知识编码来解决真实世界问题的专家系统；朱迪亚·珀尔（Judea Pearl）（2011年图灵奖得主）提出了通过原则性的方式处理不确定性的概率因果推理技术；最近的是约书亚·本吉奥（Yoshua Bengio）、杰弗里·辛顿（Geoffrey Hinton）和杨立昆（Yann LeCun）（2018年图灵奖得主）[16]，他们将“深度学习”（多层神经网络）作为现代计算的关键部分。
chap1_para161,2,"Early experiments in machine evolution (now called genetic programming) (Friedberg, 1958; Friedberg et al.",本节的其余部分将更详细地介绍人工智能历史的每个阶段。
chap1_para161,3,", 1959) were based on the undoubtedly correct belief that by making an appropriate series of small mutations to a machine-code program, one can generate a program with good performance for any particular task.",
chap1_para161,4,"The idea, then, was to try random mutations with a selection process to preserve mutations that seemed useful.",
chap1_para161,5,"Despite thousands of hours of CPU time, almost no progress was demonstrated.",
chap1_para1610,1,,"● [1, 1]中没有无底洞："
chap1_para1611,1,,● 一个方格有微风，当且仅当其相邻方格中有无底洞。
chap1_para1611,2,,必须对每个方格都进行这样的表示，在此我们只写出相关方格的表示：
chap1_para1612,1,,● 上述语句在所有wumpus世界中都为真。
chap1_para1612,2,,我们现在为智能体在这个特定世界中已访问过的前两个方格引入微风感知，以形成图7-3b所示的情形：
chap1_para1613,1,,7.4.4　一个简单的推断过程
chap1_para1614,1,,我们现在的目标是确定对于一些语句，是否成立。
chap1_para1614,2,,例如，我们的KB是否蕴含？
chap1_para1614,3,,我们的第一个推理算法是模型检验方法，它直接实现了蕴含的定义：枚举所有模型，检验在KB为真的每个模型中是否为真。
chap1_para1614,4,,模型是对每个命题符号进行真或假的赋值。
chap1_para1614,5,,"回到例子中的wumpus世界，它涉及的命题符号是B1, 1、B2, 1、P1, 1、P1, 2、P2, 1、P2, 2和P3, 1。"
chap1_para1614,6,,在有7个符号的情况下，总共有27=128个可能的模型，KB在其中3个模型中为真（如图7-9所示）。
chap1_para1614,7,,"在这3个模型中，为真，因此[1, 2]中没有无底洞。"
chap1_para1614,8,,"但是，在3个模型中，P2, 2在其中两个模型中为真，在另一个模型中为假，因此我们还无法确定[2, 2]中是否有无底洞。"
chap1_para1615,1,,图7-9以更准确的形式再现了图7-5所示的推理。
chap1_para1615,2,,图7-10描述了一个确定命题逻辑中蕴含关系的通用算法。
chap1_para1615,3,,与6.3节所示的Backtracking-Search算法类似，TT-Entails?在符号赋值的有限空间中进行递归枚举。
chap1_para1615,4,,这个算法是可靠的，因为它直接实现了蕴含的定义；这个算法也是完备的，因为它对所有KB和都适用，并且算法最后都会终止——因为需要检验的模型数量是有限的。
chap1_para1616,1,,图7-9　根据文中所述的知识库构建的真值表。
chap1_para1616,2,,如果从R1到R5都为true，则KB为true。
chap1_para1616,3,,这种情况在全部128行中只出现了3次（在最右侧的列中用下划线标出）。
chap1_para1616,4,,"在这3行中，P1, 2均为false，因此[1, 2]中没有无底洞。"
chap1_para1616,5,,"但是，[2, 2]中可能有（也可能没有）无底洞"
chap1_para1617,1,,图7-10　用于确定命题蕴含的真值表枚举算法（TT代表真值表）。
chap1_para1617,2,,当语句在一个模型中成立，PL-True?返回true。
chap1_para1617,3,,变量model代表部分模型——对于部分符号的赋值。
chap1_para1617,4,,此处的关键字and不是命题逻辑中的运算符，而是伪代码编程语言中的中缀；如果其两个参数中的任意一个为true，则返回true
chap1_para1618,1,,当然，“有限数量”并不总是等同于“少量”。
chap1_para1618,2,,如果KB和总共含有n个符号，那么就会有2n个模型。
chap1_para1618,3,,这样，算法的时间复杂性就会达到O(2n)。
chap1_para1618,4,,（空间复杂性仅为O(n)，因为枚举是深度优先的。
chap1_para1618,5,,）在本章稍后部分，我们将展示一个在大多数情况下更高效的算法。
chap1_para1618,6,,遗憾的是，命题蕴含是余NP完全的（即很可能不比NP完全简单，见附录A），因此命题逻辑所有已知推断算法的最坏情况复杂性都是输入规模的指数量级。
chap1_para1619,1,,7.5　命题定理证明
chap1_para162,1,"Failure to come to grips with the “combinatorial explosion” was one of the main criticisms of AI contained in the Lighthill report (Lighthill, 1973), which formed the basis for the decision by the British government to end support for AI research in all but two universities. (Oral tradition paints a somewhat different and more colorful picture, with political ambitions and personal animosities whose description is beside the point.)",
chap1_para1620,1,,至此，我们已经展示了如何用模型检验判定蕴含关系：枚举模型，并验证语句在所有模型中必须成立。
chap1_para1620,2,,本节将展示如何通过定理证明找出蕴含关系。
chap1_para1620,3,,定理证明对知识库中的语句直接应用推断规则，它能够在不检验模型的情况下，构建对所需语句的证明。
chap1_para1620,4,,如果模型的数量很多，但其证明很短，则定理证明会比模型检验更为高效。
chap1_para1621,1,,在深入定理证明算法的细节之前，我们还需要了解一些与蕴含相关的概念。
chap1_para1621,2,,第一个概念是逻辑等价（logical equivalence）：如果两个语句和在相同的模型集合中都为真，则这两个语句逻辑等价，可以写作。
chap1_para1621,3,,（注意，用于对语句进行声明，而则用作语句的一部分。
chap1_para1621,4,,）例如，我们可以很容易地（用真值表）证明与是逻辑等价的。
chap1_para1621,5,,其他逻辑等价见图7-11。
chap1_para1621,6,,这些等价关系在逻辑中扮演的角色与算术恒等式在普通数学中的角色非常相似。
chap1_para1621,7,,等价的另一种定义为“任意两条语句和是等价的，当且仅当它们互相蕴含”：
chap1_para1623,1,,第二个概念是有效性（validity）。
chap1_para1623,2,,如果一条语句在所有模型中都为真，则这条语句是有效的。
chap1_para1623,3,,例如，语句是有效的。
chap1_para1623,4,,有效的语句也被称为重言式（tautology）——它们必然为真。
chap1_para1623,5,,由于语句True在所有模型中都为真，所有有效的语句都逻辑等价于True。
chap1_para1623,6,,有效语句有什么用？
chap1_para1623,7,,从蕴含的定义可以推导出古希腊人早已懂得的演绎定理（deduction theorem）：
chap1_para1624,1,,对于任意语句和，当且仅当语句是有效的。
chap1_para163,1,"A third difficulty arose because of some fundamental limitations on the basic structures being used to generate intelligent behavior. For example, Minsky and Papert’s book Perceptrons (1969) proved that, although perceptrons (a simple form of neural network) could be shown to learn anything they were capable of representing, they could represent very little. In particular, a two-input perceptron could not be trained to recognize when its two inputs were different. Although their results did not apply to more complex, multilayer networks, research funding for neural-net research soon dwindled to almost nothing. Ironically, the new back-propagation learning algorithms that were to cause an enormous resurgence in neural-net research in the late 1980s and again in the 2010s had already been developed in other contexts in the early 1960s (Kelley, 1960; Bryson, 1962).",[16]　此书英文原著将约书亚·本吉奥、杰弗里·辛顿和杨立昆记录为获得了2019年图灵奖，他们实则获得的是2018年图灵奖。
chap1_para163,2,,——编者注
chap1_para164,1,1.3.4Expert systems (1969–1986),1.3.1　人工智能的诞生（1943—1956）
chap1_para165,1,The picture of problem solving that had arisen during the first decade of AI research was of a general-purpose search mechanism trying to string together elementary reasoning steps to find complete solutions.,"现在普遍认为由沃伦·麦卡洛克和沃尔特·皮茨（McCulloch and Pitts, 1943）完成的工作是人工智能的第一项研究工作。"
chap1_para165,2,"Such approaches have been called weak methods because, although general, they do not scale up to large or difficult problem instances.","他们受到皮茨的顾问尼古拉斯·拉舍夫斯基（Nicolas Rashevsky）（1936, 1938）对数学建模工作的启发，选择了3方面的资源构建模型：基础生理学知识和大脑神经元的功能，罗素和怀特海（Whitehead）对命题逻辑的形式化分析，以及图灵的计算理论。"
chap1_para165,3,"The alternative to weak methods is to use more powerful, domain-specific knowledge that allows larger reasoning steps and can more easily handle typically occurring cases in narrow areas of expertise.",他们提出了一种人工神经元模型，其中每个神经元的特征是“开”或“关”，并且会因足够数量的相邻神经元受到刺激而切换为“开”。
chap1_para165,4,"One might say that to solve a hard problem, you have to almost know the answer already.",神经元的状态被认为是“事实上等同于提出其充分激活的命题”。
chap1_para165,5,,例如，他们证明任何可计算的函数都可以通过一些神经元互相连接的网络来计算，以及所有的逻辑联结词（AND、OR、NOT等）都可以通过简单的网络结构来实现。
chap1_para165,6,,麦卡洛克和皮茨还表明适当定义的网络可以学习。
chap1_para165,7,,"唐纳德·赫布（Donald Hebb）（Hebb, 1949）示范了用于修改神经元之间连接强度的简单更新规则。"
chap1_para165,8,,他的规则，现在称为赫布型学习（Hebbian learning），至今仍是一种有影响力的模式。
chap1_para166,1,The DENDRAL program (Buchanan et al.,哈佛大学的两名本科生马文·明斯基（Marvin Minsky，1927—2016）和迪安·埃德蒙兹（Dean Edmonds）在1950年建造了第一台神经网络计算机——SNARC。
chap1_para166,2,", 1969) was an early example of this approach.",SNARC使用了3000个真空管和B-24轰炸机上一个多余的自动驾驶装置来模拟由40个神经元组成的网络。
chap1_para166,3,"It was developed at Stanford, where Ed Feigenbaum (a former student of Herbert Simon), Bruce Buchanan (a philosopher turned computer scientist), and Joshua Lederberg (a Nobel laureate geneticist) teamed up to solve the problem of inferring molecular structure from the information provided by a mass spectrometer.",后来，明斯基在普林斯顿大学研究了神经网络中的通用计算。
chap1_para166,4,The input to the program consists of the elementary formula of the molecule (e.,他的博士学位委员会对这类工作是否应该被视为数学持怀疑态度，但据说冯·诺伊曼评价：“如果现在还不能被视为数学，总有一天会的。
chap1_para166,5,g.,”
chap1_para166,6,", C6H13NO2) and the mass spectrum giving the masses of the various fragments of the molecule generated when it is bombarded by an electron beam.",
chap1_para166,7,"For example, the mass spectrum might contain a peak at m = 15, corresponding to the mass of a methyl (CH3) fragment.",
chap1_para167,1,"The naive version of the program generated all possible structures consistent with the formula, and then predicted what mass spectrum would be observed for each, comparing this with the actual spectrum.",还有许多早期工作可以被描述为人工智能，包括1952年由曼彻斯特大学的克里斯托弗·斯特雷奇（Christopher Strachey）和IBM公司的亚瑟·塞缪尔（Arthur Samuel）分别独立开发的西洋跳棋程序。
chap1_para167,2,"As one might expect, this is intractable for even moderate-sized molecules.",然而，还是图灵的观点最有影响力。
chap1_para167,3,The DENDRAL researchers consulted analytical chemists and found that they worked by looking for well-known patterns of peaks in the spectrum that suggested common substructures in the molecule.,早在1947年，他就在伦敦数学协会（London Mathematical Society）就这一主题发表了演讲，并在其1950年的文章“Computing Machinery and Intelligence”中阐明了有说服力的议程。
chap1_para167,4,"For example, the following rule is used to recognize a ketone (C=O) subgroup (which weighs 28):",在论文中，他介绍了图灵测试、机器学习、遗传算法和强化学习。
chap1_para167,5,,如第27章所述，也回答了许多针对人工智能的质疑。
chap1_para167,6,,他还认为，通过开发学习算法然后教会机器，而不是手工编写智能程序，将更容易创造出人类水平的人工智能。
chap1_para167,7,,他在随后的演讲中警告说，实现这一目标对人类来说可能不是最好的事情。
chap1_para168,1,if M is the mass of the whole molecule and there are two peaks at x1 and x2 such that (a) x1 + x2 = M + 28; (b) x1 – 28 is a high peak; (c) x2 – 28 is a high peak; and (d) At least one of x1 and x2 is high then there is a ketone subgroup.,1955年，达特茅斯学院的约翰·麦卡锡说服明斯基、克劳德·香农（Claude Shannon）和纳撒尼尔·罗切斯特（Nathaniel Rochester）帮助他召集对自动机理论、神经网络和智能研究感兴趣的美国研究人员。
chap1_para168,2,,他们于1956年夏天在达特茅斯组织了为期两个月的研讨会。
chap1_para168,3,,这场研讨会共有10位与会者，其中包括来自卡内基理工学院[17]的艾伦·纽厄尔和赫伯特·西蒙、普林斯顿大学的特伦查德·摩尔（Trenchard More）、IBM的亚瑟・塞缪尔以及来自麻省理工学院的雷·所罗门诺夫（Ray Solomonoff）和奥利弗·赛弗里奇（Oliver Selfridge）。
chap1_para168,4,,该提案指出：[18]
chap1_para169,1,"Recognizing that the molecule contains a particular substructure reduces the number of possible candidates enormously. According to its authors, DENDRAL was powerful because it embodied the relevant knowledge of mass spectroscopy not in the form of first principles but in efficient “cookbook recipes” (Feigenbaum et al., 1971). The significance of DENDRAL was that it was the first successful knowledge-intensive system: its expertise derived from large numbers of special-purpose rules. In 1971, Feigenbaum and others at Stanford began the Heuristic Programming Project (HPP) to investigate the extent to which the new methodology of expert systems could be applied to other areas.",
chap1_para17,1,"These six disciplines compose most of AI. Yet AI researchers have devoted little effort to passing the Turing test, believing that it is more important to study the underlying principles of intelligence. The quest for “artificial flight” succeeded when engineers and inventors stopped imitating birds and started using wind tunnels and learning about aerodynamics. Aeronautical engineering texts do not define the goal of their field as making “machines that fly so exactly like pigeons that they can fool even other pigeons.”",● 机器学习（machine learning），以适应新的环境，并检测和推断模式。
chap1_para170,1,The next major effort was the MYCIN system for diagnosing blood infections.,[17]　现在是卡内基梅隆大学（CMU）。
chap1_para170,2,"With about 450 rules, MYCIN was able to perform as well as some experts, and considerably better than junior doctors.",
chap1_para170,3,It also contained two major differences from DENDRAL.,
chap1_para170,4,"First, unlike the DENDRAL rules, no general theoretical model existed from which the MYCIN rules could be deduced.",
chap1_para170,5,They had to be acquired from extensive interviewing of experts.,
chap1_para170,6,"Second, the rules had to reflect the uncertainty associated with medical knowledge.",
chap1_para170,7,"MYCIN incorporated a calculus of uncertainty called certainty factors (see Chapter 13), which seemed (at the time) to fit well with how doctors assessed the impact of evidence on the diagnosis.",
chap1_para171,1,"The first successful commercial expert system, R1, began operation at the Digital Equipment Corporation (McDermott, 1982). The program helped configure orders for new computer systems; by 1986, it was saving the company an estimated $40 million a year. By 1988, DEC’s AI group had 40 expert systems deployed, with more on the way. DuPont had 100 in use and 500 in development. Nearly every major U.S. corporation had its own AI group and was either using or investigating expert systems.",[18]　这是麦卡锡的术语“人工智能”被第一次正式使用。
chap1_para171,2,,也许“计算理性”会更精确、威胁更小，但“人工智能”一直存在。
chap1_para171,3,,在达特茅斯会议50周年纪念会上，麦卡锡表示，他反对使用“计算机”或“可计算”等术语，以表达对诺伯特·维纳的敬意，因为维纳倡导模拟控制设备，而不是数字计算机。
chap1_para172,1,"The importance of domain knowledge was also apparent in the area of natural language understanding. Despite the success of Winograd’s SHRDLU system, its methods did not extend to more general tasks: for problems such as ambiguity resolution it used simple rules that relied on the tiny scope of the blocks world.",1956年夏天，我们提议在新罕布什尔州汉诺威的达特茅斯学院进行为期两个月共10人参与的人工智能研讨。
chap1_para172,2,,这次研讨是基于这样的假设：理论上可以精确描述学习的每个方面或智能的任何特征，从而可以制造机器来对其进行模拟。
chap1_para172,3,,我们将试图寻找让机器使用语言，形成抽象和概念，解决人类特有的各种问题并改进自身的方法。
chap1_para172,4,,我们认为，如果一个精心挑选的科学家团队在一整个夏天里共同研究这些问题，则可以在一个或多个方面取得重大进展。
chap1_para173,1,"Several researchers, including Eugene Charniak at MIT and Roger Schank at Yale, suggested that robust language understanding would require general knowledge about the world and a general method for using that knowledge. (Schank went further, claiming, “There is no such thing as syntax,” which upset a lot of linguists but did serve to start a useful discussion.) Schank and his students built a series of programs (Schank and Abelson, 1977; Wilensky, 1978; Schank and Riesbeck, 1981) that all had the task of understanding natural language. The emphasis, however, was less on language per se and more on the problems of representing and reasoning with the knowledge required for language understanding.",尽管有这种乐观的预测，但达特茅斯的研讨会并没有带来任何突破。
chap1_para173,2,,纽厄尔和西蒙提出了也许是最成熟的工作——一个称为“逻辑理论家”（Logic Theorist，LT）的数学定理证明系统。
chap1_para173,3,,西蒙声称：“我们已经发明了一种能够进行非数值思维的计算机程序，从而解决了神圣的身心问题。
chap1_para173,4,,”[19]研讨会结束后不久，这个程序就已经能证明罗素和怀特海的Principia Mathematica第2章中的大多数定理。
chap1_para173,5,,据报道，当罗素被告知LT提出了一个比Principia Mathematica书中更精巧的证明时，罗素感到很高兴。
chap1_para173,6,,但《符号逻辑杂志》（The Journal of Symbolic Logic）的编辑们没被打动，他们拒绝了由纽厄尔、西蒙和逻辑理论家合著的论文。
chap1_para174,1,"The widespread growth of applications to real-world problems led to the development of a wide range of representation and reasoning tools. Some were based on logic—for example, the Prolog language became popular in Europe and Japan, and the PLANNER family in the United States. Others, following Minsky’s idea of frames (1975), adopted a more structured approach, assembling facts about particular object and event types and arranging the types into a large taxonomic hierarchy analogous to a biological taxonomy.",
chap1_para175,1,"In 1981, the Japanese government announced the “Fifth Generation” project, a 10-year plan to build massively parallel, intelligent computers running Prolog. The budget was to exceed a $1.3 billion in today’s money. In response, the United States formed the Microelectronics and Computer Technology Corporation (MCC), a consortium designed to assure national competitiveness. In both cases, AI was part of a broad effort, including chip design and human-interface research. In Britain, the Alvey report reinstated the funding removed by the Lighthill report. However, none of these projects ever met its ambitious goals in terms of new AI capabilities or economic impact.",[19]　纽厄尔和西蒙还发明了一种链表处理语言IPL来编写LT。
chap1_para175,2,,他们没有编译器，只能手动将其翻译为机器代码。
chap1_para175,3,,为了避免错误，他们并行工作，在编写每条指令时相互大声喊出二进制数，以确保他们是一致的。
chap1_para176,1,"Overall, the AI industry boomed from a few million dollars in 1980 to billions of dollars in 1988, including hundreds of companies building expert systems, vision systems, robots, and software and hardware specialized for these purposes.",1.3.2　早期热情高涨，期望无限（1952—1969）
chap1_para177,1,"Soon after that came a period called the “AI winter,” in which many companies fell by the wayside as they failed to deliver on extravagant promises. It turned out to be difficult to build and maintain expert systems for complex domains, in part because the reasoning methods used by the systems broke down in the face of uncertainty and in part because the systems could not learn from experience.",20世纪50年代的知识界总体上倾向于相信“机器永远不能做X”。
chap1_para177,2,,（见第27章中图灵收集的X的详细列表。
chap1_para177,3,,）人工智能研究人员自然而然地一个接一个地演示X以回应。
chap1_para177,4,,他们特别关注那些被认为能够显示人类智能的任务，包括游戏、谜题、数学和智商测试。
chap1_para177,5,,约翰·麦卡锡将这段时期称为“瞧，妈，不需要人动手操控！
chap1_para177,6,,”（Look，Ma，no hands!）时代。
chap1_para178,1,1.3.5The return of neural networks (1986–present),纽厄尔和西蒙继LT成功之后又推出了通用问题求解器，即GPS。
chap1_para178,2,,与LT不同，GPS从一开始就被设计为模仿人类求解问题的协议。
chap1_para178,3,,结果表明，在它可以处理的有限类型的难题中，该程序考虑的子目标和可能采取的行为的顺序与人类处理相同问题的顺序类似。
chap1_para178,4,,因此，GPS可能是第一个体现“人类思维”方式的程序。
chap1_para178,5,,作为认知模型，GPS和后续程序的成功使得纽厄尔和西蒙（1976）提出了著名的物理符号系统（physical symbol system）假说，该假说认为“物理符号系统具有进行一般智能动作的必要和充分方法”。
chap1_para178,6,,意思是，任何显示出智能的系统（人类或机器）必须通过操作由符号组成的数据结构来运行。
chap1_para178,7,,之后我们会看到这个假说已经受到了多方面的挑战。
chap1_para179,1,In the mid-1980s at least four different groups reinvented the back-propagation learning algorithm first developed in the early 1960s.,在IBM，纳撒尼尔·罗切斯特和他的同事开发了首批人工智能程序。
chap1_para179,2,"The algorithm was applied to many learning problems in computer science and psychology, and the widespread dissemination of the results in the collection Parallel Distributed Processing (Rumelhart and McClelland, 1986) caused great excitement.","赫伯特·盖伦特（Herbert Gelernter）（Gelernter, 1959）构造了几何定理证明程序（Geometry Theorem Prover），它能够证明许多数学学生认为相当棘手的定理。"
chap1_para179,3,,这项工作是现代数学定理证明程序的先驱。
chap1_para18,1,1.,图灵认为，没有必要对人进行物理模拟来证明智能。
chap1_para18,2,1.,然而，其他研究人员提出了完全图灵测试（total Turing test），该测试需要与真实世界中的对象和人进行交互。
chap1_para18,3,2Thinking humanly: The cognitive modeling approach,为了通过完全图灵测试，机器人还需要具备下列能力：
chap1_para180,1,"These so-called connectionist models were seen by some as direct competitors both to the symbolic models promoted by Newell and Simon and to the logicist approach of McCarthy and others. It might seem obvious that at some level humans manipulate symbols—in fact, the anthropologist Terrence Deacon’s book The Symbolic Species (1997) suggests that this is the defining characteristic of humans. Against this, Geoff Hinton, a leading figure in the resurgence of neural networks in the 1980s and 2010s, has described symbols as the “luminiferous aether of AI”—a reference to the non-existent medium through which many 19th-century physicists believed that electromagnetic waves propagated. Certainly, many concepts that we name in language fail, on closer inspection, to have the kind of logically defined necessary and sufficient conditions that early AI researchers hoped to capture in axiomatic form. It may be that connectionist models form internal concepts in a more fluid and imprecise way that is better suited to the messiness of the real world. They also have the capability to learn from examples—they can compare their predicted output value to the true value on a problem and modify their parameters to decrease the difference, making them more likely to perform well on future examples.",从长远来看，这一时期所有探索性工作中，最有影响力的可能是亚瑟·萨缪尔对西洋跳棋的研究。
chap1_para180,2,,通过使用现在称之为强化学习的方法（见第22章），萨缪尔的程序可以以业余高手的水平进行对抗。
chap1_para180,3,,因此，他驳斥了计算机只能执行被告知的事情的观点：他的程序很快学会了玩游戏，甚至比其创造者玩得更好。
chap1_para180,4,,该程序于1956年在电视上演示，给人留下了深刻的印象。
chap1_para180,5,,和图灵一样，萨缪尔也很难找到使用计算机的机会，他只能晚上工作，使用仍在IBM制造工厂测试场地上还未出厂的计算机。
chap1_para180,6,,"萨缪尔的程序是许多后继系统的前身，如TD-Gammon（Tesauro, 1992）和AlphaGo（Silver et al., 2016）。"
chap1_para180,7,,TD-Gammon是世界上最好的西洋双陆棋棋手之一，而AlphaGo因击败人类世界围棋冠军而震惊世界（见第5章）。
chap1_para181,1,1.3.6Probabilistic reasoning and machine learning (1987–present),1958年，约翰·麦卡锡为人工智能做出了两项重要贡献。
chap1_para181,2,,在麻省理工学院人工智能实验室备忘录1号中，他定义了高级语言Lisp，Lisp在接下来的30年中成为了最重要的人工智能编程语言。
chap1_para181,3,,在一篇题为“Programs with Common Sense”的论文中，麦卡锡为基于知识和推理的人工智能系统提出了概念性议案。
chap1_para181,4,,这篇论文描述了“建议接受者”（Advice Taker），这是一个假想程序，它包含了世界的一般知识，并可以利用它得出行动规划。
chap1_para181,5,,这个概念可以用简单的逻辑公理来说明，这些逻辑公理足以生成一个开车去机场的规划。
chap1_para181,6,,该程序还被设计为能在正常运行过程中接受新的公理，从而实现无须重新编程就能够在新领域中运行。
chap1_para181,7,,因此，“建议接受者”体现了知识表示和推理的核心原则：对世界及其运作进行形式化、明确的表示，并且通过演绎来操作这种表示是很有用的。
chap1_para181,8,,这篇论文影响了人工智能的发展历程，至今仍有意义。
chap1_para182,1,"The brittleness of expert systems led to a new, more scientific approach incorporating probability rather than Boolean logic, machine learning rather than hand-coding, and experimental results rather than philosophical claims.",1958年也是马文·明斯基转到麻省理工学院的一年。
chap1_para182,2,"14 It became more common to build on existing theories than to propose brand-new ones, to base claims on rigorous theorems or solid experimental methodology (Cohen, 1995) rather than on intuition, and to show relevance to real-world applications rather than toy examples.",然而，他与麦卡锡的最初合作并没有持续。
chap1_para182,3,,麦卡锡强调形式逻辑中的表示和推理，而明斯基则对程序工作并最终形成反逻辑的观点更感兴趣。
chap1_para182,4,,1963年，麦卡锡在斯坦福大学建立了人工智能实验室。
chap1_para182,5,,1965年亚伯拉罕·鲁滨逊（J. A. Robinson）归结原理（一阶逻辑的完备定理证明算法；见第9章）的发现推进了麦卡锡使用逻辑来构建最终“建议接受者”的计划。
chap1_para182,6,,麦卡锡在斯坦福大学的工作中强调了逻辑推理的通用方法。
chap1_para182,7,,"逻辑的应用包括柯德尔·格林（Cordell Green）的问答和规划系统（Green, 1969b）以及斯坦福研究所（SRI）的Shakey机器人项目，后者（将在第26章中进一步讨论）是第一个展示逻辑推理和物理活动完全集成的项目。"
chap1_para183,1,"Shared benchmark problem sets became the norm for demonstrating progress, including the UC Irvine repository for machine learning data sets, the International Planning Competition for planning algorithms, the LibriSpeech corpus for speech recognition, the MNIST data set for handwritten digit recognition, ImageNet and COCO for image object recognition, SQUAD for natural language question answering, the WMT competition for machine translation, and the International SAT Competitions for Boolean satisfiability solvers.",在麻省理工学院，明斯基指导了一批学生，他们选择了一些似乎需要智能才能求解的有限问题。
chap1_para183,2,,这些有限的领域被称为微世界（microworld）。
chap1_para183,3,,"詹姆斯·斯莱格尔（James Slagle）的Saint程序（Slagle, 1963）能够求解大学一年级课程中典型封闭形式的微积分问题。"
chap1_para183,4,,"托马斯·埃文斯（Thomas Evans）的Analogy程序（Evans, 1968）能够解决智商测试中常见的几何类比问题。"
chap1_para183,5,,"丹尼尔·博布罗（Daniel Bobrow）的Student项目（Bobrow, 1967）能够求解代数故事问题，例如："
chap1_para184,1,"AI was founded in part as a rebellion against the limitations of existing fields like control theory and statistics, but in this period it embraced the positive results of those fields.",如果汤姆获得的客户数量是他投放的广告数量的20%的平方的两倍，已知他投放的广告数量是45，那么汤姆获得的客户数量是多少？
chap1_para184,2,As David McAllester (1998) put it:,
chap1_para185,1,"In the early period of AI it seemed plausible that new forms of symbolic computation, e.",最著名的微世界是积木世界（blocks world），由一组放置在桌面上的实心积木组成（或者更常见的是模拟桌面），如图1-3所示。
chap1_para185,2,g.,在这个世界中，一个典型的任务是用机械手以某种方式重新排列积木，这个机械手一次可以拿起一块积木。
chap1_para185,3,", frames and semantic networks, made much of classical theory obsolete.","积木世界孕育了戴维·哈夫曼（David Huffman）（Huffman, 1971）的视觉项目、戴维·沃尔茨（David Waltz）（Waltz, 1975）的视觉和约束传播工作、帕特里克·温斯顿（Patrick Winston）（Winston, 1970）的学习理论、特里·温诺格拉德（Terry Winograd）（Winograd, 1972）的自然语言理解程序以及斯科特·法尔曼（Scott Fahlman）（Fahlman, 1974）的规划器。"
chap1_para185,4,This led to a form of isolationism in which AI became largely separated from the rest of computer science.,
chap1_para185,5,This isolationism is currently being abandoned.,
chap1_para185,6,"There is a recognition that machine learning should not be isolated from information theory, that uncertain reasoning should not be isolated from stochastic modeling, that search should not be isolated from classical optimization and control, and that automated reasoning should not be isolated from formal methods and static analysis.",
chap1_para186,1,The field of speech recognition illustrates the pattern.,图1-3　积木世界的场景。
chap1_para186,2,"In the 1970s, a wide variety of different architectures and approaches were tried.","Shrdlu（Winograd, 1972）刚刚完成了一个命令——“找到一块比你所持有的积木块更高的积木块，并把它放进盒子里”"
chap1_para186,3,"Many of these were rather ad hoc and fragile, and worked on only a few carefully selected examples.",
chap1_para186,4,"In the 1980s, approaches using hidden Markov models (HMMs) came to dominate the area.",
chap1_para186,5,Two aspects of HMMs are relevant.,
chap1_para186,6,"First, they are based on a rigorous mathematical theory.",
chap1_para186,7,This allowed speech researchers to build on several decades of mathematical results developed in other fields.,
chap1_para186,8,"Second, they are generated by a process of training on a large corpus of real speech data.",
chap1_para186,9,"This ensures that the performance is robust, and in rigorous blind tests HMMs improved their scores steadily.",
chap1_para186,10,"As a result, speech technology and the related field of handwritten character recognition made the transition to widespread industrial and consumer applications.",
chap1_para186,11,"Note that there was no scientific claim that humans use HMMs to recognize speech; rather, HMMs provided a mathematical framework for understanding and solving the problem.",
chap1_para186,12,We will see in Section 1.,
chap1_para186,13,3.,
chap1_para186,14,"8, however, that deep learning has rather upset this comfortable narrative.",
chap1_para187,1,"1988 was an important year for the connection between AI and other fields, including statistics, operations research, decision theory, and control theory. Judea Pearl’s (1988) Probabilistic Reasoning in Intelligent Systems led to a new acceptance of probability and decision theory in AI. Pearl’s development of Bayesian networks yielded a rigorous and efficient formalism for representing uncertain knowledge as well as practical algorithms for probabilistic reasoning. Chapters 12, 13, 14, 15, and 18 cover this area, in addition to more recent developments that have greatly increased the expressive power of probabilistic formalisms; Chapter 21 describes methods for learning Bayesian networks and related models from data.",建立在麦卡洛克和皮茨提出的神经网络上的早期工作也蓬勃发展。
chap1_para187,2,,"什穆埃尔·温诺格拉德（Shmuel Winograd）和杰克·考恩（Jack Cowan）的研究（Winograd and Cowan, 1963）展示了大量元素如何共同代表一个独立的概念，同时提升稳健性和并行性。"
chap1_para187,3,,"赫布的学习方法分别得到了伯尼·维德罗（Bernie Widrow）（Widrow and Hoff, 1960; Widrow, 1962）和弗兰克·罗森布拉特（Frank Rosenblatt）（Rosenblatt, 1962）的改进，他们的网络分别被称为线性自适应神经网络（adaline）和感知机（perceptron）。"
chap1_para187,4,,"感知机收敛定理（perceptron convergence theorem）（Block et al., 1962）指出，学习算法可以调整感知机的连接强度来拟合任何输入数据（前提是存在这样的拟合）。"
chap1_para188,1,"A second major contribution in 1988 was Rich Sutton’s work connecting reinforcement learning—which had been used in Arthur Samuel’s checker-playing program in the 1950s—to the theory of Markov decision processes (MDPs) developed in the field of operations research. A flood of work followed connecting AI planning research to MDPs, and the field of reinforcement learning found applications in robotics and process control as well as acquiring deep theoretical foundations.",1.3.3　一些现实（1966—1973）
chap1_para189,1,"One consequence of AI’s newfound appreciation for data, statistical modeling, optimization, and machine learning was the gradual reunification of subfields such as computer vision, robotics, speech recognition, multiagent systems, and natural language processing that had become somewhat separate from core AI. The process of reintegration has yielded significant benefits both in terms of applications—for example, the deployment of practical robots expanded greatly during this period—and in a better theoretical understanding of the core problems of AI.",从一开始，人工智能研究人员对未来成功的预测毫不避讳。
chap1_para189,2,,下面这句1957年赫伯特·西蒙的名言经常被引用：
chap1_para19,1,"To say that a program thinks like a human, we must know how humans think.",● 计算机视觉（computer vision）和语音识别功能，以感知世界；
chap1_para19,2,We can learn about human thought in three ways:,
chap1_para190,1,1.3.7Big data (2001–present),我的目的不是使大家感到惊讶或震惊，我可以总结出的最简单的说法是，现在世界上存在着能够思考、学习和创造的机器。
chap1_para190,2,,此外，它们的这些能力将迅速提高，在可见的未来内，它们能够处理的问题范围将与人类思维的应用范围一样广泛。
chap1_para191,1,"Remarkable advances in computing power and the creation of the World Wide Web have facilitated the creation of very large data sets—a phenomenon sometimes known as big data. These data sets include trillions of words of text, billions of images, and billions of hours of speech and video, as well as vast amounts of genomic data, vehicle tracking data, clickstream data, social network data, and so on.",虽然“可见的未来”这个词是模糊的，但西蒙也做出了更具体的预测：10年内，计算机将成为国际象棋冠军以及机器将能证明重要的数学定理。
chap1_para191,2,,实际上，这些预测的实现（或近似实现）用了40年时间，远远超过10年。
chap1_para191,3,,当初西蒙的过度自信来自于早期人工智能系统在简单示例任务上的出色表现。
chap1_para191,4,,但是，在几乎所有情况下，这些早期系统在更困难的问题上都失败了。
chap1_para192,1,"This has led to the development of learning algorithms specially designed to take advantage of very large data sets. Often, the vast majority of examples in such data sets are unlabeled; for example, in Yarowsky’s (1995) influential work on word-sense disambiguation, occurrences of a word such as “plant” are not labeled in the data set to indicate whether they refer to flora or factory. With large enough data sets, however, suitable learning algorithms can achieve an accuracy of over 96% on the task of identifying which sense was intended in a sentence. Moreover, Banko and Brill (2001) argued that the improvement in performance obtained from increasing the size of the data set by two or three orders of magnitude outweighs any improvement that can be obtained from tweaking the algorithm.",失败有两个主要原因。
chap1_para192,2,,第一个主要原因是许多早期人工智能系统主要基于人类如何执行任务的“知情内省型”，而不是基于对任务、解的含义以及算法需要做什么才能可靠地产生解的仔细分析。
chap1_para193,1,"A similar phenomenon seems to occur in computer vision tasks such as filling in holes in photographs—holes caused either by damage or by the removal of ex-friends. Hays and Efros (2007) developed a clever method for doing this by blending in pixels from similar images; they found that the technique worked poorly with a database of only thousands of images but crossed a threshold of quality with millions of images. Soon after, the availability of tens of millions of images in the ImageNet database (Deng et al., 2009) sparked a revolution in the field of computer vision.",第二个主要原因是对人工智能要求解的问题的复杂性缺乏认识。
chap1_para193,2,,大多数早期的问题求解系统都会尝试组合不同的步骤，直到找到解为止。
chap1_para193,3,,这一策略最初奏效是因为微世界所包含的对象非常少，因此可能的动作非常少，解的动作序列也非常短。
chap1_para193,4,,在计算复杂性理论发展完备之前，人们普遍认为“扩展”到更大的问题仅仅是需要更快的硬件和更大的内存。
chap1_para193,5,,但是当研究人员无法证明涉及几十个事实的定理时，伴随着归结定理证明发展而来的乐观情绪很快就受到了打击。
chap1_para193,6,,一般而言，程序可以找到解的事实并不意味着该程序具备任何在实践中找到解所需的机制。
chap1_para194,1,"The availability of big data and the shift towards machine learning helped AI recover commercial attractiveness (Havenstein, 2005; Halevy et al., 2009). Big data was a crucial factor in the 2011 victory of IBM’s Watson system over human champions in the Jeopardy! quiz game, an event that had a major impact on the public’s perception of AI.",无限计算能力的幻想并不局限于求解问题的程序。
chap1_para194,2,,"早期的机器进化（machine evolution）［现在称为遗传编程（genetic programming）］实验（Friedberg, 1958; Friedberg et al., 1959）基于绝对正确的信念，即通过对机器代码程序进行一系列适当的小变异，就可以为任何特定任务生成表现良好的程序。"
chap1_para194,3,,这个想法就是通过选择过程来尝试随机突变，并保留似乎有用的突变。
chap1_para194,4,,尽管使用了长达数千小时的CPU时间，但几乎没有任何进展。
chap1_para195,1,1.3.8Deep learning (2011–present),"未能处理“组合爆炸”是莱特希尔报告（Lighthill, 1973）中对人工智能的主要批评之一，基于这份报告，英国政府决定在除两所大学外的所有大学中停止支持人工智能研究。"
chap1_para195,2,,（口述传说描绘了一幅稍有不同、更加丰富多彩的画面，但带有政治野心和个人好恶的描述都不是本书的话题。
chap1_para195,3,,）
chap1_para196,1,"The term deep learning refers to machine learning using multiple layers of simple, adjustable computing elements.",此外，产生智能行为的基础结构存在一些根本限制也是导致失败的原因。
chap1_para196,2,"Experiments were carried out with such networks as far back as the 1970s, and in the form of convolutional neural networks they found some success in hand-written digit recognition in the 1990s (LeCun et al.","例如，明斯基和派珀特的著作Perceptrons（Minsky and Papert, 1969）证明，尽管感知机（一种简单的神经网络形式）被证明可以学习它们能够表示的任何事物，但它们能表示的事物很少。"
chap1_para196,3,", 1995).",举例来说，我们无法训练双输入感知机来判断它的两个输入是否相同。
chap1_para196,4,"It was not until 2011, however, that deep learning methods really took off.",尽管他们的研究结果并不适用于更复杂的多层网络，但用于神经网络研究的经费很快就减少到几乎为零。
chap1_para196,5,This occurred first in speech recognition and then in visual object recognition.,"讽刺的是，在20世纪80年代和21世纪10年代再次引起神经网络研究巨大复兴的新反向传播学习算法，早在20世纪60年代初已经在其他情景下得到了发展（Kelley, 1960; Bryson, 1962）。"
chap1_para197,1,"In the 2012 ImageNet competition, which required classifying images into one of a thousand categories (armadillo, bookshelf, corkscrew, etc.), a deep learning system created in Geoffrey Hinton’s group at the University of Toronto (Krizhevsky et al., 2013) demonstrated a dramatic improvement over previous systems, which were based largely on handcrafted features. Since then, deep learning systems have exceeded human performance on some vision tasks (and lag behind in some other tasks). Similar gains have been reported in speech recognition, machine translation, medical diagnosis, and game playing. The use of a deep network to represent the evaluation function contributed to ALPHAGO’S victories over the leading human Go players (Silver et al., 2016, 2017, 2018).",1.3.4　专家系统（1969—1986）
chap1_para198,1,"These remarkable successes have led to a resurgence of interest in AI among students, companies, investors, governments, the media, and the general public.",在人工智能研究的前十年提出的问题求解是一种通用搜索机制，试图将基本的推理步骤串在一起，找到完整的解。
chap1_para198,2,"It seems that every week there is news of a new AI application approaching or exceeding human performance, often accompanied by speculation of either accelerated success or a new AI winter.",这种方法被称为弱方法（weak method），这种方法虽然很普适，但它不能扩展到大型或困难的问题实例上。
chap1_para198,3,,弱方法的替代方案是使用更强大的领域特定的知识，这些知识允许更大规模的推理步骤，并且可以更轻松地处理特定专业领域中发生的典型案例。
chap1_para198,4,,有人可能会说，必须已经差不多知道答案才能解决一个难题。
chap1_para199,1,Deep learning relies heavily on powerful hardware.,"Dendral程序（Buchanan et al., 1969）是这种方法的早期例子。"
chap1_para199,2,Whereas a standard computer CPU can do 109 or 1010 operations per second.,它是在斯坦福大学开发的，爱德华·费根鲍姆（曾是赫伯特·西蒙的学生）、布鲁斯·布坎南（Bruce Buchanan，从哲学家转行的计算机科学家）和乔舒亚·莱德伯格（Joshua Lederberg，诺贝尔生理学或医学奖得主，遗传学家）联手解决了从质谱仪提供的信息推断分子结构的问题。
chap1_para199,3,a deep learning algorithm running on specialized hardware (e.,该程序的输入包括分子的基本分子式（如C6H13NO2）和质谱，其中质谱给出了分子被电子束轰击时产生的各种碎片的质量。
chap1_para199,4,g.,例如，质谱可能在m = 15处有一个峰，这对应于甲基（CH3）碎片的质量。
chap1_para199,5,", GPU, TPU, or FPGA) might consume between 1014 and 1017 operations per second, mostly in the form of highly parallelized matrix and vector operations.",
chap1_para199,6,"Of course, deep learning also depends on the availability of large amounts of training data, and on a few algorithmic tricks (see Chapter 22).",
chap1_para2,1,"We call ourselves Homo sapiens—man the wise—because our intelligence is so important to us. For thousands of years, we have tried to understand how we think and act—that is, how our brain, a mere handful of matter, can perceive, understand, predict, and manipulate a world far larger and more complicated than itself. The field of artificial intelligence, or AI, is concerned with not just understanding but also building intelligent entities—machines that can compute how to act effectively and safely in a wide variety of novel situations.",我们称自己为智人（有智慧的人），因为智能（intelligence）对我们来说尤其重要。
chap1_para2,2,,几千年来，我们一直试图理解我们是如何思考和行动的，也就是不断地了解我们的大脑是如何凭借它那小部分物质去感知、理解、预测并操纵一个远比其自身更大更复杂的世界。
chap1_para2,3,,人工智能（artificial intelligence，AI）领域不仅涉及理解，还涉及构建智能实体。
chap1_para2,4,,这些智能实体机器需要在各种各样新奇的情况下，计算如何有效和安全地行动。
chap1_para20,1,•introspection—trying to catch our own thoughts as they go by;,● 机器人学（robotics），以操纵对象并行动。
chap1_para200,1,1.,朴素版本的程序生成所有可能的符合分子式的结构，然后预测每个结构在质谱仪中的观测结果，并将其与实际质谱进行比较。
chap1_para200,2,4 The State of the Art,正如人们所预期的，这对中等规模的分子来说也是难以处理的。
chap1_para200,3,,Dendral的研究人员咨询了分析化学家，并发现他们通过寻找质谱中已知的峰模式来工作，这些峰表明分子中的常见子结构。
chap1_para200,4,,例如，以下规则用于识别酮（C=O）结构（分子量28）：
chap1_para201,1,"Stanford University’s One Hundred Year Study on AI (also known as AI100) convenes panels of experts to provide reports on the state of the art in AI. Their 2016 report (Stone et al., 2016; Grosz and Stone, 2018) concludes that “Substantial increases in the future uses of AI applications, including more self-driving cars, healthcare diagnostics and targeted treatment, and physical assistance for elder care can be expected” and that “Society is now at a crucial juncture in determining how to deploy AI-based technologies in ways that promote rather than hinder democratic values such as freedom, equality, and transparency.” AI100 also produces an AI Index at aiindex.org to help track progress. Some highlights from the 2018 and 2019 reports (comparing to a year 2000 baseline unless otherwise stated):",如果M是整个分子的质量，且在x1和x2处有两个峰，并且
chap1_para202,1,"•Publications: AI papers increased 20-fold between 2010 and 2019 to about 20,000 a year. The most popular category was machine learning. (Machine learning papers in arXiv.org doubled every year from 2009 to 2017.) Computer vision and natural language processing were the next most popular.",（a）x1 + x2 = M + 28；（b）x1 − 28 是一个高峰；（c）x2 − 28 是一个高峰；（d）x1和 x2中至
chap1_para203,1,"•Sentiment: About 70% of news articles on AI are neutral, but articles with positive tone increased from 12% in 2016 to 30% in 2018. The most common issues are ethical: data privacy and algorithm bias.",
chap1_para204,1,•Students: Course enrollment increased 5-fold in the U.S. and 16-fold internationally from a 2010 baseline. AI is the most popular specialization in Computer Science.,
chap1_para205,1,"•Diversity: AI Professors worldwide are about 80% male, 20% female. Similar numbers hold for Ph.D. students and industry hires.",认识到分子包含特定的子结构，可以极大地减少可能候选项的量级。
chap1_para205,2,,"据作者称，Dendral之所以强大，是因为它不是以第一性原理的形式，而是以高效“食谱”的形式体现了质谱的相关知识（Feigenbaum et al., 1971）。"
chap1_para205,3,,Dendral的意义在于它是第一个成功的知识密集型系统：它的专业知识来源于大量专用规则。
chap1_para205,4,,1971年，费根鲍姆和斯坦福大学的其他研究人员开启了启发式编程项目（heuristic programming project，HPP），以此来研究专家系统（expert system）的新方法可以在多大程度上应用到其他领域。
chap1_para206,1,"•Conferences: Attendance at NeurIPS increased 800% since 2012 to 13,500 attendees. Other conferences are seeing annual growth of about 30%.",接下来的一个主要工作是用于诊断血液感染的Mycin系统。
chap1_para206,2,,Mycin有大约450条规则，它能够表现得和一些专家一样好，甚至比初级医生要好得多。
chap1_para206,3,,Mycin与Dendral有两个主要区别。
chap1_para206,4,,首先，不像Dendral规则，不存在可以推导出Mycin规则的一般理论模型，Mycin规则不得不从大量的专家访谈中获得。
chap1_para206,5,,其次，规则必须反映与医学知识相关的不确定性。
chap1_para206,6,,Mycin引入了一种称为确定性因子（certainty factor）的不确定性计算（见第13章），这在当时似乎与医生评估证据对诊断影响的方式非常吻合。
chap1_para207,1,•Industry: AI startups in the U.S. increased 20-fold to over 800.,"第一个成功的商用专家系统R1在数字设备公司（Digital Equipment Corporation，DEC）投入使用（McDermott, 1982），该程序帮助公司配置新计算机系统的订单。"
chap1_para207,2,,截至1986年，它每年为公司节省约4000万美元。
chap1_para207,3,,到1988年，DEC的人工智能小组已经部署了40个专家系统，而且还有更多的专家系统在开发中。
chap1_para207,4,,同时期，杜邦公司有100个专家系统在使用，500个在开发。
chap1_para207,5,,当时几乎每家美国大公司都有自己的人工智能团队，不是在使用专家系统，就是在研究专家系统。
chap1_para208,1,"•Internationalization: China publishes more papers per year than the U.S. and about as many as all of Europe. However, in citation-weighted impact, U.S. authors are 50% ahead of Chinese authors. Singapore, Brazil, Australia, Canada, and India are the fastest growing countries in terms of the number of AI hires.",领域知识的重要性在自然语言理解领域也很突出。
chap1_para208,2,,尽管特里·温诺格拉德的Shrdlu系统取得了成功，但它的方法并没有扩展到更一般的任务：对于歧义消解之类的问题，它使用了依赖于积木世界中微小范围的简单规则。
chap1_para209,1,"•Vision: Error rates for object detection (as achieved in LSVRC, the Large-Scale Visual Recognition Challenge) improved from 28% in 2010 to 2% in 2017, exceeding human performance. Accuracy on open-ended visual question answering (VQA) improved from 55% to 68% since 2015, but lags behind human performance at 83%.",包括麻省理工学院的尤金·查尔尼克（Eugene Charniak）和耶鲁大学的罗杰·尚克（Roger Schank）在内的几位研究人员一致认为，强大的语言理解需要关于世界的一般知识以及使用这些知识的一般方法。
chap1_para209,2,,（尚克进一步声称，“根本就没有语法这回事”，这让很多语言学家感到不安，但确实引发了一场有益的讨论。
chap1_para209,3,,"）尚克和他的学生们建立了一系列的程序（Schank and Abelson, 1977; Wilensky, 1978; Schank and Riesbeck, 1981），这些程序都用于理解自然语言。"
chap1_para209,4,,但是，重点不在于语言本身，而在于用语言理解所需的知识来表示和推理问题。
chap1_para21,1,•psychological experiments—observing a person in action;,以上6个学科构成了人工智能的大部分内容。
chap1_para21,2,,然而，人工智能研究人员很少把精力用在通过图灵测试上，他们认为研究智能的基本原理更为重要。
chap1_para21,3,,当工程师和发明家停止模仿鸟类，转而使用风洞并学习空气动力学时，对“人工飞行”的探索取得了成功。
chap1_para21,4,,航空工程学著作并未将其领域的目标定义为制造“能像鸽子一样飞行，甚至可以骗过其他真鸽子的机器”。
chap1_para210,1,•Speed: Training time for the image recognition task dropped by a factor of 100 in just the past two years. The amount of computing power used in top AI applications is doubling every 3.4 months.,在真实世界中的广泛应用引发了表示和推理工具的广泛发展。
chap1_para210,2,,有些是基于逻辑的，例如，Prolog语言在欧洲和日本流行，而Planner家族在美国流行。
chap1_para210,3,,"其他人则遵循明斯基的框架（frame）思想（Minsky, 1975），采用了一种更结构化的方法，将有关特定对象和事件类型的事实组合起来，并将这些类型组织成类似于生物分类法的大型分类层次结构。"
chap1_para211,1,"•Language: Accuracy on question answering, as measured by F1 score on the Stanford Question Answering Dataset (SQUAD), increased from 60 to 95 from 2015 to 2019; on the SQUAD 2 variant, progress was faster, going from 62 to 90 in just one year. Both scores exceed human-level performance.",1981年，日本政府宣布了“第五代计算机”计划，这是一个十年计划，旨在建造运行Prolog的大规模并行智能计算机。
chap1_para211,2,,按现在的货币系统衡量，预算将超过13亿美元。
chap1_para211,3,,作为回应，美国成立了微电子与计算机技术公司（Microelectronics and Computer Technology Corporation，MCC），这是一个旨在确保国家竞争力的联盟。
chap1_para211,4,,在这两个项目中，人工智能都是广泛努力的一部分，包括芯片设计和人机界面研究。
chap1_para211,5,,在英国，阿尔维（Alvey）报告恢复了被莱特希尔报告取消的资助资金。
chap1_para211,6,,然而，这些项目都没有在新型的人工智能能力或经济影响方面下实现其宏伟目标。
chap1_para212,1,"•Human benchmarks: By 2019, AI systems had reportedly met or exceeded human-level performance in chess, Go, poker, Pac-Man, Jeopardy!, ImageNet object detection, speech recognition in a limited domain, Chinese-to-English translation in a restricted domain, Quake III, Dota 2, StarCraft II, various Atari games, skin cancer detection, prostate cancer detection, protein folding, and diabetic retinopathy diagnosis.",总的来说，人工智能行业从1980年的几百万美元增长到1988年的数十亿美元，还产生了数百家构建专家系统、视觉系统、机器人以及专门服务于这些目的的软硬件的公司。
chap1_para213,1,"When (if ever) will AI systems achieve human-level performance across a broad variety of tasks? Ford (2018) interviews AI experts and finds a wide range of target years, from 2029 to 2200, with a mean of 2099. In a similar survey (Grace et al., 2017) 50% of respondents thought this could happen by 2066, although 10% thought it could happen as early as 2025, and a few said “never.” The experts were also split on whether we need fundamental new breakthroughs or just refinements on current approaches. But don’t take their predictions too seriously; as Philip Tetlock (2017) demonstrates in the area of predicting world events, experts are no better than amateurs.",但此后不久，经历了一段被称为“人工智能冬天”的时期，许多公司因未能兑现夸张的承诺而停滞。
chap1_para213,2,,事实证明，为复杂领域构建和维护专家系统是困难的，一部分原因是系统使用的推理方法在面临不确定性时会崩溃，另一部分原因是系统无法从经验中学习。
chap1_para214,1,"How will future AI systems operate? We can’t yet say. As detailed in this section, the field has adopted several stories about itself—first the bold idea that intelligence by a machine was even possible, then that it could be achieved by encoding expert knowledge into logic, then that probabilistic models of the world would be the main tool, and most recently that machine learning would induce models that might not be based on any well-understood theory at all. The future will reveal what model comes next.",1.3.5　神经网络的回归（1986—现在）
chap1_para215,1,What can AI do today?,在20世纪80年代中期，至少有4个不同的团队重新发明了最早在20世纪60年代初期发展起来的反向传播（back-propagation）学习算法。
chap1_para215,2,"Perhaps not as much as some of the more optimistic media articles might lead one to believe, but still a great deal.","该算法被应用于计算机科学和心理学中的许多学习问题，Parallel Distributed Processing合集（Rumelhart and McClelland, 1986）中的结果的广泛传播引起了极大的轰动。"
chap1_para215,3,Here are some examples:,
chap1_para216,1,"Robotic vehicles: The history of robotic vehicles stretches back to radio-controlled cars of the 1920s, but the first demonstrations of autonomous road driving without special guides occurred in the 1980s (Kanade et al.",这些所谓的联结主义（connectionist）模型被一些人视为纽厄尔和西蒙的符号模型以及麦卡锡和其他人的逻辑主义方法的直接竞争对手。
chap1_para216,2,", 1986; Dickmanns and Zapp, 1987).","人类在某种程度上操纵符号似乎是显而易见的——事实上，人类学家特伦斯·迪肯（Terrence Deacon）在其著作《符号化动物》（The Symbolic Species）（Deacon, 1997）中指出，这是人类的决定性特征。"
chap1_para216,3,"After successful demonstrations of driving on dirt roads in the 132-mile DARPA Grand Challenge in 2005 (Thrun, 2006) and on streets with traffic in the 2007 Urban Challenge, the race to develop self-driving cars began in earnest.",与此相反，20世纪80年代和21世纪10年代神经网络复兴的领军人物杰弗里·辛顿将符号描述为“人工智能的光以太”（19世纪许多物理学家认为电磁波传播的介质是光以太，但其实这种介质不存在）。
chap1_para216,4,"In 2018, Waymo test vehicles passed the landmark of 10 million miles driven on public roads without a serious accident, with the human driver stepping in to take over control only once every 6,000 miles.",事实上，我们在语言中命名的许多概念，经过仔细检查后，都未能获得早期人工智能研究人员希望以公理形式描述逻辑定义的充要条件。
chap1_para216,5,"Soon after, the company began offering a commercial robotic taxi service.",联结主义模型可能以一种更流畅和不精确的方式形成内部概念，更适配真实世界的混乱。
chap1_para216,6,,它们还具备从样本中学习的能力，它们可以将它们的预测输出值与问题的真实值进行比较，并修改参数以减少差异，使它们在未来的样本中更有可能表现良好。
chap1_para217,1,"In the air, autonomous fixed-wing drones have been providing cross-country blood deliveries in Rwanda since 2016.",1.3.6　概率推理和机器学习（1987—现在）
chap1_para217,2,"Quadcopters perform remarkable aerobatic maneuvers, explore buildings while constructing 3-D maps, and self-assemble into autonomous formations.",
chap1_para218,1,"Legged locomotion: BigDog, a quadruped robot by Raibert et al. (2008), upended our notions of how robots move—no longer the slow, stiff-legged, side-to-side gait of Hollywood movie robots, but something closely resembling an animal and able to recover when shoved or when slipping on an icy puddle. Atlas, a humanoid robot, not only walks on uneven terrain but jumps onto boxes and does backflips (Ackerman and Guizzo, 2016).",专家系统的脆弱性导致了一种新的、更科学的方法，结合了概率而不是布尔逻辑，基于机器学习而不是手工编码，重视实验结果而不是哲学主张。
chap1_para218,2,,"[20]现在更普遍的是，基于现有理论而不是提出全新的理论，基于严格的定理或可靠的实验方法（Cohen, 1995）而不是基于直觉的主张，以及展示与真实世界应用的相关性而不是虚拟的示例。"
chap1_para219,1,"Autonomous planning and scheduling: A hundred million miles from Earth, NASA’s Remote Agent program became the first on-board autonomous planning program to control the scheduling of operations for a spacecraft (Jonsson et al., 2000). Remote Agent generated plans from high-level goals specified from the ground and monitored the execution of those plans—detecting, diagnosing, and recovering from problems as they occurred. Today, the EUROPA planning toolkit (Barreiro et al., 2012) is used for daily operations of NASA’s Mars rovers and the SEXTANT system (Winternitz, 2017) allows autonomous navigation in deep space, beyond the global GPS system.",
chap1_para22,1,•brain imaging—observing the brain in action.,1.1.2　类人思考：认知建模方法
chap1_para220,1,"During the Persian Gulf crisis of 1991, U.S. forces deployed a Dynamic Analysis and Replanning Tool, DART (Cross and Walker, 1994), to do automated logistics planning and scheduling for transportation. This involved up to 50,000 vehicles, cargo, and people at a time, and had to account for starting points, destinations, routes, transport capacities, port and airfield capacities, and conflict resolution among all parameters. The Defense Advanced Research Project Agency (DARPA) stated that this single application more than paid back DARPA’s 30-year investment in AI.",[20]　一些人将这种变化描述为整洁派（neat，认为人工智能理论应该以数学的严谨性为基础的人）战胜了邋遢派（scruffy，那些宁愿尝试大量的想法，编写一些程序，然后评估哪些似乎可行的人）。
chap1_para220,2,,这两种方法都很重要。
chap1_para220,3,,向整洁派的转变意味着该领域已经达到了稳定和成熟的水平。
chap1_para220,4,,目前对深度学习的重视可能代表着邋遢派的复兴。
chap1_para221,1,"Every day, ride hailing companies such as Uber and mapping services such as Google Maps provide driving directions for hundreds of millions of users, quickly plotting an optimal route taking into account current and predicted future traffic conditions.",共享的基准问题集成为了展示进度的标准，包括加利福尼亚大学欧文分校的机器学习数据集库、用于规划算法的国际规划竞赛、用于语音识别的LibriSpeech语料库、用于手写数字识别的MNIST数据集、用于图像物体识别的ImageNet和COCO、用于自然语言问答的SQuAD、机器翻译的WMT竞赛以及布尔可满足性求解器国际SAT竞赛。
chap1_para222,1,"Machine translation: Online machine translation systems now enable the reading of documents in over 100 languages, including the native languages of over 99% of humans, and render hundreds of billions of words per day for hundreds of millions of users.",人工智能的创立在一定程度上是对控制理论和统计等现有领域局限性的反抗，但在这一时期，它吸纳了这些领域的积极成果。
chap1_para222,2,"While not perfect, they are generally adequate for understanding.","正如戴维·麦卡莱斯特（David McAllester）（McAllester, 1998）所说："
chap1_para222,3,For closely related languages with a great deal of training data (such as French and English) translations within a narrow domain are close to the level of a human (Wu et al.,
chap1_para222,4,", 2016b).",
chap1_para223,1,"Speech recognition: In 2017, Microsoft showed that its Conversational Speech Recognition System had reached a word error rate of 5.",在人工智能早期，符号计算的新形式（例如框架和语义网络）使大部分经典理论过时，这似乎是合理的。
chap1_para223,2,"1%, matching human performance on the Switchboard task, which involves transcribing telephone conversations (Xiong et al.",这导致了一种孤立主义，即人工智能在很大程度上与计算机科学的其他领域分离。
chap1_para223,3,", 2017).",这种孤立主义目前正在被摒弃。
chap1_para223,4,About a third of computer interaction worldwide is now done by voice rather than keyboard; Skype provides real-time speech-to-speech translation in ten languages.,人们认识到，机器学习不应该独立于信息论，不确定推理不应该独立于随机建模，搜索不应该独立于经典优化和控制，自动推理不应该独立于形式化方法和静态分析。
chap1_para223,5,"Alexa, Siri, Cortana, and Google offer assistants that can answer questions and carry out tasks for the user; for example the Google Duplex service uses speech recognition and speech synthesis to make restaurant reservations for users, carrying out a fluent conversation on their behalf.",
chap1_para224,1,"Recommendations: Companies such as Amazon, Facebook, Netflix, Spotify, YouTube, Walmart, and others use machine learning to recommend what you might like based on your past experiences and those of others like you.",语音识别领域对这种模式进行了说明。
chap1_para224,2,"The field of recommender systems has a long history (Resnick and Varian, 1997) but is changing rapidly due to new deep learning methods that analyze content (text, music, video) as well as history and metadata (van den Oord et al.",20世纪70年代，研究人员尝试了各种不同的架构和方法，许多是相当暂时和脆弱的，并且只能处理几个精心挑选的例子。
chap1_para224,3,", 2014; Zhang et al.",在20世纪80年代，使用隐马尔可夫模型（hidden Markov model，HMM）的方法开始主导这一领域。
chap1_para224,4,", 2017).",HMM有两个相关的方面。
chap1_para224,5,Spam filtering can also be considered a form of recommendation (or dis-recommendation); current AI techniques filter out over 99.,首先，它们基于严格的数学理论。
chap1_para224,6,"9% of spam, and email services can also recommend potential recipients, as well as possible response text.",这使得语音研究人员能够在其他领域数十年数学成果的基础上进行开发。
chap1_para224,7,,其次，它们是在大量真实语音数据的语料库上训练而产生的。
chap1_para224,8,,这确保了健壮性，并且在严格的盲测中，HMM的分数稳步提高。
chap1_para224,9,,因此，语音技术和手写体字符识别的相关领域向广泛的工业和消费级应用过渡。
chap1_para224,10,,注意，并没有科学证据表明人类使用HMM识别语音，HMM只是为理解和求解问题提供了一个数学框架。
chap1_para224,11,,然而，在1.3.8节中我们将看到，深度学习已经破坏了这种舒适的叙述。
chap1_para225,1,"Game playing: When Deep Blue defeated world chess champion Garry Kasparov in 1997, defenders of human supremacy placed their hopes on Go. Piet Hut, an astrophysicist and Go enthusiast, predicted that it would take “a hundred years before a computer beats humans at Go—maybe even longer.” But just 20 years later, ALPHAGO surpassed all human players (Silver et al., 2017). Ke Jie, the world champion, said, “Last year, it was still quite human-like when it played. But this year, it became like a god of Go.” ALPHAGO benefited from studying hundreds of thousands of past games by human Go players, and from the distilled knowledge of expert Go players that worked on the team.",1988年是人工智能与统计学、运筹学、决策论和控制理论等其他领域相联系的重要一年。
chap1_para225,2,,"朱迪亚·珀尔的Probabilistic Reasoning in Intelligent Systems（Pearl, 1988）使概率和决策论在人工智能中得到了新的认可。"
chap1_para225,3,,珀尔对贝叶斯网络的发展产生了一种用于表示不确定的知识的严格而有效的形式体系，以及用于概率推理的实用算法。
chap1_para225,4,,第12～16章涵盖了这个领域，此外最近的发展大大提升了概率形式体系的表达能力，第20章描述了从数据中学习贝叶斯网络（Bayesian network）和相关模型的方法。
chap1_para226,1,"A followup program, ALPHAZERO, used no input from humans (except for the rules of the game), and was able to learn through self-play alone to defeat all opponents, human and machine, at Go, chess, and shogi (Silver et al., 2018). Meanwhile, human champions have been beaten by AI systems at games as diverse as Jeopardy! (Ferrucci et al., 2010), poker (Bowling et al., 2015; Moravčík et al., 2017; Brown and Sandholm, 2019), and the video games Dota 2 (Fernandez and Mahlmann, 2018), StarCraft II (Vinyals et al., 2019), and Quake III (Jaderberg et al., 2019).",1988年的第二个主要贡献是理查德·萨顿（Rich Sutton）的工作，他将强化学习（20世纪50年代被用于亚瑟·塞缪尔的西洋跳棋程序中）与运筹学领域开发的马尔可夫决策过程（Markov decision processe，MDP）联系起来。
chap1_para226,2,,随后，大量工作将人工智能规划研究与MDP联系起来，强化学习领域在机器人和过程控制方面找到了应用，并获得了深厚的理论基础。
chap1_para227,1,"Image understanding: Not content with exceeding human accuracy on the challenging ImageNet object recognition task, computer vision researchers have taken on the more difficult problem of image captioning. Some impressive examples include “A person riding a motorcycle on a dirt road,” “Two pizzas sitting on top of a stove top oven,” and “A group of young people playing a game of frisbee” (Vinyals et al., 2017b). Current systems are far from perfect, however: a “refrigerator filled with lots of food and drinks” turns out to be a no-parking sign partially obscured by lots of small stickers.",人工智能对数据、统计建模、优化和机器学习的新认识带来的结果是，计算机视觉、机器人技术、语音识别、多智能体系统和自然语言处理等子领域逐渐统一，此前这些子领域在某种程度上已经脱离了核心人工智能。
chap1_para227,2,,重新统一的过程在应用方面（例如，在此期间实用机器人的部署大大扩展）和关于人工智能核心问题更好的理论理解方面都产生了显著的效用。
chap1_para228,1,"Medicine: AI algorithms now equal or exceed expert doctors at diagnosing many conditions, particularly when the diagnosis is based on images. Examples include Alzheimer’s disease (Ding et al., 2018), metastatic cancer (Liu et al., 2017; Esteva et al., 2017), ophthalmic disease (Gulshan et al., 2016), and skin diseases (Liu et al., 2019c). A systematic review and meta-analysis (Liu et al., 2019a) found that the performance of AI programs, on average, was equivalent to health care professionals. One current emphasis in medical AI is in facilitating human–machine partnerships. For example, the LYNA system achieves 99.6% overall accuracy in diagnosing metastatic breast cancer—better than an unaided human expert—but the combination does better still (Liu et al., 2018; Steiner et al., 2018).",1.3.7　大数据（2001—现在）
chap1_para229,1,"The widespread adoption of these techniques is now limited not by diagnostic accuracy but by the need to demonstrate improvement in clinical outcomes and to ensure transparency, lack of bias, and data privacy (Topol, 2019).",计算能力的显著进步和互联网的创建促进了巨大数据集的创建，这种现象有时被称为大数据（big data）。
chap1_para229,2,"In 2017, only two medical AI applications were approved by the FDA, but that increased to 12 in 2018, and continues to rise.",这些数据集包括数万亿字的文本、数十亿的图像、数十亿小时的语音和视频，以及海量的基因组数据、车辆跟踪数据、点击流数据、社交网络数据等。
chap1_para23,1,"Once we have a sufficiently precise theory of the mind, it becomes possible to express the theory as a computer program. If the program’s input–output behavior matches corresponding human behavior, that is evidence that some of the program’s mechanisms could also be operating in humans.",我们必须知道人类是如何思考的，才能说程序像人类一样思考。
chap1_para23,2,,我们可以通过3种方式了解人类的思维：
chap1_para230,1,Climate science: A team of scientists won the 2018 Gordon Bell Prize for a deep learning model that discovers detailed information about extreme weather events that were previously buried in climate data.,这导致了专为利用非常大的数据集而设计的学习算法的开发。
chap1_para230,2,"They used a supercomputer with specialized GPU hardware to exceed the exaop level (1018 operations per second), the first machine learning program to do so (Kurth et al.",通常，这类数据集中的绝大多数例子都没有标签。
chap1_para230,3,", 2018).","例如，在雅让斯基关于词义消歧的著作（Yarowsky, 1995）中，出现的一个词（如“plant”），并没有在数据集中标明这是指植物还是工厂。"
chap1_para230,4,Rolnick et al.,然而，如果有足够大的数据集，合适的学习算法在识别句意的任务上可以达到超过96%的准确率。
chap1_para230,5,(2019) present a 60-page catalog of ways in which machine learning can be used to tackle climate change.,"此外，班科和布里尔认为，将数据集的规模增加两到三个数量级所获得的性能提升会超过调整算法带来的性能提升（Banko and Brill, 2001）。"
chap1_para231,1,"These are just a few examples of artificial intelligence systems that exist today. Not magic or science fiction—but rather science, engineering, and mathematics, to which this book provides an introduction.",类似的现象似乎也发生在计算机视觉任务中，例如填补照片中的破洞（要么是由损坏造成的，要么是挖除前朋友造成的）。
chap1_para231,2,,"海斯和埃弗罗斯（Hays and Efros, 2007）开发了一种巧妙的方法，从类似的图像中混合像素。"
chap1_para231,3,,他们发现，该技术在仅包含数千幅图像的数据库中效果不佳，但在拥有数百万幅图像的数据库中，该技术超过了质量阈值。
chap1_para231,4,,"不久之后，ImageNet数据库（Deng et al., 2009）中可用的数千万幅图像引发了计算机视觉领域的一场革命。"
chap1_para232,1,1.,"大数据的可用性和向机器学习的转变帮助人工智能恢复了商业吸引力（Havenstein, 2005; Halevy et al., 2009）。"
chap1_para232,2,5 Risks and Benefits of AI,大数据是2011年IBM的Watson系统在《危险边缘》（Jeopardy!）问答游戏中战胜人类冠军的关键因素，这一事件深深影响了公众对人工智能的看法。
chap1_para233,1,"Francis Bacon, a philosopher credited with creating the scientific method, noted in The Wisdom of the Ancients (1609) that the “mechanical arts are of ambiguous use, serving as well for hurt as for remedy.” As AI plays an increasingly important role in the economic, social, scientific, medical, financial, and military spheres, we would do well to consider the hurts and remedies—in modern parlance, the risks and benefits—that it can bring. The topics summarized here are covered in greater depth in Chapters 28 and 29.",1.3.8　深度学习（2011—现在）
chap1_para234,1,"To begin with the benefits: put simply, our entire civilization is the product of our human intelligence. If we have access to substantially greater machine intelligence, the ceiling on our ambitions is raised substantially. The potential for AI and robotics to free humanity from menial repetitive work and to dramatically increase the production of goods and services could presage an era of peace and plenty. The capacity to accelerate scientific research could result in cures for disease and solutions for climate change and resource shortages. As Demis Hassabis, CEO of Google DeepMind, has suggested: “First solve AI, then use AI to solve everything else.”",深度学习（deep learning）是指使用多层简单的、可调整的计算单元的机器学习。
chap1_para234,2,,"早在20世纪70年代，研究人员就对这类网络进行了实验，并在20世纪90年代以卷积神经网络（convolutional neural network）（LeCun et al., 1995）的形式在手写数字识别方面取得了一定的成功。"
chap1_para234,3,,然而，直到2011年，深度学习方法才真正开始流行起来，首先是在语音识别领域，然后是在视觉物体识别领域。
chap1_para235,1,"Long before we have an opportunity to “solve AI,” however, we will incur risks from the misuse of AI, inadvertent or otherwise. Some of these are already apparent, while others seem likely based on current trends:",在2012年的ImageNet竞赛中，需要将图像分类为1000个类别之一（犰狳、书架、开瓶器等）。
chap1_para235,2,,"多伦多大学杰弗里·辛顿团队开发的深度学习系统（Krizhevsky et al., 2013）比以前基于手工特征的系统有了显著改进。"
chap1_para235,3,,从那时起，深度学习系统在某些视觉任务上的表现超过了人类，但在其他一些任务上还显落后。
chap1_para235,4,,在语音识别、机器翻译、医疗诊断和博弈方面也有类似的进展。
chap1_para235,5,,"AlphaGo（Silver et al., 2016, 2017, 2018）之所以能够战胜人类顶尖的围棋棋手，是因为它使用了深度网络来表示评价函数。"
chap1_para236,1,"•Lethal autonomous weapons: These are defined by the United Nations as weapons that can locate, select, and eliminate human targets without human intervention. A primary concern with such weapons is their scalability: the absence of a requirement for human supervision means that a small group can deploy an arbitrarily large number of weapons against human targets defined by any feasible recognition criterion. The technologies needed for autonomous weapons are similar to those needed for self-driving cars. Informal expert discussions on the potential risks of lethal autonomous weapons began at the UN in 2014, moving to the formal pre-treaty stage of a Group of Governmental Experts in 2017.",这些非凡的成功使学生、公司、投资者、政府、媒体和公众对人工智能的兴趣重新高涨。
chap1_para236,2,,似乎每周都有新的人工智能应用接近或超过人类表现的消息，通常伴随着加速成功或人工智能新寒冬的猜测。
chap1_para237,1,"•Surveillance and persuasion: While it is expensive, tedious, and sometimes legally questionable for security personnel to monitor phone lines, video camera feeds, emails, and other messaging channels, AI (speech recognition, computer vision, and natural language understanding) can be used in a scalable fashion to perform mass surveillance of individuals and detect activities of interest. By tailoring information flows to individuals through social media, based on machine learning techniques, political behavior can be modified and controlled to some extent—a concern that became apparent in elections beginning in 2016.",深度学习在很大程度上依赖于强大的硬件，一个标准的计算机CPU每秒可以进行109或1010次运算。
chap1_para237,2,,运行在特定硬件（例如GPU、TPU或FPGA）上的深度学习算法，每秒可能进行1014～1017次运算，主要是高度并行化的矩阵和向量运算。
chap1_para237,3,,当然，深度学习还依赖于大量训练数据的可用性，以及一些算法技巧（见第21章）。
chap1_para238,1,"•Biased decision making: Careless or deliberate misuse of machine learning algorithms for tasks such as evaluating parole and loan applications can result in decisions that are biased by race, gender, or other protected categories. Often, the data themselves reflect pervasive bias in society.",1.4　目前的先进技术
chap1_para239,1,"•Impact on employment: Concerns about machines eliminating jobs are centuries old. The story is never simple: machines do some of the tasks that humans might otherwise do, but they also make humans more productive and therefore more employable, and make companies more profitable and therefore able to pay higher wages. They may render some activities economically viable that would otherwise be impractical. Their use generally results in increasing wealth but tends to have the effect of shifting wealth from labor to capital, further exacerbating increases in inequality. Previous advances in technology—such as the invention of mechanical looms—have resulted in serious disruptions to employment, but eventually people find new kinds of work to do. On the other hand, it is possible that AI will be doing those new kinds of work too. This topic is rapidly becoming a major focus for economists and governments around the world.",斯坦福大学的人工智能百年研究（也称为AI100）召集了专家小组来提供人工智能最先进技术的报告。
chap1_para239,2,,"2016年的报告（Stone et al., 2016; Grosz and Stone, 2018）总结：“未来人工智能的应用将大幅增加，包括更多的自动驾驶汽车、医疗诊断和针对性的治疗，以及对老年人护理的物理援助”，并且“社会现在正处于关键时刻，将决定如何以促进而不是阻碍自由、平等和透明等民主价值观的方式部署基于人工智能的技术”。"
chap1_para239,3,,AI100还在其网站上创建了一个人工智能指数（AI Index），以帮助跟踪人工智能的进展。
chap1_para239,4,,以下列举了与2000年基线相比（除非另有说明），2018年和2019年报告的一些亮点。
chap1_para24,1,"For example, Allen Newell and Herbert Simon, who developed GPS, the “General Problem Solver” (Newell and Simon, 1961), were not content merely to have their program solve problems correctly. They were more concerned with comparing the sequence and timing of its reasoning steps to those of human subjects solving the same problems. The interdisciplinary field of cognitive science brings together computer models from AI and experimental techniques from psychology to construct precise and testable theories of the human mind.",● 内省（introspection）——试图在自己进行思维活动时捕获思维；
chap1_para240,1,"•Safety-critical applications: As AI techniques advance, they are increasingly used in high-stakes, safety-critical applications such as driving cars and managing the water supplies of cities. Fatal accidents have already occurred and highlight the difficulty of formal verification and statistical risk analysis for systems developed using machine learning techniques. The field of AI will need to develop technical and ethical standards at least comparable to those prevalent in other engineering and healthcare disciplines where people’s lives are at stake.",● 出版物：人工智能论文数量在2010年至2019年间增长了20倍，达到每年约2万篇。
chap1_para240,2,,最受欢迎的类别是机器学习（2009年至2017年，arXiv.org上的机器学习论文数量每年都会翻一番）。
chap1_para240,3,,其次是计算机视觉和自然语言处理。
chap1_para241,1,"•Cybersecurity: AI techniques are useful in defending against cyberattack, for example by detecting unusual patterns of behavior, but they will also contribute to the potency, survivability, and proliferation capability of malware. For example, reinforcement learning methods have been used to create highly effective tools for automated, personalized blackmail and phishing attacks.",● 情绪：大约70%的人工智能新闻文章是中性的，但正面基调的文章从2016年的12%上升到2018年的30%。
chap1_para241,2,,最常见的问题是道德问题——数据隐私和算法偏见。
chap1_para242,1,We will revisit these topics in more depth in Section 28.,● 学生：与2010年基线相比，课程注册人数在美国增加了5倍，全球增加了16倍。
chap1_para242,2,3.,人工智能是计算机科学中最受欢迎的专业。
chap1_para242,3,"As AI systems become more capable, they will take on more of the societal roles previously played by humans.",
chap1_para242,4,"Just as humans have used these roles in the past to perpetrate mischief, we can expect that humans may misuse AI systems in these roles to perpetrate even more mischief.",
chap1_para242,5,"All of the examples given above point to the importance of governance and, eventually, regulation.",
chap1_para242,6,"At present, the research community and the major corporations involved in AI research have developed voluntary self-governance principles for AI-related activities (see Section 28.",
chap1_para242,7,3).,
chap1_para242,8,"Governments and international organizations are setting up advisory bodies to devise appropriate regulations for each specific use case, to prepare for the economic and social impacts, and to take advantage of AI capabilities to address major societal problems.",
chap1_para243,1,What of the longer term?,● 多样性：全球人工智能领域的教授中，大约80%是男性，20%是女性。
chap1_para243,2,Will we achieve the long-standing goal: the creation of intelligence comparable to or more capable than human intelligence?,博士生和行业招聘也有类似的数字。
chap1_para243,3,"And, if we do, what then?",
chap1_para244,1,"For much of AI’s history, these questions have been overshadowed by the daily grind of getting AI systems to do anything even remotely intelligent. As with any broad discipline, the great majority of AI researchers have specialized in a specific subfield such as game-playing, knowledge representation, vision, or natural language understanding—often on the assumption that progress in these subfields would contribute to the broader goals of AI. Nils Nilsson (1995), one of the original leaders of the Shakey project at SRI, reminded the field of those broader goals and warned that the subfields were in danger of becoming ends in themselves. Later, some influential founders of AI, including John McCarthy (2007), Marvin Minsky (2007), and Patrick Winston (Beal and Winston, 2009), concurred with Nilsson’s warnings, suggesting that instead of focusing on measurable performance in specific applications, AI should return to its roots of striving for, in Herb Simon’s words, “machines that think, that learn and that create.” They called the effort human-level AI or HLAI—a machine should be able to learn to do anything a human can do. Their first symposium was in 2004 (Minsky et al., 2004). Another effort with similar goals, the artificial general intelligence (AGI) movement (Goertzel and Pennachin, 2007), held its first conference and organized the Journal of Artificial General Intelligence in 2008.",● 会议：NeurIPS的参会人数比2012年增加了8倍，达到13 500人。
chap1_para244,2,,其他会议的参会人数年增长率约为30%。
chap1_para245,1,"At around the same time, concerns were raised that creating artificial superintelligence or ASI—intelligence that far surpasses human ability—might be a bad idea (Yudkowsky, 2008; Omohundro, 2008). Turing (1996) himself made the same point in a lecture given in Manchester in 1951, drawing on earlier ideas from Samuel Butler (1863):15",● 行业：美国的人工智能初创公司数量增长了20倍，达到800多家。
chap1_para246,1,"It seems probable that once the machine thinking method had started, it would not take long to outstrip our feeble powers. ... At some stage therefore we should have to expect the machines to take control, in the way that is mentioned in Samuel Butler’s Erewhon.",● 国际化：中国每年发表的论文多于美国，与整个欧洲一样多。
chap1_para246,2,,但是，在引用加权影响方面，美国作者领先中国作者50%。
chap1_para246,3,,从人工智能招聘人数看，新加坡、巴西、澳大利亚、加拿大和印度是增长最快的国家。
chap1_para247,1,"These concerns have only become more widespread with recent advances in deep learning, the publication of books such as Superintelligence by Nick Bostrom (2014), and public pronouncements from Stephen Hawking, Bill Gates, Martin Rees, and Elon Musk.",● 视觉：物体检测的错误率（大规模视觉识别挑战，LSVRC）从2010年的28%下降到2017年的2%，超过了人类的表现。
chap1_para247,2,,自2015年以来，开放式视觉问答（VQA）的准确率从55%提高到68%，但仍远落后于人类83%的表现。
chap1_para248,1,"Experiencing a general sense of unease with the idea of creating superintelligent machines is only natural. We might call this the gorilla problem: about seven million years ago, a now-extinct primate evolved, with one branch leading to gorillas and one to humans. Today, the gorillas are not too happy about the human branch; they have essentially no control over their future. If this is the result of success in creating superhuman AI—that humans cede control over their future—then perhaps we should stop work on AI, and, as a corollary, give up the benefits it might bring. This is the essence of Turing’s warning: it is not obvious that we can control machines that are more intelligent than us.",● 速度：在过去两年中，图像识别任务的训练时间减少了100倍。
chap1_para248,2,,顶级人工智能应用使用的计算能力每3.4个月就会翻一番。
chap1_para249,1,"If superhuman AI were a black box that arrived from outer space, then indeed it would be wise to exercise caution in opening the box. But it is not: we design the AI systems, so if they do end up “taking control,” as Turing suggests, it would be the result of a design failure.",● 语言：以斯坦福问答数据集（SQuAD）的F1分数衡量的问答准确率，自2015年到 2019年从60分提升到95分，在SQuAD2版本上进展更快，仅在一年内从62分提升到90分。
chap1_para249,2,,这两个分数都超过了人类表现。
chap1_para25,1,"Cognitive science is a fascinating field in itself, worthy of several textbooks and at least one encyclopedia (Wilson and Keil, 1999).",● 心理实验（psychological experiment）——观察一个人的行为；
chap1_para25,2,We will occasionally comment on similarities or differences between AI techniques and human cognition.,
chap1_para25,3,"Real cognitive science, however, is necessarily based on experimental investigation of actual humans or animals.",
chap1_para25,4,"We will leave that for other books, as we assume the reader has only a computer for experimentation.",
chap1_para250,1,"To avoid such an outcome, we need to understand the source of potential failure. Norbert Wiener (1960), who was motivated to consider the long-term future of AI after seeing Arthur Samuel’s checker-playing program learn to beat its creator, had this to say:",● 人类基准：截至2019年，人工智能系统在多个领域达到或超越人类表现，包括国际象棋、围棋、扑克、《吃豆人》（Pac-Man）、《危险边缘》（Jeopardy!）、ImageNet物体检测、有限域中的语音识别、约束域中的英文翻译、《雷神之锤3》（Quake III）、《刀塔2》（Dota 2）、《星际争霸II》（StarCraft II）、Atari的各种游戏、皮肤癌检测、前列腺癌检测、蛋白质折叠、糖尿病视网膜病变诊断等。
chap1_para251,1,"If we use, to achieve our purposes, a mechanical agency with whose operation we cannot interfere effectively .",人工智能系统何时（如果可以的话）能够在各种任务中达到人类水平的表现？
chap1_para251,2,.,"马丁·福特（Martin Ford）（Ford, 2018）通过对人工智能专家的访谈发现这一目标时间的范围很广，从2029年到2200年，均值为2099年。"
chap1_para251,3,.,"在一项类似的调查中（Grace et al., 2017），50%的受访者认为这可能在2066年发生，有10%的人认为这最早可能在2025年发生，少数人则认为“不可能”。"
chap1_para251,4,we had better be quite sure that the purpose put into the machine is the purpose which we really desire.,对于我们是需要根本性的新突破，还是仅仅对现有方法进行改进，专家们也存在分歧。
chap1_para251,5,,"但是不要过于严肃对待他们的预测，正如菲利普·泰洛克（Philip Tetlock）（Tetlock, 2017）在预测世界事件领域所证明的那样，专家并不比业余爱好者预测得更准。"
chap1_para252,1,"Many cultures have myths of humans who ask gods, genies, magicians, or devils for something.",未来的人工智能系统将如何运作？
chap1_para252,2,"Invariably, in these stories, they get what they literally ask for, and then regret it.",我们还不能确定。
chap1_para252,3,"The third wish, if there is one, is to undo the first two.",正如本节所详述的，这个领域采用了几个关于它本身的故事：首先是一个大胆的想法，即机器的智能是可能的，然后是它可以通过将专家知识编码成逻辑来实现，接着是建模世界的概率模型将成为主要工具，以及最近的机器学习将产生可能根本不基于任何易于理解的理论的模型。
chap1_para252,4,"We will call this the King Midas problem: Midas, a legendary King in Greek mythology, asked that everything he touched should turn to gold, but then regretted it after touching his food, drink, and family members.",未来将揭示接下来会出现什么模式。
chap1_para252,5,16,
chap1_para253,1,"We touched on this issue in Section 1.1.5, where we pointed out the need for a significant modification to the standard model of putting fixed objectives into the machine. The solution to Wiener’s predicament is not to have a definite “purpose put into the machine” at all. Instead, we want machines that strive to achieve human objectives but know that they don’t know for certain exactly what those objectives are.",人工智能现在能做什么？
chap1_para253,2,,也许不像一些更乐观的媒体文章让人相信的那样多，但仍然很多，以下是一些例子。
chap1_para254,1,"It is perhaps unfortunate that almost all AI research to date has been carried out within the standard model, which means that almost all of the technical material in this edition reflects that intellectual framework. There are, however, some early results within the new framework. In Chapter 15, we show that a machine has a positive incentive to allow itself to be switched off if and only if it is uncertain about the human objective. In Chapter 17, we formulate and study assistance games, which describe mathematically the situation in which a human has an objective and a machine tries to achieve it, but is initially uncertain about what it is. In Chapter 23, we explain the methods of inverse reinforcement learning that allow machines to learn more about human preferences from observations of the choices that humans make. In Chapter 28, we explore two of the principal difficulties: first, that our choices depend on our preferences through a very complex cognitive architecture that is hard to invert; and, second, that we humans may not have consistent preferences in the first place—either individually or as a group—so it may not be clear what AI systems should be doing for us.","自动驾驶：自动驾驶的历史可以追溯到20世纪20年代的无线电遥控汽车，而在20世纪80年代首次展示了没有特殊向导的自动道路驾驶（Kanade et al., 1986; Dickmanns and Zapp, 1987）。"
chap1_para254,2,,"在2005年的212公里沙漠赛道DARPA挑战赛（Thrun, 2006）和 2007 年繁忙城市道路的城市挑战赛上，自动驾驶汽车成功展示之后，自动驾驶汽车的开发竞赛正式开始。"
chap1_para254,3,,2018年，Waymo的测试车辆在公共道路上行驶超过1600万公里，没有发生严重事故，其中人类司机每9650公里才介入一次接管控制。
chap1_para254,4,,不久之后，该公司开始提供商业机器人出租车服务。
chap1_para255,1,This chapter defines AI and establishes the cultural background against which it has developed.,自2016年以来，自动固定翼无人机一直在为卢旺达提供跨境血液输送服务。
chap1_para255,2,Some of the important points are as follows:,四轴飞行器可以进行出色的特技飞行，可以在构建三维地图的同时探索建筑，并进行自主编队。
chap1_para256,1,"•Different people approach AI with different goals in mind. Two important questions to ask are: Are you concerned with thinking, or behavior? Do you want to model humans, or try to achieve the optimal results?","腿足式机器人：雷伯特等人制作的四足机器人BigDog（Raibert et al., 2008），颠覆了我们对机器人如何行动的概念——不再是好莱坞电影中机器人缓慢、僵硬、左右摇摆的步态，而是类似于动物，并且能够在被推倒或在结冰的水坑上滑倒时恢复站立。"
chap1_para256,2,,"类人机器人Atlas不仅能在崎岖不平的路况中行走，还可以跳到箱子上，做后空翻后可以稳定落地（Ackerman and Guizzo, 2016）。"
chap1_para257,1,"•According to what we have called the standard model, AI is concerned mainly with rational action. An ideal intelligent agent takes the best possible action in a situation. We study the problem of building agents that are intelligent in this sense.","自动规划和调度：在距离地球1.6亿公里的太空，美国国家航空航天局（NASA）的“远程智能体”程序成为第一个控制航天器操作调度的机载自动规划程序（Jonsson et al., 2000）。"
chap1_para257,2,,远程智能体根据地面指定的高级目标生成规划，并监控这些规划的执行（在出现问题时检测、诊断和恢复）。
chap1_para257,3,,"现在，Europa规划工具包（Barreiro et al., 2012）被用于NASA火星探测器的日常操作，而Sextant系统（Winternitz, 2017）允许航天器在全球GPS系统之外进行深空自主导航。"
chap1_para258,1,"•Two refinements to this simple idea are needed: first, the ability of any agent, human or otherwise, to choose rational actions is limited by the computational intractability of doing so; second, the concept of a machine that pursues a definite objective needs to be replaced with that of a machine pursuing objectives to benefit humans, but uncertain as to what those objectives are.","在1991年海湾危机期间，美国军队部署了动态分析和重新规划工具Dart（Cross and Walker, 1994），为运输进行自动化的后勤规划和调度。"
chap1_para258,2,,规划涉及的交通工具、货物和人员达5万之多，并且必须考虑起点、目的地、路线、运输能力、港口和机场能力以及解决所有参数之间的矛盾。
chap1_para258,3,,美国国防高级研究计划局（Defense Advanced Research Project Agency，DARPA）表示，这一应用取得的效果足以回报DARPA过去30年在人工智能领域的投资。
chap1_para259,1,"•Philosophers (going back to 400 BCE) made AI conceivable by suggesting that the mind is in some ways like a machine, that it operates on knowledge encoded in some internal language, and that thought can be used to choose what actions to take.",每天，优步（Uber）等网约车公司和谷歌地图等地图服务为数亿用户提供行车向导，在考虑当前和预测未来交通状况的基础上快速规划最佳路线。
chap1_para26,1,"In the early days of AI there was often confusion between the approaches. An author would argue that an algorithm performs well on a task and that it is therefore a good model of human performance, or vice versa. Modern authors separate the two kinds of claims; this distinction has allowed both AI and cognitive science to develop more rapidly. The two fields fertilize each other, most notably in computer vision, which incorporates neurophysiological evidence into computational models. Recently, the combination of neuroimaging methods combined with machine learning techniques for analyzing such data has led to the beginnings of a capability to “read minds”—that is, to ascertain the semantic content of a person’s inner thoughts. This capability could, in turn, shed further light on how human cognition works.",● 大脑成像（brain imaging）——观察大脑的活动。
chap1_para260,1,"•Mathematicians provided the tools to manipulate statements of logical certainty as well as uncertain, probabilistic statements. They also set the groundwork for understanding computation and reasoning about algorithms.",机器翻译：在线机器翻译系统现在可以阅读超过100种语言的文档，涵盖99%的人类使用的母语，每天为数亿用户翻译数千亿词语。
chap1_para260,2,,虽然翻译结果还不完美，但通常足以理解。
chap1_para260,3,,"对于具有大量训练数据的密切相关的语言（如法语和英语），在特定领域内的翻译效果已经接近于人类的水平（Wu et al., 2016b）。"
chap1_para261,1,•Economists formalized the problem of making decisions that maximize the expected utility to the decision maker.,"语音识别：2017年，微软表示其会话语音识别系统的单词错误率已降至5.1%，与人类在Switchboard任务（转录电话对话）中的表现相当（Xiong et al., 2017）。"
chap1_para261,2,,现在全世界大约三分之一的计算机交互是通过语音而不是键盘完成的，另外Skype提供了10种语言的实时语音翻译。
chap1_para261,3,,Alexa、Siri、Cortana和谷歌都提供了可以回答用户问题和执行任务的助手。
chap1_para261,4,,例如，谷歌Duplex服务使用语音识别和语音合成为用户预订餐厅，它能够代表用户进行流畅的对话。
chap1_para262,1,•Neuroscientists discovered some facts about how the brain works and the ways in which it is similar to and different from computers.,推荐：Amazon、Facebook、Netflix、Spotify、YouTube、Walmart等公司利用机器学习技术，根据用户过去的经历和其他类似的人群为用户推荐可能喜欢的内容。
chap1_para262,2,,"推荐系统领域有着悠久的历史（Resnick and Varian, 1997），但由于分析内容（文本、音乐、视频）以及历史和元数据的新深度学习方法的出现，推荐系统正在迅速发生变化（van den Oord et al., 2014; Zhang et al., 2017）。"
chap1_para262,3,,垃圾邮件过滤也可以被认为是推荐（或不推荐）的一种形式。
chap1_para262,4,,目前的人工智能技术可以过滤掉99.9%以上的垃圾邮件，电子邮件服务还可以推荐潜在收件人以及可能回复的文本。
chap1_para263,1,•Psychologists adopted the idea that humans and animals can be considered information-processing machines. Linguists showed that language use fits into this model.,博弈：1997年，当“深蓝”（Deep Blue）击败国际象棋世界冠军加里·卡斯帕罗夫（Garry Kasparov）后，人类霸权的捍卫者把希望寄托在了围棋上。
chap1_para263,2,,当时，天体物理学家、围棋爱好者皮特·赫特（Piet Hut）预测称：“计算机在围棋上击败人类需要一百年的时间（甚至可能更久）。
chap1_para263,3,,"”但仅仅20年后，AlphaGo就超过了所有人类棋手（Silver et al., 2017）。"
chap1_para263,4,,世界冠军柯洁说：“去年的AlphaGo还比较接近于人，现在它越来越像围棋之神。
chap1_para263,5,,”AlphaGo得益于对人类棋手过去数十万场棋局的研究以及对团队中围棋专家的知识提炼。
chap1_para264,1,"•Computer engineers provided the ever-more-powerful machines that make AI applications possible, and software engineers made them more usable.","后继项目AlphaZero不再借助人类输入，只通过游戏规则就能够自我学习并击败所有对手，在围棋、国际象棋和日本将棋领域击败了包括人类和机器在内的对手（Silver et al., 2018）。"
chap1_para264,2,,"与此同时，人类冠军在各种游戏中被人工智能系统击败，包括《危险边缘》（Ferrucci et al., 2010）、扑克（Bowling et al., 2015; Moravčík et al., 2017; Brown and Sandholm, 2019），以及电子游戏《刀塔2》（Fernandez and Mahlmann, 2018）、《星际争霸II》（Vinyals et al., 2019）、《雷神之锤3》（Jaderberg et al., 2019）。"
chap1_para265,1,"•Control theory deals with designing devices that act optimally on the basis of feedback from the environment. Initially, the mathematical tools of control theory were quite different from those used in AI, but the fields are coming closer together.",图像理解：计算机视觉研究人员不再满足于在具有挑战性的ImageNet物体识别任务上超越人类的准确性，他们开始研究更困难的图像描述问题。
chap1_para265,2,,"一些令人印象深刻的例子包括“一个人在土路上骑摩托车”“两个比萨饼放在炉顶的烤箱上”和“一群年轻人在玩飞盘”（Vinyals et al., 2017b）。"
chap1_para265,3,,然而，目前的系统还远远不够完善，一个“装满大量食物和饮料的冰箱”原来是一个被许多小贴纸遮挡住部分的禁止停车的标志。
chap1_para266,1,"•The history of AI has had cycles of success, misplaced optimism, and resulting cutbacks in enthusiasm and funding. There have also been cycles of introducing new, creative approaches and systematically refining the best ones.",医学：现在，人工智能算法在多种疾病的诊断方面（尤其是基于图像的诊断）已经达到或超过了专家医生的水平。
chap1_para266,2,,"例如，对阿尔茨海默病（Ding et al., 2018）、转移性癌症（Liu et al., 2017; Esteva et al., 2017）、眼科疾病（Gulshan et al., 2016）和皮肤病（Liu et al., 2019c)的诊断。"
chap1_para266,3,,"一项系统回顾和汇总分析（Liu et al., 2019a）发现，人工智能程序的平均表现与医疗保健专业人员相当。"
chap1_para266,4,,目前医疗人工智能的重点之一是促进人机合作。
chap1_para266,5,,"例如，Lyna系统在诊断转移性乳腺癌方面达到了99.6%的总体准确性，优于独立的人类专家，但两者联合的效果仍然会更好（Liu et al., 2018; Steiner et al., 2018）。"
chap1_para267,1,"•AI has matured considerably compared to its early decades, both theoretically and methodologically. As the problems that AI deals with became more complex, the field moved from Boolean logic to probabilistic reasoning, and from hand-crafted knowledge to machine learning from data. This has led to improvements in the capabilities of real systems and greater integration with other disciplines.","目前，限制这些技术推广的不是诊断准确性，而是需要证明临床结果的改善，并确保透明度、无偏见和数据隐私（Topol, 2019）。"
chap1_para267,2,,2017年，只有两项医疗人工智能应用获得FDA批准，但这一数字在2018年增至12项，并在持续上升。
chap1_para268,1,"•As AI systems find application in the real world, it has become necessary to consider a wide range of risks and ethical consequences.",气候科学：一个科学家团队凭借深度学习模型获得了2018年戈登·贝尔奖，该模型发现了之前隐藏在气候数据中的极端天气事件的详细信息。
chap1_para268,2,,"他们使用了一台具有专用GPU硬件，运算性能超过exaop级别（每秒1018次运算）的超级计算机，这是第一个实现这一目标的机器学习程序（Kurth et al., 2018）。"
chap1_para268,3,,"Rolnick等人（Rolnick et al., 2019）提供了一个60页的目录，其中列举了机器学习可用于应对气候变化的方式。"
chap1_para269,1,"•In the longer term, we face the difficult problem of controlling superintelligent AI systems that may evolve in unpredictable ways. Solving this problem seems to necessitate a change in our conception of AI.",这些只是几个目前存在的人工智能系统的例子。
chap1_para269,2,,这不是魔法或科幻小说，而是科学、工程和数学，本书将对此进行介绍。
chap1_para27,1,1.1.3Thinking rationally: The “laws of thought” approach,一旦我们有了足够精确的心智理论，就有可能把这个理论表达为计算机程序。
chap1_para27,2,,如果程序的输入/输出行为与相应的人类行为相匹配，那就表明程序的某些机制也可能在人类中存在。
chap1_para270,1,Bibliographical and Historical Notes,1.5　人工智能的风险和收益
chap1_para271,1,"A comprehensive history of AI is given by Nils Nilsson (2009), one of the early pioneers of the field.",弗朗西斯·培根是一位被誉为创造科学方法的哲学家，他在《论古人的智慧》（The Wisdom of the Ancients）（1609）一书中指出：“机械艺术的用途是模糊的，它既可用于治疗，也可用于伤害。
chap1_para271,2,"Pedro Domingos (2015) and Melanie Mitchell (2019) give overviews of machine learning for a general audience, and Kai-Fu Lee (2018) describes the race for international leadership in AI.",”随着人工智能在经济、社会、科学、医疗、金融和军事领域发挥越来越重要的作用，我们应该考虑一下它可能带来的伤害和补救措施——用现代的说法，就是风险和收益。
chap1_para271,3,Martin Ford (2018) interviews 23 leading AI researchers.,这里总结的话题在第27章和第28章中有更深入的讨论。
chap1_para272,1,"The main professional societies for AI are the Association for the Advancement of Artificial Intelligence (AAAI), the ACM Special Interest Group in Artificial Intelligence (SIGAI, formerly SIGART), the European Association for AI, and the Society for Artificial Intelligence and Simulation of Behaviour (AISB). The Partnership on AI brings together many commercial and nonprofit organizations concerned with the ethical and social impacts of AI. AAAI’s AI Magazine contains many topical and tutorial articles, and its Web site, aaai.org, contains news, tutorials, and background information.",首先从收益说起。
chap1_para272,2,,简而言之，我们的整个文明是人类智慧的产物。
chap1_para272,3,,如果我们有机会获得更强大的机器智能，我们的理想上限就会大大提高。
chap1_para272,4,,人工智能和机器人技术可以将人类从繁重的重复性工作中解放出来，并大幅增加商品和服务的生产，这可能预示着一个和平富足的时代的到来。
chap1_para272,5,,加速科学研究的能力可以治愈疾病，并解决气候变化和资源短缺问题。
chap1_para272,6,,正如谷歌DeepMind首席执行官德米斯·哈萨比斯（Demis Hassabis）所建议的那样：“首先解决人工智能问题，然后再用人工智能解决其他所有问题。
chap1_para272,7,,”
chap1_para273,1,"The most recent work appears in the proceedings of the major AI conferences: the International Joint Conference on AI (IJCAI), the annual European Conference on AI (ECAI), and the AAAI Conference.",然而，早在我们有机会“解决人工智能”之前，我们就会因误用人工智能而招致风险，无论这是无意的还是其他原因。
chap1_para273,2,Machine learning is covered by the International Conference on Machine Learning and the Neural Information Processing Systems (NeurIPS) meeting.,其中一些风险已经很明显，而另一些似乎基于当前趋势。
chap1_para273,3,"The major journals for general AI are Artificial Intelligence, Computational Intelligence, the IEEE Transactions on Pattern Analysis and Machine Intelligence, IEEE Intelligent Systems, and the Journal of Artificial Intelligence Research.",
chap1_para273,4,"There are also many conferences and journals devoted to specific areas, which we cover in the appropriate chapters.",
chap1_para274,1,"1In the public eye, there is sometimes confusion between the terms “artificial intelligence” and “machine learning.” Machine learning is a subfield of AI that studies the ability to improve performance based on experience. Some AI systems use machine learning methods to achieve competence, but some do not.",● 致命性自主武器：联合国将其定义为无须人工干预即可定位、选择并击杀人类目标的武器。
chap1_para274,2,,这种武器的一个主要问题在于它们的可扩展性——不需要人类监督意味着一小群人就可以部署任意数量的武器，并且这些武器的打击目标可以是通过任何可行的识别准则来定义的人类。
chap1_para274,3,,自主武器所需的技术类似于自动驾驶汽车所需的技术。
chap1_para274,4,,关于致命性自主武器潜在风险的非正式专家讨论始于2014年的联合国会议，并于2017年进入正式的官方专家组的条约审议阶段。
chap1_para275,1,2We are not suggesting that humans are “irrational” in the dictionary sense of “deprived of normal mental clarity.” We are merely conceding that human decisions are not always mathematically perfect.,● 监视和劝诱：安全人员监视电话线路、视频摄像头、电子邮件和其他消息渠道的代价昂贵、乏味且存在法律问题，但可以以一种可扩展的方式使用人工智能（语音识别、计算机视觉、自然语言理解）对个人进行大规模监视并检测感兴趣的活动。
chap1_para275,2,,基于机器学习技术，通过社交媒体为个人量身定制信息流，可以在一定程度上修改和控制政治行为，这一问题在2016年开始的美国总统选举中变得显而易见。
chap1_para276,1,"3In one of the first books on chess, Ruy Lopez (1561) wrote, “Always place the board so the sun is in your opponent’s eyes.”",● 有偏决策：在评估假释和贷款申请等任务中，粗心或故意滥用机器学习算法可能会导致因种族、性别或其他受保护类别而产生有偏见的决策。
chap1_para276,2,,通常，数据本身反映了社会中普遍存在的偏见。
chap1_para277,1,"4The Novum Organum is an update of Aristotle’s Organon, or instrument of thought.",● 就业影响：关于机器会减少工作岗位的担忧由来已久。
chap1_para277,2,,故事从来都不是简单的。
chap1_para277,3,,机器能够完成一些人类可能会做的工作，但它们也让人类更有生产力，因此更适合被雇佣；让公司更具盈利能力，因此能够支付更高的工资。
chap1_para277,4,,它们可能使一些本来不切实际的活动在经济上可行。
chap1_para277,5,,它们的使用通常会导致财富增加，但往往会将财富从劳动力向资本转移，从而进一步加剧不平等。
chap1_para277,6,,之前的技术进步（如机械织布机的发明），对就业造成了严重的影响，但最终人们还是找到了新的工作。
chap1_para277,7,,另外，人工智能也有可能从事这些新的工作。
chap1_para277,8,,这个话题正迅速成为世界各地经济学家和政府关注的焦点。
chap1_para278,1,5Frege’s proposed notation for first-order logic—an arcane combination of textual and geometric features—never became popular.,● 安全关键的应用：随着人工智能技术的进步，它们越来越多地应用于高风险、安全关键的应用，如驾驶汽车和管理城市供水。
chap1_para278,2,,已经发生过致命事故，这凸显了对使用机器学习技术开发的系统进行正式验证和统计风险分析的困难。
chap1_para278,3,,人工智能领域需要制定技术和道德标准，至少要与其他工程和医疗领域中普遍存在的标准相当，而这些标准关乎人们的生命。
chap1_para279,1,6It has since been discovered that the tree shrew and some bird species exceed the human brain/body ratio.,● 网络安全：人工智能技术可用于防御网络攻击，如检测异常的行为模式，但这些技术也能用于增强恶意软件的威力、生存能力和扩散能力。
chap1_para279,2,,例如，强化学习方法已被用于创建高效的工具，这些工具可以进行自动化、个性化的勒索和钓鱼攻击。
chap1_para28,1,"The Greek philosopher Aristotle was one of the first to attempt to codify “right thinking”—that is, irrefutable reasoning processes. His syllogisms provided patterns for argument structures that always yielded correct conclusions when given correct premises. The canonical example starts with Socrates is a man and all men are mortal and concludes that Socrates is mortal. (This example is probably due to Sextus Empiricus rather than Aristotle.) These laws of thought were supposed to govern the operation of the mind; their study initiated the field called logic.","例如，开发通用问题求解器（General Problem Solver，GPS）的艾伦·纽厄尔（Alan Newell）和赫伯特·西蒙（Herbert Simon）并不仅仅满足于让他们的程序正确地求解问题，他们更关心的是将推理步骤的顺序和时机与求解相同问题的人类测试者进行比较（Newell and Simon, 1961）。"
chap1_para28,2,,认知科学（cognitive science）这一跨学科领域汇集了人工智能的计算机模型和心理学的实验技术，用以构建精确且可测试的人类心智理论。
chap1_para280,1,7Many cite Alexander Hood (1824) as a possible prior source.,我们将在27.3节更深入地讨论这些主题。
chap1_para280,2,,随着人工智能系统变得越来越强大，它们将更多承担以前由人类扮演的社会角色。
chap1_para280,3,,正如人类过去曾利用这些角色作恶一样，可以预见，人类可能会在这些角色中滥用人工智能系统而作恶更多。
chap1_para280,4,,上面给出的所有例子都指出了治理的重要性，以及最终监管的重要性。
chap1_para280,5,,目前，研究团体和参与人工智能研究的主要公司已经为人工智能相关活动制定了自愿自治原则（见27.3节）。
chap1_para280,6,,各国政府和国际组织正在设立咨询机构，为每个具体的用例制定适当的条例，准备应对经济和社会影响，并利用人工智能的能力来解决重大的社会问题。
chap1_para281,1,"8Golgi persisted in his belief that the brain’s functions were carried out primarily in a continuous medium in which neurons were embedded, whereas Cajal propounded the “neuronal doctrine.” The two shared the Nobel Prize in 1906 but gave mutually antagonistic acceptance speeches.",长期来看呢？
chap1_para281,2,,我们能否实现长期以来的目标：创造出与人类智力相当或更强大的智能？
chap1_para281,3,,如果我们做到了，然后呢？
chap1_para282,1,9A complex machine named after a British cartoonist who depicted whimsical and absurdly complicated contraptions for everyday tasks such as buttering toast.,在人工智能的大部分历史上，这些问题都被日常工作所掩盖——让人工智能系统做任何事情，哪怕是远程智能。
chap1_para282,2,,与任何广泛的学科一样，绝大多数人工智能研究人员专注于特定的子领域，例如博弈、知识表示、视觉或自然语言理解，通常假设这些子领域的进展将有助于实现更广泛的人工智能目标。
chap1_para282,3,,"尼尔斯·约翰·尼尔森（Nils John Nilsson）（Nilsson, 1995）作为SRI的Shakey项目的最初负责人之一，提醒了该领域那些更广泛的目标，并警告说这些子领域本身有成为目标的风险。"
chap1_para282,4,,"后来，一些有影响力的人工智能创始人，包括约翰·麦卡锡（McCarthy, 2007）、马文·明斯基（Minsky, 2007）和帕特里克·温斯顿（Beal and Winston, 2009），都认同尼尔森的警告，认为人工智能应该回归其本源，而不是专注于具体应用中可衡量的性能，用赫伯特·西蒙的话来说就是“会思考、会学习、会创造的机器”。"
chap1_para282,5,,他们将这种努力方向称为人类级别的人工智能（human-level AI，HLAI）——机器应该能够学会做人类可以做到的任何事情。
chap1_para282,6,,"他们在2004年召开了第一次研讨会（Minsky et al., 2004）。"
chap1_para282,7,,"另一个有着类似目标的工作是通用人工智能（artificial general Intelligence，AGI）运动（Goertzel and Pennachin, 2007），在2008年举行了第一次会议并组织出版了The Journal of Artificial General Intelligence。"
chap1_para283,1,"10In the postwar period, Turing wanted to use these computers for AI research—for example, he created an outline of the first chess program (Turing et al., 1953)—but the British government blocked this research.","大约在同一时间，人们担心创造远远超过人类能力的超级人工智能（artificial superintelligence，ASI）可能是个坏主意（Yudkowsky, 2008; Omohundro, 2008）。"
chap1_para283,2,,"图灵（Turing, 1996）在1951年曼彻斯特的一场演讲中也提出了同样的观点，他借鉴了塞缪尔·巴特勒（Samuel Butler）（Butler, 1863）的早期观点：[21]"
chap1_para284,1,11Now Carnegie Mellon University (CMU).,
chap1_para285,1,"12This was the first official usage of McCarthy’s term artificial intelligence. Perhaps “computational rationality” would have been more precise and less threatening, but “AI” has stuck. At the 50th anniversary of the Dartmouth conference, McCarthy stated that he resisted the terms “computer” or “computational” in deference to Norbert Wiener, who was promoting analog cybernetic devices rather than digital computers.",[21]　甚至在更早的1847年，《原始解释者》（Primitive Expounder）的编辑理查德·桑顿（Richard Thornton）就对机械计算器大加抨击：“思想……超越自身，并通过发明机器进行自我思考来消除自身存在的必要性……但是谁知道，当这种机器变得更加完美的时候，它会不会想出一个规划来弥补自己的所有缺陷，然后想出超出常人所能理解的思想！
chap1_para285,2,,”
chap1_para286,1,"13Newell and Simon also invented a list-processing language, IPL, to write LT.",似乎很可能，机器思维方法一旦开始，用不了多久它就会超越我们微弱的力量……因此，在某个阶段，我们应该需要期待机器能够受控制，就像塞缪尔·巴特勒在Erewhon中所提到的那样。
chap1_para286,2,They had no compiler and translated it into machine code by hand.,
chap1_para286,3,"To avoid errors, they worked in parallel, calling out binary numbers to each other as they wrote each instruction to make sure they agreed.",
chap1_para287,1,"14Some have characterized this change as a victory of the neats—those who think that AI theories should be grounded in mathematical rigor—over the scruffies—those who would rather try out lots of ideas, write some programs, and then assess what seems to be working. Both approaches are important. A shift toward neatness implies that the held has reached a level of stability and maturity. The present emphasis on deep learning may represent a resurgence of the scruffies.",随着深度学习方面的最新进展，尼克·波斯特洛姆（Nick Bostrom）的《超级智能》（Superintelligence）（2014）等图书的出版，以及斯蒂芬·霍金（Stephen Hawking）、比尔·盖茨（Bill Gates）、马丁·里斯（Martin Rees）和埃隆·马斯克（Elon Musk）的公开声明，这些担忧只会变得更加普遍。
chap1_para288,1,"15Even earlier, in 1847, Richard Thornton, editor of the Primitive Expounder, railed against mechanical calculators: “Mind ... outruns itself and does away with the necessity of its own existence by inventing machines to do its own thinking. ... But who knows that such machines when brought to greater perfection, may not think of a plan to remedy all their own defects and then grind out ideas beyond the ken of mortal mind!”",对创造超级智能机器的想法产生普遍的不安感是自然的。
chap1_para288,2,,我们可以称之为大猩猩问题（gorilla problem）：大约700万年前，一种现已灭绝的灵长类进化了，一个分支进化为大猩猩，另一个分支进化为人类。
chap1_para288,3,,今天，大猩猩对人类分支不太满意，大猩猩根本无法控制自己的未来。
chap1_para288,4,,如果这是成功创造出超级人工智能的结果（人类放弃对未来的控制），那么我们也许应该停止人工智能的研究，并且作为一个必然的结果，放弃人工智能可能带来的好处。
chap1_para288,5,,这就是图灵警告的本质：我们可能无法控制比我们更聪明的机器。
chap1_para289,1,16Midas would have done better if he had followed basic principles of safety and included an “undo” button and a “pause” button in his wish.,如果超级人工智能是一个来自外太空的黑匣子，那么谨慎地打开这个黑匣子确实是明智之举。
chap1_para289,2,,但事实并非如此：我们设计了人工智能系统，所以如果它们最终“掌控了自己”，那将是设计失败的结果（正如图灵所说）。
chap1_para29,1,Logicians in the 19th century developed a precise notation for statements about objects in the world and the relations among them.,"认知科学本身是一个引人入胜的领域，值得用多本教科书和至少一部百科全书（Wilson and Keil, 1999）来介绍。"
chap1_para29,2,"(Contrast this with ordinary arithmetic notation, which provides only for statements about numbers.",我们会偶尔评论人工智能技术和人类认知之间的异同，但真正的认知科学必须建立在对人类或动物实验研究的基础上。
chap1_para29,3,") By 1965, programs could, in principle, solve any solvable problem described in logical notation.",这里，我们假设读者只有一台可以做实验的计算机，因此我们将把这方面的内容留给其他书籍。
chap1_para29,4,The so-called logicist tradition within artificial intelligence hopes to build on such programs to create intelligent systems.,
chap1_para290,1,INTELLIGENT AGENTS,为了避免这种结果，我们需要了解潜在失败的根源。
chap1_para290,2,,"诺伯特·维纳（Wiener, 1960）在看到亚瑟·塞缪尔的西洋跳棋程序学会下棋并打败其创造者后，开始考虑人工智能的长远未来，他说："
chap1_para291,1,"In which we discuss the nature of agents, perfect or otherwise, the diversity of environments, and the resulting menagerie of agent types.",如果我们为了达到目的而使用一个我们无法有效干预其运作方式的机械智能体……那么我们最好能完全确定设定给机器的目标是我们真正想要实现的。
chap1_para292,1,"Chapter 1 identified the concept of rational agents as central to our approach to artificial intelligence. In this chapter, we make this notion more concrete. We will see that the concept of rationality can be applied to a wide variety of agents operating in any imaginable environment. Our plan in this book is to use this concept to develop a small set of design principles for building successful agents—systems that can reasonably be called intelligent.",许多文化都有关于人类向神灵、精灵、魔术师或魔鬼索取东西的神话。
chap1_para292,2,,在这些故事中，他们总是得到了他们真正想要的东西并最终后悔。
chap1_para292,3,,如果还有第三个愿望的话，那就是撤销前两个。
chap1_para292,4,,我们将其称为迈达斯国王问题（King Midas problem）：迈达斯是希腊神话中的传奇国王，他要求他所接触的一切都变成黄金，但他在接触了他的食物、饮料和家人后，就后悔了。
chap1_para292,5,,[22]1.1.5节中我们已经提到过这个问题，将固定目标设定给机器的标准模型需要进行重大修改。
chap1_para292,6,,解决维纳困境的方法根本不是“给机器设定一个明确的目的”。
chap1_para292,7,,相反，我们希望机器努力实现人类的目标，但知道它们并不确切地知道这些目标是什么。
chap1_para293,1,"We begin by examining agents, environments, and the coupling between them. The observation that some agents behave better than others leads naturally to the idea of a rational agent—one that behaves as well as possible. How well an agent can behave depends on the nature of the environment; some environments are more difficult than others. We give a crude categorization of environments and show how properties of an environment influence the design of suitable agents for that environment. We describe a number of basic “skeleton” agent designs, which we flesh out in the rest of the book.",
chap1_para294,1,2.,[22]　如果迈达斯遵循基本的安全原则，并在他的愿望中包括“撤消”按钮和“暂停”按钮，他会过得更好。
chap1_para294,2,1Agents and Environments,
chap1_para295,1,"An agent is anything that can be viewed as perceiving its environment through sensors and acting upon that environment through actuators. This simple idea is illustrated in Figure 2.1. A human agent has eyes, ears, and other organs for sensors and hands, legs, vocal tract, and so on for actuators. A robotic agent might have cameras and infrared range finders for sensors and various motors for actuators. A software agent receives file contents, network packets, and human input (keyboard/mouse/touchscreen/voice) as sensory inputs and acts on the environment by writing files, sending network packets, and displaying information or generating sounds. The environment could be everything—the entire universe! In practice it is just that part of the universe whose state we care about when designing this agent—the part that affects what the agent perceives and that is affected by the agent’s actions.",遗憾的是，迄今为止，几乎所有的人工智能研究都是在标准模型下进行的，这意味着这版书中几乎所有的技术材料都反映了这一知识框架。
chap1_para295,2,,然而，在新框架内已经有一些初步成果。
chap1_para295,3,,在第16章中，我们指出，当且仅当机器对人类的目标不确定时，机器才有积极的动机允许自己关闭。
chap1_para295,4,,在第18章中，我们设计并研究辅助博弈（assistance game），它在数学上描述了一种情况，即人类有一个目标而机器试图实现它，但最初不确定目标是什么。
chap1_para295,5,,在第22章中，我们解释逆向强化学习（inverse reinforcement learning）的方法，它允许机器通过观察人类的选择来更多地了解人类的偏好。
chap1_para295,6,,在第27章中，我们探讨两个主要的困难：首先，我们的选择取决于我们的偏好，这是通过一个非常复杂、难以逆向的认知结构来实现的；其次，我们人类可能在一开始就没有一致的偏好（无论是作为个人还是作为一个群体），所以人工智能系统可能并不清楚应该为我们做什么。
chap1_para296,1,Description The block diagram starts with a block labeled Agent.,
chap1_para296,2,An unknown block marked with a question mark is shown inside the agent block.,
chap1_para296,3,An arrow from the sensors points to the unknown block.,
chap1_para296,4,An arrow from the unknown block points to the actuators.,
chap1_para296,5,"An arrow from the actuators points to a block labeled Environment, which is outside the agent block.",
chap1_para296,6,An arrow from the environment block points back to sensors in the agent block.,
chap1_para297,1,Figure 2.,本章定义了人工智能并阐述了其发展的文化背景。
chap1_para297,2,1Agents interact with environments through sensors and actuators.,本章要点如下。
chap1_para298,1,"We use the term percept to refer to the content an agent’s sensors are perceiving. An agent’s percept sequence is the complete history of everything the agent has ever perceived. In general, an agent’s choice of action at any given instant can depend on its built-in knowledge and on the entire percept sequence observed to date, but not on anything it hasn’t perceived. By specifying the agent’s choice of action for every possible percept sequence, we have said more or less everything there is to say about the agent. Mathematically speaking, we say that an agent’s behavior is described by the agent function that maps any given percept sequence to an action.",● 不同的人对人工智能的期望不同。
chap1_para298,2,,首先要问的两个重要问题是：你关心的是思想还是行为？
chap1_para298,3,,你想模拟人类，还是试图达到最佳结果？
chap1_para299,1,"We can imagine tabulating the agent function that describes any given agent; for most agents, this would be a very large table—infinite, in fact, unless we place a bound on the length of percept sequences we want to consider. Given an agent to experiment with, we can, in principle, construct this table by trying out all possible percept sequences and recording which actions the agent does in response.1 The table is, of course, an external characterization of the agent. Internally, the agent function for an artificial agent will be implemented by an agent program. It is important to keep these two ideas distinct. The agent function is an abstract mathematical description; the agent program is a concrete implementation, running within some physical system.",● 根据我们所说的标准模型，人工智能主要关注理性行为。
chap1_para299,2,,理想的智能体会在某种情况下采取可能的最佳行为，在这个意义下，我们研究了智能体的构建问题。
chap1_para3,1,"Surveys regularly rank AI as one of the most interesting and fastest-growing fields, and it is already generating over a trillion dollars a year in revenue. AI expert Kai-Fu Lee predicts that its impact will be “more than anything in the history of mankind.” Moreover, the intellectual frontiers of AI are wide open. Whereas a student of an older science such as physics might feel that the best ideas have already been discovered by Galileo, Newton, Curie, Einstein, and the rest, AI still has many openings for full-time masterminds.",人工智能经常被各种调查列为最有趣、发展最快的领域之一，现在每年创造的价值超过一万亿美元。
chap1_para3,2,,人工智能专家李开复预测称，人工智能对世界的影响“将超过人类历史上的任何事物”。
chap1_para3,3,,此外，人工智能的研究前沿仍是开放的。
chap1_para3,4,,学习较古老科学（如物理学）的学生可能会认为最好的想法都已经被伽利略、牛顿、居里夫人、爱因斯坦等人发现了，但当下人工智能仍然为专业人员提供了许多机会。
chap1_para30,1,"Logic as conventionally understood requires knowledge of the world that is certain—a condition that, in reality, is seldom achieved. We simply don’t know the rules of, say, politics or warfare in the same way that we know the rules of chess or arithmetic. The theory of probability fills this gap, allowing rigorous reasoning with uncertain information. In principle, it allows the construction of a comprehensive model of rational thought, leading from raw perceptual information to an understanding of how the world works to predictions about the future. What it does not do, is generate intelligent behavior. For that, we need a theory of rational action. Rational thought, by itself, is not enough.",在人工智能发展的早期，这两种方法经常会混淆。
chap1_para30,2,,有作者认为，如果算法在某个任务中表现良好，就会是建模人类表现的良好模型，反之亦然。
chap1_para30,3,,而现代作者将这两种主张分开，这种区分使人工智能和认知科学都得到了更快的发展。
chap1_para30,4,,这两个领域相互促进，值得一提的是计算机视觉领域，它将神经生理学证据整合到了计算模型中。
chap1_para30,5,,最近，将神经影像学方法与分析数据的机器学习技术相结合，开启了“读心”能力（即查明人类内心思想的语义内容）的研究。
chap1_para30,6,,这种能力反过来可以进一步揭示人类认知的运作方式。
chap1_para300,1,"To illustrate these ideas, we use a simple example—the vacuum-cleaner world, which consists of a robotic vacuum-cleaning agent in a world consisting of squares that can be either dirty or clean. Figure 2.2 shows a configuration with just two squares, A and B. The vacuum agent perceives which square it is in and whether there is dirt in the square. The agent starts in square A. The available actions are to move to the right, move to the left, suck up the dirt, or do nothing.2 One very simple agent function is the following: if the current square is dirty, then suck; otherwise, move to the other square. A partial tabulation of this agent function is shown in Figure 2.3 and an agent program that implements it appears in Figure 2.8 on page 67.",● 这个简单的想法需要两个改进：首先，任何智能体（无论是人还是其他物体）选择理性行为的能力都受到决策计算难度的限制；其次，机器的概念需要从追求明确目标转变到追求目标以造福人类，虽然不确定这些目标是什么。
chap1_para301,1,"Description A robotic vacuum-cleaning agent and dirt are shown in block ""A"".",● 哲学家们（追溯到公元前400年）暗示大脑在某些方面就像一台机器，操作用某种内部语言编码的知识，并且这种思维可以用来选择要采取的行动，从而认为人工智能是有可能实现的。
chap1_para301,2,Dirt is shown in block B.,
chap1_para302,1,Figure 2.,● 数学家提供了运算逻辑的确定性陈述以及不确定的概率陈述的工具，也为理解计算和算法推理奠定了基础。
chap1_para302,2,2A vacuum-cleaner world with just two locations.,
chap1_para302,3,"Each location can be clean or dirty, and the agent can move left or right and can clean the square that it occupies.",
chap1_para302,4,"Different versions of the vacuum world allow for different rules about what the agent can perceive, whether its actions always succeed, and so on.",
chap1_para303,1,Looking at Figure 2.,● 经济学家将决策问题形式化，使决策者的期望效用最大化。
chap1_para303,2,"3, we see that various vacuum-world agents can be defined simply by filling in the right-hand column in various ways.",
chap1_para303,3,"The obvious question, then, is this: What is the right way to fill out the table?",
chap1_para303,4,"In other words, what makes an agent good or bad, intelligent or stupid?",
chap1_para303,5,We answer these questions in the next section.,
chap1_para304,1,Description The block diagram starts with a block labeled Agent.,● 神经科学家发现了一些关于大脑如何工作的事实，以及大脑与计算机的相似和不同之处。
chap1_para304,2,Three blocks are shown inside the Agent block.,
chap1_para304,3,"The first block inside the agent block is labeled, What the world is like now.",
chap1_para304,4,"An arrow from the first block points to the second block labeled, What action I should do now.",
chap1_para304,5,The third block is labeled Condition action rules and an arrow from the third block points to the second block.,
chap1_para304,6,An arrow from the second block points to the Actuators.,
chap1_para304,7,"An arrow from the actuators points to a block labeled Environment, which is outside the agent block.",
chap1_para304,8,An arrow from the environment block points to the sensors in the Agent block.,
chap1_para304,9,An arrow from the sensors points back to the first block.,
chap1_para305,1,Figure 2.,● 心理学家采纳了人类和动物可以被视为信息处理机器的观点。
chap1_para305,2,3Partial tabulation of a simple agent function for the vacuum-cleaner world shown in Figure 2.,语言学家指出，语言的使用符合这一模式。
chap1_para305,3,2.,
chap1_para305,4,"The agent cleans the current square if it is dirty, otherwise it moves to the other square.",
chap1_para305,5,Note that the table is of unbounded size unless there is a restriction on the length of possible percept sequences.,
chap1_para306,1,"Before closing this section, we should emphasize that the notion of an agent is meant to be a tool for analyzing systems, not an absolute characterization that divides the world into agents and non-agents. One could view a hand-held calculator as an agent that chooses the action of displaying “4” when given the percept sequence “2 + 2 =,” but such an analysis would hardly aid our understanding of the calculator. In a sense, all areas of engineering can be seen as designing artifacts that interact with the world; AI operates at (what the authors consider to be) the most interesting end of the spectrum, where the artifacts have significant computational resources and the task environment requires nontrivial decision making.",● 计算机工程师提供了更加强大的机器，使人工智能应用成为可能，而软件工程师使它们更加易用。
chap1_para307,1,2.,● 控制理论涉及在环境反馈的基础上设计最优行为的设备。
chap1_para307,2,2Good Behavior: The Concept of Rationality,最初，控制理论的数学工具与人工智能中使用的大不相同，但这两个领域越来越接近。
chap1_para308,1,A rational agent is one that does the right thing.,● 人工智能的历史经历了成功、盲目乐观以及由此导致的热情丧失和资金削减的循环，也存在引入全新创造性的方法和系统地改进最佳方法的循环。
chap1_para308,2,"Obviously, doing the right thing is better than doing the wrong thing, but what does it mean to do the right thing?",
chap1_para309,1,2.,● 与最初的几十年相比，人工智能在理论和方法上都已经相当成熟。
chap1_para309,2,2.,随着人工智能面对的问题变得越来越复杂，该领域从布尔逻辑转向概率推理，从手工编码知识转向基于数据的机器学习。
chap1_para309,3,1Performance measures,这推动了真实系统功能的改进以及与其他学科更大程度的集成。
chap1_para31,1,1.,1.1.3　理性思考：“思维法则”方法
chap1_para31,2,1.,
chap1_para31,3,4Acting rationally: The rational agent approach,
chap1_para310,1,"Moral philosophy has developed several different notions of the “right thing,” but AI has generally stuck to one notion called consequentialism: we evaluate an agent’s behavior by its consequences. When an agent is plunked down in an environment, it generates a sequence of actions according to the percepts it receives. This sequence of actions causes the environment to go through a sequence of states. If the sequence is desirable, then the agent has performed well. This notion of desirability is captured by a performance measure that evaluates any given sequence of environment states.",● 随着人工智能系统在真实世界中的应用，必须考虑各种风险和道德后果。
chap1_para311,1,"Humans have desires and preferences of their own, so the notion of rationality as applied to humans has to do with their success in choosing actions that produce sequences of environment states that are desirable from their point of view. Machines, on the other hand, do not have desires and preferences of their own; the performance measure is, initially at least, in the mind of the designer of the machine, or in the mind of the users the machine is designed for. We will see that some agent designs have an explicit representation of (a version of) the performance measure, while in other designs the performance measure is entirely implicit—the agent may do the right thing, but it doesn’t know why.",● 从长远来看，我们面临着控制超级智能的人工智能系统的难题，它们可能以不可预测的方式进化。
chap1_para311,2,,解决这个问题似乎需要改变我们对人工智能的设想。
chap1_para312,1,"Recalling Norbert Wiener’s warning to ensure that “the purpose put into the machine is the purpose which we really desire” (page 51), notice that it can be quite hard to formulate a performance measure correctly. Consider, for example, the vacuum-cleaner agent from the preceding section. We might propose to measure performance by the amount of dirt cleaned up in a single eight-hour shift. With a rational agent, of course, what you ask for is what you get. A rational agent can maximize this performance measure by cleaning up the dirt, then dumping it all on the floor, then cleaning it up again, and so on. A more suitable performance measure would reward the agent for having a clean floor. For example, one point could be awarded for each clean square at each time step (perhaps with a penalty for electricity consumed and noise generated). As a general rule, it is better to design performance measures according to what one actually wants to be achieved in the environment, rather than according to how one thinks the agent should behave.",
chap1_para313,1,"Even when the obvious pitfalls are avoided, some knotty problems remain. For example, the notion of “clean floor” in the preceding paragraph is based on average cleanliness over time. Yet the same average cleanliness can be achieved by two different agents, one of which does a mediocre job all the time while the other cleans energetically but takes long breaks. Which is preferable might seem to be a fine point of janitorial science, but in fact it is a deep philosophical question with far-reaching implications. Which is better—a reckless life of highs and lows, or a safe but humdrum existence? Which is better—an economy where everyone lives in moderate poverty, or one in which some live in plenty while others are very poor? We leave these questions as an exercise for the diligent reader.",微信扫码关注【异步社区】微信公众号，回复“e59810”获取本书配套资源以及异步社区15天VIP会员卡，近千本电子书免费畅读。
chap1_para314,1,"For most of the book, we will assume that the performance measure can be specified correctly. For the reasons given above, however, we must accept the possibility that we might put the wrong purpose into the machine—precisely the King Midas problem described on page 51. Moreover, when designing one piece of software, copies of which will belong to different users, we cannot anticipate the exact preferences of each individual user. Thus, we may need to build agents that reflect initial uncertainty about the true performance measure and learn more about it as time goes by; such agents are described in Chapters 15, 17, and 23.",
chap1_para315,1,2.,我们在此讨论智能体的本质，完美的或不完美的、环境的多样性以及由此产生的智能体类型的集合。
chap1_para315,2,2.,
chap1_para315,3,2Rationality,
chap1_para316,1,What is rational at any given time depends on four things:,第1章将理性智能体（rational agent）的概念确定为研究人工智能的方法的核心。
chap1_para316,2,,本章将使这个概念更加具体。
chap1_para316,3,,我们将看到，在任何可以想象的环境中运行的各种智能体都可以应用理性的概念。
chap1_para316,4,,本书的计划是使用这个概念来制定一小组设计原则，并用于构建成功的智能体，可以合理地称之为智能系统。
chap1_para317,1,•The performance measure that defines the criterion of success.,我们从检查智能体、环境以及它们之间的耦合开始。
chap1_para317,2,,观察到某些智能体比其他智能体表现得更好，可以自然而然地引出理性智能体的概念，即行为尽可能好。
chap1_para317,3,,智能体的行为取决于环境的性质。
chap1_para317,4,,我们将对环境进行粗略分类，并展示环境的属性如何影响智能体的设计。
chap1_para317,5,,我们描述一些基本的“框架”智能体设计，本书余下的部分将充实相关内容。
chap1_para318,1,•The agent’s prior knowledge of the environment.,2.1　智能体和环境
chap1_para319,1,•The actions that the agent can perform.,任何通过传感器（sensor）感知环境（environment）并通过执行器（actuator）作用于该环境的事物都可以被视为智能体（agent）。
chap1_para319,2,,这个简单的想法如图2-1所示。
chap1_para319,3,,一个人类智能体以眼睛、耳朵和其他器官作为传感器，以手、腿、声道等作为执行器。
chap1_para319,4,,机器人智能体可能以摄像头和红外测距仪作为传感器，还有各种电动机作为执行器。
chap1_para319,5,,软件智能体接收文件内容、网络数据包和人工输入（键盘/鼠标/触摸屏/语音）作为传感输入，并通过写入文件、发送网络数据包、显示信息或生成声音对环境进行操作。
chap1_para319,6,,环境可以是一切，甚至是整个宇宙！
chap1_para319,7,,实际上，我们在设计智能体时关心的只是宇宙中某一部分的状态，即影响智能体感知以及受智能体动作影响的部分。
chap1_para32,1,"An agent is just something that acts (agent comes from the Latin agere, to do).",希腊哲学家亚里士多德是最早试图法则化“正确思维”的人之一，他将其定义为无可辩驳的推理过程。
chap1_para32,2,"Of course, all computer programs do something, but computer agents are expected to do more: operate autonomously, perceive their environment, persist over a prolonged time period, adapt to change, and create and pursue goals.",他的三段论（syllogism）为论证结构提供了模式，当给出正确的前提时，总能得出正确的结论。
chap1_para32,3,"A rational agent is one that acts so as to achieve the best outcome or, when there is uncertainty, the best expected outcome.",举个经典的例子，当给出前提苏格拉底是人和所有人都是凡人时，可以得出结论苏格拉底是凡人。
chap1_para32,4,,［这个例子可能是塞克斯都·恩披里柯（Sextus Empiricus）提出的而不是亚里士多德提出的。
chap1_para32,5,,］这些思维法则被认为支配着思想的运作，他们的研究开创了一个称为逻辑（logic）的领域。
chap1_para320,1,•The agent’s percept sequence to date.,图2-1　智能体通过传感器和执行器与环境交互
chap1_para321,1,This leads to a definition of a rational agent:,我们使用术语感知（percept）来表示智能体的传感器正在感知的内容。
chap1_para321,2,,智能体的感知序列（percept sequence）是智能体所感知的一切的完整历史。
chap1_para321,3,,一般而言，一个智能体在任何给定时刻的动作选择可能取决于其内置知识和迄今为止观察到的整个感知序列，而不是它未感知到的任何事物。
chap1_para321,4,,通过为每个可能的感知序列指定智能体的动作选择，我们或多或少地说明了关于智能体的所有内容。
chap1_para321,5,,从数学上讲，我们说智能体的行为由智能体函数（agent function）描述，该函数将任意给定的感知序列映射到一个动作。
chap1_para322,1,"For each possible percept sequence, a rational agent should select an action that is expected to maximize its performance measure, given the evidence provided by the percept sequence and whatever built-in knowledge the agent has.",可以想象将描述任何给定智能体的智能体函数制成表格。
chap1_para322,2,,对大多数智能体来说，这将是一个非常大的表，事实上是无限的（除非限制考虑的感知序列长度）。
chap1_para322,3,,给定一个要进行实验的智能体，原则上，我们可以通过尝试所有可能的感知序列并记录智能体响应的动作来构建此表[1]。
chap1_para322,4,,当然，该表只是该智能体的外部特征。
chap1_para322,5,,在内部，人工智能体的智能体函数将由智能体程序（agent program）实现。
chap1_para322,6,,区别这两种观点很重要，智能体函数是一种抽象的数学描述，而智能体程序是一个具体的实现，可以在某些物理系统中运行。
chap1_para323,1,Consider the simple vacuum-cleaner agent that cleans a square if it is dirty and moves to the other square if not; this is the agent function tabulated in Figure 2.,
chap1_para323,2,3.,
chap1_para323,3,Is this a rational agent?,
chap1_para323,4,That depends!,
chap1_para323,5,"First, we need to say what the performance measure is, what is known about the environment, and what sensors and actuators the agent has.",
chap1_para323,6,Let us assume the following:,
chap1_para324,1,"•The performance measure awards one point for each clean square at each time step, over a “lifetime” of 1000 time steps.",[1]　如果智能体在选择其动作时使用一些随机化，那就必须多次尝试每个序列来确定每个动作的概率。
chap1_para324,2,,有人可能会认为随机地行动是相当愚蠢的，但本章后面展示出它可能非常聪明。
chap1_para325,1,"•The “geography” of the environment is known a priori (Figure 2.2) but the dirt distribution and the initial location of the agent are not. Clean squares stay clean and sucking cleans the current square. The Right and Left actions move the agent one square except when this would take the agent outside the environment, in which case the agent remains where it is.",为了阐明这些想法，我们举一个简单的例子——真空吸尘器世界。
chap1_para325,2,,在一个由方格组成的世界中，包含一个机器人真空吸尘器智能体，其中的方格可以是脏的，也可以是干净的。
chap1_para325,3,,图2-2展示了只有两个方格——方格A和方格B——的情况。
chap1_para325,4,,真空吸尘器智能体可以感知它在哪个方格中，以及方格中是否干净。
chap1_para325,5,,智能体从方格A开始。
chap1_para325,6,,可选的操作包括向右移动、向左移动、吸尘或什么都不做。
chap1_para325,7,,[2]一个非常简单的智能体函数如下：如果当前方格是脏的，就吸尘；否则，移动到另一个方格。
chap1_para325,8,,该智能体函数的部分表格如图2-3所示，实现它的智能体程序如图2-8所示。
chap1_para326,1,"•The only available actions are Right, Left, and Suck.",
chap1_para327,1,•The agent correctly perceives its location and whether that location contains dirt.,[2]　真正的机器人不太可能会有“向右移动”和“向左移动”这样的动作，而是采用“向前旋转轮子”和“向后旋转轮子”这样的动作。
chap1_para327,2,,我们选择的动作更易于在书本上理解，而不是为了在实际的机器人中易于实现。
chap1_para328,1,Under these circumstances the agent is indeed rational; its expected performance is at least as good as any other agent’s.,图2-2　一个只有两个方格的真空吸尘器世界。
chap1_para328,2,,每个位置可以是干净的，也可以是脏的，智能体可以向左移动或向右移动，可以清理它所占据的方格。
chap1_para328,3,,不同版本的真空吸尘器世界允许不同的规则，例如智能体可以感知什么，它的动作是否总是成功等
chap1_para329,1,One can see easily that the same agent would be irrational under different circumstances.,从图2-3中可以看到，通过以各种方式填充右边的列可以简单地定义各种真空世界的智能体。
chap1_para329,2,"For example, once all the dirt is cleaned up, the agent will oscillate needlessly back and forth; if the performance measure includes a penalty of one point for each movement, the agent will fare poorly.",那么，显而易见的问题是：填充表格的正确方法是什么？
chap1_para329,3,A better agent for this case would do nothing once it is sure that all the squares are clean.,换句话说，是什么使智能体表现好或坏、聪明或愚蠢？
chap1_para329,4,"If clean squares can become dirty again, the agent should occasionally check and re-clean them if needed.",我们将在2.2节中回答这些问题。
chap1_para329,5,"If the geography of the environment is unknown, the agent will need to explore it.",
chap1_para329,6,Exercise 2.,
chap1_para329,7,VACR asks you to design agents for these cases.,
chap1_para33,1,"In the “laws of thought” approach to AI, the emphasis was on correct inferences. Making correct inferences is sometimes part of being a rational agent, because one way to act rationally is to deduce that a given action is best and then to act on that conclusion. On the other hand, there are ways of acting rationally that cannot be said to involve inference. For example, recoiling from a hot stove is a reflex action that is usually more successful than a slower action taken after careful deliberation.",19世纪的逻辑学家建立了一套精确的符号系统，用于描述世界上物体及其之间的关系。
chap1_para33,2,,这与普通算术表示系统形成对比，后者只提供关于数的描述。
chap1_para33,3,,到1965年，任何用逻辑符号描述的可解问题在原则上都可以用程序求解。
chap1_para33,4,,人工智能中所谓的逻辑主义（logicism）传统希望在此类程序的基础上创建智能系统。
chap1_para330,1,2.,在结束本节之前，我们应该强调，智能体这一概念旨在成为分析系统的工具，而不是将世界划分为智能体和非智能体的绝对表征。
chap1_para330,2,2.,人们可以将手持计算器视为一个智能体，它在给定感知序列“2+2=”时选择显示“4”的动作，但这样的分析很难帮助我们理解计算器。
chap1_para330,3,"3Omniscience, learning, and autonomy",在某种意义上，工程的所有领域都可以被视为设计与世界互动的人工制品，人工智能运行在（作者认为是）这个系列最有趣的一端，在这一端，人工制品具有重要的计算资源，任务环境需要非凡的决策。
chap1_para331,1,"We need to be careful to distinguish between rationality and omniscience. An omniscient agent knows the actual outcome of its actions and can act accordingly; but omniscience is impossible in reality. Consider the following example: I am walking along the Champs Elysées one day and I see an old friend across the street. There is no traffic nearby and I’m not otherwise engaged, so, being rational, I start to cross the street. Meanwhile, at 33,000 feet, a cargo door falls off a passing airliner,3 and before I make it to the other side of the street I am flattened. Was I irrational to cross the street? It is unlikely that my obituary would read “Idiot attempts to cross street.”",图2-3　图2-2所示的真空吸尘器世界的简单智能体函数的部分表项。
chap1_para331,2,,如果当前方格是脏的，智能体就会进行清理，否则它将移到另一个方格。
chap1_para331,3,,注意，除非限制可能感知序列的长度，否则该表的大小是无限的
chap1_para332,1,"This example shows that rationality is not the same as perfection. Rationality maximizes expected performance, while perfection maximizes actual performance. Retreating from a requirement of perfection is not just a question of being fair to agents. The point is that if we expect an agent to do what turns out after the fact to be the best action, it will be impossible to design an agent to fulfill this specification—unless we improve the performance of crystal balls or time machines.",2.2　良好行为：理性的概念
chap1_para333,1,"Our definition of rationality does not require omniscience, then, because the rational choice depends only on the percept sequence to date. We must also ensure that we haven’t inadvertently allowed the agent to engage in decidedly underintelligent activities. For example, if an agent does not look both ways before crossing a busy road, then its percept sequence will not tell it that there is a large truck approaching at high speed. Does our definition of rationality say that it’s now OK to cross the road? Far from it!",理性智能体（rational agent）是做正确事情的事物。
chap1_para333,2,,显然，做正确的事情比做错误的事情要好，但是做正确的事情意味着什么呢？
chap1_para334,1,"First, it would not be rational to cross the road given this uninformative percept sequence: the risk of accident from crossing without looking is too great. Second, a rational agent should choose the “looking” action before stepping into the street, because looking helps maximize the expected performance. Doing actions in order to modify future percepts—sometimes called information gathering—is an important part of rationality and is covered in depth in Chapter 15. A second example of information gathering is provided by the exploration that must be undertaken by a vacuum-cleaning agent in an initially unknown environment.",2.2.1　性能度量
chap1_para335,1,"Our definition requires a rational agent not only to gather information but also to learn as much as possible from what it perceives. The agent’s initial configuration could reflect some prior knowledge of the environment, but as the agent gains experience this may be modified and augmented. There are extreme cases in which the environment is completely known a priori and completely predictable. In such cases, the agent need not perceive or learn; it simply acts correctly.",道德哲学发展了几种不同“正确事情”的概念，但人工智能通常坚持一种称为结果主义（consequentialism）的概念：我们通过结果来评估智能体的行为。
chap1_para335,2,,当智能体进入环境时，它会根据接受的感知产生一个动作序列。
chap1_para335,3,,这一动作序列会导致环境经历一系列的状态。
chap1_para335,4,,如果序列是理想的，则智能体表现良好。
chap1_para335,5,,这种可取性的概念由性能度量（performance measure）描述，该度量评估任何给定环境状态的序列。
chap1_para336,1,"Of course, such agents are fragile. Consider the lowly dung beetle. After digging its nest and laying its eggs, it fetches a ball of dung from a nearby heap to plug the entrance. If the ball of dung is removed from its grasp en route, the beetle continues its task and pantomimes plugging the nest with the nonexistent dung ball, never noticing that it is missing. Evolution has built an assumption into the beetle’s behavior, and when it is violated, unsuccessful behavior results.",人类有自己的欲望和偏好，因此，人类有适用于自身的理性概念。
chap1_para336,2,,这一概念与成功地选择产生环境状态序列的行动有关，这些环境状态序列从人类的角度来看是可取的。
chap1_para336,3,,但是，机器没有自己的欲望和偏好，至少在最初，性能度量是在机器设计者的头脑中或者是在机器受众的头脑中。
chap1_para336,4,,我们将看到，一些智能体设计具有性能度量的显式表示（一个版本），而在其他设计中，性能度量完全是隐式的，智能体可能会做正确的事情，但它不知道为什么。
chap1_para337,1,"Slightly more intelligent is the sphex wasp. The female sphex will dig a burrow, go out and sting a caterpillar and drag it to the burrow, enter the burrow again to check all is well, drag the caterpillar inside, and lay its eggs. The caterpillar serves as a food source when the eggs hatch. So far so good, but if an entomologist moves the caterpillar a few inches away while the sphex is doing the check, it will revert to the “drag the caterpillar” step of its plan and will continue the plan without modification, re-checking the burrow, even after dozens of caterpillar-moving interventions. The sphex is unable to learn that its innate plan is failing, and thus will not change it.",回顾诺伯特·维纳的警告，以确保“施以机器的目的是我们真正想要的目的”（1.5节），注意，正确地制定性能度量可能非常困难。
chap1_para337,2,,例如，考虑2.1节中的真空吸尘器智能体，我们可能会建议用单个8小时班次中清理的灰尘量来度量性能。
chap1_para337,3,,当然，有了理性的智能体，你所要求的就是你所得到的。
chap1_para337,4,,然而一个理性的智能体可以通过清理灰尘，然后将其全部倾倒在地板上，然后再次清理，如此反复，从而最大化这一性能度量。
chap1_para337,5,,更合适的性能度量是奖励拥有干净地板的智能体。
chap1_para337,6,,例如，在每个时间步中，每个干净的方格都可以获得1分（可能会对耗电和产生的噪音进行惩罚）。
chap1_para337,7,,作为一般规则，更好的做法是根据一个人在环境中真正想要实现的目标，而不是根据一个人认为智能体应该如何表现来设计性能度量。
chap1_para338,1,"To the extent that an agent relies on the prior knowledge of its designer rather than on its own percepts and learning processes, we say that the agent lacks autonomy. A rational agent should be autonomous—it should learn what it can to compensate for partial or incorrect prior knowledge. For example, a vacuum-cleaning agent that learns to predict where and when additional dirt will appear will do better than one that does not.",即使避免了明显的缺陷，一些棘手的问题仍然存在。
chap1_para338,2,,例如，上一段中“干净地板”的概念是基于一段时间内的平均整洁度。
chap1_para338,3,,然而，两个不同的智能体可以达到相同的平均整洁度，其中一个智能体工作始终保持一般水平，而另一个智能体短时间工作效率很高但需要长时间的休息。
chap1_para338,4,,哪种工作方式更可取似乎是保洁科学的好课题，但实际上这是一个具有深远影响的深刻哲学问题。
chap1_para338,5,,大起大落、不计后果的生活，和安全但单调的生活，哪个更好？
chap1_para338,6,,一个人人都生活在中度贫困的经济体，和一个有些人生活富裕而另一些人非常贫困的经济体，哪个更好？
chap1_para338,7,,我们把这些问题留给勤奋的读者作为习题。
chap1_para339,1,"As a practical matter, one seldom requires complete autonomy from the start: when the agent has had little or no experience, it would have to act randomly unless the designer gave some assistance.",对于本书的大部分内容，我们将假设性能度量可以正确地指定。
chap1_para339,2,"Just as evolution provides animals with enough built-in reflexes to survive long enough to learn for themselves, it would be reasonable to provide an artificial intelligent agent with some initial knowledge as well as an ability to learn.",然而，出于前面所述原因，我们必须接受这样一种可能性：我们可能会将错误的目的施加给机器，确切地说，就是1.5节描述的迈达斯国王问题。
chap1_para339,3,"After sufficient experience of its environment, the behavior of a rational agent can become effectively independent of its prior knowledge.",此外，当设计一款软件（其副本将属于不同的用户）时，我们无法预测每个用户的确切偏好。
chap1_para339,4,"Hence, the incorporation of learning allows one to design a single rational agent that will succeed in a vast variety of environments.",因此，我们可能需要构建相应的智能体，它能够反映真实性能度量的初始不确定性，并随着时间的推移对其了解更多，第16章、第18章和第22章介绍了此类智能体。
chap1_para34,1,All the skills needed for the Turing test also allow an agent to act rationally.,按照常规的理解，逻辑要求关于世界的认知是确定的，而实际上这很难实现。
chap1_para34,2,Knowledge representation and reasoning enable agents to reach good decisions.,例如，我们对政治或战争规则的了解远不如对国际象棋或算术规则的了解。
chap1_para34,3,We need to be able to generate comprehensible sentences in natural language to get by in a complex society.,概率（probability）论填补了这一鸿沟，允许我们在掌握不确定信息的情况下进行严格的推理。
chap1_para34,4,"We need learning not only for erudition, but also because it improves our ability to generate effective behavior, especially in circumstances that are new.",原则上，它允许我们构建全面的理性思维模型，从原始的感知到对世界运作方式的理解，再到对未来的预测。
chap1_para34,5,,它无法做到的是形成智能行为。
chap1_para34,6,,为此，我们还需要关于理性行为的理论，仅靠理性思考是不够的。
chap1_para340,1,2.,
chap1_para340,2,3The Nature of Environments,
chap1_para341,1,"Now that we have a definition of rationality, we are almost ready to think about building rational agents. First, however, we must think about task environments, which are essentially the “problems” to which rational agents are the “solutions.” We begin by showing how to specify a task environment, illustrating the process with a number of examples. We then show that task environments come in a variety of flavors. The nature of the task environment directly affects the appropriate design for the agent program.",在任何时候，理性取决于以下4方面：
chap1_para342,1,2.,● 定义成功标准的性能度量；
chap1_para342,2,3.,
chap1_para342,3,1Specifying the task environment,
chap1_para343,1,"In our discussion of the rationality of the simple vacuum-cleaner agent, we had to specify the performance measure, the environment, and the agent’s actuators and sensors. We group all these under the heading of the task environment. For the acronymically minded, we call this the PEAS (Performance, Environment, Actuators, Sensors) description. In designing an agent, the first step must always be to specify the task environment as fully as possible.",● 智能体对环境的先验知识；
chap1_para344,1,The vacuum world was a simple example; let us consider a more complex problem: an automated taxi driver. Figure 2.4 summarizes the PEAS description for the taxi’s task environment. We discuss each element in more detail in the following paragraphs.,● 智能体可以执行的动作；
chap1_para345,1,Description The block diagram starts with a block labeled Agent.,● 智能体到目前为止的感知序列。
chap1_para345,2,There are six blocks inside the Agent block.,
chap1_para345,3,"The first block inside the agent block is labeled, What the world is like now.",
chap1_para345,4,"Arrows from the second, third, and fourth blocks labeled State, How the world evolves, and What my actions do, point to the first block.",
chap1_para345,5,A dashed arrow from the first block points back to the state block.,
chap1_para345,6,"A solid arrow from the first block points to the fifth block labeled, What action I should do now.",
chap1_para345,7,"An arrow from the sixth block labeled, Condition action rules, points to the fifth block.",
chap1_para345,8,An arrow from the fifth block points to the Actuators.,
chap1_para345,9,"An arrow from actuators points to the block labeled, Environment, which is outside the agent block.",
chap1_para345,10,An arrow from the environment block to the sensors in the agent block.,
chap1_para345,11,An arrow from the sensors points back to the first block.,
chap1_para346,1,Figure 2.,这引出了理性智能体的定义：
chap1_para346,2,4PEAS description of the task environment for an automated taxi driver.,
chap1_para347,1,"First, what is the performance measure to which we would like our automated driver to aspire?",对于每个可能的感知序列，给定感知序列提供的证据和智能体所拥有的任何先验知识，理性智能体应该选择一个期望最大化其性能度量的动作。
chap1_para347,2,Desirable qualities include getting to the correct destination; minimizing fuel consumption and wear and tear; minimizing the trip time or cost; minimizing violations of traffic laws and disturbances to other drivers; maximizing safety and passenger comfort; maximizing profits.,
chap1_para347,3,"Obviously, some of these goals conflict, so tradeoffs will be required.",
chap1_para348,1,"Next, what is the driving environment that the taxi will face?",考虑一个简单的真空吸尘器智能体，如果一个方格是脏的就清理它，如果不脏就移动到另一个方格，这就是图2-3中给出的智能体函数。
chap1_para348,2,"Any taxi driver must deal with a variety of roads, ranging from rural lanes and urban alleys to 12-lane freeways.",它是理性智能体吗？
chap1_para348,3,"The roads contain other traffic, pedestrians, stray animals, road works, police cars, puddles, and potholes.",这需要看情况了！
chap1_para348,4,The taxi must also interact with potential and actual passengers.,首先，我们需要说明性能度量是什么，对环境了解多少，以及智能体具有哪些传感器和执行器。
chap1_para348,5,There are also some optional choices.,我们假设：
chap1_para348,6,"The taxi might need to operate in Southern California, where snow is seldom a problem, or in Alaska, where it seldom is not.",
chap1_para348,7,"It could always be driving on the right, or we might want it to be flexible enough to drive on the left when in Britain or Japan.",
chap1_para348,8,"Obviously, the more restricted the environment, the easier the design problem.",
chap1_para349,1,The actuators for an automated taxi include those available to a human driver: control over the engine through the accelerator and control over steering and braking.,● 在1000个时间步的“生命周期”内，性能度量在每个时间步为每个干净的方格奖励1分；
chap1_para349,2,"In addition, it will need output to a display screen or voice synthesizer to talk back to the passengers, and perhaps some way to communicate with other vehicles, politely or otherwise.",
chap1_para35,1,"The rational-agent approach to AI has two advantages over the other approaches. First, it is more general than the “laws of thought” approach because correct inference is just one of several possible mechanisms for achieving rationality. Second, it is more amenable to scientific development. The standard of rationality is mathematically well defined and completely general. We can often work back from this specification to derive agent designs that provably achieve it—something that is largely impossible if the goal is to imitate human behavior or thought processes.",1.1.4　理性行为：理性智能体方法
chap1_para350,1,"The basic sensors for the taxi will include one or more video cameras so that it can see, as well as lidar and ultrasound sensors to detect distances to other cars and obstacles. To avoid speeding tickets, the taxi should have a speedometer, and to control the vehicle properly, especially on curves, it should have an accelerometer. To determine the mechanical state of the vehicle, it will need the usual array of engine, fuel, and electrical system sensors. Like many human drivers, it might want to access GPS signals so that it doesn’t get lost. Finally, it will need touchscreen or voice input for the passenger to request a destination.",● 环境的“地理信息”是先验的（图2-2），但灰尘的分布和智能体的初始位置不是先验的，干净的方格会继续保持干净，吸尘（Suck）动作会清理当前方格，向左（Left）或向右（Right）的动作使智能体移动一个方格，如果该动作会让智能体移动到环境之外，智能体将保持在原来的位置；
chap1_para351,1,"In Figure 2.5, we have sketched the basic PEAS elements for a number of additional agent types. Further examples appear in Exercise 2.PEAS. The examples include physical as well as virtual environments. Note that virtual task environments can be just as complex as the “real” world: for example, a software agent (or software robot or softbot) that trades on auction and reselling Web sites deals with millions of other users and billions of objects, many with real images.",● 可用的动作仅有向右（Right）、向左（Left）和吸尘（Suck）；
chap1_para352,1,Description The block diagram starts with a block labeled Agent.,● 智能体能够正确感知其位置以及该位置是否有灰尘。
chap1_para352,2,There are seven blocks inside the Agent block.,
chap1_para352,3,"The first block inside the agent block is labeled, What the word is like now.",
chap1_para352,4,"Arrows from the second, third, and fourth blocks labeled State, How the world evolves, and What my actions do, point to the first block.",
chap1_para352,5,A dashed arow from the first block points back to the state block.,
chap1_para352,6,"A solid arrow from the first block points to the fifth block labeled, What it will be like if I do action ""A"".",
chap1_para352,7,"Arrows from third and fourth blocks labeled, How the world evolves and What my action do, point to fifth block.",
chap1_para352,8,"An arrow from the fifth block points to the sixth block labeled, What action I should do now.",
chap1_para352,9,An arrow from the seventh block labeled Goals points to the sixth block.,
chap1_para352,10,An arrow from the sixth block points to the Actuators.,
chap1_para352,11,"An arrow from the actuators points to the block labeled, Environment, which is outside the agent block.",
chap1_para352,12,An arrow from the environment block points to the sensors in the agent block.,
chap1_para352,13,An arrow from the sensors points back to the first block.,
chap1_para353,1,Figure 2.,在这种情况下，智能体确实是理性的，它的预期性能至少与任何其他智能体一样。
chap1_para353,2,5Examples of agent types and their PEAS descriptions.,
chap1_para354,1,2.,显而易见，同一个智能体在不同的情况下可能会变得不理性。
chap1_para354,2,3.,例如，一旦清除了所有灰尘，该智能体将会毫无必要地反复来回；如果性能度量考虑对每个动作罚1分，那么智能体的表现就会很差。
chap1_para354,3,2Properties of task environments,在确定所有方格都干净的情况下，一个更好的智能体不会做任何事情。
chap1_para354,4,,如果干净的方格可能再次变脏，智能体应该偶尔检查，并在必要时重新清理。
chap1_para354,5,,如果环境的地理信息是未知的，智能体则需要对其进行探索（explore）。
chap1_para354,6,,习题2.VACR要求在这些情况下设计智能体。
chap1_para355,1,The range of task environments that might arise in AI is obviously vast.,2.2.3　全知、学习和自主
chap1_para355,2,"We can, however, identify a fairly small number of dimensions along which task environments can be categorized.",
chap1_para355,3,"These dimensions determine, to a large extent, the appropriate agent design and the applicability of each of the principal families of techniques for agent implementation.",
chap1_para355,4,"First we list the dimensions, then we analyze several task environments to illustrate the ideas.",
chap1_para355,5,The definitions here are informal; later chapters provide more precise statements and examples of each kind of environment.,
chap1_para356,1,,我们需要仔细区分理性和全知（omniscience）。
chap1_para356,2,,全知的智能体能预知其行动的实际结果，并能据此采取行动，但在现实中，全知是不可能的。
chap1_para356,3,,考虑这样一个例子：有一天我正沿着香榭丽舍大街散步，我看到街对面的一位老朋友。
chap1_para356,4,,附近没有车流，我也没有别的事要做，所以理性上，我会开始过马路。
chap1_para356,5,,与此同时，在 10千米的高空，一架飞过的客机上有一扇货舱门脱落下来[3]，在我到达马路对面之前，我就被压扁了。
chap1_para356,6,,我过马路是不理性的吗？
chap1_para356,7,,我的讣告上不太可能写“试图过马路的白痴”。
chap1_para358,1,,[3]　参见N. Henderson，“波音747大型喷气式飞机迫切需要新门锁”，华盛顿邮报，1989年8月24日。
chap1_para359,1,,这个例子表明，理性不等同于完美。
chap1_para359,2,,理性使期望性能最大化，而完美使实际性能最大化。
chap1_para359,3,,不要求完美不仅仅是对智能体公平的问题。
chap1_para359,4,,关键是，如果我们期望一个智能体做事后证明是最好的行动，就不可能设计一个符合规范的智能体，除非我们改进占卜水晶球或时间机器的性能。
chap1_para36,1,"For these reasons, the rational-agent approach to AI has prevailed throughout most of the field’s history. In the early decades, rational agents were built on logical foundations and formed definite plans to achieve specific goals. Later, methods based on probability theory and machine learning allowed the creation of agents that could make decisions under uncertainty to attain the best expected outcome. In a nutshell, AI has focused on the study and construction of agents that do the right thing. What counts as the right thing is defined by the objective that we provide to the agent. This general paradigm is so pervasive that we might call it the standard model. It prevails not only in AI, but also in control theory, where a controller minimizes a cost function; in operations research, where a policy maximizes a sum of rewards; in statistics, where a decision rule minimizes a loss function; and in economics, where a decision maker maximizes utility or some measure of social welfare.",智能体（agent）就是某种能够采取行动的东西（agent来自拉丁语agere，意为“做”）。
chap1_para36,2,,当然，所有计算机程序都可以完成一些任务，但我们期望计算机智能体能够完成更多的任务：自主运行、感知环境、长期持续存在、适应变化以及制定和实现目标。
chap1_para36,3,,理性智能体（rational agent）需要为取得最佳结果或在存在不确定性时取得最佳期望结果而采取行动。
chap1_para360,1,,因此，我们对理性的定义并不需要全知，因为理性决策只取决于迄今为止的感知序列。
chap1_para360,2,,我们还必须确保我们没有无意中允许智能体进行低智的行动。
chap1_para360,3,,例如，如果一个智能体在穿过繁忙的道路之前没有向两边看，那么它的感知序列将不会告诉它有一辆大卡车正在以高速接近。
chap1_para360,4,,我们对理性的定义是不是说现在就可以过马路了？
chap1_para360,5,,绝非如此！
chap1_para361,1,,首先，考虑到这种缺乏信息的感知序列，过马路是不理性的：不观察路况就过马路发生事故的风险太大。
chap1_para361,2,,其次，理性智能体在上街之前应该选择“观察”动作，因为观察有助于最大化期望性能。
chap1_para361,3,,采取行动来改变未来的感知，有时被称为信息收集（information gathering），这是理性的一个重要组成部分，将在第16章中详细介绍。
chap1_para361,4,,信息收集的另一个例子是真空吸尘器在最初未知的环境中必须进行的探索（exploration）。
chap1_para362,1,,我们的定义要求理性智能体不仅要收集信息，还要尽可能多地从它所感知到的东西中学习（learn）。
chap1_para362,2,,智能体的初始配置可以反映对环境的一些先验知识，但随着智能体获得经验，这可能会被修改和增强。
chap1_para362,3,,在一些极端情况下，环境完全是先验已知的和完全可预测的。
chap1_para362,4,,在这种情况下，智能体不需要感知或学习，只需正确地运行。
chap1_para363,1,,当然，这样的智能体是脆弱的。
chap1_para363,2,,如卑微的粪甲虫例子，在挖出巢穴产卵后，它会从附近的一堆粪中取出一团粪来堵住入口。
chap1_para363,3,,如果粪球在途中被截下，粪甲虫根本不会注意到粪球已经不见了，仍会继续它的任务，并滑稽地用不存在的粪球堵住巢穴。
chap1_para363,4,,进化已经在粪甲虫的行为中建立了一个假设，当它被违反时，不成功的行为就会产生。
chap1_para364,1,,稍微聪明一点的是掘土黄蜂。
chap1_para364,2,,雌性掘土黄蜂会挖一个洞，出去刺一只毛毛虫并把它拖到洞口，再次进入洞里检查一切是否正常，然后把毛毛虫拖进洞里再去产卵。
chap1_para364,3,,当蜂卵孵化时，毛毛虫会充当食物来源。
chap1_para364,4,,到目前为止还不错，但如果昆虫学家在掘土黄蜂检查洞穴时将毛毛虫移动几厘米远，它将回到其规划中的“把毛毛虫拖到洞口”步骤，即使经过数十次移动毛毛虫的干预，它仍然继续执行该规划而不进行修改，不断地重新检查洞穴。
chap1_para364,5,,掘土黄蜂无法知道其固有规划正在失败，因此不会改变规划。
chap1_para365,1,,如果在某种程度上，智能体依赖于其设计者的先验知识，而不是其自身的感知和学习过程，我们就说该智能体缺乏自主性（autonomy）。
chap1_para365,2,,一个理性的智能体应该是自主的，它应该学习如何弥补部分或不正确的先验知识。
chap1_para365,3,,例如，能学习预测何时何地会出现额外灰尘的真空吸尘器比不能学习预测的要好。
chap1_para366,1,,实际上，我们很少从一开始就要求智能体完全自主：除非设计者提供一些帮助，否则当智能体几乎没有经验或完全没有经验时，它将不得不随机行动。
chap1_para366,2,,正如进化为动物提供了足够的内建反射，使其能够生存足够长的时间来学习一样，为人工智能体提供一些初始知识和学习能力也是合理的。
chap1_para366,3,,在充分体验相应环境后，理性智能体的行为可以有效地独立于其先验知识。
chap1_para366,4,,因此，结合学习能够让我们设计单个理性智能体，它能在各种各样的环境中取得成功。
chap1_para368,1,,既然已经有了理性的定义，考虑构建理性智能体的准备几乎已经完成。
chap1_para368,2,,然而，还必须考虑任务环境（task environment），它本质上是“问题”，理性智能体是“解决方案”。
chap1_para368,3,,我们首先展示如何指定任务环境，并用一些示例说明该过程。
chap1_para368,4,,然后，展示任务环境的多种形式。
chap1_para368,5,,任务环境的性质直接影响智能体程序的恰当设计。
chap1_para369,1,,2.3.1　指定任务环境
chap1_para37,1,"We need to make one important refinement to the standard model to account for the fact that perfect rationality—always taking the exactly optimal action—is not feasible in complex environments. The computational demands are just too high. Chapters 6 and 16 deal with the issue of limited rationality—acting appropriately when there is not enough time to do all the computations one might like. However, perfect rationality often remains a good starting point for theoretical analysis.",基于人工智能的“思维法则”方法重视正确的推断。
chap1_para37,2,,做出正确的推断有时是理性智能体的一部分，因为采取理性行为的一种方式是推断出某个给定的行为是最优的，然后根据这个结论采取行动。
chap1_para37,3,,但是，理性行为的有些方式并不能说与推断有关。
chap1_para37,4,,例如，从火炉前退缩是一种反射作用，这通常比经过深思熟虑后采取的较慢的动作更为成功。
chap1_para370,1,,在讨论简单的真空吸尘器智能体的理性时，我们必须指定性能度量、环境以及智能体的执行器和传感器。
chap1_para370,2,,我们将所有这些都归在任务环境的范畴下，基于首字母缩写规则，我们称其为PEAS（Performance，Environment，Actuator，Sensor）描述。
chap1_para370,3,,在设计智能体时，第一步必须始终是尽可能完整地指定任务环境。
chap1_para371,1,,真空吸尘器世界是一个简单的例子，让我们考虑一个更复杂的问题：自动驾驶出租车司机。
chap1_para371,2,,图2-4总结了出租车任务环境的PEAS描述。
chap1_para371,3,,我们将在以下段落中更详细地讨论每个元素。
chap1_para372,1,,图2-4　自动驾驶出租车司机任务环境的PEAS描述
chap1_para373,1,,首先，我们希望自动驾驶追求的性能度量（performance measure）是什么？
chap1_para373,2,,理想的标准包括到达正确的目的地，尽量减少油耗和磨损，尽量减少行程时间或成本，尽量减少违反交通法规和对其他驾驶员的干扰，最大限度地提高安全性和乘客舒适度，最大化利润。
chap1_para373,3,,显然，其中一些目标是相互冲突的，因此需要权衡。
chap1_para374,1,,接下来，出租车将面临什么样的驾驶环境（environment）？
chap1_para374,2,,任何出租车司机都必须能够在各种道路上行驶，如乡村车道、城市小巷以及12车道的高速公路。
chap1_para374,3,,道路上有其他交通工具、行人、流浪动物、道路工程、警车、水坑和坑洼。
chap1_para374,4,,出租车还必须与潜在以及实际的乘客互动。
chap1_para374,5,,另外，还有一些可选项。
chap1_para374,6,,出租车可以选择在很少下雪的南加利福尼亚州或者经常下雪的阿拉斯加运营。
chap1_para374,7,,它可能总是靠右行驶，或者我们可能希望它足够灵活，在英国或日本时可以靠左行驶。
chap1_para374,8,,显然，环境越受限，设计问题就越容易解决。
chap1_para375,1,,自动驾驶出租车的执行器（actuator）包括可供人类驾驶员使用的器件，例如通过加速器控制发动机以及控制转向和制动。
chap1_para375,2,,此外，它还需要输出到显示屏或语音合成器，以便与乘客进行对话，或许还需要某种方式与其他车辆进行礼貌的或其他方式的沟通。
chap1_para376,1,,出租车的基本传感器（sensor）将包括一个或多个摄像头以便观察，以及激光雷达和超声波传感器以便检测其他车辆和障碍物的距离。
chap1_para376,2,,为了避免超速罚单，出租车应该有一个速度表，而为了正确控制车辆（特别是在弯道上），它应该有一个加速度表。
chap1_para376,3,,要确定车辆的机械状态，需要发动机、燃油和电气系统的传感器常规阵列。
chap1_para376,4,,像许多人类驾驶者一样，它可能需要获取GPS信号，这样就不会迷路。
chap1_para376,5,,最后，乘客需要触摸屏或语音输入才能说明目的地。
chap1_para377,1,,图2-5中简要列举了一些其他智能体类型的基本PEAS元素。
chap1_para377,2,,更多示例参见习题2.PEAS。
chap1_para377,3,,这些示例包括物理环境和虚拟环境。
chap1_para377,4,,注意，虚拟任务环境可能与“真实”世界一样复杂。
chap1_para377,5,,例如，在拍卖和转售网站上进行交易的软件智能体（software agent），或称软件机器人或软机器人（softbot），为数百万其他用户和数十亿对象提供交易，其中许多对象具有真实的图片。
chap1_para378,1,,图2-5　智能体类型及其PEAS描述的示例
chap1_para379,1,,2.3.2　任务环境的属性
chap1_para38,1,1.,通过图灵测试所需的所有技能也使智能体得以采取理性行为。
chap1_para38,2,1.,知识表示和推理能让智能体做出较好的决策。
chap1_para38,3,5Beneficial machines,我们需要具备生成易于理解的自然语言句子的能力，以便在复杂的社会中生存。
chap1_para38,4,,我们需要学习不仅是为了博学多才，也是为了提升我们产生高效行为的能力，尤其是在新环境下，这种能力更加重要。
chap1_para380,1,,人工智能中可能出现的任务环境范围显然非常广泛。
chap1_para380,2,,然而，我们可以确定相当少的维度，并根据这些维度对任务环境进行分类。
chap1_para380,3,,这些维度在很大程度上决定了恰当的智能体设计以及智能体实现的主要技术系列的适用性。
chap1_para380,4,,首先我们列出维度，然后分析几个任务环境，阐明思路。
chap1_para380,5,,这里的定义是非形式化的，后面的章节提供了每种环境的更精确的陈述和示例。
chap1_para381,1,,完全可观测的（fully observable）与部分可观测的（partially observable）：如果智能体的传感器能让它在每个时间点都能访问环境的完整状态，那么我们说任务环境是完全可观测的。
chap1_para381,2,,如果传感器检测到与动作选择相关的所有方面，那么任务环境就是有效的完全可观测的，而所谓的相关又取决于性能度量标准。
chap1_para381,3,,完全可观测的环境很容易处理，因为智能体不需要维护任何内部状态来追踪世界。
chap1_para381,4,,由于传感器噪声大且不准确，或者由于传感器数据中缺少部分状态，环境可能部分可观测。
chap1_para381,5,,例如，只有一个局部灰尘传感器的真空吸尘器无法判断其他方格是否有灰尘，自动驾驶出租车无法感知其他司机的想法。
chap1_para381,6,,如果智能体根本没有传感器，那么环境是不可观测的（unobservable）。
chap1_para381,7,,在这种情况下，有人可能会认为智能体的困境是无解的，但是正如我们在第4章中讨论的那样，智能体的目标可能仍然可以实现，有时甚至是确定可以实现的。
chap1_para382,1,,单智能体的（single-agent）与多智能体的（multiagent）：单智能体和多智能体环境之间的区别似乎足够简单。
chap1_para382,2,,例如，独自解决纵横字谜的智能体显然处于单智能体环境中，而下国际象棋的智能体则处于二智能体环境中。
chap1_para382,3,,然而，这里也有一些微妙的问题。
chap1_para382,4,,首先，我们已经描述了如何将一个实体视为智能体，但没有解释哪些实体必须视为智能体。
chap1_para382,5,,智能体A（例如出租车司机）是否必须将对象B（另一辆车）视为智能体，还是可以仅将其视为根据物理定律运行的对象，类似于海滩上的波浪或随风飘动的树叶？
chap1_para382,6,,关键的区别在于B的行为是否被最佳地描述为一个性能度量的最大化，而这一性能度量的值取决于智能体A的行为。
chap1_para383,1,,例如，国际象棋中的对手实体B正试图最大化其性能度量，根据国际象棋规则，这将最小化智能体A的性能度量。
chap1_para383,2,,因此，国际象棋是一个竞争性（competitive）的多智能体环境。
chap1_para383,3,,但是，在出租车驾驶环境中，避免碰撞使所有智能体的性能度量最大化，因此它是一个部分合作的（cooperative）多智能体环境。
chap1_para383,4,,它还具有部分竞争性，例如，一个停车位只能停一辆车。
chap1_para384,1,,多智能体环境中的智能体设计问题通常与单智能体环境下有较大差异。
chap1_para384,2,,例如，在多智能体环境中，通信通常作为一种理性行为出现；在某些竞争环境中，随机行为是理性的，因为它避免了一些可预测性的陷阱。
chap1_para385,1,,确定性的（deterministic）与非确定性的（nondeterministic）：如果环境的下一个状态完全由当前状态和智能体执行的动作决定，那么我们说环境是确定性的，否则是非确定性的。
chap1_para385,2,,原则上，在完全可观测的确定性环境中，智能体不需要担心不确定性。
chap1_para385,3,,然而，如果环境是部分可观测的，那么它可能是非确定性的。
chap1_para386,1,,大多数真实情况非常复杂，以至于不可能追踪所有未观测到的方面；出于实际目的，必须将其视为非确定性的。
chap1_para386,2,,从这个意义上讲，出租车驾驶显然是非确定性的，因为人们永远无法准确地预测交通行为。
chap1_para386,3,,此外，轮胎可能会意外爆胎，发动机可能会在没有警告的情况下失灵。
chap1_para386,4,,我们描述的真空吸尘器世界是确定性的，但变化可能包括非确定性因素，如随机出现的灰尘和不可靠的吸力机制（参考习题2.VFIN）。
chap1_para387,1,,最后注意一点，随机的（stochastic）一词被一些人用作“非确定性”的同义词，但我们会区分这两个术语。
chap1_para387,2,,如果环境模型显式地处理概率（例如，“明天的降雨可能性为25%”），那么它是随机的；如果可能性没有被量化，那么它是“非确定性的”（例如，“明天有可能下雨”）。
chap1_para388,1,,回合式的（episodic）与序贯的（sequential）：在回合式任务环境中，智能体的经验被划分为原子式的回合。
chap1_para388,2,,在每一回合中，智能体接收一个感知，然后执行单个动作。
chap1_para388,3,,至关重要的是，下一回合并不依赖于前几回合采取的动作。
chap1_para388,4,,许多分类任务是回合式的。
chap1_para388,5,,例如，在装配流水线上检测缺陷零件的智能体需要根据当前零件做出每个决策，而无须考虑以前的决策；而且，当前的决策并不影响下一个零件是否有缺陷。
chap1_para388,6,,但是，在序贯环境中，当前决策可能会影响未来所有决策。
chap1_para388,7,,[4]国际象棋和出租车驾驶是序贯的：在这两种情况下，短期行为可能会产生长期影响。
chap1_para388,8,,因为在回合式环境下智能体不需要提前思考，所以要比序贯环境简单很多。
chap1_para39,1,"The standard model has been a useful guide for AI research since its inception, but it is probably not the right model in the long run.",与其他方法相比，基于人工智能的理性智能体方法有两个优点。
chap1_para39,2,The reason is that the standard model assumes that we will supply a fully specified objective to the machine.,首先，它比“思维法则”方法更普适，因为正确的推断只是实现理性的几种可能机制之一。
chap1_para39,3,,其次，它更适合科学发展。
chap1_para39,4,,理性的标准在数学上是明确定义且完全普适的。
chap1_para39,5,,我们经常可以从这个标准规范中得出可以被证明能够实现的智能体设计，而把模仿人类行为或思维过程作为目标的设计在很大程度上是不可能的。
chap1_para390,1,,[4]　“sequential”（串行）一词在计算机科学中也被用作“parallel”（并行）的反义词，与此处的含义在很大程度上是不相关的。
chap1_para391,1,,静态的（static）与动态的（dynamic）：如果环境在智能体思考时发生了变化，我们就说该智能体的环境是动态的，否则是静态的。
chap1_para391,2,,静态环境很容易处理，因为智能体在决定某个操作时不需要一直关注世界，也不需要担心时间的流逝。
chap1_para391,3,,但是，动态环境会不断地询问智能体想要采取什么行动，如果它还没有决定，那就等同于什么都不做。
chap1_para391,4,,如果环境本身不会随着时间的推移而改变，但智能体的性能分数会改变，我们就说环境是半动态的（semidynamic）。
chap1_para391,5,,驾驶出租车显然是动态的，因为驾驶算法在计划下一步该做什么时，其他车辆和出租车本身在不断移动。
chap1_para391,6,,在用时钟计时的情况下国际象棋是半动态的。
chap1_para391,7,,填字游戏是静态的。
chap1_para392,1,,离散的（discrete）与连续的（continuous）：离散/连续的区别适用于环境的状态、处理时间的方式以及智能体的感知和动作。
chap1_para392,2,,例如，国际象棋环境具有有限数量的不同状态（不包括时钟）。
chap1_para392,3,,国际象棋也有一组离散的感知和动作。
chap1_para392,4,,驾驶出租车是一个连续状态和连续时间的问题，出租车和其他车辆的速度和位置是一系列连续的值，并随着时间平稳地变化。
chap1_para392,5,,出租车的驾驶动作也是连续的（转向角等）。
chap1_para392,6,,严格来说，来自数字照相机的输入是离散的，但通常被视为表示连续变化的强度和位置。
chap1_para393,1,,已知的（known）与未知的（unknown）：严格来说，这种区别不是指环境本身，而是指智能体（或设计者）对环境“物理定律”的认知状态。
chap1_para393,2,,在已知环境中，所有行动的结果（如果环境是非确定性的，则对应结果的概率）都是既定的。
chap1_para393,3,,显然，如果环境未知，智能体将不得不了解它是如何工作的，才能做出正确的决策。
chap1_para394,1,,已知和未知环境之间的区别与完全可观测和部分可观测环境之间的区别不同。
chap1_para394,2,,一个已知的环境很可能是部分可观测的，例如，在纸牌游戏中，知道规则但仍然无法看到尚未翻转的牌。
chap1_para394,3,,相反，一个未知环境可以是完全可观测的，如一个全新的电子游戏，屏幕可能会显示整个游戏状态，但在尝试之前并不知道各个按钮的作用。
chap1_para395,1,,如2.2.1节所述，性能度量本身可能是未知的，这可能是因为设计者不确定如何正确地描述，也可能是因为最终用户（其偏好很重要）是未知的。
chap1_para395,2,,例如，出租车司机通常不知道新乘客是喜欢悠闲还是快速的旅程，是喜欢谨慎还是激进的驾驶风格。
chap1_para395,3,,虚拟个人助理一开始对新主人的个人喜好一无所知。
chap1_para395,4,,在这种情况下，智能体可以基于与设计者或用户的进一步交互来了解更多关于性能度量的信息。
chap1_para395,5,,继而，这表明，任务环境必须被视为一个多智能体环境。
chap1_para396,1,,最困难的情况是部分可观测的、多智能体的、非确定性的、序贯的、动态的、连续的且未知的。
chap1_para396,2,,驾驶出租车除了驾驶员的环境大多是已知的，在所有其他方面都很难。
chap1_para396,3,,在一个陌生的国家驾驶租来的汽车，那里有不熟悉的地理环境、不同的交通法规以及焦虑的乘客，这令人更加紧张。
chap1_para397,1,,图2-6列出了许多熟悉环境的属性。
chap1_para397,2,,注意，这些属性并不总是一成不变的。
chap1_para397,3,,例如，因为将患者的患病过程作为智能体建模并不适合，所以我们将医疗诊断任务列为单智能体，但是医疗诊断系统还可能必须应对顽固的病人和多疑的工作人员，因此环境还具有多智能体的方面。
chap1_para397,4,,此外，如果我们将任务设想为根据症状列表进行诊断，那么医疗诊断是回合式的；如果任务包括提出一系列测试、评估治疗过程中的进展、处理多个患者等，那么则是序贯的。
chap1_para398,1,,图2-6　任务环境的例子及其特征
chap1_para399,1,,因为如前所述，“已知的/未知的”不是严格意义上的环境属性，所以图2-6中没有包含此列。
chap1_para399,2,,对于某些环境，例如国际象棋和扑克，很容易为智能体提供完整的规则知识，但考虑智能体如何在没有这些知识的情况下学会玩这些游戏仍然是有趣的。
chap1_para4,1,"AI currently encompasses a huge variety of subfields, ranging from the general (learning, reasoning, perception, and so on) to the specific, such as playing chess, proving mathematical theorems, writing poetry, driving a car, or diagnosing diseases.",目前，人工智能包含大量不同的子领域，从学习、推理、感知等通用领域到下棋、证明数学定理、写诗、驾车或诊断疾病等特定领域。
chap1_para4,2,AI is relevant to any intellectual task; it is truly a universal field.,人工智能可以与任何智能任务产生联系，是真正普遍存在的领域。
chap1_para40,1,"For an artificially defined task such as chess or shortest-path computation, the task comes with an objective built in—so the standard model is applicable. As we move into the real world, however, it becomes more and more difficult to specify the objective completely and correctly. For example, in designing a self-driving car, one might think that the objective is to reach the destination safely. But driving along any road incurs a risk of injury due to other errant drivers, equipment failure, and so on; thus, a strict goal of safety requires staying in the garage. There is a tradeoff between making progress towards the destination and incurring a risk of injury. How should this tradeoff be made? Furthermore, to what extent can we allow the car to take actions that would annoy other drivers? How much should the car moderate its acceleration, steering, and braking to avoid shaking up the passenger? These kinds of questions are difficult to answer a priori. They are particularly problematic in the general area of human–robot interaction, of which the self-driving car is one example.",由于上述这些原因，在人工智能领域的大部分历史中，基于理性智能体的方法都占据了上风。
chap1_para40,2,,在最初的几十年里，理性智能体建立在逻辑的基础上，并为了实现特定目标制定了明确的规划。
chap1_para40,3,,后来，基于概率论和机器学习的方法可以使智能体在不确定性下做出决策，以获得最佳期望结果。
chap1_para40,4,,简而言之，人工智能专注于研究和构建做正确的事情的智能体，其中正确的事情是我们提供给智能体的目标定义。
chap1_para40,5,,这种通用范式非常普遍，以至于我们可以称之为标准模型（standard model）。
chap1_para40,6,,它不仅适用于人工智能，也适用于其他领域。
chap1_para40,7,,控制理论中，控制器使代价函数最小化；运筹学中，策略使奖励的总和最大化；统计学中，决策规则使损失函数最小；经济学中，决策者追求效用或某种意义的社会福利最大化。
chap1_para400,1,,与本书相关的代码库包括多个环境实现以及用于评估智能体性能的通用环境模拟器。
chap1_para400,2,,实验通常不是针对单个环境进行的，而是针对从环境类（environment class）中抽象的许多环境进行的。
chap1_para400,3,,例如，要在模拟交通中评估出租车司机，我们需要运行具有不同的交通状况、照明和天气条件的多次模拟。
chap1_para400,4,,我们关注智能体在环境类上的平均性能。
chap1_para401,1,,2.4　智能体的结构
chap1_para402,1,,到目前为止，我们通过描述行为（即在任意给定的感知序列之后执行的动作）讨论了智能体。
chap1_para402,2,,现在我们必须迎难而上来讨论智能体内部是如何工作的。
chap1_para402,3,,人工智能的工作是设计一个智能体程序（agent program）实现智能体函数，即从感知到动作的映射。
chap1_para402,4,,假设该程序将运行在某种具有物理传感器和执行器的计算设备上，我们称之为智能体架构（agent architecture）：
chap1_para404,1,,显然，我们选择的程序必须是适合相应架构的程序。
chap1_para404,2,,如果程序打算推荐步行这样的动作，那么对应的架构最好有腿。
chap1_para404,3,,架构可能只是一台普通PC，也可能是一辆带有多台车载计算机、摄像头和其他传感器的机器人汽车。
chap1_para404,4,,通常，架构使程序可以使用来自传感器的感知，然后运行程序，并将程序生成的动作选择反馈给执行器。
chap1_para404,5,,尽管本书第25章和第26章涉及传感器和执行器，但其余大部分内容都是关于设计智能体程序的。
chap1_para405,1,,2.4.1　智能体程序
chap1_para406,1,,我们在本书中设计的智能体程序都有相同的框架：它们将当前感知作为传感器的输入，并将动作返回给执行器。
chap1_para406,2,,[5]注意智能体程序（将当前感知作为输入）和智能体函数（可能依赖整个感知历史）之间的差异。
chap1_para406,3,,因为环境中没有其他可用信息，所以智能体程序别无选择，只能将当前感知作为输入。
chap1_para406,4,,如果智能体的动作需要依赖于整个感知序列，那么智能体必须记住历史感知。
chap1_para408,1,,[5]　智能体程序框架还有其他选择。
chap1_para408,2,,例如，我们可以让智能体程序作为与环境异步运行的协程。
chap1_para408,3,,每个这样的协程都有一个输入和输出端口，并由一个循环组成，该循环读取输入端口的感知，并将动作写到输出端口。
chap1_para409,1,,我们用附录B中定义的简单伪代码语言描述智能体程序。
chap1_para409,2,,（在线代码库包含真实编程语言的实现。
chap1_para409,3,,）图2-7显示了一个相当简单的智能体程序，它记录感知序列，然后使用它来索引动作表，以决定要执行的动作。
chap1_para409,4,,动作表（如图2-3中给出的真空吸尘器世界示例）明确表示了智能体程序所体现的智能体函数。
chap1_para409,5,,作为设计者，为了以这种方式构建理性智能体，我们必须构造一个表，该表包含每个可能的感知序列所对应的适当动作。
chap1_para41,1,"The problem of achieving agreement between our true preferences and the objective we put into the machine is called the value alignment problem: the values or objectives put into the machine must be aligned with those of the human. If we are developing an AI system in the lab or in a simulator—as has been the case for most of the field’s history—there is an easy fix for an incorrectly specified objective: reset the system, fix the objective, and try again. As the field progresses towards increasingly capable intelligent systems that are deployed in the real world, this approach is no longer viable. A system deployed with an incorrect objective will have negative consequences. Moreover, the more intelligent the system, the more negative the consequences.",然而在复杂的环境中，完美理性（总是采取精确的最优动作）是不可行的，它的计算代价太高了，因此需要对标准模型做一些重要的改进。
chap1_para41,2,,第5章和第17章会探讨有限理性（limited rationality）的问题，也就是在没有足够时间进行所有可能的计算的情况下，适当地采取行动。
chap1_para41,3,,但是，完美理性仍然是理论分析的良好出发点。
chap1_para410,1,,图2-7　每个新感知都会调用Table-Driven-Agent程序，并且每次返回一个动作。
chap1_para410,2,,它在内存中保留了完整的感知序列
chap1_para411,1,,表驱动的智能体构建方法注定失败，深入思考这一问题会很有启发性。
chap1_para411,2,,设为可能的感知集，T为智能体的生存期（对应它将接收的感知总数），查找表将包含条记录。
chap1_para411,3,,考虑自动驾驶出租车：来自单个摄像头（通常是8个摄像头）的视觉输入速度约为70 MB/s（每秒30帧，每帧1080 像素× 720像素，每个像素包含24位颜色信息），驾驶1小时后，将会生成一张超过10600 000 000 000条记录的表。
chap1_para411,4,,即使是作为真实世界中微小的、表现良好的片段的国际象棋，其查找表也至少有10150条记录。
chap1_para411,5,,相比之下，可观测宇宙中的原子数量少于1080个。
chap1_para411,6,,这些表的巨大规模意味着：（a）这个宇宙中没有任何物理智能体有空间存储表；（b）设计者没有时间创建表；（c）任何智能体都无法从其经验中学习所有正确的记录。
chap1_para412,1,,尽管如此，假设表填充正确，Table-Driven-Agent确实做了我们想要做的事情：它实现了所需的智能体函数。
chap1_para413,1,,人工智能面临的关键挑战是找出编写程序的方法，尽可能从一个小程序而不是从一个大表中产生理性行为。
chap1_para414,1,,"历史上有许多例子表明，在其他领域可以成功地做到这一点：例如, 20世纪70年代以前，工程师和学生使用的巨大平方根表格，现在已经被电子计算器上运行的仅有5行代码的牛顿方法所取代。"
chap1_para414,2,,现在问题是，人工智能能像牛顿处理平方根那样处理一般智能行为吗？
chap1_para414,3,,我们相信答案是肯定的。
chap1_para415,1,,在本节剩余部分中，我们将概述4种基本的智能体程序，它们体现了几乎所有智能系统的基本原理：
chap1_para416,1,,● 简单反射型智能体；
chap1_para417,1,,● 基于模型的反射型智能体；
chap1_para418,1,,● 基于目标的智能体；
chap1_para419,1,,● 基于效用的智能体。
chap1_para42,1,"Returning to the apparently unproblematic example of chess, consider what happens if the machine is intelligent enough to reason and act beyond the confines of the chessboard. In that case, it might attempt to increase its chances of winning by such ruses as hypnotizing or blackmailing its opponent or bribing the audience to make rustling noises during its opponent’s thinking time.3 It might also attempt to hijack additional computing power for itself. These behaviors are not “unintelligent” or “insane”; they are a logical consequence of defining winning as the sole objective for the machine.",1.1.5　益机[3]
chap1_para420,1,,每种智能体程序以特定的方式组合特定的组件来产生动作。
chap1_para420,2,,2.4.6节大致解释了如何将所有这些智能体转换为学习型智能体，以提高其组件的性能，从而产生更好的动作。
chap1_para420,3,,2.4.7节描述在智能体中表示组件本身的各种方式。
chap1_para420,4,,这种多样性为这一领域和这本书本身提供了一个主要的组织原则。
chap1_para421,1,,2.4.2　简单反射型智能体
chap1_para422,1,,最简单的智能体是简单反射型智能体（simple reflex agent）。
chap1_para422,2,,这些智能体根据当前感知选择动作，忽略感知历史的其余部分。
chap1_para422,3,,例如，真空吸尘器的智能体函数在图2-3所示，是一种简单反射型智能体，因为它的决策仅基于当前位置以及该位置是否有灰尘。
chap1_para422,4,,该智能体的智能体程序如图2-8所示。
chap1_para423,1,,图2-8　在只有两个位置的真空吸尘器环境中，简单反射型智能体的智能体程序，该程序实现图2-3中列出的智能体函数
chap1_para424,1,,注意，与之前对应的表相比，真空吸尘器的程序确实非常轻量。
chap1_para424,2,,最明显的简化来自忽略感知历史，这将相关感知序列的数量从4T减少到4。
chap1_para424,3,,进一步的简化基于以下事实：动作不依赖于位置，只依赖于当前方格是否有灰尘。
chap1_para424,4,,虽然我们已经使用if-then-else语句来编写智能体程序，但它非常简单，可以将其实现为布尔电路。
chap1_para425,1,,即使在更复杂的环境中，也会出现简单的反射行为。
chap1_para425,2,,想象自己是自动驾驶出租车司机。
chap1_para425,3,,如果前面的汽车刹车并且刹车灯亮起，那么你应该注意到这一点并开始刹车。
chap1_para425,4,,换句话说，你通过对视觉输入进行一些处理来建立我们称之为“前面的汽车正在刹车”的条件。
chap1_para425,5,,然后，这会触发智能体程序中的既定联结，对应动作“启动刹车”。
chap1_para425,6,,我们称这样的联结为条件-动作规则（condition-action rule）[6]，写作：
chap1_para427,1,,[6]　也称为情境-动作规则、产生式系统或 if-then规则。
chap1_para428,1,,如果前面的车正在刹车，则启动刹车。
chap1_para429,1,,人类也有许多这样的联结，其中一些是习得反应（如驾驶），而另一些则是先天反射（如在有东西接近眼睛时眨眼）。
chap1_para429,2,,在本书中，我们展示了学习和实现这种联结的几种不同方式。
chap1_para43,1,"It is impossible to anticipate all the ways in which a machine pursuing a fixed objective might misbehave. There is good reason, then, to think that the standard model is inadequate. We don’t want machines that are intelligent in the sense of pursuing their objectives; we want them to pursue our objectives. If we cannot transfer those objectives perfectly to the machine, then we need a new formulation—one in which the machine is pursuing our objectives, but is necessarily uncertain as to what they are. When a machine knows that it doesn’t know the complete objective, it has an incentive to act cautiously, to ask permission, to learn more about our preferences through observation, and to defer to human control. Ultimately, we want agents that are provably beneficial to humans. We will return to this topic in Section 1.5.",
chap1_para430,1,,图2-8所示的程序限定于一个特定的真空吸尘器环境。
chap1_para430,2,,一种更通用、更灵活的方法是，首先为条件操作规则构建通用解释器，然后为特定任务环境创建规则集。
chap1_para430,3,,图2-9给出了通用程序的结构示意图，展示条件-动作规则如何在智能体中建立从感知到动作的联结。
chap1_para430,4,,如果这看起来普通，不要担心，很快就会变得更加有趣。
chap1_para431,1,,图2-9　简单反射型智能体的示意图。
chap1_para431,2,,我们使用矩形表示智能体决策过程的当前内部状态，使用椭圆表示过程中使用的背景信息
chap1_para432,1,,图2-9中智能体对应的智能体程序如图2-10所示。
chap1_para432,2,,Interpret-Input函数根据percept生成当前状态的抽象描述。
chap1_para432,3,,给定状态描述，Rule-Match函数返回规则集中匹配的第一条规则。
chap1_para432,4,,注意，关于“规则”和“匹配”的描述纯粹是概念性的。
chap1_para432,5,,如上所述，实际实现可以像实现布尔电路的逻辑门集合一样简单。
chap1_para432,6,,或者，也可以使用“神经”电路，其中逻辑门由人工神经网络中的非线性单元代替（见第21章）。
chap1_para433,1,,图2-10　简单反射型智能体。
chap1_para433,2,,它根据一条规则进行操作，该规则的条件与感知定义的当前状态相匹配
chap1_para434,1,,简单反射型智能体具有值得赞扬的简单特性，但它们的智能有限。
chap1_para434,2,,图2-10中的智能体只有在当前感知的基础上才能做出正确的决策，也就是说，只有在环境完全可观测的情况下才可行。
chap1_para435,1,,即使是轻微的不可观测性也会造成严重的问题。
chap1_para435,2,,例如，前面给出的刹车规则假设前车正在刹车的条件可以通过当前的感知（视频的单帧）确定。
chap1_para435,3,,如果前车有一个安装在中间的（因此是唯一可识别的）刹车灯，这是可行的。
chap1_para435,4,,但是，旧款车型的尾灯、刹车灯和转向灯的配置各不相同，而且从单幅图像中分辨出汽车是在刹车还是仅仅打开了尾灯不是总能做到的。
chap1_para435,5,,一个简单反射型智能体在这样一辆车后面行驶，要么会连续不必要地刹车，或者更糟的是根本就不刹车。
chap1_para436,1,,我们在真空吸尘器世界中也可以看到类似的问题。
chap1_para436,2,,假设一个简单的真空吸尘器反射型智能体没有位置传感器，只有一个灰尘传感器。
chap1_para436,3,,这样的智能体只有两种可能的感知：[Dirty]和[Clean]。
chap1_para436,4,,它可以用吸尘（Suck）来响应[Dirty]，它该如何响应[Clean]呢？
chap1_para436,5,,如果碰巧从方格A开始，向左（Left）移动会（永远）失败，如果从方格B开始，向右（Right）移动会（永远）失败。
chap1_para436,6,,对在部分可观测环境中工作的简单反射型智能体而言，无限循环通常是不可避免的。
chap1_para437,1,,如果智能体可以随机化（randomize）其操作，则可以跳出无限循环。
chap1_para437,2,,例如，如果真空吸尘器智能体感知到[Clean]，它可能会通过抛硬币来选择左右。
chap1_para437,3,,我们很容易就能证明智能体将平均通过两步到达另一个方格。
chap1_para437,4,,如果方格是脏的，智能体将清理它，任务就会完成。
chap1_para437,5,,因此，随机化的简单反射型智能体可能优于确定性的简单反射型智能体。
chap1_para438,1,,我们在2.3节中提到，在某些多智能体环境中，正确的随机行为是理性的。
chap1_para438,2,,在单智能体环境中，随机化通常是不理性的。
chap1_para438,3,,在某些情况下，这是一个有用的技巧，可以帮助简单反射型智能体，但在大多数情况下，我们可以使用更复杂的确定性智能体以做得更好。
chap1_para439,1,,2.4.3　基于模型的反射型智能体
chap1_para44,1,1.,[3]　根据beneficial insect的翻译“益虫”，将beneficial machine翻译成“益机”。
chap1_para44,2,2The Foundations of Artificial Intelligence,——译者注
chap1_para440,1,,处理部分可观测性的最有效方法是让智能体追踪它现在观测不到的部分世界。
chap1_para440,2,,也就是说，智能体应该维护某种依赖于感知历史的内部状态（internal state），从而至少反映当前状态的一些未观测到的方面。
chap1_para440,3,,对于刹车问题，内部状态范围不仅限于摄像头拍摄图像的前一帧，要让智能体能够检测车辆边缘的两个红灯何时同时亮起或熄灭。
chap1_para440,4,,对于其他驾驶任务，如变道，如果智能体无法同时看到其他车辆，则需要追踪它们的位置。
chap1_para440,5,,为了在任何时候都能驾驶，智能体需要追踪其钥匙的位置。
chap1_para441,1,,随着时间的推移，更新这些内部状态信息需要在智能体程序中以某种形式编码两种知识。
chap1_para441,2,,首先，需要一些关于世界如何随时间变化的信息，这些信息大致可以分为两部分：智能体行为的影响和世界如何独立于智能体而发展。
chap1_para441,3,,例如，当智能体顺时针转动方向盘时，汽车就会向右转；而下雨时，汽车的摄像头就会被淋湿。
chap1_para441,4,,这种关于“世界如何运转”的知识（无论是在简单的布尔电路中还是在完整的科学理论中实现）被称为世界的转移模型（transition model）。
chap1_para442,1,,其次，我们需要一些关于世界状态如何反映在智能体感知中的信息。
chap1_para442,2,,例如，当前面的汽车开始刹车时，前向摄像头的图像中会出现一个或多个亮起的红色区域；当摄像头被淋湿时，图像中会出现水滴状物体并部分遮挡道路。
chap1_para442,3,,这种知识称为传感器模型（sensor model）。
chap1_para443,1,,转移模型和传感器模型结合在一起让智能体能够在传感器受限的情况下尽可能地跟踪世界的状态。
chap1_para443,2,,使用此类模型的智能体称为基于模型的智能体（model-based agent）。
chap1_para444,1,,图2-11给出了基于模型的反射型智能体的结构，它具有内部状态，展示了当前感知如何与旧的内部状态相结合，并基于世界如何运转的模型生成当前状态的更新描述。
chap1_para444,2,,智能体程序如图2-12所示。
chap1_para444,3,,有趣的部分是函数Update-State，它负责创建新的内部状态描述。
chap1_para444,4,,模型和状态的表示方式的细节因环境类型和智能体设计中使用的特定技术而异。
chap1_para445,1,,无论使用哪种表示，智能体几乎不可能准确地确定部分可观测环境的当前状态。
chap1_para445,2,,相反，标有“现在的世界是什么样子”（图2-11）的框表示智能体的“最佳猜测”（或者在具有多种可能性的情况下的最佳猜测）。
chap1_para445,3,,例如，一辆自动驾驶出租车可能无法看到停在它前面的大卡车周围的情况，只能猜测是什么导致了拥堵。
chap1_para445,4,,因此，关于当前状态的不确定性可能是不可避免的，但智能体仍然需要做出决定。
chap1_para446,1,,图2-11　基于模型的智能体
chap1_para447,1,,图2-12　基于模型的反射型智能体。
chap1_para447,2,,它使用内部模型追踪世界的当前状态，然后以与反射型智能体相同的方式选择动作
chap1_para448,1,,2.4.4　基于目标的智能体
chap1_para449,1,,了解环境的现状并不总是足以决定做什么。
chap1_para449,2,,例如，在一个路口，出租车可以左转、右转或直行。
chap1_para449,3,,正确的决定取决于出租车要去哪里。
chap1_para449,4,,换句话说，除了当前状态的描述之外，智能体还需要某种描述理想情况的目标信息，例如设定特定的目的地。
chap1_para449,5,,智能体程序可以将其与模型（与基于模型的反射型智能体中使用的信息相同）相结合，并选择实现目标的动作。
chap1_para449,6,,图2-13展示了基于目标的智能体结构。
chap1_para45,1,"In this section, we provide a brief history of the disciplines that contributed ideas, viewpoints, and techniques to AI.",自标准模型被提出以来，其一直是人工智能研究的指南，但从长远来看，它可能不是一个正确的模型，原因是标准模型假设我们总是为机器提供完全指定的目标。
chap1_para45,2,"Like any history, this one concentrates on a small number of people, events, and ideas and ignores others that also were important.",
chap1_para45,3,We organize the history around a series of questions.,
chap1_para45,4,We certainly would not wish to give the impression that these questions are the only ones the disciplines address or that the disciplines have all been working toward AI as their ultimate fruition.,
chap1_para450,1,,有时，基于目标的动作选择很直接，例如，单个动作能够立刻实现目标的情况。
chap1_para450,2,,有时会更棘手，例如，智能体为了找到实现目标的方法而不得不考虑很长的复杂序列。
chap1_para450,3,,搜索（第3～5章）和规划（第11章）是人工智能的子领域，专门用于寻找实现智能体目标的动作序列。
chap1_para451,1,,注意，这类决策从根本上不同于前面描述的条件-动作规则，因为它涉及对未来的考虑，包括“如果我这样做会发生什么？
chap1_para451,2,,”和“这会让我快乐吗？
chap1_para451,3,,”在反射型智能体设计中，这种信息并没有被明确地表示出来，因为内置规则直接从感知映射到动作。
chap1_para451,4,,反射型智能体在看到刹车灯时刹车，但它不知道为什么。
chap1_para451,5,,基于目标的智能体在看到刹车灯时会刹车，因为这是它预测的唯一动作，这个动作可以实现不撞到其他汽车的目标。
chap1_para452,1,,图2-13　基于模型、基于目标的智能体。
chap1_para452,2,,它追踪世界状态以及它试图实现的一系列目标，并选择一项最终能够实现目标的动作
chap1_para453,1,,尽管基于目标的智能体看起来效率较低，但它更灵活，因为支持其决策的知识是显式表示的，并且可以修改。
chap1_para453,2,,例如，只要将目的地指定为目标，就可以很容易地更改基于目标的智能体的行为，以到达不同的目的地。
chap1_para453,3,,反射型智能体关于何时转弯和何时直行的规则只适用于单一目的地，这些规则必须全部更换才能去新的目的地。
chap1_para454,1,,2.4.5　基于效用的智能体
chap1_para455,1,,在大多数环境中，仅靠目标并不足以产生高质量的行为。
chap1_para455,2,,例如，许多动作序列都能使出租车到达目的地（从而实现目标），但有些动作序列比其他动作序列更快、更安全、更可靠或更便宜。
chap1_para455,3,,目标只是在“快乐”和“不快乐”状态之间提供了一个粗略的二元区别。
chap1_para455,4,,更一般的性能度量应该允许根据不同世界状态的“快乐”程度对智能体进行比较。
chap1_para455,5,,经济学家和计算机科学家通常用效用（utility）这个词来代替“快乐”，因为“快乐”听起来不是很科学。
chap1_para455,6,,[7]
chap1_para457,1,,[7]　这里的“utility”一词指的是“实用的品质”，而不是电力公司或自来水厂等公共设施。
chap1_para458,1,,我们已经看到，性能度量会给任何给定的环境状态序列打分，因此它可以很容易地区分到达出租车目的地所采取的更可取和更不可取的方式。
chap1_para458,2,,智能体的效用函数（utility function）本质上是性能度量的内部化。
chap1_para458,3,,如果内部效用函数和外部性能度量一致，那么根据外部性能度量选择动作，以使其效用最大化的智能体是理性的。
chap1_para459,1,,再次强调，这不是理性的唯一实现方式，我们已经看到了一个适用于真空吸尘器世界的理性智能体程序（图2-8），但并不知道它的效用函数是什么。
chap1_para459,2,,与基于目标的智能体一样，基于效用的智能体在灵活性和学习方面有很多优势。
chap1_para459,3,,此外，在两种情况下，仅靠目标是不充分的，但基于效用的智能体仍然可以做出理性的决策。
chap1_para459,4,,首先，当存在相互冲突的目标时，只能实现其中的一部分（例如速度和安全），效用函数会进行适当的权衡。
chap1_para459,5,,其次，当智能体有多个目标实现，但没有一个目标可以确定地实现时，效用提供了一种方法，可以权衡目标的重要性和成功的可能性。
chap1_para46,1,1.,人为定义的任务，如国际象棋或最短路径计算之类的，都附带固有的目标，因此标准模型是适用的。
chap1_para46,2,2.,然而，在真实世界中，我们越来越难以完全正确地指定目标。
chap1_para46,3,1Philosophy,例如，在设计自动驾驶汽车时，我们可能会认为目标是安全到达目的地。
chap1_para46,4,,但是，由于存在其他司机失误、设备故障等原因，在任何道路上行驶都有可能受伤，因此，严格的安全目标是要求待在车库里而不要上路驾驶。
chap1_para46,5,,向目的地前进和承担受伤风险是需要权衡的，应该如何进行这种权衡？
chap1_para46,6,,此外，我们能在多大程度上允许汽车采取会惹恼其他司机的行动？
chap1_para46,7,,汽车应该在多大程度上调控其加速、转向和刹车动作，以避免摇晃乘客？
chap1_para46,8,,这类问题很难预先回答。
chap1_para46,9,,在人机交互的整个领域，这些问题尤其严重，自动驾驶只是其中一个例子。
chap1_para460,1,,部分可观测性和非确定性在真实世界中普遍存在，因此，不确定性下的决策也普遍存在。
chap1_para460,2,,从技术上讲，基于效用的理性智能体会选择能够最大化其动作结果期望效用（expected utility）的动作，也就是在给定每个结果的概率和效用的情况下，智能体期望得到的平均效用（附录A更精确地定义了期望）。
chap1_para460,3,,在第16章中，我们证明，任何理性智能体的行为都必须表现得好像拥有一个效用函数，并试图最大化其期望值。
chap1_para460,4,,具有显式效用函数的智能体可以使用通用算法做出理性决策，该算法不依赖于特定效用函数的最大化。
chap1_para460,5,,通过这种方式，理性的“全局”定义（将那些具有最高性能的智能体函数指定为理性）变成了对理性智能体设计的“局部”约束，并可以通过一个简单的程序来表示。
chap1_para461,1,,基于效用的智能体结构如图2-14所示。
chap1_para461,2,,基于效用的智能体程序见第16章和第17章，其中设计了决策型智能体，必须处理非确定性或部分可观测环境中固有的不确定性。
chap1_para461,3,,如第18章所述，多智能体环境中的决策也在效用理论的框架下进行了研究。
chap1_para462,1,,图2-14　基于模型、基于效用的智能体。
chap1_para462,2,,它使用了一个世界模型以及一个效用函数来衡量它在各状态之间的偏好，然后选择产生最佳期望效用的动作，其中期望效用是通过对所有可能的结果状态和对应概率加权所得
chap1_para463,1,,说到这里，读者可能会想，“这么简单吗？
chap1_para463,2,,只需要构建能够最大化期望效用的智能体，我们就完成了？
chap1_para463,3,,”这类智能体确实是智能的，但这并不简单。
chap1_para463,4,,基于效用的智能体必须对其环境进行建模和跟踪，这些任务涉及大量关于感知、表示、推理和学习的研究。
chap1_para463,5,,这些研究结果填满了本书的许多章节。
chap1_para463,6,,选择效用最大化的行动方案也是一项艰巨的任务，需要更多的章节描述精巧的算法。
chap1_para463,7,,即使使用这些算法，由于计算复杂性，完美理性在实践中通常是无法实现的（正如我们在第1章中所指出的）。
chap1_para463,8,,我们还应该注意到，并非所有基于效用的智能体都是基于模型的。
chap1_para463,9,,我们将在第22章和第26章中看到，无模型的智能体（model-free agent）可以学习在特定情况下什么样的动作是最好的，而不必确切地了解该动作如何改变环境。
chap1_para464,1,,最后，所有这些都假设设计者能够正确地指定效用函数，第17章、第18章和第22章将更深入讨论未知效用函数的问题。
chap1_para465,1,,2.4.6　学习型智能体
chap1_para466,1,,我们已经描述了一些智能体程序和选择动作的方法。
chap1_para466,2,,到目前为止，我们还没有解释智能体程序是如何产生的。
chap1_para466,3,,在图灵（Turing，1950）早期的著名论文中，他考虑手动编程实现智能机器的想法。
chap1_para466,4,,他估计了这可能需要多少工作量，并得出结论，“似乎需要一些更快捷的方法”。
chap1_para466,5,,他提出的方法是构造学习型机器，然后教它们。
chap1_para466,6,,在人工智能的许多领域，这是目前创建最先进系统的首选方法。
chap1_para466,7,,任何类型的智能体（基于模型、基于目标、基于效用等）都可以构建（或不构建）成学习型智能体。
chap1_para467,1,,正如我们之前提到的，学习还有另一个优势：它让智能体能够在最初未知的环境中运作，并变得比其最初的知识可能允许的能力更强。
chap1_para467,2,,在本节中，我们简要介绍学习型智能体的主要思想。
chap1_para467,3,,在整本书中，我们对特定类型智能体中的学习因素和方法的评论贯穿全书。
chap1_para467,4,,第19～22章将更加深入地介绍学习算法本身。
chap1_para468,1,,学习型智能体可分为4个概念组件，如图2-15所示。
chap1_para468,2,,最重要的区别在于负责提升的学习元素（learning element）和负责选择外部行动的性能元素（performance element）。
chap1_para468,3,,性能元素是我们之前认为的整个智能体：它接受感知并决定动作。
chap1_para468,4,,学习元素使用来自评估者（critic）对智能体表现的反馈，并以此确定应该如何修改性能元素以在未来做得更好。
chap1_para469,1,,图2-15　通用学习型智能体。
chap1_para469,2,,“性能元素”框表示我们之前认为的整个智能体程序，现在“学习元素”框可以修改该程序以提升其性能
chap1_para47,1,•Can formal rules be used to draw valid conclusions?,在我们的真实需求和施加给机器的目标之间达成一致的问题称为价值对齐问题（value alignment problem），即施加给机器的价值或目标必须与人类的一致。
chap1_para47,2,,如果我们在实验室或模拟器中开发人工智能系统（就像该领域的大多数历史案例一样），就可以轻松地解决目标指定不正确的问题：重置系统、修复目标然后重试。
chap1_para47,3,,随着人工智能的发展，越来越强大的智能系统需要部署在真实世界中，这种方法不再可行。
chap1_para47,4,,部署了错误目标的系统将会导致负面影响，而且，系统越智能，其负面影响就越严重。
chap1_para470,1,,学习元素的设计在很大程度上取决于性能元素的设计。
chap1_para470,2,,当设计者试图设计一个学习某种能力的智能体时，第一个问题不是“我要如何让它学习这个？
chap1_para470,3,,”而是“一旦智能体学会了如何做，它将使用什么样的性能元素？
chap1_para470,4,,”给定性能元素的设计，可以构造学习机制来改进智能体的每个部分。
chap1_para471,1,,评估者告诉学习元素：智能体在固定性能标准方面的表现如何。
chap1_para471,2,,评估者是必要的，因为感知本身并不会指示智能体是否成功。
chap1_para471,3,,例如，国际象棋程序可能会收到一个感知，提示它已将死对手，但它需要一个性能标准来知道这是一件好事；感知本身并没有这么说。
chap1_para471,4,,确定性能标准很重要。
chap1_para471,5,,从概念上讲，应该把它看作完全在智能体之外，因为智能体不能修改性能标准以适应自己的行为。
chap1_para472,1,,学习型智能体的最后一个组件是问题生成器（problem generator）。
chap1_para472,2,,它负责建议动作，这些动作将获得全新和信息丰富的经验。
chap1_para472,3,,如果性能元素完全根据自己的方式，它会继续选择已知最好的动作。
chap1_para472,4,,但如果智能体愿意进行一些探索，并在短期内做一些可能不太理想的动作，那么从长远来看，它可能会发现更好的动作。
chap1_para472,5,,问题生成器的工作是建议这些探索性行动。
chap1_para472,6,,这就是科学家在进行实验时所做的。
chap1_para472,7,,伽利略并不认为从比萨斜塔顶端扔石头本身有价值。
chap1_para472,8,,他并不是想要打碎石头或改造不幸行人的大脑。
chap1_para472,9,,他的目的是通过确定更好的物体运动理论来改造自己的大脑。
chap1_para473,1,,学习元素可以对智能体图（图2-9、图2-11、图2-13和图2-14）中显示的任何“知识”组件进行更改。
chap1_para473,2,,最简单的情况是直接从感知序列学习。
chap1_para473,3,,观察成对相继的环境状态可以让智能体了解“我的动作做了什么”以及“世界如何演变”以响应其动作。
chap1_para473,4,,例如，如果自动驾驶出租车在湿滑路面上行驶时进行一定程度的刹车，那么它很快就会发现实际减速多少，以及它是否滑出路面。
chap1_para473,5,,问题生成器可能会识别出模型中需要改进的某些部分，并建议进行实验，例如在不同条件下的不同路面上尝试刹车。
chap1_para474,1,,无论外部性能标准如何，改进基于模型的智能体的组件，使其更好地符合现实几乎总是一个好主意。
chap1_para474,2,,（从计算的角度来看，在某些情况下简单但稍微不准确的模型比完美但极其复杂的模型更好。
chap1_para474,3,,）当智能体试图学习反射组件或效用函数时，需要外部标准的信息。
chap1_para475,1,,例如，假设出租车司机因为乘客在旅途中感到非常不适，没有收到小费。
chap1_para475,2,,外部性能标准必须告知智能体，小费的损失对其整体性能有负面影响；然后，该智能体可能会了解到暴力操作有损其自身的效用。
chap1_para475,3,,从某种意义上说，性能标准将传入感知的一部分区分为奖励（reward）或惩罚（penalty），以提供对智能体行为质量的直接反馈。
chap1_para475,4,,动物的疼痛和饥饿等固有的性能标准可以通过这种方式理解。
chap1_para476,1,,更一般地说，人类的选择可以提供有关人类偏好的信息。
chap1_para476,2,,例如，假设出租车不知道人们通常不喜欢噪声，于是决定不停地按喇叭以确保行人知道它即将到来。
chap1_para476,3,,随之而来的人类行为，如盖住耳朵、说脏话甚至可能剪断喇叭上的电线，将为智能体提供更新其效用函数的证据。
chap1_para476,4,,这个问题将在第22章进一步讨论。
chap1_para477,1,,总之，智能体有各种各样的组件，这些组件可以在智能体程序中以多种方式表示，因此学习方法之间似乎存在很大差异。
chap1_para477,2,,然而，主题仍然是统一的：智能体中的学习可以概括为对智能体的各个组件进行修改的过程，使各组件与可用的反馈信息更接近，从而提升智能体的整体性能。
chap1_para478,1,,2.4.7　智能体程序的组件如何工作
chap1_para479,1,,我们已经将智能体程序（用非常高级的术语）描述为由各种组件组成，其功能是回答诸如“现在的世界是什么样的？
chap1_para479,2,,”“我现在应该采取什么动作？
chap1_para479,3,,”“我的动作将导致什么？
chap1_para479,4,,”等问题。
chap1_para479,5,,人工智能学生的下一个问题是，“这些组件究竟是如何工作的？
chap1_para479,6,,”要正确回答这个问题大约需要一千页的篇幅，但在这里我们希望读者能够注意一些基本区别，即组件表示智能体所处环境的各种方式之间的区别。
chap1_para48,1,•How does the mind arise from a physical brain?,回想看似没有问题的国际象棋案例，想象一下，如果机器足够智能，可以推断并采取超出棋盘限制的动作，会发生什么。
chap1_para48,2,,例如，它可能试图通过催眠或勒索对手，或贿赂观众在对手思考时发出噪声等手段来增加获胜的机会。
chap1_para48,3,,[4]它也可能会为自己劫持额外的计算能力。
chap1_para48,4,,这些行为不是“愚蠢”或“疯狂”的，这些行为是将获胜定义为机器唯一目标的逻辑结果。
chap1_para480,1,,粗略地说，我们可以通过一个复杂性和表达能力不断增加的横轴来描述表示，即原子表示、因子化表示和结构化表示。
chap1_para480,2,,为了辅助说明这些观点，我们可以考虑特定的智能体组件，例如处理“我的动作会导致什么”。
chap1_para480,3,,这个组件描述了作为采取动作的结果可能在环境中引起的变化，图2-16展示了如何表示这些转移的示意图。
chap1_para481,1,,在原子表示（atomic representation）中，世界的每一个状态都是不可分割的，它没有内部结构。
chap1_para481,2,,考虑这样一个任务：通过城市序列找到一条从某个国家的一端到另一端的行车路线（我们在图3-1中会解决这个问题）。
chap1_para481,3,,为了解决这个问题，将世界状态简化为所处城市的名称就足够了，这就是单一的知识原子，也是一个“黑盒”，它唯一可分辨的属性是与另一个黑盒相同或不同。
chap1_para481,4,,搜索和博弈中的标准算法（第3～5章）、隐马尔可夫模型（第14章）以及马尔可夫决策过程（第17章）都基于原子表示。
chap1_para482,1,,因子化表示（factored representation）将每个状态拆分为一组固定的变量或属性，每个变量或属性都可以有一个值。
chap1_para482,2,,考虑同一驾驶问题更真实的描述，即我们需要关注的不仅仅是一个城市或另一个城市的原子位置，可能还需要关注油箱中的汽油量、当前的GPS坐标、油量警示灯是否工作、通行费、收音机上的电台等。
chap1_para482,3,,两个不同的原子状态没有任何共同点（只是不同的黑盒），但两个不同的因子化状态可以共享某些属性（如位于某个特定的GPS位置），而其他属性不同（如有大量汽油或没有汽油），这使得研究如何将一种状态转换为另一种状态变得更加容易。
chap1_para482,4,,人工智能的许多重要领域都基于因子化表示，包括约束满足算法（第6章）、命题逻辑（第7章）、规划（第11章）、贝叶斯网络（第12～16章）以及各种机器学习算法。
chap1_para483,1,,图2-16　表示状态及其之间转移的3种方法：（a）原子表示一个状态（如B或C）是没有内部结构的黑盒；（b）因子化表示状态由属性值向量组成，值可以是布尔值、实值或一组固定符号中的一个；（c）结构化表示状态包括对象，每个对象可能有自己的属性以及与其他对象的关系
chap1_para484,1,,出于许多目的，我们需要将世界理解为存在着相互关联的事物，而不仅仅是具有值的变量。
chap1_para484,2,,例如，我们可能会注意到前面有一辆卡车正在倒车进入一个奶牛场的车道，但一头散养的奶牛挡住了卡车的路。
chap1_para484,3,,因子化表示不太可能为属性TruckAheadBackingIntoDairyFarmDrivewayBlockedByLooseCow预先配备true或false的值。
chap1_para484,4,,这就需要一个结构化表示（structured representation），在这种表示中可以明确地描述诸如奶牛和卡车之类的对象及其各种不同的关系（见图2-16c）。
chap1_para484,5,,结构化表示是关系数据库和一阶逻辑（第8～10章）、一阶概率模型（第15章）和大部分自然语言理解（第23章和第24章）的基础。
chap1_para484,6,,事实上，人类用自然语言表达的大部分内容都与对象及其关系有关。
chap1_para485,1,,如前所述，原子表示、因子化表示和结构化表示所在的轴是表达性（expressiveness）增强的轴。
chap1_para485,2,,粗略地说，可以通过简洁的描述捕捉到更具表达性的表示，表达性差的表示也可以捕捉到一切，但需要更多描述。
chap1_para485,3,,通常，表达性更强的语言更简洁；例如，国际象棋规则可以用一两页结构化表示语言（如一阶逻辑）来描述，但需要数千页因子化表示语言（如命题逻辑）来描述，而需要1038页的原子语言（如有限状态自动机）来描述。
chap1_para485,4,,但是，随着表示能力的增强，推理和学习变得更加复杂。
chap1_para485,5,,为了在避免缺点的同时获得表达性表示的好处，真实世界中的智能系统可能需要轴上的所有点同时运行。
chap1_para486,1,,另一个表示轴涉及从概念到物理记忆中位置的映射，包括计算机的内存和大脑的记忆。
chap1_para486,2,,如果概念和记忆位置之间存在一对一的映射，我们称之为局部表示（localist representation）。
chap1_para486,3,,但是，如果一个概念的表示分布在多个记忆位置，并且每个记忆位置被用作多个不同概念表示的一部分，我们称之为分布式表示（distributed representation）。
chap1_para486,4,,分布式表示对噪声和信息丢失更健壮。
chap1_para486,5,,使用局部表示，从概念到记忆位置的映射是随机的，如果传输错误而导致几位乱码，我们可能会将卡车（Truck）与无关的概念停战（Truce）混淆。
chap1_para486,6,,但在分布式表示中，可以把每个概念想象成多维空间中的一个点，即使有一些乱码，也会移动到该空间中附近的点，其具有相似的含义。
chap1_para488,1,,本章是人工智能的旋风之旅，在这个过程中我们认为人工智能是智能体设计的科学。
chap1_para488,2,,本章要回顾的要点如下。
chap1_para489,1,,● 智能体是在环境中感知和行动的事物。
chap1_para489,2,,智能体的智能体函数指定智能体在响应任意感知序列时所采取的动作。
chap1_para49,1,•Where does knowledge come from?,
chap1_para490,1,,● 性能度量评估智能体在环境中的行为。
chap1_para490,2,,给定到目前为止所看到的感知序列，理性智能体的动作是为了最大化性能度量的期望值。
chap1_para491,1,,● 任务环境规范包括性能度量、外部环境、执行器和传感器。
chap1_para491,2,,在设计智能体时，第一步必须始终是尽可能完整地指定任务环境。
chap1_para492,1,,● 任务环境在几个重要维度上有所不同。
chap1_para492,2,,它们可以是完全可观测的或部分可观测的、单智能体的或多智能体的、确定性的或非确定性的、回合式的或序贯的、静态的或动态的、离散的或连续的、已知的或未知的。
chap1_para493,1,,● 在性能度量未知或难以正确指定的情况下，智能体优化错误目标的风险很大。
chap1_para493,2,,在这种情况下，智能体设计应该反映真实目标的不确定性。
chap1_para494,1,,● 智能体程序实现智能体函数。
chap1_para494,2,,存在各种基本的智能体编程，反映了决策过程中明确使用的信息类型。
chap1_para494,3,,这些设计在效率、紧凑性和灵活性方面各不相同。
chap1_para494,4,,智能体程序的适当设计取决于环境的性质。
chap1_para495,1,,● 简单反射型智能体直接响应感知，而基于模型的反射型智能体保持内部状态以跟踪当前感知中不明晰的世界状态。
chap1_para495,2,,基于目标的智能体采取行动来实现目标，而基于效用的智能体试图最大化自己期望的“快乐”。
chap1_para496,1,,● 所有智能体都可以通过学习提升性能。
chap1_para5,1,1.,1.1　什么是人工智能
chap1_para5,2,1What Is AI?,
chap1_para50,1,•How does knowledge lead to action?,"[4]　鲁伊·洛佩兹（Ruy Lopez）在最早的一本关于国际象棋的书（Lopez, 1561）中写道：“把棋盘放好，让阳光晃进对手的眼睛。"
chap1_para50,2,,”
chap1_para500,1,,第3章　通过搜索进行问题求解
chap1_para501,1,,在本章中，我们讨论一个智能体是如何向前搜索，找到一个动作序列来实现它的最终目标。
chap1_para502,1,,当要采取的正确动作不是很明显时，智能体可能需要提前规划：考虑一个形成通往目标状态路径的动作序列。
chap1_para502,2,,这样的智能体被称为问题求解智能体（problem-solving agent），它所进行的计算过程被称为搜索（search）。
chap1_para503,1,,如2.4.7节所述，问题求解智能体使用原子（atomic）表示，也就是说，世界状态被视为一个整体，其内部结构对问题求解算法来说是不可见的。
chap1_para503,2,,使用状态的因子化（factored）表示或结构化（structured）表示的智能体称为规划智能体（planning agent），第7章和第11章中将会讨论。
chap1_para504,1,,我们将在本书中介绍若干搜索算法。
chap1_para504,2,,在本章中，我们将只考虑最简单的环境，即回合式的、单智能体的、完全可观测的、确定性的、静态的、离散的和已知的环境，并对有信息（informed）算法和无信息（uninformed）算法进行区分。
chap1_para504,3,,在有信息算法中，智能体可以估计自己到目标的距离，而在无信息算法中不能进行这样的估计。
chap1_para504,4,,第4章会讨论更一般的环境中的问题，第5章则考虑了多智能体的情形。
chap1_para505,1,,本章使用了渐近复杂性的概念（即O(n)表示法）。
chap1_para505,2,,不熟悉这些概念的读者可以参阅附录A。
chap1_para506,1,,3.1　问题求解智能体
chap1_para507,1,,想象一下，一个智能体正在罗马尼亚度假。
chap1_para507,2,,它想参观景点，想学习罗马尼亚语，想享受罗马尼亚的夜生活但又不想宿醉，等等。
chap1_para507,3,,这一决策问题是复杂的。
chap1_para507,4,,现在，假设智能体目前位于Arad，并且买了一张第二天从Bucharest起飞且不能退款的机票。
chap1_para507,5,,智能体观察路牌后发现，从Arad出发有3条路：一条通往Sibiu，一条通往Timisoara，还有一条通往Zerind。
chap1_para507,6,,但这都不是它的目的地，所以除非智能体熟悉罗马尼亚的地理环境，不然它不知道该走哪条路。
chap1_para507,7,,[1]
chap1_para509,1,,[1]　我们假设大多数读者都处于同样的处境，并且很容易想象自己和智能体一样毫无头绪。
chap1_para509,2,,我们向不能利用这一教学安排的罗马尼亚读者道歉，因为他们清楚地知晓哪条路更易到达Bucharest。
chap1_para51,1,"Aristotle (384–322 BCE) was the first to formulate a precise set of laws governing the rational part of the mind. He developed an informal system of syllogisms for proper reasoning, which in principle allowed one to generate conclusions mechanically, given initial premises.",一台实现固定目标的机器可能会出现很多不当行为，要预测所有不当行为是不可能的。
chap1_para51,2,,因此，我们有足够理由认为标准模型是不充分的。
chap1_para51,3,,我们不希望机器“聪明”地实现它们的目标，而是希望它们实现我们的目标。
chap1_para51,4,,如果我们不能将这些目标完美地传达给机器，就需要一个新的表述，也就是机器正在实现我们的目标，但对于目标是什么则是不确定的。
chap1_para51,5,,当一台机器意识到它不了解完整的目标时，它就会有谨慎行动的动机，会寻求许可，并通过观察来更多地了解我们的偏好，遵守人为控制。
chap1_para51,6,,最终，我们想要的是对人类可证益的（provably beneficial）智能体。
chap1_para51,7,,我们将在1.5节中讨论这个主题。
chap1_para510,1,,如果智能体没有额外信息，也就是说，如果环境是未知的（unknown），那么智能体只能随机执行一个动作。
chap1_para510,2,,这种情况将在第4章讨论。
chap1_para510,3,,在本章中，我们假设智能体总是能够访问与世界相关的信息，例如图3-1中的地图。
chap1_para510,4,,有了这些信息，智能体可以执行以下4个阶段的问题求解过程。
chap1_para511,1,,● 目标形式化（goal formulation）：智能体的目标为到达Bucharest。
chap1_para511,2,,目标通过限制智能体的目的和需要考虑的动作来组织其行为。
chap1_para512,1,,图3-1　罗马尼亚部分地区的简化道路图，道路距离单位为英里（1英里 = 1.61千米）
chap1_para513,1,,● 问题形式化（problem formulation）：智能体刻画实现目标所必需的状态和动作——进而得到这个世界中与实现目标相关的部分所构成的抽象模型。
chap1_para513,2,,对智能体来说，一个好的模型应该考虑从一个城市到其相邻城市的动作，这时，状态中只有“当前所在城市”会由于动作而改变。
chap1_para514,1,,● 搜索（search）：在真实世界中采取任何动作之前，智能体会在其模型中模拟一系列动作，并进行搜索，直到找到一个能到达目标的动作序列。
chap1_para514,2,,这样的序列称为解（solution）。
chap1_para514,3,,智能体可能不得不模拟多个无法到达目标的序列，但最终它要么找到一个解（例如从Arad到Sibiu到Fagaras再到Bucharest），要么发现问题是无解的。
chap1_para515,1,,● 执行（execution）：现在智能体可以执行解中的动作，一次执行一个动作。
chap1_para516,1,,一个重要的性质是，在一个完全可观测的、确定性的、已知的环境中，任何问题的解都是一个固定的动作序列：开车到Sibiu，然后到Fagaras，最后到达Bucharest。
chap1_para516,2,,如果模型是正确的，那么一旦智能体找到了一个解，它就可以在执行动作时忽略它的感知（“闭上眼睛”），因为解一定会到达目标。
chap1_para516,3,,控制理论家称之为开环（open-loop）系统，因为忽略感知打破了智能体和环境之间的环路。
chap1_para516,4,,如果模型有可能是不正确的，或者环境是非确定性的，那么监控感知的闭环（closed-loop）方法会更安全（见4.4节）。
chap1_para517,1,,在部分可观测或非确定性环境中，问题的解将是一个根据感知推荐不同的未来动作的分支策略。
chap1_para517,2,,例如，智能体可能规划从Arad开车到Sibiu，但还需要一个应变规划，以防它不小心到了Zerind或者发现了“Drum Închis”（道路封闭）的标志。
chap1_para518,1,,3.1.1　搜索问题和解
chap1_para519,1,,搜索问题（problem）的形式化定义如下。
chap1_para52,1,Ramon Llull (c. 1232–1315) devised a system of reasoning published as Ars Magna or The Great Art (1305). Llull tried to implement his system using an actual mechanical device: a set of paper wheels that could be rotated into different permutations.,1.2　人工智能的基础
chap1_para520,1,,● 可能的环境状态（state）的集合，我们称之为状态空间（state space）。
chap1_para521,1,,● 智能体启动时的初始状态（initial state），例如Arad。
chap1_para522,1,,● 一个或多个目标状态（goal state）的集合。
chap1_para522,2,,有时问题只有一个目标状态（如Bucharest），有时存在若干个可供选择的目标状态，也有时目标是由一个适用于许多状态（可能是无限多个状态）的属性所定义的。
chap1_para522,3,,例如，在一个真空吸尘器世界里，目标可能是让任何位置都没有灰尘，而无论该状态的其他情况如何。
chap1_para522,4,,我们通过给问题指定一个Is-Goal方法来将这3种可能性都考虑在内。
chap1_para522,5,,在本章中，为了简单起见，我们有时会直接用“目标”一词，它表示“任一可能的目标状态”。
chap1_para523,1,,● 智能体可以采取的行动（action）。
chap1_para523,2,,给定一个状态s，Actions(s)将返回在s中可以执行的有限[2]动作集合。
chap1_para523,3,,我们称集合中的任一动作在s中都是适用的（applicable）。
chap1_para523,4,,例如：
chap1_para525,1,,[2]　对于具有无限多个动作的问题，我们需要本章之外的其他技巧。
chap1_para526,1,,● 转移模型（transition model）用于描述每个动作所起到的作用。
chap1_para526,2,,"Result(s, a)将返回在状态s中执行动作a所产生的状态。"
chap1_para526,3,,例如：
chap1_para527,1,,"● 动作代价函数（action cost function），在编程中记作Action-Cost(s, a, s' )，在数学运算中记作c(s, a, s' )。"
chap1_para527,2,,它给出了在状态s中执行动作a从而转移到状态s'的数值代价。
chap1_para527,3,,问题求解智能体应该使用反映其自身性能指标的代价函数；例如，对于寻径智能体，动作代价可能是以英里为单位的长度（如图3-1所示），也可能是完成动作所花费的时间。
chap1_para528,1,,一个动作序列形成一条路径（path），而解（solution）是一条从初始状态到某个目标状态的路径。
chap1_para528,2,,我们假设动作代价是可累加的；也就是说，一条路径的总代价是各个动作代价的总和。
chap1_para528,3,,最优解（optimal solution）是所有解中路径代价最小的解。
chap1_para528,4,,在本章中，我们假设所有的动作代价都为正，以减少复杂性。
chap1_para528,5,,[3]
chap1_para53,1,"Around 1500, Leonardo da Vinci (1452–1519) designed but did not build a mechanical calculator; recent reconstructions have shown the design to be functional. The first known calculating machine was constructed around 1623 by the German scientist Wilhelm Schickard (1592–1635). Blaise Pascal (1623–1662) built the Pascaline in 1642 and wrote that it “produces effects which appear nearer to thought than all the actions of animals.” Gottfried Wilhelm Leibniz (1646–1716) built a mechanical device intended to carry out operations on concepts rather than numbers, but its scope was rather limited. In his 1651 book Leviathan, Thomas Hobbes (1588–1679) suggested the idea of a thinking machine, an “artificial animal” in his words, arguing “For what is the heart but a spring; and the nerves, but so many strings; and the joints, but so many wheels.” He also suggested that reasoning was like numerical computation: “For ‘reason’ ... is nothing but ‘reckoning,’ that is adding and subtracting.”",在本节中，我们将简要介绍为人工智能提供思想、观点和技术的学科的历史。
chap1_para53,2,,像任何历史一样，本书只关注少数人物、事件和思想，而忽略其他同样重要的。
chap1_para53,3,,我们围绕一系列问题来组织这段历史。
chap1_para53,4,,我们不希望带给读者这样一种印象：这些问题是各个学科唯一要解决的问题，或者各个学科都将人工智能作为最终成果而努力。
chap1_para530,1,,[3]　在任何存在负代价环的问题中，代价最优解为在这个环中循环无限次。
chap1_para530,2,,不存在负代价环时，Bellman-Ford算法和Floyd-Warshall算法（本章暂未涉及）可以处理负代价动作。
chap1_para530,3,,只要连续的零代价动作的数量是有限的，处理零代价动作就很容易。
chap1_para530,4,,例如，假设有一个机器人，其移动的代价为正，但旋转90°的代价为0；只要连续旋转90°动作的数量不超过3个，本章的算法就可以处理这个问题。
chap1_para530,5,,存在无限多个任意小的动作代价的问题也很复杂。
chap1_para530,6,,考虑Zeno悖论的情况，存在一个动作，它每次向目标移动剩余距离的二分之一，代价为上一次移动代价的二分之一。
chap1_para530,7,,这个问题不存在动作数量有限的解，但为了防止搜索在没有完全到达目标的情况下采取无限数量的动作，我们可以要求所有动作的代价至少为，为某个较小的正值。
chap1_para531,1,,状态空间可以用图（graph）来表示，图中的顶点表示状态，顶点之间的有向边表示动作。
chap1_para531,2,,图3-1所示的罗马尼亚地图就是这样一个图，每条道路表示两种动作，即两个方向各表示一种。
chap1_para532,1,,3.1.2　问题形式化
chap1_para533,1,,我们将前文中去往Bucharest的问题形式化为一个模型（model）——一种抽象的数学描述，而不是真实存在的实物。
chap1_para533,2,,与简单的原子状态描述Arad相比，实际的旅行的世界状态包括很多内容：旅行伙伴、当时的广播节目、窗外的风景、附近是否有执法人员、到下一个休息站的距离、道路状况、天气、交通等。
chap1_para533,3,,所有这些因素都被排除在我们的模型之外，因为它们与寻找前往Bucharest的路线问题无关。
chap1_para534,1,,从表示中剔除细节的过程称为抽象（abstraction）。
chap1_para534,2,,一个良好的问题形式化应该具有适度的细节层次。
chap1_para534,3,,如果智能体的动作细化到“右脚向前移动1厘米”或“方向盘向左转动1度”的层次上，那它可能永远都找不到走出停车场的路，更不用说去Bucharest了。
chap1_para535,1,,我们能更精确地定义合适的抽象层级（level of abstraction）吗？
chap1_para535,2,,我们所选择的抽象状态和动作对应于大量具体的世界状态和动作序列。
chap1_para535,3,,现在考虑抽象问题的解，例如，从Arad到Sibiu，到Rimnicu Vilcea，到Pitesti，再到Bucharest的路径。
chap1_para535,4,,这个抽象解对应于大量更详细的路径。
chap1_para535,5,,例如，从Sibiu开往Rimnicu Vilcea的途中，我们可以打开收音机，而在其他的旅程中关掉收音机。
chap1_para536,1,,如果我们能够将任何抽象解细化为更详细的世界中的解，那么这种抽象就是合理的；一个充分条件是，对于“in Arad”的每个详细状态，都有一条到达“in Sibiu”状态的详细路径，以此类推。
chap1_para536,2,,[4]如果执行解中的每个动作都比原始问题更容易，那么抽象是有用的；在我们的示例中，“从Arad开车到Sibiu”的动作，任何一个一般水平的司机都可以在不进一步搜索或规划的情况下完成。
chap1_para536,3,,因此，选择一个好的抽象需要删除尽可能多的细节，同时保留合理性，并确保抽象动作易于执行。
chap1_para536,4,,如果没有构造有用的抽象的能力，智能体将被真实世界完全淹没。
chap1_para538,1,,[4]　参见11.4节。
chap1_para54,1,"It’s one thing to say that the mind operates, at least in part, according to logical or numerical rules, and to build physical systems that emulate some of those rules. It’s another to say that the mind itself is such a physical system. René Descartes (1596–1650) gave the first clear discussion of the distinction between mind and matter. He noted that a purely physical conception of the mind seems to leave little room for free will. If the mind is governed entirely by physical laws, then it has no more free will than a rock “deciding” to fall downward. Descartes was a proponent of dualism. He held that there is a part of the human mind (or soul or spirit) that is outside of nature, exempt from physical laws. Animals, on the other hand, did not possess this dual quality; they could be treated as machines.",
chap1_para540,1,,问题求解的方法已被应用于大量任务环境中。
chap1_para540,2,,我们在这里列出一些典型问题，区分为标准化问题和真实世界问题。
chap1_para540,3,,标准化问题（standardized problem）常用于说明或训练各种问题求解方法。
chap1_para540,4,,它具有简洁、准确的描述，因此适合作为研究人员比较算法性能的基准。
chap1_para540,5,,真实世界问题（real-world problem），如机器人导航，则意味着这一问题的解是人们实际使用的，且问题的形式化是独特的而非标准化的，因为例如在机器人导航问题中，每个机器人具有不同的传感器，产生不同的数据。
chap1_para541,1,,3.2.1　标准化问题
chap1_para542,1,,网格世界（grid world）问题是一个由正方形单元格组成的二维矩形阵列，在这个阵列中，智能体可以从一个单元格移动到另一个单元格。
chap1_para542,2,,一般来说，智能体可以水平或垂直地移动到任何无障碍的相邻单元格，在某些问题中还可以沿对角线移动。
chap1_para542,3,,单元格中可以包含智能体能拿起、推开或施加其他动作的物体，也可以存在阻止智能体进入单元格内的墙壁或其他不可逾越的障碍。
chap1_para542,4,,2.1节中的真空吸尘器世界（vacuum world）可以表示为一个网格世界问题。
chap1_para543,1,,● 状态：即哪些对象在哪些单元格中。
chap1_para543,2,,在真空吸尘器世界中，对象就是智能体和灰尘。
chap1_para543,3,,对于只有两个单元格的简单情形，智能体可以位于这两个单元格中的任何一个，每个单元格都可能存在灰尘，所以共有2×2×2 = 8个状态（见图3-2）。
chap1_para543,4,,一般来说，存在n个单元格的真空吸尘器环境有n×2n 个状态。
chap1_para544,1,,● 初始状态：任一状态都可以被指定为初始状态。
chap1_para545,1,,● 动作：在只有两个单元格的情形中，我们可以定义3种动作，即吸尘（Suck）、向左（Left）移动和向右（Right）移动。
chap1_para545,2,,在二维多单元格世界中，我们则需要更多种移动动作。
chap1_para545,3,,我们可以增加向上（Upward）和向下（Downward）的动作，从而得到4种绝对的（absolute）移动动作，或者可以将其转换为以自我为中心的动作，即从相对于智能体的角度来定义，例如，向前（Forward）、向后（Backward）、右转（TurnRight）和左转（TurnLeft）。
chap1_para546,1,,● 转移模型：Suck将去除单元格内的任何灰尘；Forward将智能体朝它所面对的方向向前移动一个单元格，除非它撞到墙（在这种情况下，这个行动不起作用）。
chap1_para546,2,,Backward让智能体朝相反的方向移动一个单元格，而TurnRight和TurnLeft则将智能体的朝向旋转90°。
chap1_para547,1,,● 目标状态： 每个单元格都保持干净的状态。
chap1_para548,1,,● 动作代价： 每个动作的代价都是1。
chap1_para549,1,,图3-2　两个单元格的真空吸尘器世界的状态空间图。
chap1_para549,2,,共有8个状态，每个状态有3种动作：L = Left（向左）、R = Right（向右）、S = Suck（吸尘）
chap1_para55,1,"An alternative to dualism is materialism, which holds that the brain’s operation according to the laws of physics constitutes the mind. Free will is simply the way that the perception of available choices appears to the choosing entity. The terms physicalism and naturalism are also used to describe this view that stands in contrast to the supernatural.",● 可以使用形式化规则得出有效结论吗？
chap1_para550,1,,另一种类型的网格世界是推箱子问题（sokoban puzzle），在这个问题中，智能体的目标是将一些散落在网格中的箱子推到指定的存储位置。
chap1_para550,2,,每个单元格最多容纳一个箱子。
chap1_para550,3,,当智能体向前移动到放有一个箱子的单元格，而箱子另一侧的单元格为空时，箱子和智能体都向前移动一格。
chap1_para550,4,,智能体不能把一个箱子推到另一个箱子上或墙上。
chap1_para550,5,,对于存在n个无障碍单元格和b个箱子的世界，共有个状态；例如，在一个存在12个箱子的8×8网格中，有超过200万亿个状态。
chap1_para551,1,,在滑块问题（sliding-tile puzzle）中，若干滑块（有时称为块或片）排列在一个有若干空白区域的网格中，其中滑块可以滑进空白区域。
chap1_para551,2,,它的一个变体是汽车华容道问题（Rush Hour puzzle），在这个问题中，我们需要在6×6的网格中滑动汽车和卡车，目标是将一辆汽车从交通堵塞中解救出来。
chap1_para551,3,,滑块问题中最著名的变体是8数码问题（8-puzzle）（见图3-3），它由一个3×3的网格、8个带编号的滑块和一个空格组成，目标是达到指定的状态，如图3-3中右侧所示。
chap1_para551,4,,类似的还有由4×4的网格组成的15数码问题（15-puzzle）。
chap1_para551,5,,对8数码问题做如下形式化处理。
chap1_para552,1,,● 状态：指定每个滑块位置的状态描述。
chap1_para553,1,,● 初始状态：任何状态都可以被指定为初始状态。
chap1_para553,2,,注意，可以根据奇偶性划分状态空间——任何给定目标都可以从恰好一半的可能初始状态到达（见习题 3.PART）。
chap1_para554,1,,● 动作：虽然在真实世界中是滑块在移动，但描述动作的最简单方法是假设空格执行Left、Right、Up或Down动作。
chap1_para554,2,,如果空格位于边缘或角落，则不是所有的动作都可用。
chap1_para555,1,,● 转移模型：将状态和动作映射为一个结果状态；例如，图3-3中，对于初始状态，我们采取Left动作，那么结果状态中滑块5和空格将交换位置。
chap1_para556,1,,● 目标状态：尽管任何状态都可以作为目标状态，但我们通常用有序编号指定目标状态，如图3-3所示。
chap1_para557,1,,● 动作代价：每个动作的代价都为1。
chap1_para558,1,,注意，每个问题的形式化都涉及抽象。
chap1_para558,2,,8数码问题中的动作被抽象为它们的开始状态和结束状态，忽略滑块滑动的中间位置。
chap1_para558,3,,我们已经通过抽象除去了一些动作，例如，当滑块被卡住时需要晃动木板，并排除了用刀取出滑块然后再放回去的可能性。
chap1_para558,4,,最终只剩下对规则的描述，避免了实际操作的所有细节。
chap1_para559,1,,图3-3　8数码问题的一个典型实例
chap1_para56,1,"Given a physical mind that manipulates knowledge, the next problem is to establish the source of knowledge. The empiricism movement, starting with Francis Bacon’s (1561–1626) Novum Organum,4 is characterized by a dictum of John Locke (1632–1704): “Nothing is in the understanding, which was not first in the senses.”",● 思维是如何从物质大脑中产生的？
chap1_para560,1,,"我们介绍的最后一个标准化问题是由高德纳（Knuth, 1964）设计的，它说明了无限状态空间是如何产生的。"
chap1_para560,2,,高德纳推测，通过只由平方根、向下取整和阶乘操作组成的序列可以从数字4得到任何正整数。
chap1_para560,3,,例如，我们可以这样从4得到5：
chap1_para561,1,,问题定义很简单，如下所述。
chap1_para564,1,,● 动作：应用平方根、向下取整或阶乘操作（阶乘仅用于整数）。
chap1_para565,1,,● 转移模型：根据运算的数学定义给出。
chap1_para566,1,,● 目标状态：所求的正整数。
chap1_para568,1,,这一问题的状态空间是无限的：对于任意大于2的整数，阶乘操作总是产生一个更大的整数。
chap1_para568,2,,这个问题很有趣，因为它探索了非常大的数字：从4到5的最短路径生成了数字(4!)! = 620 448 401 733 239 439 360 000。
chap1_para568,3,,无限状态空间经常出现在涉及数学表达式生成、电路、证明、程序和其他递归定义对象的任务中。
chap1_para569,1,,3.2.2　真实世界问题
chap1_para57,1,"David Hume’s (1711–1776) A Treatise of Human Nature (Hume, 1739) proposed what is now known as the principle of induction: that general rules are acquired by exposure to repeated associations between their elements.",
chap1_para570,1,,我们已经了解了如何根据指定的位置和沿着它们之间的边进行的位置转移来定义寻径问题（route-finding problem）。
chap1_para570,2,,寻径算法有许多应用场景。
chap1_para570,3,,其中一些是上文中罗马尼亚例子的直接扩展，例如提供导航的网站和车载系统等。
chap1_para570,4,,（需要考虑的主要复杂因素是因与交通相关的延迟而导致的代价变化，以及因道路封闭而导致的路线变更。
chap1_para570,5,,）另一些例如计算机网络中的视频流路由、军事行动规划和飞机航线规划系统等，则更加复杂。
chap1_para570,6,,下面介绍旅行规划网站必须解决的航空旅行问题。
chap1_para571,1,,● 状态：每个状态显然包括当前位置（例如，某个机场）和当前时间。
chap1_para571,2,,此外，由于每个动作（一个航段）的代价可能依赖于之前的航段、票价基础以及它们是国内航班还是国际航班，状态必须记录这些额外的“历史”信息。
chap1_para572,1,,● 初始状态：用户家所在的机场。
chap1_para573,1,,● 动作：在当前时间之后，从当前位置乘坐任意航班任意舱位起飞，如果需要，还要留出足够的时间在机场中转。
chap1_para574,1,,● 转移模型：乘坐航班产生的结果状态将航班的目的地作为新的当前位置，将航班的到达时间作为新的当前时间。
chap1_para575,1,,● 目标状态：目的地城市。
chap1_para575,2,,有时目标可能更复杂一点，例如“乘坐直达航班到达目的地”。
chap1_para576,1,,● 动作代价：金钱成本、等待时间、飞行时间、海关和入境手续、舱位质量、当日时间、飞机类型、常旅客奖励积分等的组合。
chap1_para577,1,,商业旅行咨询系统使用的就是上述问题的形式化。
chap1_para577,2,,不过，在处理航空公司错综复杂的票价结构时，还会有许多额外的复杂因素。
chap1_para577,3,,例如，任何有经验的旅行者都知道，并不是所有的航空旅行都能按计划进行。
chap1_para577,4,,因此，一个真正好的系统应该包括应变规划——如航班延误或者错过转机时的应对方案。
chap1_para578,1,,旅行问题（touring problem）描述的是一组必须访问的地点，而非单一目的地。
chap1_para578,2,,旅行商问题（traveling salesperson problem，TSP），就是一个旅行问题，即地图上每个城市都必须被访问。
chap1_para578,3,,其目标是找到代价小于C的旅行路线（在优化版本中，目标是找到代价最低的旅行路线）。
chap1_para578,4,,为了提高TSP算法的性能，科研人员付出了大量的努力。
chap1_para578,5,,该算法也可以扩展到处理车队问题。
chap1_para578,6,,"例如，规划波士顿校车路线的搜索优化算法为人们节约了500万美元，减少了交通拥堵和空气污染，同时还为司机和学生节省了时间（Bertsimas et al., 2019）。"
chap1_para578,7,,除了规划行程，搜索算法还被用于规划自动电路板钻孔机钻头的运动和装料机在车间内的移动等任务。
chap1_para579,1,,超大规模集成电路布图（VLSI layout）问题需要在一个芯片上定位数百万个元件和连接点，以最小化芯片面积、电路延迟和杂散电容，并最大化成品率。
chap1_para579,2,,布图问题在逻辑设计阶段之后，通常分为两个部分：单元布图（cell layout）和通道布线（channel routing）。
chap1_para579,3,,在单元布图中，电路的基本元件分组为若干单元，每个单元执行一些特定功能。
chap1_para579,4,,每个单元都有固定的占用区域（大小和形状），并且需要与其他每个单元建立一定数量的连接。
chap1_para579,5,,单元布图的目的是将单元彼此不重叠地放置在芯片上，并且单元之间有足够的空间布置连线。
chap1_para579,6,,通道布线的目的则是通过单元之间的间隙为每条导线寻找特定的路线。
chap1_para579,7,,这些搜索问题极其复杂，但绝对值得研究。
chap1_para58,1,"Building on the work of Ludwig Wittgenstein (1889–1951) and Bertrand Russell (1872–1970), the famous Vienna Circle (Sigmund, 2017), a group of philosophers and mathematicians meeting in Vienna in the 1920s and 1930s, developed the doctrine of logical positivism. This doctrine holds that all knowledge can be characterized by logical theories connected, ultimately, to observation sentences that correspond to sensory inputs; thus logical positivism combines rationalism and empiricism.",● 知识如何导致行为？
chap1_para580,1,,机器人导航（robot navigation）是寻径问题的一个推广。
chap1_para580,2,,机器人不必沿着明确的路径（如罗马尼亚的道路）行走，而是可以四处游走，实际上是自己走自己的路。
chap1_para580,3,,对于在平面上移动的圆形机器人，空间本质上是二维的。
chap1_para580,4,,当机器人的手臂和腿也必须受到控制时，搜索空间就变成了多维的——每个关节角都是一个维度。
chap1_para580,5,,为了使基本上连续的搜索空间变成有限空间，需要一些更先进的技术（见第26章）。
chap1_para580,6,,除了问题的复杂性外，真正的机器人还必须处理传感器读取错误、电动机控制中的错误、部分可观测性以及可能改变环境的其他智能体等问题。
chap1_para581,1,,自20世纪70年代以来，由机器人对复杂物体（例如电动机）进行自动装配排序（automatic assembly sequencing）已成为标准的工业实践。
chap1_para581,2,,算法首先找到一个可行的装配序列，然后对装配过程进行优化。
chap1_para581,3,,将装配线上的人工劳动减少到最低限度可以节省大量时间和成本。
chap1_para581,4,,装配问题的目标是找到某个对象的各个零件的组装顺序。
chap1_para581,5,,如果顺序错误，那么只能撤消某些已完成的工序，否则无法在序列的后面添加其他部分。
chap1_para581,6,,检查序列中动作的可行性是与机器人导航问题密切相关的几何搜索难题。
chap1_para581,7,,因此，合法动作的生成是装配排序问题中代价较高的部分。
chap1_para581,8,,任何实用算法都必须尽量避免探索全部的状态空间，而应只探索状态空间中的很小一部分。
chap1_para581,9,,一类重要的装配问题是蛋白质设计（protein design），其目的是找到一种氨基酸序列，该序列能够折叠成具有正确特性的三维蛋白质结构，以治疗某些疾病。
chap1_para583,1,,搜索算法（search algorithm）将搜索问题作为输入并返回问题的解或报告failure（当解不存在时）。
chap1_para583,2,,在本章中，我们考虑在状态空间图上叠加一棵搜索树（search tree）的算法，该算法从初始状态形成各条路径，并试图找到一条可以达到某个目标状态的路径。
chap1_para583,3,,搜索树中的每个节点（node）对应于状态空间中的一个状态，搜索树中的边对应于动作。
chap1_para583,4,,树的根对应于问题的初始状态。
chap1_para584,1,,理解状态空间和搜索树之间的区别非常重要。
chap1_para584,2,,状态空间描述了世界的（可能无限的）状态集，以及允许从一个状态转移到另一个状态的动作。
chap1_para584,3,,搜索树描述了这些状态之间通向目标的路径。
chap1_para584,4,,搜索树可以有多条路径（因此可以有多个节点）到达任何给定状态，但树中的每个节点都只有唯一一条返回根的路径（与所有树一样）。
chap1_para585,1,,图3-4展示了寻找从Arad到Bucharest的路径的前几步。
chap1_para585,2,,搜索树的根节点位于初始状态，Arad。
chap1_para585,3,,我们可以按如下方式扩展（expand）节点：考虑该状态的可用动作Actions，使用Result函数查看这些动作指向何处，并为每个结果状态生成（generating）一个新节点，称为子节点（child node）或后继节点（successor node）。
chap1_para585,4,,每个子节点的父节点（parent node）都是Arad。
chap1_para586,1,,图3-4　3棵部分搜索树，用于寻找从Arad到Bucharest的路线。
chap1_para586,2,,已扩展节点用淡紫色和粗体字母表示；边界上已生成但未被扩展的节点用绿色表示；对应于这两种类型节点的状态集被称为已达。
chap1_para586,3,,接下来可能生成的节点用虚线表示。
chap1_para586,4,,注意，在最下面的树中，有一个从Arad到Sibiu再到Arad的环，这不可能是最优路径，因此搜索不应该从那里继续
chap1_para587,1,,现在我们必须从这3个子节点中选择一个考虑下一步扩展。
chap1_para587,2,,这就是搜索的本质——先跟踪一个选项，之后再考虑其他选项。
chap1_para587,3,,假定我们选择先扩展Sibiu。
chap1_para587,4,,结果如图3-4中最下面的搜索树所示，我们得到了6个未被扩展的节点（以绿色节点显示）。
chap1_para587,5,,我们称之为搜索树的边界（frontier）。
chap1_para587,6,,任何已经生成过节点的状态都称为已达（reached）状态（无论该节点是否被扩展）。
chap1_para587,7,,[5]图3-5为叠加在状态空间图上的搜索树。
chap1_para589,1,,[5]　一些作者将边界称为开节点表，这在地理学上不太容易引起共鸣，在计算上也不太合适，因为在这里，队列比表更有效。
chap1_para589,2,,这些作者还使用闭节点表一词来指代之前已扩展的节点的集合，在我们的术语中，这些节点为已达节点去掉边界节点后的剩余节点。
chap1_para59,1,The confirmation theory of Rudolf Carnap (1891–1970) and Carl Hempel (1905–1997) attempted to analyze the acquisition of knowledge from experience by quantifying the degree of belief that should be assigned to logical sentences based on their connection to observations that confirm or disconfirm them. Carnap’s book The Logical Structure of the World (1928) was perhaps the first theory of mind as a computational process.,亚里士多德（Aristotle，公元前384—公元前322）制定了一套精确的法则来统御思维的理性部分，他是历史上第一位这样做的哲学家。
chap1_para59,2,,他发展了一套非正式的三段论系统进行适当的推理，该系统原则上允许人们在给定初始前提下机械地得出结论。
chap1_para590,1,,图3-5　由图3-1中的罗马尼亚问题的图搜索生成的搜索树序列。
chap1_para590,2,,在每一阶段，我们扩展边界上的每个节点，使用所有不指向已达状态的可用动作延伸每条路径。
chap1_para590,3,,需要注意的是，在第三阶段，最高位置的城市（Oradea）有两个后继城市，这两个城市都已经有其他路径到达，所以没有路径可以从Oradea延伸
chap1_para591,1,,注意，边界分离（separate）了状态空间图的两个区域，即内部区域（其中每个状态都已被扩展）和外部区域（尚未到达的状态）。
chap1_para591,2,,该属性如图3-6所示。
chap1_para592,1,,图3-6　以矩形网格问题为例说明图搜索的分离性质。
chap1_para592,2,,边界（绿色）分离了内部（淡紫色）和外部（虚线）。
chap1_para592,3,,边界是已达但尚未扩展的节点（及相应的状态）的集合；内部是已被扩展的节点（及相应的状态）的集合；外部是尚未到达的状态的集合。
chap1_para592,4,,在（a）中，只有根节点被扩展。
chap1_para592,5,,在（b）中，上面的边界节点被扩展。
chap1_para592,6,,在（c）中，按顺时针顺序扩展根节点的其他后继节点
chap1_para593,1,,3.3.1　最佳优先搜索
chap1_para594,1,,我们如何决定下一步从边界扩展哪个节点？
chap1_para594,2,,最佳优先搜索（best-first search）是一种非常通用的方法，在这种方法中，我们选择使得某个评价函数（evaluation function）f(n)的值最小的节点n。
chap1_para594,3,,算法如图3-7所示。
chap1_para594,4,,在每次迭代中，选择边界上具有最小f(n)值的一个节点，如果它的状态是目标状态，则返回这个节点，否则调用Expand生成子节点。
chap1_para594,5,,对于每个子节点，如果之前未到达过该子节点，则将其添加到边界；如果到达该子节点的当前路径的代价比之前任何路径都要小，则将其重新添加到边界。
chap1_para594,6,,该算法要么返回failure，要么返回一个节点（表示一条通往目标的路径）。
chap1_para594,7,,通过使用不同的f(n)函数，可以得到不同的具体算法，本章将介绍这些算法。
chap1_para595,1,,图3-7　最佳优先搜索算法以及扩展节点的函数。
chap1_para595,2,,这里使用的数据结构将在3.3.2节中介绍。
chap1_para595,3,,yield的说明见附录B
chap1_para596,1,,3.3.2　搜索数据结构
chap1_para597,1,,搜索算法需要一个数据结构来跟踪搜索树。
chap1_para597,2,,树中的节点（node）由一个包含4个组成部分的数据结构表示。
chap1_para598,1,,● node.State：节点对应的状态。
chap1_para599,1,,● node.Parent：父节点，即树中生成该节点的节点。
chap1_para6,1,"We have claimed that AI is interesting, but we have not said what it is. Historically, researchers have pursued several different versions of AI. Some have defined intelligence in terms of fidelity to human performance, while others prefer an abstract, formal definition of intelligence called rationality—loosely speaking, doing the “right thing.” The subject matter itself also varies: some consider intelligence to be a property of internal thought processes and reasoning, while others focus on intelligent behavior, an external characterization.1",我们声称人工智能很有趣，但是我们还没有描述它是什么。
chap1_para6,2,,历史上研究人员研究过几种不同版本的人工智能。
chap1_para6,3,,有些根据对人类行为的复刻来定义智能，而另一些更喜欢用“理性”（rationality）来抽象正式地定义智能，直观上的理解是做“正确的事情”。
chap1_para6,4,,智能主题的本身也各不相同：一些人将智能视为内部思维过程和推理的属性，而另一些人则关注智能的外部特征，也就是智能行为。
chap1_para6,5,,[1]
chap1_para60,1,The final element in the philosophical picture of the mind is the connection between knowledge and action.,"拉蒙·鲁尔（Ramon Llull，约1232—1315）设计了一种推理系统，发表为Ars Magna（即The Great Art）（Llull, 1305）[5]。"
chap1_para60,2,This question is vital to AI because intelligence requires action as well as reasoning.,鲁尔试图使用实际的机械设备——一组可以旋转成不同排列的纸盘——实现他的系统。
chap1_para60,3,"Moreover, only by understanding how actions are justified can we understand how to build an agent whose actions are justifiable (or rational).",
chap1_para600,1,,● node.Action：父节点生成该节点时采取的动作。
chap1_para601,1,,● node.Path-Cost：从初始状态到此节点的路径总代价。
chap1_para601,2,,在数学公式中，一般使用g(node)表示Path-Cost。
chap1_para602,1,,通过从一个节点返回的Parent指针，我们可以复原到达该节点的路径上的状态和动作。
chap1_para602,2,,从一个目标节点开始复原，我们就可以得到问题的解。
chap1_para603,1,,我们需要一个数据结构来存储边界。
chap1_para603,2,,一个恰当的选择是某种队列（queue），因为边界上的操作有以下几个。
chap1_para604,1,,● Is-Empty( frontier)：返回true当且仅当边界中没有节点。
chap1_para605,1,,● Pop( frontier)：返回边界中的第一个节点并将它从边界中删除。
chap1_para606,1,,● Top( frontier)：返回（但不删除）边界中的第一个节点。
chap1_para607,1,,"● Add(node, frontier)：将节点插入队列中的适当位置。"
chap1_para608,1,,搜索算法使用了3种不同类型的队列。
chap1_para609,1,,● 优先队列（priority queue）首先弹出根据评价函数f计算得到的代价最小的节点。
chap1_para609,2,,它被用于最佳优先搜索。
chap1_para61,1,Aristotle argued (in De Motu Animalium) that actions are justified by a logical connection between goals and knowledge of the action’s outcome:,
chap1_para610,1,,● FIFO队列（FIFO queue），即先进先出队列（first-in-first-out queue），首先弹出最先添加到队列中的节点；它被用于广度优先搜索。
chap1_para611,1,,● LIFO队列（LIFO queue），即后进先出队列（last-in-first-out queue），也称为栈（stack），首先弹出最近添加的节点；它被用于深度优先搜索。
chap1_para612,1,,已达状态可以存储为一个查找表（例如，哈希表），其中每个键是一个状态，对应的值是该状态的节点。
chap1_para613,1,,3.3.3　冗余路径
chap1_para614,1,,图3-4（最下面一排）所示的搜索树包含了一条从Arad到Sibiu再回到Arad的路径。
chap1_para614,2,,这时我们称Arad为搜索树中的一个重复状态（repeated state），在本例中该重复状态是由循环（cycle）［也称为环路（loopy path）］生成的。
chap1_para614,3,,因此，即使状态空间只有20种状态，完整的搜索树也是无限的，因为遍历循环的频率没有限制。
chap1_para615,1,,循环是冗余路径（redundant path）的一种特殊情况。
chap1_para615,2,,例如，我们可以通过路径Arad—Sibiu（总长140英里）或路径Arad—Zerind—Oradea—Sibiu（总长297英里）到达Sibiu。
chap1_para615,3,,第二条路径是冗余的——是到达相同状态的一种比较差的方式——在我们寻找最优路径时不需要考虑它。
chap1_para616,1,,考虑一个10×10网格世界中的智能体，它能够移动到8个相邻方格中的任何一个。
chap1_para616,2,,如果没有障碍，智能体可以在9步或更少的移动内到达100个方格中的任何一个。
chap1_para616,3,,但是长度为9的路径的数量几乎是89（由于网格边缘的存在，路径数稍微少了一点），超过了1亿条。
chap1_para616,4,,也就是说，平均意义下，有超过100万条长度为9的冗余路径到达同一个单元格，如果我们消除了冗余路径，搜索完成的速度可以快大约100万倍。
chap1_para616,5,,俗话说，不记得历史的算法注定要重复历史。
chap1_para616,6,,有3种方法可以解决这一问题。
chap1_para617,1,,第一，我们可以记住之前到达的所有状态（就像最佳优先搜索一样），这样能够检测到所有冗余路径，并只保留每个状态的最优路径。
chap1_para617,2,,这适用于存在大量冗余路径的状态空间，当内存可以容纳下已达状态表时，它是首选方法。
chap1_para618,1,,第二，我们不必担心对过去的重复。
chap1_para618,2,,在一些问题形式化中，很少或不可能出现两条路径到达相同状态。
chap1_para618,3,,以装配问题为例，每个动作都会将一个零件添加到一个不断发展的装配中，零件是有序的，因此可以先添加A，然后再添加B，但不能先添加B，然后再添加A。
chap1_para618,4,,"对于这些问题, 如果我们不记录已达状态也不检查冗余路径，则可以节省内存空间。"
chap1_para618,5,,如果搜索算法会检查冗余路径，我们称之为图搜索（graph search）；否则，称之为树状搜索（tree-like search）[6]。
chap1_para618,6,,图3-7中的Best-First-Search算法是一种图搜索算法；如果删除所有对reached的引用，即为树状搜索，它使用更少的内存，但会出现到达相同状态的冗余路径，因此运行速度会更慢。
chap1_para62,1,"But how does it happen that thinking is sometimes accompanied by action and sometimes not, sometimes by motion, and sometimes not? It looks as if almost the same thing happens as in the case of reasoning and making inferences about unchanging objects. But in that case the end is a speculative proposition ... whereas here the conclusion which results from the two premises is an action. ... I need covering; a cloak is a covering. I need a cloak. What I need, I have to make; I need a cloak. I have to make a cloak. And the conclusion, the “I have to make a cloak,” is an action.",[5]　Ars Magna为拉丁文书名，翻译成英文的书名为The Great Art。
chap1_para62,2,,——编者注
chap1_para620,1,,[6]　我们称之为“树状搜索”，是因为无论如何搜索，状态空间仍然是相同的图；我们只是把它当作一棵树，从每个节点返回根只有一条路径。
chap1_para621,1,,第三，我们可以选择折中方法，检查循环，但通常不检查冗余路径。
chap1_para621,2,,由于每个节点都有一个父指针链，因此可以通过跟踪父指针链来查看路径末端的状态之前是否在路径中出现过，从而不需要额外内存即可检查是否存在循环。
chap1_para621,3,,某些算法实现一直沿着这个链向上移动，从而消除了所有循环。
chap1_para621,4,,另一些算法实现仅跟踪少数几个链接（例如，到父节点、祖父节点和曾祖父节点），因此仅需花费固定的时间就可以消除所有短循环（并依靠其他机制来处理长循环）。
chap1_para622,1,,3.3.4　问题求解性能评估
chap1_para623,1,,在开始设计各种搜索算法之前，需要考虑在这些算法中进行选择时所使用的标准。
chap1_para623,2,,我们可以从以下4个方面评价算法的性能。
chap1_para624,1,,● 完备性（completeness）：当存在解时，算法是否能保证找到解，当不存在解时，是否能保证报告失败？
chap1_para625,1,,● 代价最优性（cost optimality）：它是否找到了所有解中路径代价最小的解？
chap1_para625,2,,[7]
chap1_para627,1,,[7]　一些作者使用“可容许性”这一术语表示寻找最小代价解的性质，还有一些作者仅使用“最优性”，但这可能与其他类型的最优性相混淆。
chap1_para628,1,,● 时间复杂性（time complexity）：找到解需要多长时间？
chap1_para628,2,,可以用秒数来衡量，或者更抽象地用状态和动作的数量来衡量。
chap1_para629,1,,● 空间复杂性（space complexity）：执行搜索需要多少内存？
chap1_para63,1,In the Nicomachean Ethics (Book III.,大约在1500年，列奥纳多·达·芬奇（Leonardo da Vinci，1452—1519）设计了一台机械计算器，虽然当时并未制造，但最近的重构表明该设计是可行的。
chap1_para63,2,"3, 1112b), Aristotle further elaborates on this topic, suggesting an algorithm:",第一台已知的计算器是在1623年前后由德国科学家威廉·席卡德（Wilhelm Schickard，1592—1635）制造的。
chap1_para63,3,,布莱兹·帕斯卡（Blaise Pascal，1623—1662）于1642年建造了滚轮式加法器（Pascaline），并写道：“它产生的效用似乎比动物的所有行为更接近思维。
chap1_para63,4,,”戈特弗里德·威廉·莱布尼茨（Gottfried Wilhelm Leibniz，1646—1716）制造了一台机械设备，旨在根据概念而非数值进行操作，但其应用范围相当有限。
chap1_para63,5,,托马斯·霍布斯（Thomas Hobbes，1588—1679）在《利维坦》（Leviathan）一书中提出了会思考的机器的想法，用他的话说就是一种“人造动物”，设想“心脏无非就是发条，神经只是一些游丝，而关节不过是一些齿轮”。
chap1_para63,6,,他还主张推理就像是数值计算，认为“推理就是一种计算，也就是相加减”。
chap1_para63,7,,[6]
chap1_para630,1,,为了理解完备性，考虑一个具有单一目标的搜索问题。
chap1_para630,2,,这个目标可能是状态空间的任何地方；因此，一个完备的算法必须能够系统地探索从初始状态可以到达的每一个状态。
chap1_para630,3,,在有限状态空间中，这是很容易实现的：只要我们跟踪路径并切断循环（例如，Arad到Sibiu再到Arad），最终我们将到达每一个可到达的状态。
chap1_para631,1,,在无限状态空间中，则需要更加小心。
chap1_para631,2,,例如，在高德纳的“4”问题中反复应用“阶乘”操作的算法将沿着从4到4!到(4!)!……的无限路径行进。
chap1_para631,3,,同样地，在一个没有障碍的无限网格上，沿着直线不停前进也会形成由新状态组成的无限路径。
chap1_para631,4,,在这两种情况下，算法永远不会返回它之前到达的状态，但它是不完备的，因为状态空间中的大部分状态永远都不会到达。
chap1_para632,1,,完备的搜索算法探索无限状态空间的方式必须是系统的（systematic），以确保它最终能够到达与初始状态相关的任何状态。
chap1_para632,2,,例如，在无限网格上，一种系统搜索方法是螺旋路径，它覆盖了距离原点s步远的所有单元格，然后移动到s + 1步远的单元格。
chap1_para632,3,,遗憾的是，在一个不存在解的无限状态空间中，一个合理的算法会一直搜索，它不会终止，因为它不知道下一个状态是否是目标状态。
chap1_para633,1,,时间复杂性和空间复杂性与问题的困难程度相关。
chap1_para633,2,,在理论计算机科学中，一种典型的度量方式是状态空间图的大小，，其中是图中顶点（状态节点）的数量，是边（不同的状态/动作对）的数量。
chap1_para633,3,,当状态空间图是显式的数据结构（如罗马尼亚地图）时，这种度量是合适的。
chap1_para633,4,,但在许多人工智能问题中，状态空间图只是由初始状态、动作和转移模型隐式地表示。
chap1_para633,5,,对于隐式的状态空间，复杂性可以用3个量来衡量：d，最优解的深度（depth）或动作数；m，任意路径的最大动作数；b，需要考虑的节点的分支因子（branching factor）或后继节点数。
chap1_para634,1,,3.4　无信息搜索策略
chap1_para635,1,,无信息搜索算法不提供有关某个状态与目标状态的接近程度的任何线索。
chap1_para635,2,,例如，考虑一个位于Arad且目标为Bucharest的智能体。
chap1_para635,3,,一个对罗马尼亚地理一无所知的无信息智能体无法判断第一步应该前往Zerind还是Sibiu。
chap1_para635,4,,相比之下，了解每个城市位置的有信息智能体（3.5节）则知道Sibiu距离Bucharest更近，因此Sibiu更有可能在最短路线上。
chap1_para636,1,,3.4.1　广度优先搜索
chap1_para637,1,,当所有动作的代价相同时，正确的策略是采用广度优先搜索（breadth-first search），即先扩展根节点，然后扩展根节点的所有后继节点，再扩展后继节点的后继，以此类推。
chap1_para637,2,,这是一种系统的搜索策略，因此即使在无限状态空间上也是完备的。
chap1_para637,3,,我们可以通过调用Best-First-Search实现广度优先搜索，其中评价函数f(n)是节点的深度，即到达该节点所需的动作数。
chap1_para638,1,,然而，我们可以通过一些技巧来提高算法效率。
chap1_para638,2,,先进先出队列比优先队列速度更快，并且能提供正确的节点顺序：新节点（总是比其父节点更深）进入队列的队尾，而旧节点，即比新节点浅的节点，首先被扩展。
chap1_para638,3,,此外，reached可以是一组状态，而不是状态到节点的映射，因为一旦到达某个状态，我们就再也找不到到达该状态的更好路径了。
chap1_para638,4,,这也意味着我们可以进行早期目标测试（early goal test），即在生成节点后立即检查该节点是否为一个解，而不是像最佳优先搜索使用的后期目标测试（late goal test）那样，等节点弹出队列后再检查该节点是否为一个解。
chap1_para638,5,,图3-8展示了在二叉树上进行广度优先搜索的过程，图3-9展示了使用早期目标测试来提高效率的算法。
chap1_para639,1,,图3-8　简单二叉树上的广度优先搜索。
chap1_para639,2,,每个阶段接下来要扩展的节点用三角形标记表示
chap1_para64,1,"We deliberate not about ends, but about means.",
chap1_para64,2,"For a doctor does not deliberate whether he shall heal, nor an orator whether he shall persuade, .",
chap1_para64,3,.,
chap1_para64,4,.,
chap1_para64,5,"They assume the end and consider how and by what means it is attained, and if it seems easily and best produced thereby; while if it is achieved by one means only they consider how it will be achieved by this and by what means this will be achieved, till they come to the first cause, .",
chap1_para64,6,.,
chap1_para64,7,.,
chap1_para64,8,and what is last in the order of analysis seems to be first in the order of becoming.,
chap1_para64,9,"And if we come on an impossibility, we give up the search, e.",
chap1_para64,10,g.,
chap1_para64,11,", if we need money and this cannot be got; but if a thing appears possible we try to do it.",
chap1_para640,1,,图3-9　广度优先搜索和一致代价搜索算法
chap1_para641,1,,广度优先搜索总是能找到一个动作最少的解，因为当它生成深度为d的节点时，说明它已经生成了深度为d - 1的所有节点，如果其中一个节点是解，它应该已经被找到了。
chap1_para641,2,,这意味着，对于所有动作都具有相同代价的问题，它是代价最优的，但对于不具有该特性的问题，则不一定是最优的。
chap1_para641,3,,这两种情况都是完备的。
chap1_para641,4,,在时间和空间方面，想象我们在搜索一棵均衡树，其中每个状态都有b个后继。
chap1_para641,5,,搜索树的根生成b个节点，每个节点又生成b个节点，第二层总共是b2个节点。
chap1_para641,6,,每个节点又生成b个节点，从而在第三层产生b3个节点，以此类推。
chap1_para641,7,,现在假设解的深度为d，那么生成的节点总数为
chap1_para642,1,,所有节点都存储在内存中，所以时间复杂性和空间复杂性都是O(bd)。
chap1_para642,2,,这样的指数级上界是可怕的。
chap1_para642,3,,举一个典型的真实世界中的例子，考虑一个分支因子b = 10、处理速度为每秒100万节点、内存需求为1 KB/节点的问题。
chap1_para642,4,,深度d = 10的搜索将花费不到3小时的时间，但需要10 TB的内存。
chap1_para642,5,,对广度优先搜索来说，内存需求是一个比执行时间更严重的问题。
chap1_para642,6,,但时间仍然是一个重要因素。
chap1_para642,7,,深度d = 14时，即使有无限内存，搜索也需要3.5年。
chap1_para642,8,,一般来说，除了最小的问题实例，指数级复杂性的搜索问题无法通过无信息搜索求解。
chap1_para643,1,,3.4.2　Dijkstra算法或一致代价搜索
chap1_para644,1,,当动作具有不同的代价时，一个显而易见的选择是使用最佳优先搜索，评价函数为从根到当前节点的路径的代价。
chap1_para644,2,,理论计算机科学界称之为Dijkstra算法，人工智能界则称之为一致代价搜索（uniform-cost search）。
chap1_para644,3,,不同于广度优先搜索在深度一致的波（首先是深度1，然后是深度2，以此类推）中展开，一致代价搜索算法的思想是在路径代价一致的波中展开。
chap1_para644,4,,该算法可以通过调用Best-First-Search实现，评价函数为Path-Cost，如图3-9所示。
chap1_para645,1,,考虑图3-10，问题是从Sibiu到达Bucharest。
chap1_para645,2,,Sibiu的后继是Rimnicu Vilcea和Fagaras，代价分别为80和99。
chap1_para645,3,,然后扩展代价最小的节点Rimnicu Vilcea，加入节点Pitesti，其代价为80 + 97 = 177。
chap1_para645,4,,此时代价最小的节点是Fagaras，所以接着扩展Fagaras，加入节点Bucharest，代价为99 + 211 = 310。
chap1_para645,5,,目标节点是Bucharest，但算法只在扩展节点时测试其是否为目标节点，而不是在生成节点时测试，因此它还没有检测到这是一条通往目标的路径。
chap1_para646,1,,图3-10　罗马尼亚问题状态空间的一部分，选择这部分来说明一致代价搜索
chap1_para647,1,,算法继续进行，接下来选择Pitesti进行扩展，添加到Bucharest的第二条路径，代价为80 + 97 + 101 = 278。
chap1_para647,2,,它的代价更低，因此用它取代reached中之前的路径，并添加到frontier中。
chap1_para647,3,,结果证明，这个节点目前具有最小代价，因此它被认为是下一个要扩展的节点，此时我们发现它是一个目标节点，从而返回该节点。
chap1_para647,4,,注意，如果我们在生成节点时检查目标，而不是在扩展代价最小的节点时检查，那么我们将返回一个代价更高的路径（即经过Fagaras的路径）。
chap1_para648,1,,一致代价搜索的复杂性用C*和表示，C*是最优解的代价[8]，是每个动作代价的下界，。
chap1_para648,2,,那么算法在最坏情况下的时间复杂性和空间复杂性是，比bd大得多。
chap1_para648,3,,这是因为一致代价搜索在探索包含一个可能有用的高代价动作的路径之前，可能会先探索具有低代价动作的大型树。
chap1_para648,4,,当所有动作代价相同时，等于bd+1，这时一致代价搜索类似于广度优先搜索。
chap1_para65,1,Aristotle’s algorithm was implemented 2300 years later by Newell and Simon in their General Problem Solver program. We would now call it a greedy regression planning system (see Chapter 11). Methods based on logical planning to achieve definite goals dominated the first few decades of theoretical research in AI.,[6]　此处对《利维坦》一书中的引用采用了商务印书馆1985年9月出版的由黎思复、黎廷弼翻译的《利维坦》版本中的译文。
chap1_para65,2,,——编者注
chap1_para650,1,,[8]　在这里，以及整本书中，C*中的“*”表示C的最优值。
chap1_para651,1,,一致代价搜索是完备的，也是代价最优的，因为它找到的第一个解的代价至少与边界上的任何其他节点的代价一样小。
chap1_para651,2,,一致代价搜索会按照代价递增的顺序系统地考虑所有路径，而不会陷入一直沿单一无限路径探索的困境（假设所有动作的代价 ）。
chap1_para652,1,,3.4.3　深度优先搜索与内存问题
chap1_para653,1,,深度优先搜索（depth-first search）总是优先扩展边界中最深的节点。
chap1_para653,2,,它可以通过调用Best-First-Search来实现，其中评价函数f为深度的负数。
chap1_para653,3,,然而，它通常不是以图搜索的形式实现而是以树状搜索（不维护已达状态表）的形式实现。
chap1_para653,4,,搜索的过程如图3-11所示，搜索先直接到达搜索树的最深层，这里的节点不存在后继节点。
chap1_para653,5,,然后，搜索将“回退”到下一个仍存在未扩展后继节点的最深的节点。
chap1_para653,6,,深度优先搜索不是代价最优的，它会返回它找到的第一个解，即使这个解不是路径代价最小的。
chap1_para654,1,,图3-11　二叉树的深度优先搜索过程中，从开始状态A到目标M，共12步（从左到右，从上到下）。
chap1_para654,2,,边界节点为绿色，用三角形表示下一步要扩展的节点。
chap1_para654,3,,已扩展的节点为淡紫色，潜在的未来节点用模糊的虚线表示。
chap1_para654,4,,边界中没有后继的已扩展节点（用非常模糊的线表示）可以丢弃
chap1_para655,1,,对于树型的有限状态空间，算法是有效且完备的。
chap1_para655,2,,对于无环状态空间，算法可能会通过不同路径多次扩展同一状态，但是（最终）将系统地探索整个空间。
chap1_para656,1,,在有环状态空间中，深度优先搜索算法可能陷入无限循环；因此，一些深度优先搜索算法的实现会检查每个新节点是否存在循环。
chap1_para656,2,,在无限状态空间中，深度优先搜索不是系统性的：即使没有循环，它也可能陷入无限路径。
chap1_para656,3,,因此，深度优先搜索是不完备的。
chap1_para657,1,,那么，为什么还会有人选择使用深度优先搜索而不是广度优先搜索或最佳优先搜索呢？
chap1_para657,2,,答案是，对于使用树状搜索可以处理的问题，深度优先搜索对内存的需求要小得多。
chap1_para657,3,,深度优先搜索根本不保留reached表，并且边界集很小：如果将广度优先搜索中的边界集视为不断扩展的球体的表面，那么深度优先搜索中的边界集只是球体的半径。
chap1_para658,1,,对于图3-11所示的有限树状状态空间，深度优先的树状搜索所花费的时间与状态数成正比，其空间复杂性仅为O(bm)，其中b是分支因子，m是树的最大深度。
chap1_para658,2,,有些问题在广度优先搜索时需要EB量级的内存，而在深度优先搜索时仅需要KB量级。
chap1_para658,3,,由于其对内存的节约使用，深度优先树状搜索已经成为许多人工智能领域的基本工具，例如，约束满足（第6章）、命题可满足性（第7章）和逻辑编程（第9章）。
chap1_para659,1,,回溯搜索（backtracking search）是深度优先搜索的一种变体，它使用的内存更少。
chap1_para659,2,,（详见第6章。
chap1_para659,3,,）在回溯搜索中，一次只生成一个后继，而不是所有后继节点；每个部分扩展的节点会记住下一个要生成的后继节点。
chap1_para659,4,,此外，回溯通过直接修改当前状态描述而不是为一个全新的状态分配内存来生成后继状态。
chap1_para659,5,,这将内存需求减少到只有一个状态描述和一条具有O(m)个动作的路径；与深度优先搜索的O(bm)个状态相比，节省了大量资源。
chap1_para659,6,,通过回溯，我们还可以为当前路径上的状态维护一个有效的集合数据结构，从而使检查循环的时间从O(m)减少到O(1)。
chap1_para659,7,,为了使回溯起作用，我们必须能够在回溯时撤销每个动作。
chap1_para659,8,,回溯对许多具有大型状态描述的问题（例如机器人组装）的成功求解至关重要。
chap1_para66,1,Thinking purely in terms of actions achieving goals is often useful but sometimes inapplicable.,有观点认为，思维至少在某种程度上是根据逻辑或数值规则运作的，可以建立模仿其中的一些规则的物理系统。
chap1_para66,2,"For example, if there are several different ways to achieve a goal, there needs to be some way to choose among them.",也有观点说，思维本身就是这样一个物理系统。
chap1_para66,3,"More importantly, it may not be possible to achieve a goal with certainty, but some action must still be taken.",勒内·笛卡儿（René Descartes，1596—1650）首次清晰地讨论了思维与物质之间的区别。
chap1_para66,4,How then should one decide?,他指出，思维的纯粹物理概念似乎没有给自由意志留下多少空间。
chap1_para66,5,"Antoine Arnauld (1662), analyzing the notion of rational decisions in gambling, proposed a quantitative formula for maximizing the expected monetary value of the outcome.",如果思维完全受物理法则支配，那么它拥有的自由意志不会比一块“决定”往下掉的石头多。
chap1_para66,6,"Later, Daniel Bernoulli (1738) introduced the more general notion of utility to capture the internal, subjective value of an outcome.",笛卡儿是二元论（dualism）的支持者。
chap1_para66,7,"The modern notion of rational decision making under uncertainty involves maximizing expected utility, as explained in Chapter 15.",他认为，人类思维（灵魂或者精神）的一部分处于自然之外，不受物理定律的约束。
chap1_para66,8,,但是，动物不具备这种二元特性，它们可以被视为机器。
chap1_para660,1,,3.4.4　深度受限和迭代加深搜索
chap1_para661,1,,为了避免深度优先搜索陷入无限路径，我们可以使用深度受限搜索（depth-limited search）。
chap1_para661,2,,这是一个深度优先搜索的改进版本，在深度受限搜索中，我们设置深度界限，将深度上的所有节点视为其不存在后继节点（见图3-12）。
chap1_para661,3,,深度受限搜索算法的时间复杂性为O(b)，空间复杂性为O(b)。
chap1_para661,4,,遗憾的是，如果我们对的选择不当，算法将无法得到解，成为不完备的算法。
chap1_para662,1,,由于深度优先搜索是一种树状搜索，通常无法避免在冗余路径上浪费时间，但我们可以以一定的计算时间为代价来消除循环。
chap1_para662,2,,沿着父节点向上查看几个节点，就能检测出大多数循环；更长的循环则由深度界限处理。
chap1_para663,1,,有时可以根据对问题的了解选择一个较好的深度界限。
chap1_para663,2,,例如，罗马尼亚地图上有20个城市。
chap1_para663,3,,因此， = 19是一个有效的界限。
chap1_para663,4,,但是如果仔细研究地图，我们会发现，从任何一个城市到达另一个城市最多需要9步。
chap1_para663,5,,这个数值称为状态空间图的直径（diameter），它为我们提供了更好的深度界限，从而可以更有效地进行深度受限搜索。
chap1_para663,6,,然而，对于大多数问题，在求解问题之前，我们无法知道什么深度界限是好的。
chap1_para664,1,,迭代加深搜索（iterative deepening search）解决了如何选择一个合适的的问题，方法是尝试所有值：首先是0，然后是1，然后是2，依次类推——直到找到一个解，或者深度受限搜索返回failure值（而不是cutoff值）。
chap1_para664,2,,算法如图3-12所示。
chap1_para664,3,,迭代加深搜索结合了深度优先和广度优先搜索的许多优点。
chap1_para664,4,,和深度优先搜索一样，它对内存的需求也不大：当问题存在解时，是O(bd)，在不存在解的有限状态空间上，是O(bm)。
chap1_para664,5,,与广度优先搜索一样，迭代加深搜索对于所有动作都具有相同代价的问题是最优的，并且在有限无环状态空间上是完备的，或者说在任何有限状态空间上，当我们检查路径节点上所有的循环时，它都是完备的。
chap1_para665,1,,图3-12　迭代加深和深度受限树状搜索。
chap1_para665,2,,迭代加深搜索反复调用界限递增的深度受限搜索。
chap1_para665,3,,它返回以下3种类型的值中的一种：一个解节点；当它搜索了所有节点，证明在任何深度都不存在解时，返回failure；当在比更深的层上可能存在解时，返回cutoff。
chap1_para665,4,,这是一种树状搜索算法，它不记录reached状态，因此比最佳优先搜索使用的内存要少得多，但存在通过不同路径多次访问相同状态的风险。
chap1_para665,5,,另外，如果Is-Cycle检验函数不检查所有环，那么算法可能会陷入一个无限循环
chap1_para666,1,,存在解时，时间复杂性为O(bd)，不存在解时，时间复杂性为O(bm)。
chap1_para666,2,,与广度优先搜索相同，迭代加深搜索的每次迭代也会生成一个新层级，但是广度优先搜索将所有节点都存储在内存中，而迭代加深搜索则会重复之前的层级，从而以花费更多的时间为代价节省了内存。
chap1_para666,3,,图3-13展示了二叉搜索树上的迭代加深搜索的4次迭代，在第4次迭代时找到了解。
chap1_para667,1,,迭代加深搜索可能看起来很浪费，因为搜索树顶端附近的状态被多次重复生成。
chap1_para667,2,,但是对于许多状态空间，大多数节点位于底层，所以上层是否重复并不重要。
chap1_para667,3,,在迭代加深搜索中，底层（深度d）的节点被生成一次，倒数第二层的节点被生成两次，以此类推，直到根节点的子节点（生成d次）。
chap1_para667,4,,所以在最坏情况下生成的节点总数是
chap1_para668,1,,时间复杂性为O(bd)——与广度优先搜索相近。
chap1_para668,2,,例如，当b = 10、d = 5时，生成的节点数分别为
chap1_para669,1,,如果你确实很在意重复的问题，可以使用一种混合方法，即先运行广度优先搜索，直到几乎消耗掉所有可用内存，然后对边界集中的所有节点应用迭代加深搜索。
chap1_para669,2,,通常，当搜索状态空间大于内存容量而且解的深度未知时，迭代加深搜索是首选的无信息搜索方法。
chap1_para67,1,"In matters of ethics and public policy, a decision maker must consider the interests of multiple individuals.",唯物主义（materialism）是二元论的一种替代，它认为大脑根据物理定律的运作构成了思维。
chap1_para67,2,"Jeremy Bentham (1823) and John Stuart Mill (1863) promoted the idea of utilitarianism: that rational decision making based on maximizing utility should apply to all spheres of human activity, including public policy decisions made on behalf of many individuals.",自由意志仅仅是实体对可选决策的感知。
chap1_para67,3,Utilitarianism is a specific kind of consequentialism: the idea that what is right and wrong is determined by the expected outcomes of an action.,物理主义（physicalism）和自然主义（naturalism）这两个术语也被用于描述这类与超自然观点相反的观点。
chap1_para670,1,,图3-13　二叉搜索树上的迭代加深搜索的4次迭代（目标为M），深度界限从0到3。
chap1_para670,2,,注意，内部节点形成了一条路径。
chap1_para670,3,,三角形标记下一步要扩展的节点，边界为加粗轮廓的绿色节点，非常模糊的节点可被证明不可能是这种深度界限下的解的一部分
chap1_para671,1,,3.4.5　双向搜索
chap1_para672,1,,到目前为止，我们介绍的算法都是从一个初始状态开始，最终到达多个可能目标状态中的任意一个。
chap1_para672,2,,另一种称为双向搜索（bidirectional search）的方法则同时从初始状态正向搜索和从目标状态反向搜索，直到这两个搜索相遇。
chap1_para672,3,,算法的动机是，要比bd小得多（例如，当b = d = 10时，复杂性不到之前算法的五万分之一）。
chap1_para673,1,,为此，我们需要维护两个边界集和两个已达状态表，并且要能反向推理：如果状态s'是s的正向后继，那么我们需要知道s是s'的反向后继。
chap1_para673,2,,当两个边界触碰到一起时，我们就找到了一个解。
chap1_para673,3,,[9]
chap1_para675,1,,[9]　在我们的实现中，reached数据结构支持查询给定状态是否为其成员，而边界数据结构（一个优先队列）不支持，因此我们使用reached检查是否互相触碰；但从概念上讲，我们查询的是这两个边界是否已经相遇。
chap1_para675,2,,通过将每个目标状态的节点加载到反向边界和反向已达表中，可以将实现扩展为处理多个目标状态。
chap1_para676,1,,双向搜索有很多不同版本，就像有很多不同的单向搜索算法一样。
chap1_para676,2,,在这一节中，我们将介绍双向最佳优先搜索。
chap1_para676,3,,尽管存在两个独立的边界，但接下来要扩展的节点始终是两个边界中的评价函数值最小的节点。
chap1_para676,4,,当函数为路径代价时，我们得到双向一致代价搜索，如果最优路径的代价是C*，则不扩展代价大于的节点。
chap1_para676,5,,这将使得速度大大提高。
chap1_para677,1,,一般的最佳优先双向搜索算法如图3-14所示。
chap1_para677,2,,我们传入问题和评价函数的两个版本，一个是正向的（下标F），另一个是反向的（下标B）。
chap1_para677,3,,当评价函数是路径代价时，找到的第一个解将是最优解，但是对于不同的评价函数，这一结论不一定是正确的。
chap1_para677,4,,因此，我们会记录迄今为止找到的最优解，并且可能不得不多次更新最优解，直到Terminated测试证明不可能再有更好的解。
chap1_para678,1,,图3-14　双向最佳优先搜索维护两个边界集和两个已达状态表。
chap1_para678,2,,当一个边界中的路径到达另一半搜索已达状态时，这两条路径（通过Join-Nodes函数）被连起来构成一个解。
chap1_para678,3,,我们得到的第一个解不一定是最优的；函数Terminated决定了什么时候停止寻找新的解
chap1_para679,1,,3.4.6　无信息搜索算法对比
chap1_para68,1,"In contrast, Immanuel Kant, in 1785, proposed a theory of rule-based or deontological ethics, in which “doing the right thing” is determined not by outcomes but by universal social laws that govern allowable actions, such as “don’t lie” or “don’t kill.” Thus, a utilitarian could tell a white lie if the expected good outweighs the bad, but a Kantian would be bound not to, because lying is inherently wrong. Mill acknowledged the value of rules, but understood them as efficient decision procedures compiled from first-principles reasoning about consequences. Many modern AI systems adopt exactly this approach.",如果给定可以操纵知识的实体思维，接下来的问题就是建立知识的来源。
chap1_para68,2,,经验主义（empiricism）运动始于弗朗西斯·培根（Francis Bacon，1561—1626）的《新工具》（Novum Organum）[7]一书，并以约翰·洛克（John Locke，1632—1704）的名言“知识归根到底都来源于经验”为特征。
chap1_para680,1,,图3-15根据3.3.4节中列出的4个评价标准对无信息搜索算法进行了比较。
chap1_para680,2,,这种比较适用于不检查重复状态的树状搜索版本。
chap1_para680,3,,对于检查重复状态的图搜索，主要区别在于，对于有限状态空间，深度优先搜索是完备的，并且空间复杂性和时间复杂性受到状态空间大小（顶点和边的数量，）的限制。
chap1_para681,1,,图3-15　搜索算法比较。
chap1_para681,2,,b是分支因子；m是搜索树的最大深度；d是最浅层解的深度，当不存在解时为m；是深度界限
chap1_para682,1,,3.5　有信息（启发式）搜索策略
chap1_para683,1,,本节将展示有信息搜索（informed search）策略——使用关于目标位置的特定领域线索——如何比无信息搜索策略更有效地找到解。
chap1_para683,2,,线索以启发式函数（heuristic function）的形式出现，记为h(n)：[10]
chap1_para685,1,,[10]　这看起来可能很奇怪，启发式函数真正需要的只是节点的状态，但作用对象却是节点。
chap1_para685,2,,一般使用h(n)而不是h(s)，是为了与评价函数f (n)和路径代价g(n)保持一致。
chap1_para686,1,,h(n) = 从节点n的状态到目标状态的最小代价路径的代价估计值
chap1_para687,1,,例如，在寻径问题中，我们可以通过计算地图上两点之间的直线距离来估计从当前状态到目标的距离。
chap1_para687,2,,我们将在3.6节中详细研究启发式函数及其来源。
chap1_para688,1,,3.5.1　贪心最佳优先搜索
chap1_para689,1,,贪心最佳优先搜索（greedy best-first search）是最佳优先搜索的一种形式，它首先扩展h(n)值最小的节点——看起来最接近目标的节点——因为这样可能可以更快找到解。
chap1_para689,2,,因此，评价函数f(n) = h(n)。
chap1_para69,1,1.,
chap1_para69,2,2.,
chap1_para69,3,2Mathematics,
chap1_para690,1,,让我们看看这种算法如何求解罗马尼亚寻径问题；我们使用直线距离（straight-line distance）作为启发式函数，记为hSLD。
chap1_para690,2,,如果目标是Bucharest，我们需要知道到Bucharest的直线距离，如图3-16所示。
chap1_para690,3,,例如，hSLD(Arad) = 366。
chap1_para690,4,,注意，无法从问题描述本身（即Actions和Result函数）来计算hSLD的值。
chap1_para690,5,,此外，根据经验可知，hSLD与实际道路距离相关，因此是一个有用的启发式函数。
chap1_para691,1,,图3-17展示了使用hSLD搜索从Arad到Bucharest的路径的贪心最佳优先搜索的过程。
chap1_para691,2,,从Arad扩展的第一个节点是Sibiu，因为启发式函数认为它比Zerind或Timisoara更接近Bucharest。
chap1_para691,3,,下一个要扩展的节点是Fagaras，因为根据启发式函数，它现在最接近Bucharest。
chap1_para691,4,,Fagaras接着生成了Bucharest，即目标节点。
chap1_para691,5,,对于这一特定问题，使用hSLD的贪心最佳优先搜索无须扩展不在解路径上的节点就找到了解。
chap1_para691,6,,但是，它找到的解并不是代价最优的：经由Sibiu和Fagaras到达Bucharest的路径比经过Rimnicu Vilcea和Pitesti的路径长32英里。
chap1_para691,7,,这就是为什么这种算法会被称为“贪心的”——在每次迭代中，它都会做出在当前看来最优的（即可以最接近目标的）选择，但这也会导致贪心法在全局意义上可能产生比谨慎的算法更糟糕的结果。
chap1_para692,1,,图3-16　hSLD（到Bucharest的直线距离）的值
chap1_para693,1,,图3-17　基于直线距离启发式函数hSLD的贪心最佳优先树状搜索的各个阶段（目标为Bucharest）。
chap1_para693,2,,节点上标有h值
chap1_para694,1,,贪心最佳优先图搜索在有限状态空间中是完备的，但在无限状态空间中是不完备的。
chap1_para694,2,,最坏情况下的时间复杂性和空间复杂性是。
chap1_para694,3,,然而，使用一个好的启发式函数，复杂性可以大大降低，对于某些问题可以达到O(bm)。
chap1_para695,1,,3.5.2　A*搜索
chap1_para696,1,,最常见的有信息搜索算法是A*搜索（A* search）（读为“A星搜索”），这是一种最佳优先搜索，评价函数为
chap1_para697,1,,其中g(n)是从初始状态到节点n的路径代价，h(n)是从节点n到一个目标状态的最短路径的代价估计值，因此我们有
chap1_para698,1,,f(n) = 经过n到一个目标状态的最优路径的代价估计值
chap1_para699,1,,在图3-18中，我们展示了目标为Bucharest的A*搜索过程。
chap1_para699,2,,g的值由图3-1中的动作代价计算得到，hSLD的值在图3-16中给出。
chap1_para699,3,,注意，Bucharest首先出现在图3-18的步骤e的边界中，但算法并没有选择它来进行扩展（因此它没有被检测为一个解），因为此时它不是边界中代价最小的节点（f = 450）——代价最小的节点是Pitesti（f = 417）。
chap1_para699,4,,换句话说，可能存在一个经过Pitesti的解，代价低至417，所以算法不会满足于一个代价为450的解。
chap1_para699,5,,在图3-18的步骤f中，另一条到Bucharest的路径此时代价最小（f = 418），因此它被选中并被检测为最优解。
chap1_para7,1,"From these two dimensions—human vs. rational2 and thought vs. behavior—there are four possible combinations, and there have been adherents and research programs for all four. The methods used are necessarily different: the pursuit of human-like intelligence must be in part an empirical science related to psychology, involving observations and hypotheses about actual human behavior and thought processes; a rationalist approach, on the other hand, involves a combination of mathematics and engineering, and connects to statistics, control theory, and economics. The various groups have both disparaged and helped each other. Let us look at the four approaches in more detail.",
chap1_para70,1,•What are the formal rules to draw valid conclusions?,[7]　培根的《新工具》（Novum Organum）是亚里士多德的《工具论》（Organon）的更新。
chap1_para700,1,,A*搜索是完备的。
chap1_para700,2,,[11]它是否是代价最优则取决于启发式函数的某些性质。
chap1_para700,3,,一个关键性质是可容许性（admissibility）：一个可容许的启发式（admissible heuristic）函数永远不会高估到达某个目标的代价。
chap1_para700,4,,（因此，一个可容许的启发式函数是乐观的。
chap1_para700,5,,）
chap1_para702,1,,[11]　再强调一次，假设所有动作的代价都 ，状态空间要么有解，要么有限。
chap1_para703,1,,对于可容许的启发式函数，A*是代价最优的，我们可以通过反证法来证明这一点。
chap1_para703,2,,假设最优路径的代价为C*，但是该算法返回的路径代价为C C*，那么最优路径上一定存在某个未扩展的节点n（因为如果最优路径上的所有节点都已被扩展，那么算法返回的将是这个最优解）。
chap1_para703,3,,因此，使用符号g*(n)表示从起点到n的最优路径的代价，h*(n)表示从n到最近目标的最优路径的代价，我们将得到
chap1_para704,1,,第一行和最后一行矛盾，所以“算法可能返回次优路径”的假设一定是错误的——A*一定只返回代价最优路径。
chap1_para705,1,,另一个稍强的性质为一致性（consistency）。
chap1_para705,2,,如果对于每个节点n以及由动作a生成的n的每个后继节点n' 有以下条件，则启发式函数h(n)是一致的：
chap1_para706,1,,这是三角不等式（triangle inequality）的一种形式，它规定三角形的一条边不能大于其他两条边之和（见图3-19）。
chap1_para706,2,,一致的启发式函数的一个实例是上文中的直线距离hSLD。
chap1_para707,1,,图3-18　A*搜索的各个阶段（目标为Bucharest）。
chap1_para707,2,,节点上标有f = g + h，h值为图3-16中得到的到Bucharest的直线距离
chap1_para708,1,,"图3-19　三角不等式：如果启发式函数h是一致的，那么单个数值h(n)小于从n到n'的动作代价值c(n, a, n')加上启发式函数的估计值h(n')的和"
chap1_para709,1,,一致的启发式函数都是可容许的（反过来不成立），因此，使用一致的启发式函数的A*搜索都是代价最优的。
chap1_para709,2,,此外，如果使用一致的启发式函数，算法第一次到达某个状态时，它就在一条最优路径上，因此我们永远不需要将某个状态重复添加到边界中，也不必更改reached中的条目。
chap1_para709,3,,但是，如果使用不一致的启发式函数，最终可能导致多个路径到达相同状态，而且如果每条新路径的路径代价都小于前一条路径，最终在边界中该状态会有多个节点，这会耗费时间和空间。
chap1_para709,4,,因此，有些A*搜索算法的实现会注意让一个状态只进入边界一次，如果找到了到达该状态的更优路径，那么该状态的所有后继都会更新（这要求节点除了父指针外还要有子指针）。
chap1_para709,5,,"这些复杂性使得许多研究人员在实现A*搜索时避免使用不一致的启发式函数，但费尔纳等人（Felner et al., 2011）认为，最坏的结果在实践中很少发生，因此不应该害怕不一致的启发式函数。"
chap1_para71,1,•What can be computed?,"大卫·休谟（David Hume，1711—1776）的《人性论》（A Treatise of Human Nature）（Hume, 1739）提出了现在称为归纳法（induction）的原则：通过暴露要素之间的重复联系获得一般规则。"
chap1_para710,1,,如果采用不可容许的启发式函数，那么A*搜索可能是代价最优的，也可能不是。
chap1_para710,2,,存在两种情况使得A*搜索是代价最优的：第一，如果存在一条代价最优路径，对于该路径上的所有节点n，h(n)都是可容许的，那么无论启发式函数在路径外状态上的值如何，算法都能找到这条路径。
chap1_para710,3,,第二，假设最优解的代价为C*，次优解的代价为C2，如果h(n)高估了部分代价但又没有高估太多，都不超过C2 − C*，那么也可以保证A*返回的解是代价最优的。
chap1_para711,1,,3.5.3　搜索等值线
chap1_para712,1,,一种对搜索进行可视化的方法是在状态空间中绘制等值线（contour），就像在地形图中绘制等高线一样。
chap1_para712,2,,如图3-20所示，在标记为400的等值线内，所有节点都有，以此类推。
chap1_para712,3,,因为A*扩展的是f代价最小的边界节点，所以它是从初始节点扇形地向外扩展，以f 值递增的同心带状方式添加节点。
chap1_para713,1,,一致代价搜索中也存在等值线，但是等值线表示g代价，而不是g + h。
chap1_para713,2,,一致代价搜索中，等值线将以初始状态为圆心呈“圆形”向各个方向均匀扩展，而不是偏向于目标状态。
chap1_para713,3,,对于具有好的启发式函数的A*搜索，g + h带将朝一个目标状态延伸（如图3-20所示），并且在最优路径周围收敛变窄。
chap1_para714,1,,需要清楚的是，扩展路径时，g代价是单调的（monotonic）：路径代价始终随着路径的延伸而不断增加，因为动作代价始终为正。
chap1_para714,2,,[12]因此，所得到的同心等值线彼此不会交叉，如果希望画出的等值线足够精细，则可以在任何路径上的任意两个节点之间画一条线。
chap1_para716,1,,[12]　从技术上讲，始终保持增加的代价称为“严格单调的”；永远不会减少但可能保持不变的代价称为“单调的”。
chap1_para717,1,,但代价是否单调递增则并不显然。
chap1_para717,2,,当你将一条路径从n扩展到n'时，代价从变为。
chap1_para717,3,,消去g(n)项，我们可以看到，当且仅当时，路径代价单调递增。
chap1_para717,4,,换句话说，当且仅当启发式函数是一致的时，路径代价单调递增。
chap1_para717,5,,[13]但需要注意的是，一条路径可能会在一行中贡献若干个具有相同g(n) + h(n)得分的节点；当h的减少量恰好等于刚刚采取的动作代价时，就会发生这种情况（例如，在一个网格问题中，当n与目标在同一行然后向目标迈进一步时，g增加1，h减少1）。
chap1_para717,6,,如果C*是最优解路径的代价，那么以下说法成立。
chap1_para719,1,,[13]　事实上，“单调启发式函数”这一术语是“一致的启发式函数”的同义词。
chap1_para719,2,,"这两种观点是独立发展的，但是之后被证明是等价的（Pearl, 1984）。"
chap1_para72,1,•How do we reason with uncertain information?,"以路德维希·维特根斯坦（Ludwig Wittgenstein，1889—1951）和伯特兰·罗素（Bertrand Russell，1872—1970）的工作为基础，著名的维也纳学派（Sigmund, 2017）——一群在20世纪20年代及20世纪30年代聚集在维也纳的哲学家和数学家——发展了逻辑实证主义（logical positivism）学说。"
chap1_para72,2,,该学说认为，所有知识都可以通过逻辑理论来描述，逻辑理论最终与对应于感知输入的观察语句（observation sentence）相联系。
chap1_para72,3,,因此，逻辑实证主义结合了理性主义和经验主义。
chap1_para720,1,,● A*搜索将扩展从初始状态可以到达并且路径上的每个节点都满足的所有节点。
chap1_para720,2,,我们称这些节点为必然扩展节点（surely expanded node）。
chap1_para721,1,,● A*搜索可能会在选出目标节点之前扩展某些恰好在“目标等值线”（即f (n) = C*）上的节点。
chap1_para722,1,,● A*搜索不扩展的节点。
chap1_para723,1,,图3-20　罗马尼亚地图，其中等值线为f = 380、f = 400和f = 420，初始状态为Arad。
chap1_para723,2,,给定等值线内的节点的代价f = g + h小于或等于等值线值
chap1_para724,1,,我们认为具有一致启发式函数的A*搜索是效率最优（optimally efficient）的，因为任何从初始状态扩展搜索路径并使用相同启发式信息的算法都必须扩展A*的所有必然扩展节点（因为任何一个必然扩展节点都可能是某个最优解的一部分）。
chap1_para724,2,,对于f(n)=C*的节点，某个算法可能运气好，首先选择了最优节点，而另一个算法就没这么幸运。
chap1_para724,3,,我们在定义最优效率时不考虑这种差异。
chap1_para725,1,,A*之所以高效，是因为它会对那些对于寻找最优解没有帮助的搜索树节点进行剪枝（pruning）。
chap1_para725,2,,在图3-18b中，我们看到，对于Timisoara，f = 447；对于Zerind，f = 449。
chap1_para725,3,,即使它们是根的子节点并且是采用一致代价搜索或广度优先搜索时首先扩展的节点，它们也永远不会被A*搜索扩展，因为A*会首先找到f = 418的解。
chap1_para725,4,,对许多人工智能领域来说，剪枝（不必进行检查就可以排除不正确的答案）非常重要。
chap1_para726,1,,在所有这些算法中，A*搜索都是完备的、代价最优的和效率最优的，这是相当令人满意的结果。
chap1_para726,2,,遗憾的是，这并不意味着A*适用于所有搜索需求。
chap1_para726,3,,问题在于，对于许多问题，所扩展的节点数可能是解路径长度的指数级。
chap1_para726,4,,例如，考虑一个具有超强吸力的真空吸尘器世界，它可以以单位代价清理任一方格却不需要访问该方格。
chap1_para726,5,,在这种情况下，可以按任何顺序清理方格。
chap1_para726,6,,如果开始时有N个脏的方格，则有2N种状态，其中某个子集已被清理；所有这些状态都在最优解路径上，因此满足，所以所有这些状态都会被A*搜索访问。
chap1_para727,1,,3.5.4　满意搜索：不可容许的启发式函数与加权A*搜索
chap1_para728,1,,A*搜索有很多好的性质，但它扩展了大量节点。
chap1_para728,2,,如果我们愿意接受次优但“足够好”的解——我们称之为满意（satisficing）解，则可以探索更少的节点（花费更少的时间和空间）。
chap1_para728,3,,如果我们允许A*搜索使用不可容许的启发式函数（inadmissible heuristic）（它可能会高估到达某个目标的代价），那么我们就有可能错过最优解，但是该启发式函数可能更准确，从而减少了需要扩展的节点数。
chap1_para728,4,,例如，道路工程师知道弯道指数（detour index）的概念，它是应用于直线距离的乘数，用来说明道路的典型曲率。
chap1_para728,5,,弯道指数1.3意味着如果两个城市的直线距离相距10千米，那么它们之间的最优路径的一个恰当的估计值是13千米。
chap1_para728,6,,对于大多数地区，弯道指数的范围是1.2到1.6。
chap1_para729,1,,不仅仅是与道路相关的问题，我们还可以将这一思想应用于任何问题，我们采用一种称为加权A*搜索（weighted A* search）的方法，对启发式函数的值进行更重的加权，评价函数为，其中。
chap1_para73,1,"Philosophers staked out some of the fundamental ideas of AI, but the leap to a formal science required the mathematization of logic and probability and the introduction of a new branch of mathematics: computation.",鲁道夫·卡纳普（Rudolf Carnap，1891—1970）和卡尔·亨佩尔（Carl Hempel，1905—1997）的确证理论（confirmation theory）试图通过量化应分配给逻辑语句的信念度来分析从经验中获取知识，信念度的取值基于逻辑语句与确证或否定它们的观察之间的联系。
chap1_para73,2,,"卡纳普的《世界的逻辑构造》（The Logical Structure of the World）（Carnap, 1928）也许是最先提出将思维视为计算过程这一理论的著作。"
chap1_para730,1,,图3-21为一个网格世界中的搜索问题。
chap1_para730,2,,在图3-21a中，A*搜索必须探索大部分状态空间才能找到最优解。
chap1_para730,3,,在图3-21b中，加权A*搜索找到一个代价稍高的解，但搜索时间要快得多。
chap1_para730,4,,我们看到，加权搜索使得已达状态的等值线专注于趋向某个目标。
chap1_para730,5,,这意味着需要探索的状态变少，但如果最优路径偏离加权搜索的等值线（就像在这种情况下一样），则无法找到最优路径。
chap1_para730,6,,一般来说，如果最优解的代价是C*，那么加权A*搜索将找到一个代价介于C*和W×C*之间的解；但在实践中，通常结果更接近于C*而不是W×C*。
chap1_para731,1,,图3-21　同一网格上的两种搜索：（a）A*搜索，（b）加权A*搜索，权重W = 2。
chap1_para731,2,,灰色线条表示障碍，紫色线是一条从绿色起始点到红色目标点的路径，较小的点是每次搜索到达的状态。
chap1_para731,3,,在这个特定问题上，加权A*搜索探索的状态数不到A*搜索探索的状态数的七分之一，找到的路径的代价只比最优代价大了5%
chap1_para732,1,,我们已经考虑过以各种方式组合g和h来评价状态的搜索方法；加权A*搜索可以看作是其他方法的一般化。
chap1_para737,1,,你可以称加权A*搜索为“有点贪心的搜索”：就像贪心最佳优先搜索一样，它使得搜索专注于趋向一个目标；但是，它不会完全忽略路径代价，并且会暂停代价高昂但进展甚微的路径。
chap1_para738,1,,次优的搜索算法有很多，其区别在于“足够好”的标准。
chap1_para738,2,,在有界次优搜索（bounded suboptimal search）中，我们寻找一个能保证代价在最优代价的常数因子W倍内的解。
chap1_para738,3,,加权A*搜索提供了这一保证。
chap1_para738,4,,在有界代价搜索（bounded-cost search）中，我们寻找一个代价小于某个常数C的解。
chap1_para738,5,,在无界代价搜索（unbounded-cost search）中，我们接受任何代价的解，只要能快速找到它。
chap1_para739,1,,无界代价搜索算法的一个例子是快速搜索（speedy search），它是一种贪心最佳优先搜索，使用到达目标所需动作个数的估计值作为启发式函数，不考虑这些动作的代价。
chap1_para739,2,,因此，对于所有动作都具有相同代价的问题，它等于贪心最佳优先搜索，但当动作具有不同代价时，它往往会导致搜索快速找到一个代价可能很高的解。
chap1_para74,1,"The idea of formal logic can be traced back to the philosophers of ancient Greece, India, and China, but its mathematical development really began with the work of George Boole (1815–1864), who worked out the details of propositional, or Boolean, logic (Boole, 1847). In 1879, Gottlob Frege (1848–1925) extended Boole’s logic to include objects and relations, creating the first-order logic that is used today.5 In addition to its central role in the early period of AI research, first-order logic motivated the work of Gödel and Turing that underpinned computation itself, as we explain below.",思维的哲学图景中最后一个要素是知识与动作之间的联系。
chap1_para74,2,,这个问题对人工智能来说至关重要，因为智能不仅需要推理，还需要动作。
chap1_para74,3,,而且，只有理解了怎样的行为是合理的，才能理解如何构建行为是合理的（或理性的）智能体。
chap1_para740,1,,3.5.5　内存受限搜索
chap1_para741,1,,A*搜索的主要问题是它对内存的使用较多。
chap1_para741,2,,在本节中，我们将介绍一些可以节省空间的实现技巧和一些能够更好地利用可用空间的全新算法。
chap1_para742,1,,内存被分为frontier状态和reached状态。
chap1_para742,2,,在我们所实现的最佳优先搜索中，边界上的状态存储在两个位置：边界中的一个节点（因此我们可以决定下一步扩展哪个节点）和已达状态表中的一个表项（因此我们知道之前是否访问过该状态）。
chap1_para742,3,,对于许多问题（例如探索网格），这种重复不是关注点，因为frontier要比reached小得多，所以复制边界中的状态所需内存相对较少。
chap1_para742,4,,但是有些算法实现只保留这两个位置中的其中一个，从而节省了一点空间，其代价是算法变得更复杂（可能会减慢速度）。
chap1_para743,1,,另一种可能性是，当我们能够证明不再需要某些状态时，就将它们从reached中删除。
chap1_para743,2,,对于某些问题，我们可以利用分离性质（图3-6），同时禁止掉头行动，以确保所有行动要么是从边界向外移动，要么是移动到另一个边界状态。
chap1_para743,3,,在这种情况下，我们只需检查边界就能判断是否有冗余路径，并且可以删除reached状态表。
chap1_para744,1,,对于其他问题，我们可以维护引用计数（reference count）——到达某一状态的次数，并且在再也没有路径可以到达该状态时将其从reached表中删除。
chap1_para744,2,,例如，在网格世界中，每个状态只能从它的4个邻居状态到达，一旦我们已经到达了一个状态4次，就可以将它从表中删除。
chap1_para745,1,,现在，我们考虑旨在节省内存使用的新算法。
chap1_para746,1,,束搜索（beam search）对边界的大小进行了限制。
chap1_para746,2,,最简单的方法是只保留具有最优f值的k个节点，放弃其他已扩展节点。
chap1_para746,3,,这当然会导致搜索变成不完备的和次优的算法，但我们可以选取合适的k以充分利用可用内存，算法执行速度也会更快，因为它只扩展了较少的节点。
chap1_para746,4,,对于许多问题，它可以找到很好的近似最优解。
chap1_para746,5,,你可以将一致代价搜索或A*搜索看作在同心等值线的各个方向扩展，而将束搜索看作只探索这些等值线的主要部分，即包含k个最佳候选的部分。
chap1_para747,1,,另一种形式的束搜索并不严格限制边界的大小，而是保留f值在最优f值的范围内的所有节点。
chap1_para747,2,,这样的话，当存在几个强得分节点时，只会保留几个节点，但如果不存在强节点，则会保留更多节点，直到出现一个强节点。
chap1_para748,1,,迭代加深A*搜索（iterative-deepening A* search，IDA*）之于A*搜索，就像迭代加深搜索之于深度优先搜索一样：IDA*既拥有A*的优点，又不要求在内存中保留所有已达状态，这样做的代价是需要多次访问某些状态。
chap1_para748,2,,它是一种非常重要且常用的用于解决内存不足问题的算法。
chap1_para749,1,,在标准的迭代加深搜索中，截断值为深度，每次迭代深度增加1。
chap1_para749,2,,而在IDA*中，截断值是f代价（g + h）；在每次迭代中，新的截断值为超过上一次迭代截断值的节点中最小的f代价。
chap1_para749,3,,换句话说，每次迭代都会彻底地搜索一个f等值线，找到一个刚好超出该等值线的节点，并使用该节点的f代价作为下一个等值线。
chap1_para749,4,,像8数码这样的问题，每条路径的f代价都是整数，这非常有效地使得每次迭代都朝着目标稳步前进。
chap1_para749,5,,如果最优解的代价是C*，那么迭代的次数不可能超过C*（例如，最难的8数码问题的迭代次数不超过31）。
chap1_para749,6,,但对于每个节点的f代价都不相同的问题，每一个新的等值线可能只包含一个新节点，并且迭代次数可能等于状态数。
chap1_para75,1,"The theory of probability can be seen as generalizing logic to situations with uncertain information—a consideration of great importance for AI. Gerolamo Cardano (1501–1576) first framed the idea of probability, describing it in terms of the possible outcomes of gambling events. In 1654, Blaise Pascal (1623–1662), in a letter to Pierre Fermat (1601–1665), showed how to predict the future of an unfinished gambling game and assign average payoffs to the gamblers. Probability quickly became an invaluable part of the quantitative sciences, helping to deal with uncertain measurements and incomplete theories. Jacob Bernoulli (1654–1705, uncle of Daniel), Pierre Laplace (1749–1827), and others advanced the theory and introduced new statistical methods. Thomas Bayes (1702–1761) proposed a rule for updating probabilities in the light of new evidence; Bayes’ rule is a crucial tool for AI systems.",亚里士多德在《论动物的运动》（De Motu Animalium）中指出，动作的合理性是通过目标和动作结果的知识之间的逻辑联系来证明的：
chap1_para750,1,,递归最佳优先搜索（recursive best-first search，RBFS）（见图3-22）试图模拟标准的最佳优先搜索的操作，但仅仅使用线性空间。
chap1_para750,2,,RBFS类似于递归深度优先搜索，但它不是沿着当前路径无限地向下搜索，而是使用f_limit变量跟踪从当前节点的任意祖先节点可得到的最优备选路径的f值。
chap1_para750,3,,如果当前节点超过了这个限制，那么递归将回到备选路径上。
chap1_para750,4,,随着递归的展开，RBFS将路径上每个节点的f值替换为一个倒推值（backed-up value）——其子节点的最优f值。
chap1_para750,5,,通过这种方式，RBFS可以记住被它遗忘的子树中最优叶节点的f值，因此，在之后的某个时刻，RBFS可以决定是否要重新扩展该子树。
chap1_para750,6,,图3-23展示了RBFS是如何到达Bucharest的。
chap1_para751,1,,图3-22　递归最佳优先搜索算法
chap1_para752,1,,在一定程度上，RBFS比IDA*更高效，但仍然存在重复生成大量节点的问题。
chap1_para752,2,,在图3-23的示例中，RBFS沿着经过Rimnicu Vilcea的路径，然后“改变主意”去尝试经过Fagaras，然后又“回心转意”。
chap1_para752,3,,之所以会发生这些改变，是因为每次扩展当前的最优路径时，它的f值很可能增加——对于靠近目标的节点，h值通常不那么乐观。
chap1_para752,4,,当这种情况发生时，次优路径可能会成为最优路径，因此搜索必须回溯。
chap1_para752,5,,每一次改变对应于IDA*的一次迭代，并且可能需要多次重新扩展已经遗忘的节点，以重建最优路径，并对该路径再扩展一个节点。
chap1_para753,1,,图3-23　使用RBFS搜索到Bucharest的最短路线的各个阶段。
chap1_para753,2,,每次递归调用的f_limit值标注在每个当前节点的上方，每个节点上都标有它的f代价。
chap1_para753,3,,（a）沿着经过Rimnicu Vilcea的路径前进，直到当前最优叶节点（Pitesti）的值比最优备选路径（Fagaras）差。
chap1_para753,4,,（b）递归回溯，被遗忘子树的最优叶节点值（417）被备份到Rimnicu Vilcea；接着扩展Fagaras，得到最优叶节点值450。
chap1_para753,5,,（c）递归回溯，被遗忘子树的最优叶节点值（450）被备份到Fagaras；然后扩展Rimnicu Vilcea。
chap1_para753,6,,这一次，因为最优备选路径（经由Timisoara）的代价至少为447，所以继续扩展Bucharest
chap1_para754,1,,如果启发式函数h(n)是可容许的，那么RBFS是最优的。
chap1_para754,2,,它的空间复杂性在最深的最优解的深度上是线性的，但时间复杂性很难刻画：既取决于启发式函数的准确性，也取决于最优路径随节点扩展变化的频率。
chap1_para754,3,,它按照f得分递增的顺序来扩展节点，即使f是非单调的。
chap1_para755,1,,IDA*和RBFS使用内存太少，它们的时间复杂性会受到影响。
chap1_para755,2,,在两次迭代之间，IDA*只保留一个数值：当前的f代价限制。
chap1_para755,3,,RBFS在内存中保留了更多的信息，但它只使用线性空间：即使有更多的内存可用，RBFS也无法利用。
chap1_para755,4,,因为它们会遗忘它们所做的大部分事情，这两种算法都可能会多次重复探索相同状态。
chap1_para756,1,,因此，确定我们有多少可用内存并允许算法使用所有内存似乎是明智的。
chap1_para756,2,,执行这样操作的两种算法是MA*（memory-bounded A*，内存受限的A*）和SMA*（simplified MA*，简化的MA*）。
chap1_para756,3,,SMA*更简单一些，所以我们介绍SMA*。
chap1_para756,4,,SMA*很像A*算法，不断扩展最优叶节点，直到内存被填满。
chap1_para756,5,,此时，它不能再为搜索树添加新节点，除非删除旧节点。
chap1_para756,6,,SMA*总是丢弃最差的叶节点，即f值最大的叶节点。
chap1_para756,7,,和RBFS一样，SMA*将被遗忘节点的值备份到其父节点。
chap1_para756,8,,这样，被遗忘子树的祖先知道该子树中最优路径的质量。
chap1_para756,9,,有了这一信息，只有在所有其他路径看起来都比它已经遗忘的路径更差时，SMA*才会重新生成该子树。
chap1_para756,10,,这意味着如果节点n的所有后代都被遗忘了，那么尽管我们不知道从n开始应该走哪条路径，但我们仍知道是否应该从n开始走。
chap1_para757,1,,本书附带的在线代码库中描述了完整的SMA*算法。
chap1_para757,2,,有一点值得注意，我们之前提到SMA*将扩展最优叶节点，删除最差叶节点。
chap1_para757,3,,如果所有叶节点的f值都相同呢？
chap1_para757,4,,为了避免算法选择同一个节点进行删除和扩展操作，SMA*扩展最新的最优叶节点并删除最老的最差叶节点。
chap1_para757,5,,当只有一个叶节点时，这两者是同一个节点，但在这种情况下，当前的搜索树一定是一条从根节点到叶节点的占满所有内存的单一路径。
chap1_para757,6,,如果叶节点不是目标节点，那么即使它在最优解路径上，也无法在可用内存范围内得到这个解。
chap1_para757,7,,因此，完全可以丢弃该节点，就好像它没有后继节点一样。
chap1_para758,1,,如果存在任意可达解，也就是说，如果最浅的目标节点的深度d小于内存大小（用节点数表示），那么SMA*就是完备的。
chap1_para758,2,,如果存在可达的最优解，那么SMA*就是最优的；否则，就返回当前最优的可达解。
chap1_para758,3,,在实践中，SMA*是寻找最优解的一个相当稳健的选择，特别是当状态空间是一个图、行动代价不一致，并且生成节点的总开销相比维护边界集和已达集的总开销更大时。
chap1_para759,1,,然而，在非常困难的问题上，常常会出现SMA*被迫在许多候选解路径之间来回不断切换的情况，只有一小部分路径可以存入内存。
chap1_para759,2,,［这类似于磁盘分页系统中的抖动（thrashing）问题。
chap1_para759,3,,］那么，重复生成相同节点就需要额外的时间，这意味着，在给定无限内存的情况下可以用A*实际求解的问题，对于SMA*将变得难以处理。
chap1_para759,4,,也就是说，从计算时间的角度，内存限制会使问题变得难以处理。
chap1_para759,5,,虽然还没有现有理论解释如何在时间和内存之间权衡，但这似乎是一个不可避免的问题。
chap1_para759,6,,唯一的出路是放弃最优性要求。
chap1_para76,1,"The formalization of probability, combined with the availability of data, led to the emergence of statistics as a field. One of the first uses was John Graunt’s analysis of London census data in 1662. Ronald Fisher is considered the first modern statistician (Fisher, 1922). He brought together the ideas of probability, experiment design, analysis of data, and computing—in 1919, he insisted that he couldn’t do his work without a mechanical calculator called the MILLIONAIRE (the first calculator that could do multiplication), even though the cost of the calculator was more than his annual salary (Ross, 2012).",但是，思考有时伴随着行为，有时却没有，有时伴随着行动，有时却没有，这是如何发生的？
chap1_para76,2,,这看起来和对不变的对象进行推理和推断时发生的情况几乎是一样的。
chap1_para76,3,,但是在那种情况下，结局是一个推测性的命题……而在这里，由两个前提得出的结论是一个行为……我需要覆盖物；斗篷是一种覆盖物。
chap1_para76,4,,我需要一件斗篷。
chap1_para76,5,,我需要什么，我必须做什么；我需要一件斗篷。
chap1_para76,6,,我必须做一件斗篷。
chap1_para76,7,,结论是，“我必须做一件斗篷”，这是一个行为。
chap1_para760,1,,3.5.6　双向启发式搜索
chap1_para761,1,,我们发现，在单向最佳优先搜索中，使用f(n) = g(n) + h(n)作为评价函数可以得到A*搜索，保证找到代价最优的解（假设h是可容许的），同时在所扩展的节点数上效率最优。
chap1_para762,1,,在双向最佳优先搜索中，我们也可以尝试使用f(n) = g(n) + h(n)，但遗憾的是，即使使用可容许的启发式函数，算法也不能保证可以找到代价最优的解，更不能保证效率最优。
chap1_para762,2,,"可以证明的是，在双向搜索中一定会被扩展的并不是单个的节点，而是节点对（分别来自两个边界），因此任何效率证明都必须考虑节点对（Eckerle et al., 2017）。"
chap1_para763,1,,我们先介绍一些新的符号。
chap1_para763,2,,对于正向搜索（以初始状态作为根节点）中的节点，我们用fF(n) = gF(n) + hF(n)作为评价函数；对于反向搜索（以某个目标状态作为根节点）中的节点，我们用fB(n) = gB(n) + hB(n)作为评价函数。
chap1_para763,3,,尽管正向搜索和反向搜索求解的是同一个问题，但它们具有不同的评价函数，这是因为，启发式函数依据其努力方向是目标状态还是初始状态而有所不同。
chap1_para763,4,,我们假设启发式函数是可容许的。
chap1_para764,1,,考虑从初始状态到节点m的正向路径和从目标到节点n的反向路径。
chap1_para764,2,,我们可以如下定义一个解代价的下界（这个解先沿着前向路径从初始状态到达m，然后以某种方式到达n，最后再沿着后向路径从n到达目标）。
chap1_para765,1,,换句话说，这样一条路径的代价一定不小于两部分路径代价之和（因为它们之间的剩余连接一定具有非负代价），而且也一定不小于任一部分的f代价估计值（因为启发式的估计是乐观的）。
chap1_para765,2,,"因此，有如下的定理：对于任意一对节点m和n，若lb(m, n)小于最优代价C*，那么算法必须扩展m或n，因为经过这两个节点的路径是一个潜在的最优解。"
chap1_para765,3,,然而，一个难题是我们无法确定扩展这两者中的哪个节点才是最优的，因此，没有一个双向搜索算法可以保证效率最优——如果算法总是首先选择一对节点中错误的那个进行扩展，那么任何算法都可能需要扩展到最小节点数两倍的节点。
chap1_para765,4,,"一些双向启发式搜索算法显式地管理一个(m, n)节点对队列，但我们将坚持双向最佳优先搜索（图3-14），它有两个边界优先队列，并使用模拟lb准则的评价函数："
chap1_para766,1,,接下来要扩展的节点将是f2值最小的节点；它可以来自任何一个边界。
chap1_para766,2,,这个f2函数保证算法永远不会扩展（来自任一边界的）的节点。
chap1_para766,3,,当两个边界相交时，任一边界内的节点都不存在超过C*/2的路径代价，在这种意义上，我们可以说搜索的两部分“在中间相遇”。
chap1_para766,4,,图3-24为一个双向搜索的示例。
chap1_para767,1,,图3-24　双向搜索维护两个边界：左半部分，节点A和B是开始状态的后继；右半部分，节点F是目标状态的逆向后继。
chap1_para767,2,,"每个节点都标有f = g + h值和f2 = max(2g, g + h)值。"
chap1_para767,3,,（g值是每个箭头上所显示的动作代价的总和；h值是任意的，而且不能从图中的任何内容推出。
chap1_para767,4,,）最优解“开始-A-F-目标”的代价C* = 4 + 2 + 4 = 10，这意味着一个在中间相遇的双向算法不应该扩展任何的节点；实际上，下一个要扩展的节点是A或F（g = 4），这将引导我们找到一个最优解。
chap1_para767,5,,如果我们首先扩展f代价最低的节点，那么下一个扩展的将是B和C，D和E将与A并列，但它们的，因此当f2是评价函数时它们永远不会被扩展
chap1_para768,1,,我们已经介绍了一种方法，即用hF估计到目标的距离（或者说，当问题有多个目标状态时，估计到最近目标的距离），用hB估计到开始状态的距离。
chap1_para768,2,,这就是所谓的front-to-end搜索。
chap1_para768,3,,另一种方法是front-to-front搜索，它试图估计到另一个边界的距离。
chap1_para768,4,,显然，如果边界内有数百万个节点，那么对每个节点应用启发式函数然后取最小值是非常低效的。
chap1_para768,5,,但它可以从边界中抽样几个节点。
chap1_para768,6,,在某些特定问题域中，可以对边界进行总结，例如，在网格搜索问题中，我们可以递增地计算边界的界限框，并使用到界限框的距离作为启发式函数。
chap1_para769,1,,双向搜索有时比单向搜索更有效，有时则不然。
chap1_para769,2,,一般来说，如果我们有一个很好的启发式函数，那么A*搜索会生成专注于目标的搜索等值线，使用双向搜索则增益不大。
chap1_para769,3,,使用一般的启发式函数时，在中间相遇的双向搜索往往会扩展较少的节点，因此双向搜索是首选方法。
chap1_para769,4,,在启发式函数较差的最坏情况下，搜索算法将不再专注于目标，并且双向搜索具有与A*相同的渐近复杂性。
chap1_para769,5,,使用f2评价函数和可容许的启发式函数h的双向搜索算法是完备且最优的。
chap1_para77,1,"The history of computation is as old as the history of numbers, but the first nontrivial algorithm is thought to be Euclid’s algorithm for computing greatest common divisors. The word algorithm comes from Muhammad ibn Musa al-Khwarizmi, a 9th century mathematician, whose writings also introduced Arabic numerals and algebra to Europe. Boole and others discussed algorithms for logical deduction, and, by the late 19th century, efforts were under way to formalize general mathematical reasoning as logical deduction.",在《尼各马可伦理学》（Nicomachean Ethics）（第三卷第3章，1112b）中，亚里士多德进一步阐述了这个主题，并提出了一个算法：
chap1_para771,1,,在本节中，我们将研究启发式函数的准确性是如何影响搜索性能的，并考虑如何构造启发式函数。
chap1_para771,2,,我们将8数码问题作为主要示例。
chap1_para771,3,,如3.2节所述，它的目标是将滑块水平或竖直地滑动到空格中，直到棋盘布局与目标布局一致（图3-25）。
chap1_para772,1,,图3-25　8数码问题的典型实例。
chap1_para772,2,,最短的解需要26步动作
chap1_para773,1,,在一个8数码问题中，存在9!/2 = 181 400个可达状态，所以搜索算法可以轻松地将它们全部保存在内存中。
chap1_para773,2,,但是对于15数码问题，存在16!/2个状态（超过10万亿个），因此，为了搜索这个空间，我们需要借助一个较好的可容许的启发式函数。
chap1_para773,3,,对于15数码问题，这样的启发式函数有着悠久的历史。
chap1_para773,4,,下面介绍两个常用的选择。
chap1_para774,1,,● h1 = 错位滑块的数量（不包括空格）。
chap1_para774,2,,图3-25中，所有的8个滑块都不在原位，所以开始状态的h1 = 8。
chap1_para774,3,,h1是一个可容许的启发式函数，因为任何错位滑块都至少需要一次移动才能回到正确的位置。
chap1_para775,1,,● h2 = 滑块到其目标位置距离的总和。
chap1_para775,2,,因为滑块不能沿对角线移动，所以距离是水平距离和垂直距离之和——有时称为城市街区距离或曼哈顿距离（Manhattan distance）。
chap1_para775,3,,h2也是可容许的，因为任何移动操作所能做的就是将一个滑块向目标移近一步。
chap1_para775,4,,图3-25中开始状态的滑块1到滑块8得到的曼哈顿距离为
chap1_para776,1,,正如我们希望的那样，这两种方法都没有高估实际的解代价26。
chap1_para777,1,,3.6.1　启发式函数的准确性对性能的影响
chap1_para778,1,,一种描述启发式函数质量的方法是有效分支因子（effective branching factor）b*。
chap1_para778,2,,如果针对一个特定问题，A*搜索所生成的总节点数是n，而解的深度是d，那么b*就是深度为d的均衡树要包含n + 1个节点所必需的分支因子。
chap1_para778,3,,因此有
chap1_para779,1,,例如，如果A*用52个节点在第5层上找到了一个解，那么有效分支因子是1.92。
chap1_para779,2,,在不同的问题实例中，有效分支因子可能会发生变化，但通常对于特定领域（如8数码问题），在所有复杂的问题实例中它都是相当恒定的。
chap1_para779,3,,因此，对一小部分问题的b*进行实验测量可以为启发式函数的总体有用性提供良好的指导。
chap1_para779,4,,设计良好的启发式函数的b*接近1，使得我们能以合理的计算代价求解相当大的问题。
chap1_para78,1,"Kurt Gӧdel (1906–1978) showed that there exists an effective procedure to prove any true statement in the first-order logic of Frege and Russell, but that first-order logic could not capture the principle of mathematical induction needed to characterize the natural numbers. In 1931, Gӧdel showed that limits on deduction do exist. His incompleteness theorem showed that in any formal theory as strong as Peano arithmetic (the elementary theory of natural numbers), there are necessarily true statements that have no proof within the theory.",我们考虑的不是目的，而是实现目的的手段。
chap1_para78,2,,医生并不考虑是否要使一个人健康，演说家并不考虑是否要去说服听众……他们是先确定一个目的，然后考虑用什么手段和方式来达到目的。
chap1_para78,3,,如果有几种手段，他们考虑的就是哪种手段最能实现目的。
chap1_para78,4,,如果只有一种手段，他们考虑的就是怎样利用这一手段去达到目的，这一手段又需要通过哪种手段来获得。
chap1_para78,5,,这样，他们就在所发现的东西中一直追溯到最初的东西……分析的终点也就是起点。
chap1_para78,6,,如果恰巧遇到不可能的事情，例如需要钱却得不到钱，那么就放弃这种考虑。
chap1_para78,7,,而所谓可能的事情，就是以我们自身能力可以做到的那些事情。
chap1_para78,8,,[8]
chap1_para780,1,,"科尔夫和里德（Korf and Reid, 1998）认为，对于一个使用给定启发式函数h的A*剪枝，刻画其效果的一个更好方式是：有效深度（effective depth）相比于真实深度的减少量kh（一个常数）。"
chap1_para780,2,,这意味着相较于无信息搜索的代价O(bd)，上述方法的总搜索代价为。
chap1_para780,3,,他们在魔方和n数码问题上的实验结果表明，这一公式可以准确地预测各种解长度范围内（至少对于大于kh的解长度）的抽样问题实例的总搜索代价。
chap1_para781,1,,在图3-26中，我们生成了随机8数码问题，并使用无信息广度优先搜索和使用h1或h2的A*搜索求解该问题，报告了每种搜索策略和每种解长度所生成的平均节点数及相应的有效分支因子。
chap1_para781,2,,结果表明，h2优于h1，两者都优于无启发式算法。
chap1_para782,1,,图3-26　使用广度优先搜索、使用h1（错位滑块）的A*搜索或使用h2（曼哈顿距离）的A*搜索求解8数码问题的搜索代价和有效分支因子的比较。
chap1_para782,2,,每个解长度d（6～28）的数据为100多个实例的平均结果
chap1_para783,1,,有人可能会问，h2是否总是优于h1。
chap1_para783,2,,答案是“基本上，是的”。
chap1_para783,3,,从这两种启发式函数的定义可以看出，对于任意节点n，都有。
chap1_para783,4,,因此我们说h2占优于（dominate）h1。
chap1_para783,5,,优势可以直接转化为效率：使用h2的A*永远不会比使用h1的A*扩展更多的节点（除了的节点）。
chap1_para783,6,,证明很简单。
chap1_para783,7,,回想一下3.5.3节观察到的，每个的节点都一定会被扩展。
chap1_para783,8,,也就是说，当h一致时，每个的节点都一定会被扩展。
chap1_para783,9,,但是，因为对于所有节点，h2至少和h1一样大，每个在h2下一定会被扩展的节点在h1下也一定会被扩展，而h1还可能导致其他的节点也被扩展。
chap1_para783,10,,因此，通常情况下，只要启发式函数是一致的并且其计算时间不太长，使用具有较高值的启发式函数效果都会更好。
chap1_para784,1,,3.6.2　从松弛问题出发生成启发式函数
chap1_para785,1,,我们已经看到，对于8数码问题，h1（错位滑块）和h2（曼哈顿距离）都是相当好的启发式函数，其中h2更好。
chap1_para785,2,,人们是怎么想出h2这样的启发式函数的？
chap1_para785,3,,计算机是否有可能自动地设计出这种启发式函数？
chap1_para786,1,,h1和h2是对8数码问题剩余路径长度的估计，但对简化版本的问题来说，它们也是非常精确的路径长度。
chap1_para786,2,,如果改变游戏规则，即滑块可以移动到任何地方，而不是只能移动到相邻的空格，那么h1将给出最短解的准确长度。
chap1_para786,3,,类似地，如果一个滑块可以向任意方向移动一个方格，甚至移动到一个被占用的方格上，那么h2将给出最短解的准确长度。
chap1_para786,4,,减少了对动作的限制条件的问题称为松弛问题（relaxed problem）。
chap1_para786,5,,松弛问题的状态空间图是原始状态空间的一个超图，因为删除限制条件会导致原图中边的增加。
chap1_para787,1,,因为松弛问题向状态空间图中添加了一些边，根据定义，原问题的任一最优解也是松弛问题的一个解；但是，如果增加的边提供了捷径，松弛问题可能有更好的解。
chap1_para787,2,,因此，松弛问题中最优解的代价可以作为原问题的一个可容许的启发式函数。
chap1_para787,3,,此外，因为得到的启发式函数是松弛问题的准确代价，所以它一定满足三角不等式，因此它是一致的（见3.5.2节）。
chap1_para788,1,,如果用形式语言定义一个问题，则可以自动构造它的松弛问题。
chap1_para788,2,,[14]例如，如果将8数码问题的行动描述为
chap1_para79,1,"This fundamental result can also be interpreted as showing that some functions on the integers cannot be represented by an algorithm—that is, they cannot be computed. This motivated Alan Turing (1912–1954) to try to characterize exactly which functions are computable—capable of being computed by an effective procedure. The Church–Turing thesis proposes to identify the general notion of computability with functions computed by a Turing machine (Turing, 1936). Turing also showed that there were some functions that no Turing machine can compute. For example, no machine can tell in general whether a given program will return an answer on a given input or run forever.",
chap1_para790,1,,[14]　在第8章和第11章中，我们将介绍适用于此任务的形式语言：有了可操纵的形式化描述，就可以自动化地构建松弛问题。
chap1_para790,2,,现在，我们先使用自然语言。
chap1_para791,1,,如果方格X与方格Y相邻，且Y是空格，那么滑块可以从方格X移动到方格Y。
chap1_para792,1,,我们可以通过删除一个或两个条件来生成3种松弛问题。
chap1_para793,1,,（a）如果方格X与方格Y相邻，那么滑块可以从方格X移动到方格Y。
chap1_para794,1,,（b）如果方格Y是空格，那么滑块可以从方格X移动到方格Y。
chap1_para795,1,,（c）滑块可以从方格X移动到方格Y。
chap1_para796,1,,由（a）可以推导出h2（曼哈顿距离）。
chap1_para796,2,,原因是，如果我们将每个滑块依次移动到其目标位置，那么h2就是准确的步数。
chap1_para796,3,,由（b）推导出的启发式函数将在习题3.GASC中讨论。
chap1_para796,4,,由（c）我们可以推导出h1（错位滑块），因为如果可以仅用一步就将滑块移动到其预期目标位置，那么h1就是准确的步数。
chap1_para796,5,,需要注意的是，通过这种方法生成的松弛问题本质上不需要搜索就能求解，因为松弛规则将问题分解为8个独立的子问题。
chap1_para796,6,,如果松弛问题本身很难求解，那么获取相应的启发式函数值的代价将非常高。
chap1_para797,1,,"Absolver程序可以通过“松弛问题”方法及各种其他技术从问题定义中自动生成启发式函数（Prieditis, 1993）。"
chap1_para797,2,,Absolver为8数码问题生成了一种新的启发式函数，它优于任何已有的启发式函数。
chap1_para797,3,,此外，Absolver为著名的魔方问题找到了第一种有效的启发式函数。
chap1_para798,1,,"如果一个可容许的启发式函数集合h1, …, hm可以求解同一个问题，但没有一个函数明显优于其他函数，那么我们应该选择哪个函数？"
chap1_para798,2,,事实证明，我们可以通过如下定义，得到最优的启发式函数：
chap1_para799,1,,这种复合启发式函数将选择对于所讨论节点最准确的函数。
chap1_para799,2,,因为hi都是可容许的，所以h也是可容许的（如果hi都是一致的，则h也是一致的）。
chap1_para799,3,,此外，h优于所有组成它的启发式函数。
chap1_para799,4,,唯一的缺点是h(n)的计算时间更长。
chap1_para799,5,,如果考虑这一问题，另一种选择是在每次评价时随机选择一个启发式函数，或者使用机器学习算法来预测哪个启发式函数是最优的。
chap1_para799,6,,这样做可能会导致启发式函数失去一致性（即使每个hi都是一致的），但在实践中，它通常能更快地求解问题。
chap1_para8,1,1.,[1]　公众有时会将“人工智能”和“机器学习”这两个术语混淆。
chap1_para8,2,1.,机器学习是人工智能的子领域，研究基于经验提升表现的能力。
chap1_para8,3,1Acting humanly: The Turing test approach,有些人工智能系统使用机器学习方法来获得能力，有些则不然。
chap1_para80,1,"Although computability is important to an understanding of computation, the notion of tractability has had an even greater impact on AI.",[8]　此处对《尼各马可伦理学》一书中的引用采用了商务印书馆2017年8月出版的廖申白翻译的《尼各马可伦理学》版本中的译文。
chap1_para80,2,"Roughly speaking, a problem is called intractable if the time required to solve instances of the problem grows exponentially with the size of the instances.",——编者注
chap1_para80,3,"The distinction between polynomial and exponential growth in complexity was first emphasized in the mid-1960s (Cobham, 1964; Edmonds, 1965).",
chap1_para80,4,It is important because exponential growth means that even moderately large instances cannot be solved in any reasonable time.,
chap1_para800,1,,3.6.3　从子问题出发生成启发式函数：模式数据库
chap1_para801,1,,可容许的启发式函数也可以由给定问题的子问题（subproblem）的解代价推导得到。
chap1_para801,2,,例如，图3-27为图3-25中8数码问题实例的一个子问题。
chap1_para801,3,,子问题涉及将滑块1、2、3、4和空格分别放置到正确位置。
chap1_para801,4,,显然，这个子问题最优解的代价是完整问题代价的一个下界。
chap1_para801,5,,在某些情况下，它比曼哈顿距离更准确。
chap1_para802,1,,图3-27　图3-25中所给出的8数码实例的子问题。
chap1_para802,2,,任务是将滑块1、2、3、4和空格放置到正确位置，而不考虑其他滑块的情况
chap1_para803,1,,模式数据库（pattern database）的思想是为每个可能的子问题（在我们的示例中，为4个滑块和空格的所有可能排列）存储准确的解代价。
chap1_para803,2,,（数据库中将有9×8×7×6×5 = 15 120种模式。
chap1_para803,3,,其他4个滑块与子问题的求解无关，但移动这些滑块将计入子问题的解代价。
chap1_para803,4,,）然后，通过在数据库中查找相应的子问题，为搜索过程中遇到的每个状态计算一个可容许的启发式函数hDB。
chap1_para803,5,,数据库本身是从目标状态反向搜索并记录所遇到的每个新模式的代价来构建的[15]；这一搜索的开销将分摊到后续的问题实例中，因此如果我们需要求解很多问题，那么这种方法是有意义的。
chap1_para805,1,,[15]　通过从目标反向回溯，可以立即获得所遇到的每个实例的准确的解代价。
chap1_para805,2,,这是动态规划的一个示例，我们将在第17章进一步讨论。
chap1_para806,1,,与空格搭配的滑块1-2-3-4的选择是相当随意的；我们还可以为5-6-7-8、2-4-6-8等建立数据库。
chap1_para806,2,,每个数据库产生一种可容许的启发式函数，正如前文所述，可以通过取最大值对这些启发式函数进行组合。
chap1_para806,3,,这种组合的启发式函数要比曼哈顿距离精确得多；求解随机15数码问题时所生成的节点数可以减少到千分之一。
chap1_para806,4,,然而，每增加一个数据库，收益会随之减少，内存和计算成本也会增加。
chap1_para807,1,,你们可能想知道从1-2-3-4数据库和5-6-7-8数据库中得到的启发式函数是否可以相加，因为这两个子问题似乎没有重叠。
chap1_para807,2,,这会是一个可容许的启发式函数吗？
chap1_para807,3,,答案是否定的，因为对于一个给定的状态，1-2-3-4子问题和5-6-7-8子问题的解一定会有一些重复操作——1-2-3-4不可能在不接触5-6-7-8的情况下移动到位，反之亦然。
chap1_para807,4,,但是，如果我们不计入这些操作，换句话说，如果我们让其他滑块直接消失呢？
chap1_para807,5,,也就是说，我们不记录求解1-2-3-4子问题的总代价，而只记录与1-2-3-4有关的操作数。
chap1_para807,6,,那么这两个代价的和仍然是求解完整问题代价的一个下界。
chap1_para807,7,,这就是不相交模式数据库（disjoint pattern database）的思想。
chap1_para807,8,,有了这样的数据库，可以在几毫秒内求解随机的15数码问题——与使用曼哈顿距离相比，生成的节点数不到原来的万分之一。
chap1_para807,9,,对于24数码问题，则可以获得大约一百万倍的加速。
chap1_para807,10,,不相交模式数据库适用于滑块数码问题，因为每次移动只涉及一个滑块，因而原问题可以被划分成若干个子问题使得每次移动只影响一个子问题。
chap1_para808,1,,3.6.4　使用地标生成启发式函数
chap1_para809,1,,一些在线服务可以托管含有数千万个顶点的地图，并在毫秒内找到代价最优的驾驶路线。
chap1_para809,2,,即使是我们之前提到的最优的搜索算法，做到这一点也要比这些在线服务多耗费100万倍的时间。
chap1_para809,3,,那在线服务是怎么做到这一点的呢？
chap1_para809,4,,这里有很多技巧，但最重要的是对一些最优路径代价的预计算（precomputation）。
chap1_para809,5,,虽然预计算可能相当耗时，但只需完成一次预计算，就可以摊销数十亿用户的搜索请求。
chap1_para81,1,"The theory of NP-completeness, pioneered by Cook (1971) and Karp (1972), provides a basis for analyzing the tractability of problems: any problem class to which the class of NP-complete problems can be reduced is likely to be intractable. (Although it has not been proved that NP-complete problems are necessarily intractable, most theoreticians believe it.) These results contrast with the optimism with which the popular press greeted the first computers—“Electronic Super-Brains” that were “Faster than Einstein!” Despite the increasing speed of computers, careful use of resources and necessary imperfection will characterize intelligent systems. Put crudely, the world is an extremely large problem instance!",2300年后，纽厄尔和西蒙在他们的通用问题求解器（General Problem Solver）程序中实现了亚里士多德的算法。
chap1_para81,2,,我们现在将其称为贪婪回归规划系统（见第11章）。
chap1_para81,3,,在人工智能理论研究的前几十年中，基于逻辑规划以实现确定目标的方法占据主导地位。
chap1_para810,1,,我们可以通过预计算并存储每对顶点之间的最优路径代价来生成完美的启发式函数。
chap1_para810,2,,这需要空间和时间——对于含有1万个顶点的图很实用，但对于1000万个顶点，这样的复杂性不可接受。
chap1_para811,1,,更好的方法是从顶点中选择一些（也许10个或20个）地标点（landmark point）[16]。
chap1_para811,2,,"然后，对于图中每个地标L和每个其他顶点v，我们计算并存储C*(v, L)，即从v到L的最优路径的准确代价。"
chap1_para811,3,,"（我们同样需要C*(L, v)；在无向图上，C*(L, v)与C*(v, L)相同；在有向图上，如单行道，我们则需要单独计算C*(L, v)。"
chap1_para811,4,,）给定存储的C*表，我们可以很容易地创建出一个高效的（尽管是不可容许的）启发式函数：在所有地标中，从当前节点到地标然后到目标节点代价的最小值为
chap1_para813,1,,[16]　地标点有时被称为“枢轴”或“锚点”。
chap1_para814,1,,如果最优路径刚好经过一个地标，这个启发式函数将是准确的；否则，这个启发式函数就是不可容许的——它高估了到目标的代价。
chap1_para814,2,,在A*搜索中，如果启发式函数是准确的，那么一旦到达一个位于最优路径上的节点，此后所扩展的每个节点都将位于最优路径上。
chap1_para814,3,,把等值线想象为沿着这条最优路径前进。
chap1_para814,4,,搜索将沿着最优路径进行，在每次迭代中加入一个代价为c的动作，然后到达一个h值减少c的结果状态，这意味着在整条路径上总的f = g + h得分将保持在常量C*。
chap1_para815,1,,一些寻径算法通过在图中添加捷径（shortcut）——人工定义的对应于一条最优多行动路径的边——来节省更多的时间。
chap1_para815,2,,例如，如果我们在美国最大的100个城市之间预先定义了捷径，并且尝试从位于加利福尼亚州的加利福尼亚大学伯克利分校校区导航到纽约的纽约大学，那么我们可以走萨克拉门托（Sacramento）到曼哈顿（Manhattan）之间的捷径，一次动作就能覆盖90%的路径。
chap1_para816,1,,hL(n)是高效的，但不是可容许的。
chap1_para816,2,,只要稍加注意，我们就可以提出一种既高效又可容许的启发式函数：
chap1_para817,1,,这被称为差分启发式（differential heuristic）函数（因为包含减法）。
chap1_para817,2,,可以把它理解为在比目标还要远的某个位置设置一个地标点。
chap1_para817,3,,如果目标恰好在从n到该地标点的最优路径上，那么“考虑从n到L的完整路径，然后减去这条路径的最后一部分，即从goal到L，即可得到从n到goal的这段路径的准确代价”。
chap1_para817,4,,如果目标稍微偏离到地标的最优路径，启发式函数将是不准确的，但仍然是可容许的。
chap1_para817,5,,比目标近的地标是没有用的；例如，一个恰好位于n和goal正中间的地标将导致hDH = 0，这是没有用的。
chap1_para818,1,,下面我们介绍几种选择地标点的方法。
chap1_para818,2,,随机选择速度较快，但如果我们多花些功夫将地标分散开来，使得它们彼此之间不太接近，我们将得到更好的结果。
chap1_para818,3,,贪心方法是随机选择第一个地标，然后找到离它最远的点，将其添加到地标集合中，接着在每次迭代中添加离最近地标最远的点。
chap1_para818,4,,如果你有用户过去的搜索请求日志，那么你可以选择搜索中经常请求的地点作为地标。
chap1_para818,5,,对于差分启发式函数，地标分布在图的周界上更好。
chap1_para818,6,,因此，一个比较好的技术是找到图的质心，围绕质心划分出k个楔形（就像饼状图一样），并在每个楔形中选择离中心最远的顶点。
chap1_para819,1,,地标在寻径问题上尤其有效，这是由世界上道路的布局方式导致的：许多交通运输实际上都是在地标之间穿行，所以土木工程师在这些路线上修建最宽、最快的道路；地标式搜索可以更轻松地复原这些路线。
chap1_para82,1,1.,纯粹从行为的角度来思考实现目标通常是有用的，但在某些情况是不适用的。
chap1_para82,2,2.,例如，如果有几种不同的方法可以实现目标，我们就需要某种方法来进行选择。
chap1_para82,3,3Economics,更重要的是，确定性地实现一个目标可能是无法做到的，但某些行为仍然必须被实施。
chap1_para82,4,,那该如何决策呢？
chap1_para82,5,,"安托万·阿尔诺（Antoine Arnauld）（Arnauld, 1662）分析了赌博中的理性决策概念，提出了一种量化公式，可以最大化期望收入的货币价值。"
chap1_para82,6,,"后来，丹尼尔·伯努利（Daniel Bernoulli）（Bernoulli, 1738）引入了更普适的效用（utility）概念，可以体现结果的内在主观价值。"
chap1_para82,7,,如第16章所述，在不确定性下，理性决策的现代概念涉及最大化期望效用。
chap1_para820,1,,3.6.5　学习以更好地搜索
chap1_para821,1,,我们介绍了几种固定的搜索策略（广度优先、A*等），这些都是计算机科学家精心设计和编程实现的。
chap1_para821,2,,那么智能体能自己学习如何更好地搜索吗？
chap1_para821,3,,答案是肯定的，这种方法基于一个重要的概念，元级状态空间（metalevel state space）。
chap1_para821,4,,元级状态空间中的每个状态将捕捉在普通状态空间（例如罗马尼亚地图）进行搜索的程序的内部（计算）状态。
chap1_para821,5,,［为了区分这两个概念，我们将罗马尼亚地图称为对象级状态空间（object-level state space）。
chap1_para821,6,,］例如，A*算法的内部状态由当前搜索树组成。
chap1_para821,7,,元级状态空间中的每个动作都是一个改变内部状态的计算步；例如，A*中的每一个计算步扩展一个叶节点，并将其后续节点添加到树中。
chap1_para821,8,,因此，图3-18展示了一个逐渐增大的搜索树序列，它描述了元级状态空间中的一条路径，路径上的每个状态都是一棵对象级搜索树。
chap1_para822,1,,现在，图3-18中的路径共有5步，包括一个扩展Fagaras的步骤，这一步不是非常有用。
chap1_para822,2,,对于更困难的问题，将存在很多这样的错误步骤，元级学习（metalevel learning）算法可以从这些经验中学习，以避免探索毫无希望的子树。
chap1_para822,3,,这种学习算法将在第22章中介绍。
chap1_para822,4,,学习的目标是对计算开销和路径代价进行权衡，以最小化求解问题的总代价。
chap1_para823,1,,3.6.6　从经验中学习启发式函数
chap1_para824,1,,我们已经看到，生成启发式函数的一种方法是设计一个容易找到最优解的松弛问题，另一种选择是从经验中学习。
chap1_para824,2,,这里的“经验”意味着，例如，求解大量8数码问题。
chap1_para824,3,,"一个8数码问题的每个最优解都提供了一个“(目标,路径)”对作为示例。"
chap1_para824,4,,可以利用学习算法通过这些示例构造一个函数h，（幸运的话）它可以近似搜索过程中出现的其他状态的真实路径代价。
chap1_para824,5,,这些方法中的大多数学习到的都是启发式函数的一个不完美的近似，因此存在启发式函数不可容许的风险。
chap1_para824,6,,这必然导致算法需要在学习时间、搜索运行时间和解的代价之间进行权衡。
chap1_para824,7,,机器学习技术将在第19章中介绍。
chap1_para824,8,,第22章中介绍的强化学习方法也适用于搜索问题。
chap1_para825,1,,如果除了原始状态描述外，还提供与预测启发式函数值相关的状态特征（feature），那么一些机器学习技术将表现得更好。
chap1_para825,2,,例如，“错位滑块数”这一特征可能有助于预测8数码问题中状态与目标的实际距离。
chap1_para825,3,,我们将这一特征记作x1(n)。
chap1_para825,4,,我们可以使用100个随机生成的8数码配置，并收集其真实解代价的统计数据。
chap1_para825,5,,我们可能会发现，当x1(n) = 5时，平均的解代价大约是14，等等。
chap1_para825,6,,当然，可以使用多种特征。
chap1_para825,7,,例如，第二个特征x2(n)可能是“在当前状态相邻而在目标状态中不相邻的滑块对的数量”。
chap1_para825,8,,如何对x1(n)和x2(n)进行组合来预测h(n)？
chap1_para825,9,,一种常见的方法是线性组合：
chap1_para826,1,,可以调整常数c1和c2以适应随机生成的配置中实际数据的值。
chap1_para826,2,,我们希望c1和c2都是正值，因为错位滑块和不正确的相邻对都会使得问题更难求解。
chap1_para826,3,,注意，这个启发式函数满足目标状态h(n) = 0的条件，但它不一定是可容许的或一致的。
chap1_para828,1,,本章对搜索算法进行了介绍，智能体可以用这些算法在各种环境中选择动作序列——只要环境是回合式的、单智能体的、完全可观测的、确定性的、静态的、离散的和已知的。
chap1_para828,2,,算法需要在搜索所需时间、可用内存和解的质量之间进行权衡。
chap1_para828,3,,如果我们对于启发式函数的形式拥有额外的领域相关知识来估计给定状态离目标有多远，或者我们预计算涉及模式或地标的部分解，算法会更高效。
chap1_para829,1,,● 在智能体开始搜索之前，必须形式化一个良定义的问题。
chap1_para83,1,•How should we make decisions in accordance with our preferences?,在道德和公共政策方面，决策者必须考虑多个个体的利益。
chap1_para83,2,,"杰里米·边沁（Jeremy Bentham）（Bentham, 1823）和约翰·斯图尔特·穆勒（John Stuart Mill）（Mill, 1863）提出了功利主义（utilitarianism）思想：基于效用最大化的理性决策应该适用于人类活动的所有领域，包括代表许多个体做出公共政策的决策。"
chap1_para83,3,,功利主义是一种特殊的结果主义（consequentialism），行为的预期结果决定了正确与否。
chap1_para830,1,,● 问题由5部分组成：初始状态、动作集合、描述这些动作结果的转移模型、目标状态集合和动作代价函数。
chap1_para831,1,,● 问题的环境用状态空间图表示。
chap1_para831,2,,通过状态空间（一系列动作）从初始状态到达一个目标状态的路径是一个解。
chap1_para832,1,,● 搜索算法通常将状态和动作看作原子的，即没有任何内部结构（尽管我们在学习时引入了状态特征）。
chap1_para833,1,,● 根据完备性、代价最优性、时间复杂性和空间复杂性来评估搜索算法。
chap1_para834,1,,● 无信息搜索方法只能访问问题定义。
chap1_para834,2,,算法构建一棵搜索树，试图找到一个解。
chap1_para834,3,,算法会根据其首先扩展的节点而有所不同。
chap1_para835,1,,❏ 最佳优先搜索根据评价函数选择节点进行扩展。
chap1_para836,1,,❏ 广度优先搜索首先扩展深度最浅的节点；它是完备的，对于单位动作代价是最优的，但具有指数级空间复杂性。
chap1_para837,1,,❏ 一致代价搜索扩展路径代价g(n)最小的节点，对于一般的动作代价是最优的。
chap1_para838,1,,❏ 深度优先搜索首先扩展最深的未扩展节点。
chap1_para838,2,,它既不是完备的也不是最优的，但具有线性级空间复杂性。
chap1_para838,3,,深度受限搜索增加了一个深度限制。
chap1_para839,1,,❏ 迭代加深搜索在不断增加的深度限制上调用深度优先搜索，直到找到一个目标。
chap1_para839,2,,当完成全部循环检查时，它是完备的，同时对于单位动作代价是最优的，且具有与广度优先搜索相当的时间复杂性和线性级空间复杂性。
chap1_para84,1,•How should we do this when others may not go along?,相反，伊曼努尔·康德（Immanuel Kant）在1785年提出了一种基于规则或义务伦理学（deontological ethics）的理论。
chap1_para84,2,,在该理论中，“做正确的事”不是由结果决定的，而是由管理可行行为的普适社会法则所决定的，可行行为包括“不要撒谎”“不要杀人”等。
chap1_para84,3,,因此，如果期望的好处大于坏处，那么功利主义者可以撒一个善意的谎言，但康德主义者则不能这样做，因为撒谎本质上就是错误的。
chap1_para84,4,,穆勒承认规则的价值，但将其理解为基于第一性原理对结果进行推理的高效决策程序。
chap1_para84,5,,许多现代人工智能系统正是采用了这种方法。
chap1_para840,1,,❏ 双向搜索扩展两个边界，一个围绕初始状态，另一个围绕目标，当两个边界相遇时搜索停止。
chap1_para841,1,,● 有信息搜索方法可以访问启发式函数h(n)来估计从n到目标的解代价。
chap1_para841,2,,它们可以访问一些附加信息，例如，存有解代价的模式数据库。
chap1_para842,1,,❏ 贪心最佳优先搜索扩展h(n)值最小的节点。
chap1_para842,2,,它不是最优的，但通常效率很高。
chap1_para843,1,,❏ A*搜索扩展f(n) = g(n) + h(n)值最小的节点。
chap1_para843,2,,在h(n)可容许的条件下，A*是完备的、最优的。
chap1_para843,3,,对于许多问题，A*的空间复杂性仍然很高。
chap1_para844,1,,❏ 双向A*搜索有时比A*搜索本身更高效。
chap1_para845,1,,❏ IDA*（迭代加深A*搜索）是A*搜索的迭代加深版本，它解决了空间复杂性问题。
chap1_para846,1,,❏ RBFS（递归最佳优先搜索）和SMA*（简化的内存受限A*）搜索是健壮的最优搜索算法，它们仅使用有限的内存；如果时间充足，它们可以解决对A*来说内存不足的问题。
chap1_para847,1,,❏ 束搜索限制了边界的大小；因此它是非完备的、次优的，但束搜索通常能找到相当好的解，运行速度也比完备搜索更快。
chap1_para848,1,,❏ 加权A*搜索将搜索专注于一个目标，以扩展更少的节点，但它牺牲了最优性。
chap1_para849,1,,● 启发式搜索算法的性能取决于启发式函数的质量。
chap1_para849,2,,我们有时可以通过松弛问题定义、在模式数据库中存储预计算的子问题的解代价、定义地标点，或者从问题类的经验中学习来构建良好的启发式函数。
chap1_para85,1,•How should we do this when the payoff may be far in the future?,
chap1_para852,1,,第4章　复杂环境中的搜索
chap1_para853,1,,在本章中，我们放宽了第3章的简化假设，以更接近真实世界。
chap1_para854,1,,第3章讨论了完全可观测的、确定性的、静态的、已知的环境中的问题，问题的解是一个动作序列。
chap1_para854,2,,在本章中，我们将放宽这些限制。
chap1_para854,3,,首先，我们考虑这样一个问题，即寻找一个好的状态而不考虑到达该状态的路径，状态包括离散状态（4.1节）和连续状态（4.2节）。
chap1_para854,4,,然后，我们放宽了确定性假设（4.3节）和可观测性假设（4.4节）。
chap1_para854,5,,在一个非确定性的世界中，智能体将需要一个条件规划，并根据它所观测到的情况执行不同的动作——例如，红灯停，绿灯行。
chap1_para854,6,,对于部分可观测性环境，智能体还需要记录它的可能状态。
chap1_para854,7,,最后，4.5节将指导智能体使用在线搜索（online search）通过一个未知空间，在未知空间中一边前进一边学习。
chap1_para855,1,,4.1　局部搜索和最优化问题
chap1_para856,1,,在第3章的搜索问题中，我们希望找到一条通过搜索空间的路径，如一条从Arad到Bucharest的路径。
chap1_para856,2,,但有时我们只关心最终状态，而不是到达状态的路径。
chap1_para856,3,,例如，在8皇后问题中（图4-3），我们只关心如何找到8个皇后的有效最终配置（因为如果知道配置，重构它的创建步骤就非常简单）。
chap1_para856,4,,这也适用于许多重要应用，例如集成电路设计、工厂车间布局、作业车间调度、自动编程、电信网络优化、农作物种植规划和投资组合管理。
chap1_para857,1,,局部搜索（local search）算法的操作是从一个起始状态搜索到其相邻状态，它不记录路径，也不记录已达状态集。
chap1_para857,2,,这意味着它们不是系统性的——可能永远不会探索问题的解实际所在的那部分搜索空间。
chap1_para857,3,,但是，它们有两个主要优点：（1）使用很少的内存；（2）通常可以在系统性算法不适用的大型或无限状态空间中找到合理的解。
chap1_para858,1,,局部搜索算法也可以求解最优化问题（optimization problem），其目标是根据目标函数（objective function）找到最优状态。
chap1_para859,1,,为了理解局部搜索，我们考虑在状态空间地形图（state-space landscape）中布局的问题状态，如图4-1所示。
chap1_para859,2,,地形图中的每个点（状态）都有一个“标高”，由目标函数值定义。
chap1_para859,3,,如果标高对应于目标函数，那么目的就是找到最高峰——全局极大值（global maximum）——我们称这个过程为爬山（hill climbing）；如果标高对应于代价，那么目的就是找到最低谷——全局极小值（global minimum）——我们称之为梯度下降（gradient descent）。
chap1_para86,1,"The science of economics originated in 1776, when Adam Smith (1723–1790) published An Inquiry into the Nature and Causes of the Wealth of Nations. Smith proposed to analyze economies as consisting of many individual agents attending to their own interests. Smith was not, however, advocating financial greed as a moral position: his earlier (1759) book The Theory of Moral Sentiments begins by pointing out that concern for the well-being of others is an essential component of the interests of every individual.",● 得出有效结论的形式化规则是什么？
chap1_para860,1,,图4-1　一维状态空间地形图，其标高对应于目标函数。
chap1_para860,2,,目的是找到全局极大值
chap1_para861,1,,4.1.1　爬山搜索
chap1_para862,1,,爬山搜索算法如图4-2所示。
chap1_para862,2,,它记录当前状态并在每次迭代中移动到值最大的相邻状态，也就是说，它朝最陡上升（steepest ascent）的方向前进。
chap1_para862,3,,当它到达一个没有邻居具有更高值的“峰值”时，算法终止。
chap1_para862,4,,爬山法不会考虑超出当前状态的直接邻居之外的状态。
chap1_para862,5,,这就像是一个健忘的人在大雾中试图找到珠穆朗玛峰的顶峰。
chap1_para862,6,,注意，使用爬山搜索的一种方法是使用启发式代价函数的负值作为目标函数；算法将局部地爬升至到目标的启发式距离最小的状态。
chap1_para863,1,,图4-2　爬山搜索算法是最基本的局部搜索技术。
chap1_para863,2,,在每一步中，当前节点被其最优邻居节点替换
chap1_para864,1,,我们将使用8皇后问题（图4-3）进一步说明爬山法。
chap1_para864,2,,我们将使用一个完整状态形式化（complete-state formulation），即每个状态都包含解的所有组成部分，但它们可能并不都在正确的位置。
chap1_para864,3,,在这种情况下，每个状态都包括在棋盘上放置8个皇后，每列一个。
chap1_para864,4,,初始状态是随机选择的，状态后继是通过将一个皇后移动到同一列中的另一格所生成的所有可能状态（所以每个状态有8×7 = 56个后继）。
chap1_para864,5,,启发式代价函数h是可相互攻击的皇后对的数量；只有当该状态是一个解时，h值才是0。
chap1_para864,6,,（如果两个皇后在同一条线上，即使它们之间存在一个中间棋子，这两个皇后也会被视为形成相互攻击。
chap1_para864,7,,）图4-3b展示了一个h = 17的状态以及它所有后继的h值。
chap1_para865,1,,爬山法有时被称为贪心局部搜索（greedy local search），因为它只是选择最优的邻居状态，而不事先考虑下一步该如何走。
chap1_para865,2,,虽然贪婪被视为七宗罪之一，但事实证明，贪心算法往往相当有效。
chap1_para865,3,,爬山法可以在求解问题时取得快速进展，因为它通常可以很容易地改善一个差的状态。
chap1_para865,4,,例如，只需5步就可以从图4-3b的状态到达图4-3a的状态，该状态的h = 1，与解非常接近。
chap1_para865,5,,遗憾的是，爬山法可能会由于以下原因而陷入困境。
chap1_para866,1,,● 局部极大值（local maxima）：局部极大值是一个比它每个相邻状态都高但比全局极大值低的峰顶。
chap1_para866,2,,爬山法到达局部极大值附近就会被向上拉向峰顶，但随后将困在局部极大值处无路可走。
chap1_para866,3,,图4-1示意性地说明了这一问题。
chap1_para866,4,,更具体地说，图4-3a中的状态是一个局部极大值（即代价h的局部极小值）；不管移动哪个皇后都会让情况变得更差。
chap1_para867,1,,图4-3　（a）8皇后问题：在棋盘上放置8个皇后，使得它们不能互相攻击。
chap1_para867,2,,（皇后会攻击同一行、同一列或对角线上的任何棋子。
chap1_para867,3,,）当前状态非常接近于一个解，除了第4列和第7列的两个皇后会沿对角线互相攻击。
chap1_para867,4,,（b）一个8皇后状态，其启发式代价估计值h = 17。
chap1_para867,5,,棋盘显示了通过在同一列移动皇后而获得的每一个可能后继的h值。
chap1_para867,6,,有8个移动并列最优，其h = 12。
chap1_para867,7,,爬山法将选择它们中的一个
chap1_para868,1,,● 岭（ridge）：如图4-4 所示。
chap1_para868,2,,岭的存在将导致一系列局部极大值，对于贪心算法，这是很难处理的。
chap1_para869,1,,图4-4　岭为爬山法带来困难的示意图。
chap1_para869,2,,状态网格（蓝色圆点）叠加在从左到右上升的岭上，形成了一个彼此不直接相连的局部极大值序列。
chap1_para869,3,,从每个局部极大值出发，所有可选动作都指向下坡。
chap1_para869,4,,这样的拓扑在低维状态空间中很常见，例如二维平面中的点。
chap1_para869,5,,但是在具有成百上千个维度的状态空间中，这种直观图并不成立，而且通常至少存在几个维度使得算法有可能漏掉岭和平台区
chap1_para87,1,"Most people think of economics as being about money, and indeed the first mathematical analysis of decisions under uncertainty, the maximum-expected-value formula of Arnauld (1662), dealt with the monetary value of bets. Daniel Bernoulli (1738) noticed that this formula didn’t seem to work well for larger amounts of money, such as investments in maritime trading expeditions. He proposed instead a principle based on maximization of expected utility, and explained human investment choices by proposing that the marginal utility of an additional quantity of money diminished as one acquired more money.",
chap1_para870,1,,● 平台区（plateau）：平台区是指状态空间地形图中的平坦区域。
chap1_para870,2,,它可能是一块平坦的局部极大值，不存在上坡的出口；也可能是一个山肩（shoulder），从山肩出发还有可能继续前进（参见图4-1）。
chap1_para870,3,,爬山搜索可能会迷失在平台区上。
chap1_para871,1,,在每种情况下，算法都会到达一个无法再取得进展的点。
chap1_para871,2,,从一个随机生成的8皇后状态开始，在86%的情况下，最陡上升爬山法会被卡住，它只能解决14%的问题实例。
chap1_para871,3,,但是，它求解速度很快，成功找到解时平均步数为4，被卡住时平均步数为3，这对一个具有万个状态的状态空间来说不算糟糕。
chap1_para872,1,,我们怎么才能求解更多问题？
chap1_para872,2,,一个答案是当我们到达一个平台区时继续前进——允许横向移动（sideways move），希望这个平台区真的是一个山肩，如图4-1所示。
chap1_para872,3,,但如果我们实际上位于一块平坦的局部极大值上，那么算法就会陷入死循环。
chap1_para872,4,,因此，我们可以限制连续横向移动的次数，如在100次连续横向移动之后停止。
chap1_para872,5,,这种方法将爬山法成功求解问题实例的百分比从14%提高到了94%。
chap1_para872,6,,成功是有代价的：平均下来，对每个成功实例算法需要运行约21步，失败实例约64步。
chap1_para873,1,,爬山法存在很多变体。
chap1_para873,2,,随机爬山法（stochastic hill climbing）在上坡行动中随机选择一个；被选中的概率随着上坡陡度的变化而变化。
chap1_para873,3,,这种方法通常比最陡上升法收敛得更慢，但在某些状态地形图中，它能找到更好的解。
chap1_para873,4,,首选爬山法（first-choice hill climbing）通过不断随机地生成后继直到生成一个比当前状态更好的后继为止来实现随机爬山。
chap1_para873,5,,当一个状态存在众多（如数千个）后继时，这是一个很好的策略。
chap1_para874,1,,另一种变体是随机重启爬山法（random-restart hill climbing），它来自于一句格言：“如果一开始没有成功，那么尝试，再尝试。
chap1_para874,2,,”它从随机生成的初始状态开始，执行一系列爬山搜索，直到找到目标。
chap1_para874,3,,算法完备的概率为1，因为它最终会生成一个目标状态作为初始状态。
chap1_para874,4,,如果每一次爬山搜索成功的概率为p，那么需要重启的期望次数为1 / p。
chap1_para874,5,,对于不允许横向移动的8皇后实例，，所以大概需要7次迭代才能找到一个目标（6次失败，1次成功）。
chap1_para874,6,,所需步数的期望为一次成功迭代的代价加上(1−p)/p倍的失败代价，总共约为22步。
chap1_para874,7,,当允许横向移动时，平均需要次迭代，步。
chap1_para874,8,,因此，对于8皇后问题，随机重启爬山法是非常有效的。
chap1_para874,9,,即使有300万个皇后，这种方法也能在很短的时间内找到解。
chap1_para874,10,,[1]
chap1_para876,1,,"[1]　卢比等人（Luby et al., 1993）建议在搜索固定次数之后重启，并表明这比让每次搜索都无限期地继续下去要有效得多。"
chap1_para877,1,,爬山法是否能成功在很大程度上取决于状态空间地形图的形状：如果几乎不存在局部极大值和平台区，那么随机重启爬山法可以很快找到一个好的解。
chap1_para877,2,,但是，许多实际问题的地形图看起来更像是平地上散布着一群秃顶豪猪，每个豪猪的刺上还住着微型豪猪。
chap1_para877,3,,NP困难问题（参见附录 A）通常存在指数级数量的局部极大值。
chap1_para877,4,,尽管如此，在几次重启后，通常也可以找到相当好的局部极大值。
chap1_para878,1,,4.1.2　模拟退火
chap1_para879,1,,从不“下坡”，即从不向值较低（或代价较高）的状态移动的爬山算法总是很容易陷入局部极大值。
chap1_para879,2,,相比之下，纯粹的随机游走算法不考虑状态值，而是随机移动到一个后继状态，它最终能够找到全局极大值，但它的效率非常低。
chap1_para879,3,,因此，尝试将爬山法和随机游走结合起来以同时获得高效性和完备性，似乎是合理的。
chap1_para88,1,Léon Walras (pronounced “Valrasse”) (1834–1910) gave utility theory a more general foundation in terms of preferences between gambles on any outcomes (not just monetary outcomes). The theory was improved by Ramsey (1931) and later by John von Neumann and Oskar Morgenstern in their book The Theory of Games and Economic Behavior (1944). Economics is no longer the study of money; rather it is the study of desires and preferences.,● 如何使用不确定的信息进行推理？
chap1_para880,1,,模拟退火（simulated annealing）就是这样一种算法。
chap1_para880,2,,在冶金学中，退火（annealing）是一种通过将金属或玻璃加热到高温然后逐渐冷却的方法使材料达到低能量结晶态以进行回火或硬化的过程。
chap1_para880,3,,为了更好地解释模拟退火，我们将关注点从爬山转换为梯度下降（gradient descent）（即，最小化代价），想象这样一项任务，把一个乒乓球放入一个崎岖表面的最深的裂缝中。
chap1_para880,4,,如果只是让球滚动，它会停在一个局部极小值。
chap1_para880,5,,如果晃动平面，乒乓球会从局部极小值中弹出来——也许会弹到更深的局部极小值中，在那里它将耗费更多的时间。
chap1_para880,6,,诀窍是晃动幅度要足够大，以使球从局部极小值中弹出，但又不能太大，以至于从全局极小值中弹出。
chap1_para880,7,,模拟退火就是开始时用力晃动（即高温），然后逐渐降低晃动强度（即降低温度）。
chap1_para881,1,,模拟退火算法的总体结构（图4-5）与爬山法类似。
chap1_para881,2,,然而，它不是选择最佳移动，而是选择随机移动。
chap1_para881,3,,如果该移动使得情况改善，那么它总是会被接受。
chap1_para881,4,,否则，算法以小于1的概率接受该移动。
chap1_para881,5,,概率随着该移动的“坏的程度”——评估值变差的量——呈指数级下降。
chap1_para881,6,,概率也会随“温度”T的降低而减小：开始时T较高，“坏”的移动更有可能被接受，当T降低时，可能性也逐渐降低。
chap1_para881,7,,如果schedule所设置的T降到0的速度足够慢，那么玻尔兹曼分布的一个性质是所有概率都集中在全局极大值上，即算法将以接近1的概率找到全局极大值。
chap1_para882,1,,图4-5　模拟退火算法，一种允许某些下坡移动的随机爬山法。
chap1_para882,2,,输入的schedule是关于时间的函数，它决定了“温度”T的值
chap1_para883,1,,从20世纪80年代开始，模拟退火就被用于求解VLSI布图问题。
chap1_para883,2,,它已广泛应用于工厂调度和其他大规模优化任务。
chap1_para884,1,,4.1.3　局部束搜索
chap1_para885,1,,对于内存限制问题，在内存中只保存一个节点似乎有些极端。
chap1_para885,2,,局部束搜索（local beam search）算法记录k个状态而不是只记录一个。
chap1_para885,3,,它从k个随机生成的状态开始。
chap1_para885,4,,在每一步中，生成全部k个状态的所有后继状态。
chap1_para885,5,,如果其中任意一个是目标状态，那么算法停止。
chap1_para885,6,,否则，它将从完整列表中选择k个最佳后继并重复上述操作。
chap1_para886,1,,从第一印象来看，具有k个状态的局部束搜索似乎只不过是并行（而非串行）地运行k次随机重启。
chap1_para886,2,,事实上，这两种算法是完全不同的。
chap1_para886,3,,在随机重启搜索中，每个搜索进程独立运行。
chap1_para886,4,,而在局部束搜索中，有用信息将在并行的搜索线程之间传递。
chap1_para886,5,,实际上，生成最佳后继的那些状态会对其他状态说：“过来，这里的草更绿！
chap1_para886,6,,”算法将很快放弃那些没有效果的搜索并把资源转移到取得最大进展的路径上。
chap1_para887,1,,如果k个状态之间缺乏多样性，局部束搜索可能会受到影响——k个状态可能聚集在状态空间的一块小区域内，导致搜索只不过是k倍慢版本的爬山法。
chap1_para887,2,,一种被称作随机束搜索（stochastic beam search）的变体可以帮助缓解这个问题，它类似于随机爬山法。
chap1_para887,3,,随机束搜索不是选择最佳的k个后继状态，而是选择概率与它对应的目标函数值成正比的后继状态，从而增加了多样性。
chap1_para888,1,,4.1.4　进化算法
chap1_para889,1,,进化算法（evolutionary algorithm）可以看作随机束搜索的变体，算法的动机明显来自生物学中自然选择的隐喻：一个由个体（状态）组成的种群，其中最适应环境（值最高）的个体可以生成后代（后继状态）来繁衍下一代，这个过程被称为重组（recombination）。
chap1_para889,2,,进化算法存在无数种形式，它们按照以下方式变化。
chap1_para89,1,"Decision theory, which combines probability theory with utility theory, provides a formal and complete framework for individual decisions (economic or otherwise) made under uncertainty—that is, in cases where probabilistic descriptions appropriately capture the decision maker’s environment. This is suitable for “large” economies where each agent need pay no attention to the actions of other agents as individuals. For “small” economies, the situation is much more like a game: the actions of one player can significantly affect the utility of another (either positively or negatively). Von Neumann and Morgenstern’s development of game theory (see also Luce and Raiffa, 1957) included the surprising result that, for some games, a rational agent should adopt policies that are (or least appear to be) randomized. Unlike decision theory, game theory does not offer an unambiguous prescription for selecting actions. In AI, decisions involving multiple agents are studied under the heading of multiagent systems (Chapter 17).",哲学家们提出了人工智能的一些基本理念，但人工智能要成为正规科学，需要逻辑和概率的数学化，并引入一个新的数学分支——计算。
chap1_para891,1,,● 每个个体的表示。
chap1_para891,2,,在遗传算法（genetic algorithm）中，每个个体都是有限字母表上的一个字符串（通常是一个布尔字符串），就像DNA是字母表ACGT上的一个字符串一样。
chap1_para891,3,,在进化策略（evolution strategy）中，个体是实数序列，而在遗传编程（genetic programming）中，个体是计算机程序。
chap1_para892,1,,● 混合数，，是一起形成后代的亲本的数量。
chap1_para892,2,,最常见的情况是：双亲结合它们的“基因”（它们表示的一部分）来形成后代。
chap1_para892,3,,当时，为随机束搜索（可以看作无性繁殖）。
chap1_para892,4,,也是可能的，这在自然界中很少发生，但很容易在计算机上进行模拟。
chap1_para893,1,,● 选择（selection）过程。
chap1_para893,2,,选择将成为下一代亲本的个体：一种可能是从所有个体中选择，被选中的概率与其适应度得分成正比。
chap1_para893,3,,另一种可能是随机选择n个个体（），然后选择最适合的个个体作为亲本。
chap1_para894,1,,● 重组过程。
chap1_para894,2,,一种常见的方法（假设）是随机选择一个杂交点（crossover point）来分割每个父字符串，并将这些部分重新组合以形成两个子串，一个是亲本1的第一部分和亲本2的第二部分的组合；另一个是亲本1的第二部分和亲本2的第一部分的组合。
chap1_para895,1,,● 突变率（mutation rate），它决定了后代在其表示上发生随机突变的频率。
chap1_para895,2,,一旦产生了一个后代，其组成中的每位都将以与突变率相等的概率被翻转。
chap1_para896,1,,● 下一代的构成。
chap1_para896,2,,可能只包括新形成的后代，也可能还包括一些上一代中得分最高的个体［这种做法被称为精英主义（elitism），它确保总体适应度永远不会随着时间的推移而下降］。
chap1_para896,3,,"而淘汰（culling），即丢弃所有分数低于给定阈值的个体，会使得进化加速（Baum et al., 1995）。"
chap1_para897,1,,图4-6a为由4个8位数字符串组成的种群，每个字符串代表8皇后问题的一个状态：第c位数字表示第c列中皇后的行号。
chap1_para897,2,,在图4-6b中，每个状态根据适应度函数进行评级。
chap1_para897,3,,适应度越高越好，所以对于8皇后问题，我们使用非攻击皇后对的数量作为适应度，解的适应度为8×7/2 = 28。
chap1_para897,4,,图4-6b中4个状态的值分别为24、23、20和11。
chap1_para897,5,,然后将适应度得分归一化为概率，结果显示在图4-6b中的适应度旁边。
chap1_para898,1,,图4-6　遗传算法，图示为表示8皇后状态的数字字符串。
chap1_para898,2,,（a）中的初始种群根据（b）中的适应度函数进行排序从而得到（c）中的配对，（d）是产生的后代，（e）是可能发生的突变
chap1_para899,1,,在图4-6c中，根据图4-6b中的概率选出两对父字符串。
chap1_para899,2,,注意，有一个个体被选择了两次，还有一个没有被选择。
chap1_para899,3,,对于每一对被选择的亲本，随机选择一个杂交点（虚线）。
chap1_para899,4,,在图4-6d中，我们在杂交点处交叉两个父串，以生成新的后代。
chap1_para899,5,,例如，第一对亲本中的第一个子串从第一个父串获得前三个数字（327），从第二个父串获得剩余数字（48552）。
chap1_para899,6,,这一重组步骤中所包含的8皇后状态如图4-7所示。
chap1_para9,1,"The Turing test, proposed by Alan Turing (1950), was designed as a thought experiment that would sidestep the philosophical vagueness of the question “Can a machine think?” A computer passes the test if a human interrogator, after posing some written questions, cannot tell whether the written responses come from a person or from a computer. Chapter 28 discusses the details of the test and whether a computer would really be intelligent if it passed. For now, we note that programming a computer to pass a rigorously applied test provides plenty to work on. The computer would need the following capabilities:",从人与理性[2]以及思想与行为这两个维度来看，有4种可能的组合，而且这4种组合都有其追随者和相应的研究项目。
chap1_para9,2,,他们所使用的方法必然是不同的：追求类人智能必须在某种程度上是与心理学相关的经验科学，包括对真实人类行为和思维过程的观察和假设；而理性主义方法涉及数学和工程的结合，并与统计学、控制理论和经济学相联系。
chap1_para9,3,,各个研究团体既互相轻视又互相帮助。
chap1_para9,4,,接下来，让我们更细致地探讨这4种方法。
chap1_para90,1,"Economists, with some exceptions, did not address the third question listed above: how to make rational decisions when payoffs from actions are not immediate but instead result from several actions taken in sequence.",形式化逻辑（formal logic）的思想可以追溯到古希腊、古印度和古代中国的哲学家，但它的数学发展真正始于乔治·布尔（George Boole，1815—1864）的工作。
chap1_para90,2,"This topic was pursued in the field of operations research, which emerged in World War II from efforts in Britain to optimize radar installations, and later found innumerable civilian applications.","布尔提出了命题和布尔逻辑的细节（Boole, 1847）。"
chap1_para90,3,"The work of Richard Bellman (1957) formalized a class of sequential decision problems called Markov decision processes, which we study in Chapter 16 and, under the heading of reinforcement learning, in Chapter 23.",1879年，戈特洛布·弗雷格（Gottlob Frege，1848—1925）将布尔逻辑扩展到包括对象和关系，创建了沿用至今的一阶逻辑[9]。
chap1_para90,4,,一阶逻辑除了在人工智能研究的早期发挥核心作用外，还激发了哥德尔和图灵的工作，这些工作支撑了计算本身。
chap1_para900,1,,图4-7　对应于图4-6c中前两个亲本和图4-6d中第一个后代的8皇后状态。
chap1_para900,2,,在杂交步中，丢弃绿色列，保留红色列。
chap1_para900,3,,（图4-6中数字的解释：第1行是最下面一行，第8行是最上面一行）
chap1_para901,1,,最后，在图4-6e中，每个字符串中的每个位置都以某个很小的独立概率发生随机突变。
chap1_para901,2,,第一个、第三个和第四个后代的某个位发生了突变。
chap1_para901,3,,在8皇后问题中，这相当于随机选择一个皇后，并将其随机移动到它所在列的某个位置。
chap1_para901,4,,通常情况下，早期的种群是多样化的，所以在搜索过程的早期阶段，杂交常常在状态空间中采取较大的步调（类似于模拟退火）。
chap1_para901,5,,在经过许多代选择提高了适应度后，种群的多样性减少，步调也随之变小。
chap1_para901,6,,图4-8介绍了实现所有这些步骤的算法。
chap1_para902,1,,图4-8　遗传算法。
chap1_para902,2,,在这个函数中，population是种群中个体的有序列表，weights是每个个体所对应的适应度值的列表，而fitness是计算这些值的函数
chap1_para903,1,,遗传算法类似于随机束搜索，但增加了杂交操作。
chap1_para903,2,,如果存在可以执行有用功能的区域，杂交操作是有利的。
chap1_para903,3,,例如，将前3列皇后分别放在第2行、第4行和第6行（在这些位置上它们不会互相攻击），就组成了一个有用的区域，它可以与其他个体中出现的其他有用区域相结合，从而形成一个解。
chap1_para903,4,,数学上可以证明，如果这些区域没有任何用途——例如，如果遗传密码的位置是随机排列的——那么杂交就没有任何优势。
chap1_para904,1,,遗传算法理论用模式（schema）思想来解释它是如何运作的，模式是指其中某些位未确定的子串。
chap1_para904,2,,例如，模式246*****表示前3个皇后分别位于位置2、4和6的所有8皇后状态。
chap1_para904,3,,与该模式相匹配的字符串（例如24613578）称作该模式的实例（instance）。
chap1_para904,4,,可以证明，如果某模式实例的平均适应度高于平均值，那么该模式的实例数量将随着时间推移而不断增加。
chap1_para906,1,,"进化论是由查尔斯·达尔文（Charles Darwin）（Darwin, 1859）和艾尔弗雷德·拉塞尔·华莱士（Alfred Russel Wallace）（Wallace, 1858）各自独立提出的。"
chap1_para906,2,,它的中心思想很简单：变异发生在繁殖过程中，并将在后代中以一定比例保存下来，大概与它们对生殖适应度的影响成比例。
chap1_para907,1,,达尔文在《物种起源》（On the Origin of Species by Means of Natural Selection）中的理论没有解释生物体的特征是如何遗传和改变的。
chap1_para907,2,,"控制这些过程的概率定律由修道士格雷戈尔·孟德尔（Gregor Mendel）（Mendel, 1866）首先发现，他使用豌豆进行了实验。"
chap1_para907,3,,"很久之后，沃森和克里克（Watson and Crick, 1953）确定了DNA分子的结构及其AGTC（腺嘌呤、鸟嘌呤、胸腺嘧啶、胞嘧啶）序列。"
chap1_para907,4,,在标准模型中，基因序列上某点发生突变和“杂交”（后代的DNA通过合成父母双方的DNA长片段产生）都会导致变异。
chap1_para908,1,,进化和局部搜索算法的相似性前文已经介绍过了；随机束搜索和进化的主要区别在于是否为有性生殖，有性生殖中后代是由多个而非单个个体产生的。
chap1_para908,2,,然而，进化的实际机制比大多数遗传算法要丰富得多。
chap1_para908,3,,例如，突变包括DNA的逆转、复制和大段移动；有些病毒会从一个生物体中借用DNA再将其自身插入另一个生物体；还有一些转座基因只是在基因组中把自己复制成千上万次。
chap1_para909,1,,甚至还有一些基因会破坏不携带该基因的可能配对对象的细胞，从而增加它们自身的复制机会。
chap1_para909,2,,最重要的是，基因自身对基因组复制和翻译成生物体的机制进行编码。
chap1_para909,3,,在遗传算法中，这些机制是单独的程序，不体现在被操作的字符串中。
chap1_para91,1,"Work in economics and operations research has contributed much to our notion of rational agents, yet for many years AI research developed along entirely separate paths. One reason was the apparent complexity of making rational decisions. The pioneering AI researcher Herbert Simon (1916–2001) won the Nobel Prize in economics in 1978 for his early work showing that models based on satisficing—making decisions that are “good enough,” rather than laboriously calculating an optimal decision—gave a better description of actual human behavior (Simon, 1947). Since the 1990s, there has been a resurgence of interest in decision-theoretic techniques for AI.",
chap1_para910,1,,达尔文进化论可能看起来效率很低，它盲目地产生了大约1043个生物体，却丝毫没有改进它的搜索启发式函数。
chap1_para910,2,,但是学习在进化中确实起着作用。
chap1_para910,3,,"尽管另一位伟大的法国博物学家让·拉马克（Jean Lamarck）（Lamarck, 1809）曾错误地提出，生物体一生中通过适应而获得的特性会遗传给后代，但詹姆斯·鲍德温（James Baldwin）（Baldwin, 1896）提出的表面上相似的理论则是正确的：学习可以有效地放宽适应度要求，从而加快进化速度。"
chap1_para910,4,,如果一个生物体具有一种不太适应环境的特性，但它也具有足够的可塑性，可以学习以一种有益的方式适应环境，那么生物体会将这种特性传递下去。
chap1_para910,5,,"计算机仿真（Hinton and Nowlan, 1987）证实了鲍德温效应（Baldwin effect）是真实存在的，其结果是，难以学习的事情最终会存在于基因组中，而容易学习的事情不必进入基因组（Morgan and Griffiths, 2015）。"
chap1_para911,1,,显然，如果相邻位之间完全不相关，效果就没那么显著，因为几乎不存在功能一致的连续区域。
chap1_para911,2,,当模式对应于解中有意义的组件时，遗传算法效果最优。
chap1_para911,3,,例如，如果字符串表示天线，那么模式则表示天线的各组成部分，如反射器和导向器。
chap1_para911,4,,一个好的组件可能在各种不同的设计中都是好的。
chap1_para911,5,,这表明，遗传算法的成功依赖于精细的表示工程。
chap1_para912,1,,"实际上，遗传算法在广泛的最优化方法中占有一席之地（Marler and Arora, 2004），尤其是复杂结构问题，如电路布图或作业车间调度，以及最近的深度神经网络架构演变（Miikkulainen et al., 2019）。"
chap1_para912,2,,目前还不清楚遗传算法的吸引力是来自于它在特定任务上的性能优势，还是来自于进化本身。
chap1_para913,1,,4.2　连续空间中的局部搜索
chap1_para914,1,,在第2章中，我们解释了离散环境和连续环境之间的区别，并指出大多数的真实世界环境都是连续的。
chap1_para914,2,,连续动作空间的分支因子是无限的，因此我们目前介绍的大多数算法（除了首选爬山法和模拟退火）都无法处理连续空间。
chap1_para915,1,,本节将非常简要地介绍一些连续空间的局部搜索技术。
chap1_para915,2,,关于这个主题的文献有很多。
chap1_para915,3,,许多基本技术起源于牛顿和莱布尼茨发明微积分之后的17世纪。
chap1_para915,4,,[2]本书的一些章节会介绍这些技术的应用，包括学习、视觉和机器人技术相关的章节。
chap1_para917,1,,[2]　向量、矩阵和导数的知识对于学习本节内容很有帮助（见附录A）。
chap1_para918,1,,考虑一个实例。
chap1_para918,2,,假设我们希望在罗马尼亚新建3个机场，使得地图上每个城市到其最近机场的直线距离平方和最小。
chap1_para918,3,,（罗马尼亚地图见图3-1。
chap1_para918,4,,"）状态空间定义为3个机场的坐标：(x1, y1)、(x2, y2)和(x3, y3)。"
chap1_para918,5,,这是一个六维空间；我们也可以说状态由6个变量（variable）定义。
chap1_para918,6,,一般地，状态定义为n 维向量，x。
chap1_para918,7,,在这个空间中移动对应于移动地图上的一个或多个机场。
chap1_para918,8,,"对于任一特定状态，一旦计算出最近城市，目标函数f(x) = f (x1, y1, x2, y2, x3, y3)的计算就会变得相对容易。"
chap1_para918,9,,设Ci是最近机场（在状态x下）为机场 i 的城市集合。
chap1_para918,10,,那么，我们有
chap1_para92,1,1.,[9]　弗雷格提出的一阶逻辑符号（文本和几何特征的神秘组合）从未流行起来。
chap1_para92,2,2.,
chap1_para92,3,4Neuroscience,
chap1_para920,1,,这一方程不仅对于状态x是正确的，而且对于x局部邻域中的状态也是正确的。
chap1_para920,2,,然而，对全局来说，它是不正确的；如果我们偏离x太远（通过大幅改变一个或多个机场的位置），那么该机场的最近城市集合会发生变化，我们需要重新计算Ci。
chap1_para921,1,,处理连续状态空间的一种方法是离散化（discretize）。
chap1_para921,2,,"例如，我们可以将(xi, yi)的位置限制在矩形网格上间距为的固定点，而不是允许它的位置可以为连续二维空间中的任意点。"
chap1_para921,3,,那么，空间中的每个状态将存在12个后继（对应于将6个变量分别增加），而不是之前的无限多个。
chap1_para921,4,,然后我们就可以对离散空间应用任意局部搜索算法。
chap1_para921,5,,或者，我们可以通过随机采样后继状态，即在随机方向上移动一个小量，使分支因子变为有限值。
chap1_para921,6,,通过两个相邻点之间目标函数值的变化来衡量进度的方法称为经验梯度（empirical gradient）法。
chap1_para921,7,,经验梯度搜索与离散化状态空间中的最陡上升爬山法相同。
chap1_para921,8,,随着时间逐渐减小的值可以得到更准确的解，但不一定在极限范围内收敛到全局最优值。
chap1_para922,1,,通常我们有一个以数学形式表达的目标函数，这样我们就可以用微积分来解析地而非经验地求解问题。
chap1_para922,2,,许多方法都试图利用地形图的梯度（gradient）来找到最大值。
chap1_para922,3,,目标函数的梯度是一个向量∇f，它给出了最陡斜面的长度和方向。
chap1_para922,4,,对于我们的问题，有
chap1_para923,1,,在某些情况下，我们可以通过解∇f = 0方程找到一个极大值。
chap1_para923,2,,（这是可以做到的，例如，如果我们只新建一个机场；问题的解是所有城市坐标的算术平均值。
chap1_para923,3,,）然而，在许多情况下，这个方程不存在闭式解。
chap1_para923,4,,例如，对于3个机场的情况，梯度的表达式依赖于当前状态中哪些城市离各个机场最近。
chap1_para923,5,,这意味着我们只能局部地（而非全局地）计算梯度，例如，
chap1_para925,1,,给定一个局部正确的梯度表达式，我们可以根据下式来更新当前状态从而实现最陡上升爬山法：
chap1_para926,1,,其中是一个很小的常数，通常称为步长（step size）。
chap1_para926,2,,存在很多调整的方法。
chap1_para926,3,,基本问题是，如果太小，需要的迭代步太多；如果太大，搜索可能会越过最大值。
chap1_para926,4,,线搜索（line search）技术试图通过不断延伸当前梯度方向——通常通过对反复加倍——直到f再次开始减小来克服上述困境。
chap1_para926,5,,出现上述现象的点成为新的当前状态。
chap1_para926,6,,在这点上如何选择新的方向，有几种不同的方法。
chap1_para927,1,,对于许多问题，最有效的算法是古老的牛顿-拉弗森法（Newton-Raphson method）。
chap1_para927,2,,这是一种求函数根（即求解g(x) = 0形式的方程）的通用方法。
chap1_para927,3,,它的工作原理是根据牛顿公式计算根x的一个新的估计值：
chap1_para928,1,,要找到f的最大值或最小值，需要找到使得梯度为零向量（即）的x。
chap1_para928,2,,因此，牛顿公式中的g(x)为，更新方程可以写成矩阵-向量形式：
chap1_para929,1,,其中Hf(x)为二阶导数的黑塞矩阵（Hessian matrix），其元素Hij由给出。
chap1_para929,2,,对于上述机场问题实例，从式（4-2）可以看出，Hf(x)相当简单：非对角元素为零，机场i的对角线元素的值恰好为Ci中城市数目的两倍。
chap1_para929,3,,每一时刻的计算表明，每一步更新将机场i直接移动到Ci的质心处，即式（4-1）中f的局部表达式的最小值。
chap1_para929,4,,[3]然而，对于高维问题，计算黑塞矩阵的n2个元素以及对它求逆的开销可能非常昂贵，因此产生了许多牛顿-拉弗森法的近似版本。
chap1_para93,1,•How do brains process information?,概率（probability）论可以视为信息不确定情况下的广义逻辑，这对人工智能来说是非常重要的考虑。
chap1_para93,2,,吉罗拉莫·卡尔达诺（Gerolamo Cardano，1501—1576）首先提出了概率的概念，并根据赌博事件的可能结果对其进行了刻画。
chap1_para93,3,,1654年，布莱兹·帕斯卡（Blaise Pascal，1623—1662）在给皮埃尔·费马（Pierre Fermat，1601—1665）的信中展示了如何预测一个未完成的赌博游戏的结局，并为赌徒分配平均收益。
chap1_para93,4,,概率很快成为定量科学的重要组成部分，用于处理不确定的度量和不完备的理论。
chap1_para93,5,,雅各布·伯努利（Jacob Bernoulli，1654—1705，丹尼尔·伯努利的叔叔）、皮埃尔·拉普拉斯（Pierre Laplace，1749—1827）等人发展了这一理论，并引入了新的统计方法。
chap1_para93,6,,托马斯·贝叶斯（Thomas Bayes，1702—1761）提出了根据新证据更新概率的法则。
chap1_para93,7,,贝叶斯法则是人工智能系统的重要工具。
chap1_para931,1,,[3]　一般来说，牛顿-拉弗森更新可以看作在x处用一个二次曲面拟合f，下一步则直接移动到该曲面的最小值——如果f是二次的，则也是f的最小值。
chap1_para932,1,,局部搜索方法在连续状态空间和离散状态空间中一样，同样受到局部极大值、岭和平台区的影响。
chap1_para932,2,,随机重启和模拟退火通常很有用。
chap1_para932,3,,然而，高维连续空间非常大，算法很容易陷入困境。
chap1_para933,1,,最后一个话题是约束优化（constrained optimization）。
chap1_para933,2,,如果一个优化问题的解必须满足对变量值的一些硬性约束，那么这个问题就是受约束的。
chap1_para933,3,,例如，在机场选址问题中，我们可能会将选址限制在罗马尼亚境内的陆地上（而不是某个湖中心）。
chap1_para933,4,,约束优化问题的难度取决于约束和目标函数的性质。
chap1_para933,5,,最著名的一类问题是线性规划（linear programming）问题，其约束必须是能构成凸集的线性不等式[4]，目标函数也必须是线性的。
chap1_para933,6,,线性规划的时间复杂性是关于变量数目的多项式。
chap1_para935,1,,[4]　如果点集S中任意两点的连线也包含在S中，则称S是凸的。
chap1_para935,2,,凸函数（convex function）是指其上方空间构成凸集的函数；根据定义，凸函数没有局部（相对于全局）极小值。
chap1_para936,1,,线性规划可能是最广泛研究和最有用的优化方法。
chap1_para936,2,,它是更一般的凸优化（convex optimization）问题的一种特例，允许约束区域为任意凸区域，目标函数为约束区域内的任意凸函数。
chap1_para936,3,,在一定条件下，凸优化问题也是多项式时间内可解的，即使有上千个变量，也可能是实际可行的。
chap1_para936,4,,机器学习和控制理论中的几个重要问题可以形式化为凸优化问题（见第20章）。
chap1_para937,1,,4.3　使用非确定性动作的搜索
chap1_para938,1,,在第3章中，我们假设环境为完全可观测的、确定性的、已知的。
chap1_para938,2,,因此，智能体可以观测到初始状态，计算出可以到达目标的动作序列，然后“闭着眼睛”执行这些动作，而不需要使用自己的感知。
chap1_para939,1,,然而，当环境部分可观测时，智能体并不确定它处于什么状态；当环境是非确定性的时，智能体不知道在执行某个动作后将转移到什么状态。
chap1_para939,2,,这意味着智能体所思考的不再是“我现在位于s1状态，如果我执行a动作，我将会进入s2状态”，而是“我现在位于s1或s3状态，如果我执行a动作，我将会进入s2、s4或s5状态”。
chap1_para939,3,,我们把智能体认为其可能位于的物理状态集合称为信念状态（belief state）。
chap1_para94,1,"Neuroscience is the study of the nervous system, particularly the brain. Although the exact way in which the brain enables thought is one of the great mysteries of science, the fact that it does enable thought has been appreciated for thousands of years because of the evidence that strong blows to the head can lead to mental incapacitation. It has also long been known that human brains are somehow different; in about 335 BCE Aristotle wrote, “Of all the animals, man has the largest brain in proportion to his size.”6 Still, it was not until the middle of the 18th century that the brain was widely recognized as the seat of consciousness. Before then, candidate locations included the heart and the spleen.",概率的形式化结合数据的可用性，使统计学（statistics）成为了一个新研究领域。
chap1_para94,2,,最早的应用之一是1662年约翰·格兰特（John Graunt）对伦敦人口普查数据的分析。
chap1_para94,3,,"罗纳德·费舍尔（Ronald Fisher）被认为是第一位现代统计学家，他汇总了概率、实验设计、数据分析和计算等思想（Fisher, 1922）。"
chap1_para94,4,,"在1919年，他坚称，如果没有机械计算器“百万富翁”（Millionaire，第一个可以做乘法的计算器），他就无法进行工作，尽管这台计算器的成本远远超过了他的年薪（Ross, 2012）。"
chap1_para940,1,,在部分可观测的和非确定性的环境中，问题的解不再是一个序列，而是一个条件规划（conditional plan）（有时也称为应变规划或策略），条件规划根据智能体在执行规划时接收到的感知来指定动作。
chap1_para940,2,,本节先讨论非确定性，部分可观测性留待4.4节讨论。
chap1_para941,1,,4.3.1　不稳定的真空吸尘器世界
chap1_para942,1,,如图4-9所示，第2章中的真空吸尘器世界具有8种状态。
chap1_para942,2,,有3种动作——向左Left、向右Right和吸尘Suck，目标是清理所有的灰尘（状态7和8）。
chap1_para942,3,,如果环境是完全可观测的、确定性的和完全已知的，那么使用第3章的任意算法都很容易求解这个问题，它的解是一个动作序列。
chap1_para942,4,,"例如，如果初始状态是1，那么动作序列[Suck, Right, Suck]可以到达目标状态8。"
chap1_para943,1,,图4-9　真空吸尘器世界的8种可能状态；状态7和8是目标状态
chap1_para944,1,,现在假设我们以一个功能强大但不稳定的真空吸尘器的形式引入非确定性。
chap1_para944,2,,在不稳定的真空吸尘器世界中，Suck的工作原理如下。
chap1_para945,1,,● 在一个脏的方格中，Suck会清理这一方格，有时也会清理它的相邻方格。
chap1_para946,1,,● 在一个干净方格中，Suck有时反而会把灰尘弄到地面上。
chap1_para946,2,,[5]
chap1_para948,1,,[5]　我们假设大多数读者都会遇到类似的问题，并且会共情我们的智能体。
chap1_para948,2,,我们向那些拥有现代化高效清洁设备从而无法利用这一教学设计的读者道歉。
chap1_para949,1,,为了更准确地形式化这一问题，我们需要推广第3章的转移模型概念。
chap1_para949,2,,我们不使用返回单个结果状态的Result函数来定义转移模型，而是使用返回一组可能的结果状态的新的Result函数。
chap1_para949,3,,例如，在不稳定的真空吸尘器世界中，状态1中的Suck动作要么只清理当前位置，要么同时清理两个位置：
chap1_para95,1,"Paul Broca’s (1824–1880) investigation of aphasia (speech deficit) in brain-damaged patients in 1861 initiated the study of the brain’s functional organization by identifying a localized area in the left hemisphere—now called Broca’s area—that is responsible for speech production.7 By that time, it was known that the brain consisted largely of nerve cells, or neurons, but it was not until 1873 that Camillo Golgi (1843–1926) developed a staining technique allowing the observation of individual neurons (see Figure 1.1). This technique was used by Santiago Ramon y Cajal (1852–1934) in his pioneering studies of neuronal organization.8 It is now widely accepted that cognitive functions result from the electrochemical operation of these structures. That is, a collection of simple cells can lead to thought, action, and consciousness. In the pithy words of John Searle (1992), brains cause minds.",计算的历史与数字的历史一样古老，但用于计算最大公约数的欧几里得算法被认为是第一个非平凡的算法（algorithm）。
chap1_para95,2,,“算法”一词源自一位9世纪的数学家穆罕默德·本·穆萨·阿尔·花剌子模（Muhammad ibn Musa al-Khwarizmi），他的著作还将阿拉伯数字和代数引入了欧洲。
chap1_para95,3,,布尔等人讨论了逻辑演绎的算法，到19世纪末，人们开始努力将一般的数学推理形式化为逻辑演绎。
chap1_para950,1,,如果我们是从状态1开始，那么没有任何一个单独的动作序列能够求解问题，因此我们需要如下的条件规划：
chap1_para952,1,,我们看到，条件规划可以包含if–then–else步骤；这意味着解是树而不是序列。
chap1_para952,2,,这里的if语句中的条件用来测试当前状态；这是智能体在运行时能够观测到的，但规划时还不知道。
chap1_para952,3,,或者，我们也可以用公式来测试感知而不是状态。
chap1_para952,4,,真实物理世界中的许多问题都是应变问题，因为不可能对未来进行准确预测。
chap1_para952,5,,因此，许多人在走路时都会睁着眼睛。
chap1_para953,1,,4.3.2　与或搜索树
chap1_para954,1,,我们如何得到这些非确定性问题的条件解？
chap1_para954,2,,和第3章一样，我们首先从构造搜索树开始，但是这里的树有一个不同的特性。
chap1_para954,3,,在确定性环境中，分支是由智能体在每个状态下自己的选择引入的：我可以执行这个动作或那个动作。
chap1_para954,4,,我们称这些节点为或节点（OR node）。
chap1_para954,5,,例如，在真空吸尘器世界中，智能体在或节点上选择Left、Right或Suck。
chap1_para954,6,,而在非确定性环境中，环境对每个动作的结果的选择也会引入分支。
chap1_para954,7,,我们称这些节点为与节点（AND node）。
chap1_para954,8,,"例如，状态1中的Suck动作会产生信念状态{5,7}，因此智能体需要为状态5与状态7分别找到一个规划。"
chap1_para954,9,,这两种节点交替出现，形成如图4-10所示的与或树（AND–OR tree）。
chap1_para955,1,,图4-10　不稳定的真空吸尘器世界搜索树的前两层。
chap1_para955,2,,状态节点是必须选择某个动作的或节点。
chap1_para955,3,,与节点（用圆圈表示）上的每个结果都必须处理，结果分支间用弧线连接。
chap1_para955,4,,找到的解用粗线标识
chap1_para956,1,,与或搜索问题的解是完整搜索树的一棵子树：（1）每个叶子都是一个目标节点，（2）在每个或节点上选择一个动作，（3）每个与节点包括所有结果分支。
chap1_para956,2,,解在图中用粗线标识；对应于式（4-3）中的规划。
chap1_para957,1,,图4-11给出了与或图搜索的深度优先递归算法。
chap1_para957,2,,该算法的一个关键是它处理环的方法，环经常出现在非确定性问题中（例如，动作有时不起作用，或者一个意外的影响被纠正）。
chap1_para957,3,,如果当前状态与从根到它的路径上的某个状态相同，就返回失败。
chap1_para957,4,,这并不意味着从当前状态出发没有解；这仅仅意味着，如果存在一个非循环解，那么它肯定可以从当前状态的早期镜像到达，因此可以丢弃新的镜像。
chap1_para957,5,,有了这一检查，可以确保算法在任何有限状态空间中都能终止，因为每条路径都必定到达一个目标、一个死胡同或一个重复状态。
chap1_para957,6,,注意，该算法并不检查当前状态是否是从根出发的其他路径上的某个状态的重复状态，这一点对效率来说很重要。
chap1_para958,1,,图4-11　非确定性环境生成的与或图的搜索算法。
chap1_para958,2,,解是一个条件规划，它考虑每一个非确定性的结果，并为每个结果制定规划
chap1_para959,1,,与或图也可以使用广度优先或最佳优先的方式进行探索。
chap1_para959,2,,我们必须修改启发式函数的概念，即估计一个条件解而不是一个序列的代价，但可容许性的概念可以继续保留，而且存在类似的用于寻找最优解的A*算法（参见本章末尾的参考文献与历史注释）。
chap1_para96,1,"Description The neuron consists of a cell body, which is also labeled Soma.",库尔特·哥德尔（Kurt Gödel，1906—1978）表明，虽然存在一种有效方法能够证明弗雷格和罗素的一阶逻辑中的任何真实陈述，但是一阶逻辑无法满足表征自然数所需的数学归纳原理。
chap1_para96,2,The nucleus is present at the center of the cell body.,1931年，哥德尔证明关于演绎的限制确实存在。
chap1_para96,3,Finger-like fibers labeled dendrites extend out from the cell body.,哥德尔的不完全性定理（incompleteness theorem）表明，在任何像皮亚诺算术（Peano arithmetic，自然数的基本理论）这样强的形式化理论中，必然存在一些没有证明的真实陈述。
chap1_para96,4,A single long fiber extends into a tubular structure labeled axon.,
chap1_para96,5,The other end of the axon branches further as tree-like projections labeled Axonal arborization.,
chap1_para96,6,An axon from another neuron cell is shown to be in contact with one of the dendrites of the neuron cell in view.,
chap1_para96,7,The region or junction of contact between the dendrite and one of the tree-like projections from another axon is labeled the synapse.,
chap1_para96,8,Two of such synapses are shown at the end of the tree-like projections from the neuron in view.,
chap1_para960,1,,4.3.3　反复尝试
chap1_para961,1,,考虑一个光滑的真空吸尘器世界，它与普通的（稳定的）真空吸尘器世界基本相同，但移动操作有时会失效，使得智能体停在原地。
chap1_para961,2,,"例如，在状态1中执行Right将产生信念状态{1,2}。"
chap1_para961,3,,图4-12为部分搜索图；显然，从状态1出发不存在非循环解，And-Or-Search将返回失败。
chap1_para961,4,,然而，存在一个循环解（cyclic solution），即反复尝试Right动作，直到它生效。
chap1_para961,5,,我们可以用一个新的while结构来表示上述过程：
chap1_para962,1,,或者用标签（label）表示规划的某一部分，之后可以引用这个标签：
chap1_para963,1,,什么时候可以考虑将循环规划作为解？
chap1_para963,2,,最小条件是每个叶节点都是一个目标状态，并且叶节点可以从规划中的任意点到达。
chap1_para963,3,,除此之外，我们还要考虑造成非确定性的原因。
chap1_para963,4,,如果情况确实是，真空吸尘器机器人的驱动机制在某些时间工作，但在其他时间真空吸尘器会发生随机、独立地滑动，那么智能体可以保证，如果动作重复足够多次，最终总会生效，规划也会成功。
chap1_para963,5,,但是，如果这种非确定性来自机器人或环境的一些尚未观测到的原因（例如，传动带断了，那么机器人将永远不会移动），重复这个动作也没有用。
chap1_para964,1,,为了便于理解，我们可以认为，它是将初始问题形式（完全可观测的，非确定性的）转化为另一种形式（部分可观测的，确定性的），其中循环规划的失败正是由于传动带的某个不可观测的特性。
chap1_para964,2,,在第12章中，我们将讨论如何判断几种不确定可能性中哪个可能性更大。
chap1_para965,1,,图4-12　光滑的真空吸尘器世界的部分搜索图，（一些）循环已经明确地标出。
chap1_para965,2,,这个问题的所有解都是循环规划，因为真空吸尘器无法稳定地移动
chap1_para966,1,,4.4　部分可观测环境中的搜索
chap1_para967,1,,现在我们考虑部分可观测性问题，即智能体的感知不足以确定准确的状态。
chap1_para967,2,,这意味着，智能体的一些动作将致力于减少当前状态的不确定性。
chap1_para968,1,,4.4.1　无观测信息的搜索
chap1_para969,1,,当智能体的感知根本不提供任何信息时，问题就变成了无传感器（sensorless）问题，或称一致性（conformant）问题。
chap1_para969,2,,起初，你可能会认为，如果无传感器智能体不知道起始状态，那它就无法求解问题，但出人意料的是，无传感器解非常普遍且有用，主要是因为它们不依赖于传感器是否正常工作。
chap1_para969,3,,例如，在制造系统中，已经开发出许多巧妙的方法，通过使用一系列行动而无须任何感知，从未知初始位置正确定位零件。
chap1_para969,4,,有时，即使存在可感知的条件规划，无传感器规划也会更好。
chap1_para969,5,,例如，医生通常会开一种广谱抗生素，而不是使用条件规划：先验血，接着等待结果，然后再开一种更具体的抗生素。
chap1_para969,6,,这种无传感器规划节省了时间和金钱，并且避免了在检测结果出来之前感染恶化的风险。
chap1_para97,1,Figure 1.,这个基本结果也可以解释为作用于整数上的某些函数无法用算法表示，即它们无法被计算。
chap1_para97,2,1The parts of a nerve cell or neuron.,这促使艾伦·图灵（Alan Turing，1912—1954）试图准确地描述哪些函数是可计算的，即能够通过有效的过程进行计算。
chap1_para97,3,"Each neuron consists of a cell body, or soma, that contains a cell nucleus.","丘奇-图灵论题（Church-Turing thesis）提出将图灵机（Turing, 1936）可计算的函数作为可计算性的一般概念。"
chap1_para97,4,Branching out from the cell body are a number of fibers called dendrites and a single long fiber called the axon.,图灵还表明，存在某些任何图灵机都无法计算的函数。
chap1_para97,5,"The axon stretches out for a long distance, much longer than the scale in this diagram indicates.",例如，没有一台机器能够在广义上判断给定程序是会根据给定的输入返回答案，还是永远运行下去。
chap1_para97,6,"Typically, an axon is 1 cm long (100 times the diameter of the cell body), but can reach up to 1 meter.",
chap1_para97,7,"A neuron makes connections with 10 to 100,000 other neurons at junctions called synapses.",
chap1_para97,8,Signals are propagated from neuron to neuron by a complicated electrochemical reaction.,
chap1_para97,9,The signals control brain activity in the short term and also enable long-term changes in the connectivity of neurons.,
chap1_para97,10,These mechanisms are thought to form the basis for learning in the brain.,
chap1_para97,11,"Most information processing goes on in the cerebral cortex, the outer layer of the brain.",
chap1_para97,12,The basic organizational unit appears to be a column of tissue about 0.,
chap1_para97,13,"5 mm in diameter, containing about 20,000 neurons and extending the full depth of the cortex (about 4 mm in humans).",
chap1_para970,1,,考虑一个（确定性）真空吸尘器世界的无传感器版本。
chap1_para970,2,,假设智能体知道它所在世界的地理环境，但不知道它自己的位置和灰尘的分布。
chap1_para970,3,,"在这种情况下，它的初始信念状态为{1, 2, 3, 4, 5, 6, 7, 8}（见图4-9）。"
chap1_para970,4,,"现在，如果智能体执行Right动作，它将位于{2, 4, 6, 8}中的某个状态——智能体在没有感知的情况下获得了信息！"
chap1_para970,5,,"执行[Right, Suck]之后，智能体将总是位于{4, 8}中的某个状态。"
chap1_para970,6,,"最终，无论初始状态是什么，执行[Right, Suck, Left, Suck]之后，智能体必定会到达目标状态7。"
chap1_para970,7,,我们称，智能体可以强迫（coerce）世界到达状态7。
chap1_para971,1,,无传感器问题的解是一个动作序列，而不是条件规划（因为它没有感知）。
chap1_para971,2,,但是，我们是在信念状态空间而非物理状态空间中进行搜索。
chap1_para971,3,,[6]在信念状态空间中，问题是完全可观测的，因为智能体始终知道自己的信念状态。
chap1_para971,4,,此外，无传感器问题的解（如果有的话）始终是一个动作序列。
chap1_para971,5,,这是因为，正如第3章的原始问题一样，每个动作后接收到的感知是完全可预测的——它们总是空的！
chap1_para971,6,,所以不存在需要规划的偶发事件。
chap1_para971,7,,即使环境是非确定性的，这也是正确的。
chap1_para973,1,,[6]　在完全可观测的环境中，每个信念状态只包含一个物理状态。
chap1_para973,2,,因此，我们可以将第3章的算法看作在信念状态为单元素的信念状态空间中搜索。
chap1_para974,1,,我们可以为无传感器搜索问题介绍新的算法。
chap1_para974,2,,但是，如果我们将底层物理问题转化为信念状态问题，我们就可以使用第3章中现有的算法，即，对信念状态而非物理状态进行搜索。
chap1_para974,3,,原问题P，由ActionsP、ResultP等组成，信念状态问题则包括以下部分。
chap1_para975,1,,● 状态：信念状态空间包含物理状态的每一个可能子集。
chap1_para975,2,,如果原问题P有N个状态，那么信念状态问题有2N个信念状态，尽管有很多状态都无法从初始状态到达。
chap1_para976,1,,● 初始状态：通常，初始信念状态包含P中的所有状态，尽管在某些情况下，智能体具有更多的先验知识。
chap1_para977,1,,● 动作：这部分有点棘手。
chap1_para977,2,,假设智能体位于信念状态，但是；那么智能体就无法确定哪些动作是合法的。
chap1_para977,3,,如果我们假定非法动作不会对环境产生影响，那么执行当前信念状态b下的任意物理状态的所有动作的并集都是安全的。
chap1_para978,1,,但是，如果非法动作可能导致严重后果，那么只允许执行动作的交集（对所有状态都合法的动作的集合）更安全。
chap1_para978,2,,对于真空吸尘器世界，每个状态都具有相同的合法动作，所以两种方法将给出相同的结果。
chap1_para979,1,,● 转移模型：对于确定性动作，对于每个当前可能状态，新的信念状态中都存在一个如下结果状态（尽管一些结果状态可能是相同的）。
chap1_para98,1,We now have some data on the mapping between areas of the brain and the parts of the body that they control or from which they receive sensory input.,尽管可计算性（computability）对理解计算很重要，但易处理性（tractability）的概念对人工智能的影响更大。
chap1_para98,2,"Such mappings are able to change radically over the course of a few weeks, and some animals seem to have multiple maps.",粗略地说，如果解决一个问题实例所需的时间随着问题规模呈指数增长，那么这个问题就是难处理的。
chap1_para98,3,"Moreover, we do not fully understand how other areas can take over functions when one area is damaged.","在20世纪60年代中期，复杂性的多项式增长和指数增长之间的区别首次被强调（Cobham, 1964; Edmonds, 1965）。"
chap1_para98,4,There is almost no theory on how an individual memory is stored or on how higher-level cognitive functions operate.,因为指数级增长意味着即使是中等规模的问题实例也无法在合理的时间内解决，所以易处理性很重要。
chap1_para981,1,,对于非确定性动作，新的信念状态则包含了将该动作应用于当前信念状态中的任一状态的所有可能结果。
chap1_para982,1,,对于确定性动作，b'不会大于b，而对于非确定性动作，b'可能会大于b（见图4-13）。
chap1_para983,1,,图4-13　（a）预测在无传感器真空吸尘器世界执行确定性动作Right后的下一个信念状态；（b）在光滑的无传感器真空吸尘器世界中的同一状态下执行同一动作的预测
chap1_para984,1,,● 目标测试：如果信念状态中的任一状态s满足底层问题的目标测试，Is-GoalP(s)，则智能体有可能到达了目标。
chap1_para984,2,,如果所有状态都满足Is-GoalP(s)，则智能体必定到达了目标。
chap1_para984,3,,我们的目标是使得智能体必定到达了目标。
chap1_para985,1,,● 路径代价：这部分也很棘手。
chap1_para985,2,,如果同一动作在不同状态下代价不同，那么在给定信念状态下执行动作的代价是几种不同值中的一种。
chap1_para985,3,,（这导致了一类新的问题，我们将在习题4.MVAL中讨论。
chap1_para985,4,,）现在我们假定同一动作在所有状态下具有相同代价，因此动作代价可以直接从底层物理问题中转换。
chap1_para986,1,,图4-14为确定性无传感器真空吸尘器世界的可达信念状态空间。
chap1_para986,2,,在28 = 256种可能信念状态中只有12种可以到达。
chap1_para987,1,,图4-14　确定性无传感器真空吸尘器世界的信念状态空间的可达部分。
chap1_para987,2,,每个矩形框对应一个信念状态。
chap1_para987,3,,在任何给定点，智能体都有一个信念状态，但它不知道自己位于哪个物理状态。
chap1_para987,4,,初始信念状态（完全未知）位于最上面的中间方框
chap1_para988,1,,上述定义确保信念状态问题的形式化能够从底层物理问题的定义自动构建。
chap1_para988,2,,一旦完成，就可以用第3章的任何普通搜索算法求解无传感器问题。
chap1_para989,1,,在一般的图搜索中，需要检测新到达的状态之前是否已经到达过。
chap1_para989,2,,"这也适用于信念状态；例如，在图4-14中，动作序列[Suck, Left, Suck]从初始状态出发，到达与序列[Right, Left, Suck]相同的信念状态，即，{5, 7}。"
chap1_para989,3,,"现在，考虑[Left]到达的信念状态，{1, 3, 5, 7}。"
chap1_para989,4,,"显然，这与{5, 7}不同，但它是{5, 7}的超集。"
chap1_para989,5,,我们可以抛弃（剪枝）任何一个这样的信念状态超集。
chap1_para989,6,,为什么？
chap1_para989,7,,"因为从{1, 3, 5, 7}出发的解一定也是任何单一状态1、3、5和7的解，因此，它也是这些单一状态任意组合的解，例如{5, 7}；因此我们没有必要试着求解{1, 3, 5, 7}，可以专注于求解更严格简单的信念状态{5, 7}。"
chap1_para99,1,The measurement of intact brain activity began in 1929 with the invention by Hans Berger of the electroencephalograph (EEG).,"由斯蒂芬·库克（Stephen Cook）（Cook, 1971）和理查德·卡普（Richard Karp）（Karp, 1972）开创的NP完全性（NP-completeness）理论为分析问题的易处理性提供了基础：任何可以归约到NP完全的问题都可能是难处理的。"
chap1_para99,2,The development of functional magnetic resonance imaging (fMRI) (Ogawa et al.,（尽管尚未证明NP完全问题一定是难处理的，但大多数理论家都相信这一点。
chap1_para99,3,", 1990; Cabeza and Nyberg, 2001) is giving neuroscientists unprecedentedly detailed images of brain activity, enabling measurements that correspond in interesting ways to ongoing cognitive processes.",）这些结果与大众媒体对第一台计算机的乐观态度——“比爱因斯坦还快的电子超级大脑！
chap1_para99,4,"These are augmented by advances in single-cell electrical recording of neuron activity and by the methods of optogenetics (Crick, 1999; Zemelman et al.",”——形成了鲜明对比。
chap1_para99,5,", 2002; Han and Boyden, 2007), which allow both measurement and control of individual neurons modified to be light-sensitive.",尽管计算机的速度在不断提高，但对资源的谨慎使用和必要的缺陷将成为智能系统的特征。
chap1_para99,6,,粗略地说，世界是一个极大的问题实例！
chap1_para990,1,,"反过来，如果已经生成{1, 3, 5, 7}，并且发现它是可解的，那么它的任何子集，如{5, 7}，可以确保也是可解的。"
chap1_para990,2,,（如果我有一个解，它在我对自己处于何种状态“非常困惑”时都是有效的，那么在我“不那么困惑”时它仍然是有效的。
chap1_para990,3,,）这种额外剪枝可能会显著提高无传感器问题的求解效率。
chap1_para991,1,,然而，即使有这样的改进，我们所介绍的无传感器问题求解方法在实践中也几乎是不可行的。
chap1_para991,2,,一个问题是信念状态空间非常庞大——我们在第3章中看到过，一个大小为N的搜索空间已经过于庞大，而现在我们搜索空间的大小为2N。
chap1_para991,3,,此外，搜索空间中的每个元素都是一个不超过N个元素的集合。
chap1_para991,4,,对于较大的N，内存空间甚至不足以表示单个的信念状态。
chap1_para992,1,,一种解决方案是用更紧凑的描述来表示信念状态。
chap1_para992,2,,例如，在英语中，我们可以用“Nothing”表示初始状态；我们可以用“Not in the rightmost column”表示执行Left动作后的信念状态，等等。
chap1_para992,3,,第7章介绍了如何在形式化表示模式中实现上述表示。
chap1_para993,1,,另一种方法是避免使用标准搜索算法，它们将信念状态看作和任何其他问题状态一样的黑盒。
chap1_para993,2,,然而，我们可以选择查看信念状态内部，并设计增量信念状态搜索（incremental belief-state search）算法，即，每次只为一个物理状态建立解。
chap1_para993,3,,"例如，在无传感器真空吸尘器世界中，初始信念状态为{1, 2, 3, 4, 5, 6, 7, 8}，我们必须找到一个在所有8种状态下都有效的动作序列。"
chap1_para993,4,,我们可以先找到状态1的解；然后检查它对于状态2是否有效；如果无效，则回溯寻找状态1的另一个解，以此类推。
chap1_para994,1,,正如与或搜索必须为与节点上的每个分支找到解一样，这一算法也必须为信念状态下的每个物理状态找到解；区别在于与或搜索可以为每个分支找到不同的解，而增量信念状态搜索必须找到一个对所有状态都有效的解。
chap1_para995,1,,增量方法的主要优点是，它通常能够快速检测出失败——当一个信念状态无解时，通常情况下，它的子集（包含最先检测的几个状态）也是无解的。
chap1_para995,2,,在某些情况下，这将导致与信念状态规模成正比的加速，信念状态本身可能就和物理状态空间一样大。
chap1_para996,1,,4.4.2　部分可观测环境中的搜索
chap1_para997,1,,对许多问题来说，没有感知就无法求解。
chap1_para997,2,,例如，求解无传感器8数码问题是不可能的。
chap1_para997,3,,但是，一点点感知可能就有很大帮助：如果我们能够看到左上角的方格，就能求解8数码问题。
chap1_para997,4,,解包括依次将每个滑片移动到可观测的方格中，并从那时起记录该滑片的位置。
chap1_para998,1,,对于部分可观测问题，问题形式化将定义一个Percept(s)函数，它返回智能体在给定状态下接收到的感知。
chap1_para998,2,,如果感知是非确定性的，那么我们可以使用Percepts函数返回可能感知的集合。
chap1_para998,3,,对于完全可观测问题，每个状态s下，Percept(s) = s，对于无传感器问题，Percept(s)= null。
chap1_para999,1,,考虑一个局部感知真空吸尘器世界，智能体拥有一个位置传感器（在左侧方格中生成感知L，右侧方格中生成感知R）和一个灰尘传感器（当前方格内有灰尘时生成感知Dirty，否则生成Clean）。
chap1_para999,2,,"因此，状态1的Percept为[L, Dirty]。"
chap1_para999,3,,"对于部分可观测的情况，通常会存在几个状态产生相同感知的情况；状态3也会产生[L, Dirty]。"
chap1_para999,4,,"因此，给定这一初始感知，初始信念状态将为{1,3}。"
chap1_para999,5,,我们可以将部分可观测问题信念状态之间的转移模型分为3个阶段，如图4-15所示。
chap2_para1,1,INTELLIGENT AGENTS,我们在此讨论智能体的本质，完美的或不完美的、环境的多样性以及由此产生的智能体类型的集合。
chap2_para10,1,"We can imagine tabulating the agent function that describes any given agent; for most agents, this would be a very large table—infinite, in fact, unless we place a bound on the length of percept sequences we want to consider. Given an agent to experiment with, we can, in principle, construct this table by trying out all possible percept sequences and recording which actions the agent does in response.1 The table is, of course, an external characterization of the agent. Internally, the agent function for an artificial agent will be implemented by an agent program. It is important to keep these two ideas distinct. The agent function is an abstract mathematical description; the agent program is a concrete implementation, running within some physical system.",[1]　如果智能体在选择其动作时使用一些随机化，那就必须多次尝试每个序列来确定每个动作的概率。
chap2_para10,2,,有人可能会认为随机地行动是相当愚蠢的，但本章后面展示出它可能非常聪明。
chap2_para100,1,•Simple reflex agents;,"历史上有许多例子表明，在其他领域可以成功地做到这一点：例如, 20世纪70年代以前，工程师和学生使用的巨大平方根表格，现在已经被电子计算器上运行的仅有5行代码的牛顿方法所取代。"
chap2_para100,2,,现在问题是，人工智能能像牛顿处理平方根那样处理一般智能行为吗？
chap2_para100,3,,我们相信答案是肯定的。
chap2_para1000,1,,我们考虑汽车装配的一小部分环节，包括15个任务：安装轮轴（axle）（前、后），固定4个车轮（wheel）（左和右、前和后），拧紧每个车轮的螺母（nuts），固定轮毂盖（cap），并检查（inspect）最终装配。
chap2_para1000,2,,我们可以将任务表示为15个变量：
chap2_para1001,1,,接着，我们需要表示各个任务间的优先约束（precedence constraint）。
chap2_para1001,2,,当任务T1必须在T2之前完成且任务T1所需时间为d1时，我们将添加一个如下形式的算术约束：
chap2_para1002,1,,在这个示例中，轮轴必须在车轮安装前到位，安装一个轮轴需要10分钟，所以有
chap2_para1003,1,,接下来，我们必须固定每个车轮（需要1分钟），拧紧螺母（2分钟），最后安装轮毂盖（1分钟，但暂未表示）：
chap2_para1004,1,,假设有4个工人来安装车轮，但他们必须共用一个工具来辅助安装轮轴。
chap2_para1004,2,,此时我们需要一个析取约束（disjunctive constraint）表示AxleF和AxleB在时间上不能重叠：要么先做AxleF，要么先做AxleB：
chap2_para1005,1,,这一约束看起来更加复杂，结合了算术约束和逻辑约束。
chap2_para1005,2,,但它仍可以简化为AxleF和AxleB可以取的一组值。
chap2_para1006,1,,我们还需要说明，检查是最后一项任务，需要3分钟。
chap2_para1006,2,,对于除Inspect外的每个变量，我们都需要添加一个形式的约束。
chap2_para1006,3,,最后，假设我们需要在30分钟内完成整个装配任务。
chap2_para1006,4,,因此，所有变量的域被限制为
chap2_para1007,1,,这一特定问题的求解非常琐碎，但CSP已经成功地应用于此类具有几千个变量的车间作业调度问题。
chap2_para1008,1,,6.1.3　CSP形式体系的变体
chap2_para1009,1,,"最简单的CSP所涉及的变量具有离散有限域（discrete, finite domain）。"
chap2_para1009,2,,地图着色问题和带有时间限制的调度问题都属于这类问题。
chap2_para1009,3,,8皇后问题（图4-3）也可以看作是一个有限域CSP，其中变量对应第1～8列中的皇后，每个变量的域为该列皇后可能的行号，。
chap2_para1009,4,,约束为不允许两个皇后在同一行或同一对角线上。
chap2_para101,1,•Model-based reflex agents;,在本节剩余部分中，我们将概述4种基本的智能体程序，它们体现了几乎所有智能系统的基本原理：
chap2_para1010,1,,离散域也可以是无限的（infinite），例如整数集或字符串集。
chap2_para1010,2,,（如果我们不对作业调度问题设置截止时间，那么每个变量的开始时间构成的域将是无限的。
chap2_para1010,3,,）对于无限域，我们必须使用类似这样的隐式约束，而不是显式的值元组。
chap2_para1010,4,,对于整数变量的线性约束（linear constraint）（像刚刚给出的约束一样，每个变量都只以线性形式出现）存在特殊的求解算法（在这里不讨论）。
chap2_para1010,5,,可以证明，不存在求解整数变量上一般非线性约束（nonlinear constraint）的算法——这个问题是不可判定的。
chap2_para1011,1,,连续域（continuous domain）约束满足问题是真实世界中的常见问题，在运筹学领域得到了广泛研究。
chap2_para1011,2,,例如，哈勃太空望远镜的实验调度需要非常精确的观测时间，每次观测和机动的开始时间、结束时间都是连续值变量，必须服从各种天文的、优先级的和电力的约束。
chap2_para1011,3,,最著名的一类连续域CSP是线性规划问题，其约束必须为线性等式或不等式。
chap2_para1011,4,,线性规划（linear programming）问题可以在关于变量个数的多项式时间内求解。
chap2_para1011,5,,此外人们还研究了具有不同类型约束和目标函数的问题——二次规划、二阶锥规划等。
chap2_para1011,6,,这些问题构成了应用数学的一个重要领域。
chap2_para1012,1,,除了检查CSP中变量的类型以外，检查约束的类型也是很有用。
chap2_para1012,2,,最简单的类型是一元约束（unary constraint），它限制单个变量的值。
chap2_para1012,3,,例如，在地图着色问题中，南澳大利亚州人可能不喜欢绿色，我们可以用一元约束表示。
chap2_para1012,4,,（变量的域的初始说明也可以看作一元约束。
chap2_para1012,5,,）
chap2_para1013,1,,二元约束（binary constraint）关系到两个变量。
chap2_para1013,2,,例如，是一个二元约束。
chap2_para1013,3,,二元CSP（binary CSP）只存在一元约束和二元约束，可以用如图6-1b所示的约束图表示。
chap2_para1014,1,,我们也可以定义高阶约束。
chap2_para1014,2,,"例如，三元约束Between(X, Y, Z)可以定义为。"
chap2_para1015,1,,包含任意个数变量的约束称为全局约束（global constraint）。
chap2_para1015,2,,（这个名称很传统，但容易混淆，因为它不需要包含问题中的所有变量）。
chap2_para1015,3,,最常见的全局约束之一是Alldiff，它表示约束中涉及的所有变量必须具有不同的值。
chap2_para1015,4,,在数独问题中（见6.2.6节），一行、一列或3×3框中的所有变量必须满足Alldiff约束。
chap2_para1016,1,,另一个例子是密码算术（cryptarithmetic）谜题（图6-2a）。
chap2_para1016,2,,密码算术谜题中的每个字母代表一个不同数字。
chap2_para1016,3,,"图6-2a中的情况，将表示为全局约束Alldiff(F, T, U, W, R, O)。"
chap2_para1016,4,,4列上的加法约束可以写成如下n元约束：
chap2_para1017,1,,其中C1、C2和C3为辅助变量，表示十位、百位或千位上的进位数。
chap2_para1017,2,,这些约束可以用约束超图（constraint hypergraph）表示，如图6-2b所示。
chap2_para1017,3,,超图由普通节点（图中的圆圈）和表示n元约束的超节点（正方形）组成，n元约束为包含n个变量的约束。
chap2_para1018,1,,图6-2　（a）密码算术问题。
chap2_para1018,2,,不同字母表示不同数字，目的是找到使加法算式成立的代替字母的数字，附加约束为不允许前导零。
chap2_para1018,3,,（b）密码算术问题的约束超图，用来表示Alldiff约束（最上面的方框）以及每列的加法约束（中间的4个方框）。
chap2_para1018,4,,变量C1、C2和C3表示从右到左3列的进位数
chap2_para1019,1,,或者，正如习题6.NARY需要你证明的，如果引入足够多的辅助变量，每个有限域约束都可以简化为一组二元约束。
chap2_para1019,2,,这意味着我们可以将任意一个CSP转换为只有二元约束的CSP，这将使算法设计变得更加简单。
chap2_para1019,3,,将n元CSP转换为二元CSP的另一种方式是对偶图（dual graph）变换：创建一个新图，原图中的每个约束用新图中的一个变量表示，原图中的每对共享变量的约束用新图中的一个二元约束表示。
chap2_para102,1,•Goal-based agents; and,● 简单反射型智能体；
chap2_para1020,1,,例如，考虑变量为的CSP，每个变量的域为，带有两个约束和。
chap2_para1020,2,,对偶图的变量则为，对偶图中C1变量的域为原问题C1约束中的元组的集合，同样地，C2的域是元组的集合。
chap2_para1020,3,,对偶图具有二元约束，其中R1是定义C1和C2之间约束的新关系。
chap2_para1020,4,,在这种情况下，。
chap2_para1021,1,,然而，我们可能更喜欢Alldiff这样的全局约束，而不是一组二元约束，这有两个原因。
chap2_para1021,2,,首先，使用Alldiff描述问题更简单而且更不容易出错。
chap2_para1021,3,,其次，可以为全局约束设计相比于基元约束更有效的专用推理算法。
chap2_para1021,4,,我们将在6.2.5节介绍这些推理算法。
chap2_para1022,1,,到目前为止，我们所描述的约束都是绝对约束，违反这些约束的可能解将被排除。
chap2_para1022,2,,许多真实世界的CSP包含偏好约束（preference constraint），偏好约束规定哪些解是首选的。
chap2_para1022,3,,例如，在大学排课问题中，存在绝对约束，如一个教授不可以同时上两门课。
chap2_para1022,4,,但也可能存在偏好约束：R教授可能更喜欢在上午上课，而N教授更喜欢在下午上课。
chap2_para1022,5,,让R教授在下午2点上课仍是一个可行解（除非R教授碰巧是系主任），但不是最优解。
chap2_para1023,1,,偏好约束通常可以编码为个别变量赋值的代价。
chap2_para1023,2,,例如，为R教授分配一个下午时段相对于总体目标函数的代价为2分，而分配上午时段的代价为1分。
chap2_para1023,3,,通过这样的形式化，带偏好约束的CSP可以用基于路径的或局部的优化搜索方法求解。
chap2_para1023,4,,我们称这样的问题为约束优化问题（constrained optimization problem，COP）。
chap2_para1023,5,,线性规划是一类COP。
chap2_para1024,1,,6.2　约束传播：CSP中的推断
chap2_para1025,1,,原子的状态空间搜索算法只有一种方式：通过扩展节点来访问后继节点。
chap2_para1025,2,,CSP算法有不同选择。
chap2_para1025,3,,它可以通过选择一个新的变量赋值来生成后继，或者执行一种称为约束传播（constraint propagation）的特定类型推断：使用约束减少一个变量的合法值的数量，这反过来又可以减少另一个变量的合法值，以此类推。
chap2_para1025,4,,其思想是，通过这一过程，当我们选择下一个变量赋值时，需要考虑的选项会减少。
chap2_para1025,5,,约束传播可以与搜索交替进行，也可以作为搜索开始前的预处理步骤。
chap2_para1025,6,,有时这种预处理就可以求解整个问题，所以根本不需要搜索。
chap2_para1026,1,,约束传播的核心思想是局部一致性（local consistency）。
chap2_para1026,2,,如果我们将每个变量看作图中的一个节点（见图6-1b），将每个二元约束看作一条边，则增强图中每一部分局部一致性的过程会导致整个图中不一致的值被删除。
chap2_para1026,3,,局部一致性有几种不同类型，我们现在依次介绍。
chap2_para1027,1,,6.2.1　节点一致性
chap2_para1028,1,,如果单个变量的域中的所有值都满足该变量的一元约束，则该变量（对应于CSP图中的某个节点）是节点一致的。
chap2_para1028,2,,例如，在澳大利亚地图着色问题（图6-1）的变体中，南澳大利亚州人不喜欢绿色，变量SA的初始域为，可以通过删除green使其保持节点一致，SA的域缩减为。
chap2_para1028,3,,如果图中的每个变量都是节点一致的，那么整个图是节点一致的。
chap2_para1029,1,,在求解过程开始时，通过缩减具有一元约束的变量的域，可以很容易地消除CSP中的所有一元约束。
chap2_para1029,2,,如前文所述，还可以将所有n元约束转换为二元约束。
chap2_para1029,3,,因此，一些CSP求解器只处理二元约束，要求用户提前消除其他约束。
chap2_para1029,4,,除非特别说明，本章的剩余部分都基于这一假设。
chap2_para103,1,•Utility-based agents.,● 基于模型的反射型智能体；
chap2_para1030,1,,6.2.2　弧一致性
chap2_para1031,1,,如果CSP中某一变量的域内的所有值都满足该变量的二元约束，那么该变量就是弧一致的（arc consistent）[3]。
chap2_para1031,2,,"更正式地说，对于变量Xi、Xj，如果对于当前域Di中的每个值，Dj中都存在一些值满足弧(Xi, Xj)上的二元约束，则称Xi相对于Xj是弧一致的。"
chap2_para1031,3,,如果每个变量相对所有其他变量都是弧一致的，那么这个图就是弧一致的。
chap2_para1031,4,,例如，考虑约束Y = X2，其中X和Y的域都是十进制数字。
chap2_para1031,5,,我们可以将这一约束显式地写为。
chap2_para1031,6,,"为了使X相对于Y弧一致，我们将X的域缩减为{0, 1, 2, 3}。"
chap2_para1031,7,,"如果要使Y相对于X弧一致，那么Y的域为{0, 1, 4, 9}，此时整个CSP是弧一致的。"
chap2_para1031,8,,但是，弧一致性对澳大利亚地图着色问题没有任何帮助。
chap2_para1031,9,,"考虑(SA, WA)的如下不同色约束："
chap2_para1033,1,,[3]　我们一直使用的术语是“边”而不是“弧”，所以将其称为“边一致”会更合适，但历史上使用的术语是“弧一致”。
chap2_para1034,1,,无论为SA（或WA）选择哪个值，另一变量都存在一个有效值。
chap2_para1034,2,,所以应用弧一致性对两个变量的域都没有影响。
chap2_para1035,1,,最流行的增强弧一致性的算法为AC-3（见图6-3）。
chap2_para1035,2,,为了使每个变量保持弧一致，AC-3算法将维护一个弧队列。
chap2_para1035,3,,初始时，队列包含CSP中的所有弧。
chap2_para1035,4,,（每个二元约束都有两条弧，每个方向各一条。
chap2_para1035,5,,"）然后AC-3从队列中弹出任意一条弧(Xi, Xj)并使Xi相对于Xj弧一致。"
chap2_para1035,6,,如果Di保持不变，算法就会处理下一条弧。
chap2_para1035,7,,"但是如果Di得以修正（域变小），那么我们将所有的弧(Xk, Xi)添加到队列中，其中Xk是Xi的邻居。"
chap2_para1035,8,,这样做的原因是，即使之前已经处理过Xk，Di的变化也可能会进一步缩减Dk。
chap2_para1035,9,,如果Di变为空集，那么表示整个CSP不存在一致解，AC-3可以马上返回失败。
chap2_para1035,10,,否则，我们继续检查，不断尝试缩减变量的域，直到队列中没有弧。
chap2_para1035,11,,此时，我们得到了一个与原始CSP等价的CSP（它们的解相同），但弧一致CSP搜索起来会更快，因为它的变量的域更小。
chap2_para1035,12,,在某些情况下，它可以完全求解问题（通过将每个域的大小缩减为1），而在其他情况下，它可以证明解不存在（通过将某些域的大小缩减为0）。
chap2_para1036,1,,图6-3　弧一致性算法AC-3。
chap2_para1036,2,,应用AC-3算法后，要么每条弧都是弧一致的，要么某些变量的域为空集，说明该CSP无解。
chap2_para1036,3,,"“AC-3”这个名字来源于算法的发明者（Mackworth, 1977），因为他论文中用到的算法是开发的第三个版本"
chap2_para1037,1,,AC-3的算法复杂性可以如下分析。
chap2_para1037,2,,假设CSP有n个变量，每个变量的域大小不超过d，带有c个二元约束（弧）。
chap2_para1037,3,,"每个弧(Xk, Xi)最多只能插入队列d次，因为Xi最多有d个值要删除。"
chap2_para1037,4,,对弧一致性的检查可以在O(d2)时间内完成，因此最坏情况下的时间复杂性为O(cd3)。
chap2_para1038,1,,6.2.3　路径一致性
chap2_para1039,1,,假设我们要给澳大利亚地图涂上两种颜色，红色和蓝色。
chap2_para1039,2,,此时弧一致性不起作用，因为将弧的一端涂成红色，另一端涂成蓝色可以分别满足每个约束。
chap2_para1039,3,,但显然这个问题是无解的：因为西澳大利亚州、北领地和南澳大利亚州彼此相邻，仅仅是它们就需要至少3种颜色。
chap2_para104,1,Each kind of agent program combines particular components in particular ways to generate actions.,● 基于目标的智能体；
chap2_para104,2,Section 2.,
chap2_para104,3,4.,
chap2_para104,4,6 explains in general terms how to convert all these agents into learning agents that can improve the performance of their components so as to generate better actions.,
chap2_para104,5,"Finally, Section 2.",
chap2_para104,6,4.,
chap2_para104,7,7 describes the variety of ways in which the components themselves can be represented within the agent.,
chap2_para104,8,This variety provides a major organizing principle for the field and for the book itself.,
chap2_para1040,1,,弧一致性利用弧（二元约束）将域（一元约束）收紧。
chap2_para1040,2,,为了求解地图着色等问题，我们需要更强的一致性概念。
chap2_para1040,3,,路径一致性（path consistency）使用隐式约束（通过观测变量的三元组推断）将二元约束收紧。
chap2_para1041,1,,考虑两个变量的集合和第三个变量Xm，如果对于每个满足上约束（如果有的话）的赋值，都存在Xm的一个赋值满足和上的约束，则称相对于Xm是路径一致的。
chap2_para1041,2,,这一名称是指从Xi途经Xm到Xj的路径的整体一致性。
chap2_para1042,1,,让我们考虑用两种颜色为澳大利亚地图着色时的路径一致性。
chap2_para1042,2,,我们要使集合相对于NT路径一致。
chap2_para1042,3,,首先枚举集合的一致赋值。
chap2_para1042,4,,在这种情况下，只有两个一致赋值：和。
chap2_para1042,5,,可以看到，对于这两种赋值，NT不能是红色或蓝色（因为它会与WA或SA发生冲突）。
chap2_para1042,6,,因为NT不存在有效选择，所以我们消除了这两种赋值，最终不存在有效赋值。
chap2_para1042,7,,因此，我们知道了这个问题是无解的。
chap2_para1043,1,,6.2.4　k一致性
chap2_para1044,1,,可以用k一致性（k-consistency）的概念定义更强的传播形式。
chap2_para1044,2,,如果对于CSP的任意(k −1)个变量的集合以及这些变量的任意一致赋值，任意第k个变量都存在一个一致赋值，则称该CSP是k一致的。
chap2_para1044,3,,1一致性表示，给定空集，我们可以使任何单变量集合满足一致性，这就是我们所说的节点一致性。
chap2_para1044,4,,2一致性等价于弧一致性。
chap2_para1044,5,,对于二元约束图，3一致性等价于路径一致性。
chap2_para1045,1,,如果一个CSP是k一致的，也是(k −1)一致的，(k −2)一致的……一直到1一致的，则称它是强k一致的（strongly k-consistent）。
chap2_para1045,2,,现在假设我们有一个包含n个节点的CSP，并且是强n一致的(即当k = n时，强k一致)，那么可以这样求解该问题：首先，为X1选择一个一致值。
chap2_para1045,3,,然后因为图是2一致的，所以保证能为X2选出一个一致值，因为它是3一致的，所以能为X3选出一个值，以此类推。
chap2_para1045,4,,"对于每个变量Xi，我们只需在它的域的d个值中搜索，就可以找到一个与X1, …, Xi−1一致的值。"
chap2_para1045,5,,总运行时间只有O(n2d)。
chap2_para1046,1,,当然，世界上没有免费的午餐：约束满足问题通常是NP完全的，任何建立n一致性的算法在最坏情况下的时间复杂性都是n的指数级。
chap2_para1046,2,,更糟的是，n一致性所需的空间复杂性也是n的指数级。
chap2_para1046,3,,在实践中，确定适当的一致性检查层级基本上是一门经验科学。
chap2_para1046,4,,比较常见的是计算2一致性，其次是计算3一致性。
chap2_para1047,1,,6.2.5　全局约束
chap2_para1048,1,,前文提到，全局约束涉及任意个数的变量（但不一定是所有变量）。
chap2_para1048,2,,实际问题中经常出现全局约束，可以通过专用算法处理这些约束，这些算法比目前介绍的一般方法更加高效。
chap2_para1048,3,,例如，Alldiff约束规定所有相关变量必须取不同的值（如上文的密码算术问题和下文的数独问题）。
chap2_para1048,4,,对Alldiff约束进行不一致性检测的一种简单形式如下所示：如果约束中涉及m个变量，而且它们一共具有n个可能的不同值，且，那么约束不可能满足。
chap2_para1049,1,,这将导出以下简单算法。
chap2_para1049,2,,首先，删除约束中任意一个单值变量（域中只有一个值的变量），并且从其余变量的域中删除该变量的值。
chap2_para1049,3,,只要还存在单值变量，就重复上述过程。
chap2_para1049,4,,如果在任一点上产生了空集，或者存在比剩余取值数更多的变量，则检测到了不一致性。
chap2_para105,1,2.,● 基于效用的智能体。
chap2_para105,2,4.,
chap2_para105,3,2Simple reflex agents,
chap2_para1050,1,,上述方法可以检测图6-1中赋值的不一致性。
chap2_para1050,2,,注意，变量SA、NT和Q是通过Alldiff约束有效连接的，因为每对都必须取两种不同颜色。
chap2_para1050,3,,将AC-3应用于这个部分赋值后，SA、NT和Q的域都缩减为。
chap2_para1050,4,,也就是说，我们有3个变量，但只有两种颜色，这违反了Alldiff约束。
chap2_para1050,5,,因此，对高阶约束进行简单一致性处理有时比对等价的二元约束集应用弧一致性更高效。
chap2_para1051,1,,另一种重要的高阶约束是资源约束（resource constraint），有时也称为Atmost约束。
chap2_para1051,2,,"例如，在一个调度问题中，设P1, …, P4分别表示分配给4个任务的人数。"
chap2_para1051,3,,分配总人数不超过10的约束写为。
chap2_para1051,4,,通过检验当前域的最小值之和可以检测不一致性。
chap2_para1051,5,,"例如，如果每个变量的域都是{3, 4, 5, 6}，则不可能满足Atmost约束。"
chap2_para1051,6,,另一个例子是，如果当前某个变量的域中的最大值加上所有其他变量的域的最小值超过约束，则可以通过删除该最大值来保持一致性。
chap2_para1051,7,,"因此，如果示例中的每个变量的域都是{2, 3, 4, 5, 6}，那么可以从每个域中删除5和6。"
chap2_para1052,1,,对于大规模的、具有整数值的资源有限问题（例如用几百辆车运送几千人的物流问题）将每个变量的域表示为一个大的整数集然后通过一致性检查方法逐渐缩减这个集合通常是不可能的。
chap2_para1052,2,,相反，域由上界和下界表示，通过边界传播（bound propagation）处理。
chap2_para1052,3,,例如，在航班调度问题中，假设存在两趟航班，F1和F2，其中飞机的容量分别为165和385。
chap2_para1052,4,,F1和F2航班上乘客数量的初始域为
chap2_para1054,1,,现在假设我们有附加约束，两趟航班所搭载的总乘客数必须是420：。
chap2_para1054,2,,通过传播边界约束，我们将域缩减为
chap2_para1056,1,,如果对于任意变量X和它的上下界值，任意变量Y，都存在满足X和Y之间约束的Y的值，则称CSP是边界一致的（bounds-consistent）。
chap2_para1056,2,,这种边界传播在实际的约束问题中得到了广泛应用。
chap2_para1058,1,,数独（Sudoku）游戏非常流行，它将数百万人引入了约束满足问题，尽管他们可能没有意识到这一点。
chap2_para1058,2,,数独棋盘由81个方格组成，有些方格预先填有1到9的数字。
chap2_para1058,3,,谜题是将所有剩余方格填满，并且任意一行、一列或3×3方框中不存在相同数字（见图6-4）。
chap2_para1058,4,,一行、一列或一个方框称为一个单元（unit）。
chap2_para1059,1,,图6-4　（a）一个数独问题。
chap2_para1059,2,,（b）它的解
chap2_para106,1,The simplest kind of agent is the simple reflex agent.,每种智能体程序以特定的方式组合特定的组件来产生动作。
chap2_para106,2,"These agents select actions on the basis of the current percept, ignoring the rest of the percept history.",2.4.6节大致解释了如何将所有这些智能体转换为学习型智能体，以提高其组件的性能，从而产生更好的动作。
chap2_para106,3,"For example, the vacuum agent whose agent function is tabulated in Figure 2.",2.4.7节描述在智能体中表示组件本身的各种方式。
chap2_para106,4,"3 is a simple reflex agent, because its decision is based only on the current location and on whether that location contains dirt.",这种多样性为这一领域和这本书本身提供了一个主要的组织原则。
chap2_para106,5,An agent program for this agent is shown in Figure 2.,
chap2_para106,6,8.,
chap2_para1060,1,,报纸和益智书籍上的数独游戏都有一个特点，即有且只有一个解。
chap2_para1060,2,,尽管有些问题手动求解很难，需要花费几十分钟，但CSP求解器每秒可以处理几千个问题。
chap2_para1061,1,,可以将数独游戏看作含有81个变量的CSP，每个变量对应一个方格。
chap2_para1061,2,,用变量名A1到A9表示第一行（从左到右），I1到I9表示最后一行。
chap2_para1061,3,,"空方格的域为{1, 2, 3, 4, 5, 6, 7, 8, 9}，预先填好的方格的域只有一个值。"
chap2_para1061,4,,此外，还有27个不同的Alldiff约束，每个单元（行、列和含有9个方格的方框）各有一个Alldiff约束：
chap2_para1062,1,,"Alldiff (A1, A2, A3, A4, A5, A6, A7, A8, A9)"
chap2_para1063,1,,"Alldiff (B1, B2, B3, B4, B5, B6, B7, B8, B9)"
chap2_para1065,1,,"Alldiff (A1, B1, C1, D1, E1, F1, G1, H1, I1)"
chap2_para1066,1,,"Alldiff (A2, B2, C2, D2, E2, F2, G2, H2, I2)"
chap2_para1068,1,,"Alldiff (A1, A2, A3, B1, B2, B3, C1, C2, C3)"
chap2_para1069,1,,"Alldiff (A4, A5, A6, B4, B5, B6, C4, C5, C6)"
chap2_para107,1,"Description Part (“a”), Atomic: An arrow from a block labeled B points to a block labeled C. Part (b), Factored: Two blocks labeled B and C are shown. In both blocks, four circles are shown one below the other and two progress bars are shown below the bottom circle. In block B, the circles have alternating black and blue shades from the top. In the first progress bar, black shade fills about 40 percent of the bar while the blue shade fills the rest. In the second progress bar, the black shade fills about 90 percent of the bar while the blue shade fills the rest. In block C, the first two circles from the top are shaded blue and the other two circles are shaded black. In the first progress bar, black shade fills about 40 percent of the bar while the blue shade fills the rest. In the second progress bar, the black shade fills about 60 percent of the bar while the blue shade fills the rest. Part (c), Structured: The figure shows two blocks connected by an arrow. There are four red blocks, three green blocks, and two white blocks in the first block. These are arranged in three columns and four rows. The following blocks are shown on each row. Row 1: Column 1, red. Column 2, green. Row 2: Column 2, red. Row 3: Column 1, red. Column 2, green. Column 3, white. Row 4: Column 1, white. Column 2, red. Column 3, green. These blocks are connected using arrows in different paths. There are four red blocks, three green blocks, and four white blocks in the second block. These are arranged in three columns and four rows. The following blocks are shown on each row. Row 1: Column 1, white. Column 2, green. Column 3, white. Row 2: Column 2, red. Column 3, red. Row 3: Column 1, red. Column 2, white. Column 3, white. Row 4: Column 1, green. Column 2, red. Column 3, green. These blocks are connected using arrows in different paths.",2.4.2　简单反射型智能体
chap2_para1071,1,,让我们看看弧一致性能带我们走多远。
chap2_para1071,2,,假设Alldiff约束已被扩展为二元约束（例如A1 A2），这样我们就可以直接应用AC-3算法。
chap2_para1071,3,,考虑图6-4a中的变量E6——正中间方框中2、8之间的空格。
chap2_para1071,4,,按照方框的约束，我们可以从E6的域中删除1、2、7和8。
chap2_para1071,5,,按照它所在列的约束，我们可以删除5、6、2、8、9和3（尽管2和8已经被删除）。
chap2_para1071,6,,此时E6的域是{4}；换句话说，我们知道了E6的解。
chap2_para1071,7,,现在考虑变量I6——最后一行中间方框中被1、3、3包围的空格。
chap2_para1071,8,,在它所在列应用弧一致性，可以删除5、6、2、4（因为我们现在知道E6一定是4）、8、9和3。
chap2_para1071,9,,我们利用它和I5的弧一致性删除1，此时I6的域中只剩下7。
chap2_para1071,10,,现在第6列中有8个已知值，所以根据弧一致性可以推出A6一定是1。
chap2_para1071,11,,沿着这样的思路继续推断，最终AC-3可以求解整个问题——所有变量的域都缩减为单个值，如图6-4b所示。
chap2_para1072,1,,当然，如果每个数独问题都可以通过机械地应用AC-3求解，那么它很快就会失去吸引力，实际上AC-3只适用于最简单的数独问题。
chap2_para1072,2,,稍微困难一点的问题可以用PC-2求解，但需要花费更大的计算代价：在一个数独问题中，需要考虑255 960个不同的路径约束。
chap2_para1072,3,,为了求解最困难的数独问题并取得高效进展，我们必须更聪明一些。
chap2_para1073,1,,事实上，数独对人类解谜者的吸引力在于，他们需要足智多谋地应用更复杂的推理策略。
chap2_para1073,2,,数独爱好者给这些策略取了各种有趣的名字，如“三链数删减法”。
chap2_para1073,3,,它的工作原理如下：在任一单元（行、列或方框）中，找到3个方格，它们的域包含相同的3个数字或这3个数字的子集。
chap2_para1073,4,,例如，这3个域可能是、和。
chap2_para1073,5,,我们并不知道哪个方格是1、3或8，但我们知道这3个数字一定分布在这3个方格中。
chap2_para1073,6,,因此，我们可以将1、3和8从该单元中所有其他方格的域中删除。
chap2_para1074,1,,有趣的是，这些方法并不只是专用于数独。
chap2_para1074,2,,对于数独，我们确实必须说它有81个变量，域是数字1～9，有27个Alldiff约束。
chap2_para1074,3,,但除此之外，所有策略（弧一致性、路径一致性等）普遍适用于所有CSP，而不仅仅是数独问题。
chap2_para1074,4,,即使是三链数删减法，也是一种加强Alldiff约束一致性的策略，而不是特定于数独本身。
chap2_para1074,5,,这就是CSP形式体系的作用：对于每个新问题域，我们只需按照约束定义问题，然后就可以使用一般的约束求解机制。
chap2_para1075,1,,6.3　CSP的回溯搜索
chap2_para1076,1,,有时我们完成约束传播过程后仍存在具有多个可能值的变量。
chap2_para1076,2,,在这种情况下，我们必须通过搜索来求解问题。
chap2_para1076,3,,本节中我们将介绍用于部分赋值的回溯搜索算法，6.4节中我们将介绍用于完整赋值的局部搜索算法。
chap2_para1077,1,,考虑标准的深度受限搜索（第3章）是如何求解CSP的。
chap2_para1077,2,,状态可能是一个部分赋值，而动作将对该赋值进行扩展，例如，在澳大利亚地图着色问题中，添加赋值NSW = red或SA = blue。
chap2_para1077,3,,对于具有n个变量，域大小为d的CSP，我们最终将得到一个搜索树，所有的完整赋值（因此所有的解）都是深度为n的叶节点。
chap2_para1077,4,,但要注意，第一层的分支因子为nd，因为n个变量中的任意变量都可以取d个值中的任意值。
chap2_para1077,5,,下一层的分支因子是(n −1)d，以此类推n层。
chap2_para1077,6,,所以树总共有n! · dn个叶节点，即使可能的完整赋值只有dn种！
chap2_para1078,1,,如果意识到CSP具有的一个关键性质：可交换性（commutativity），我们就可以消去因子n!。
chap2_para1078,2,,如果任意给定的动作集合的应用顺序对结果没有影响，则称该问题是可交换的。
chap2_para1078,3,,在CSP中，不管我们先赋值NSW = red，再赋值SA = blue，还是交换顺序，都没有区别。
chap2_para1078,4,,因此，我们只需考虑搜索树中每个节点上的单个变量。
chap2_para1078,5,,在根节点上，我们可能需要在SA = red、SA = green和SA = blue之间做出选择，但我们永远不需要在NSW = red和SA = blue之间做出选择。
chap2_para1078,6,,在这一限制下，叶节点的数量减少到dn，这正是我们所希望的。
chap2_para1078,7,,在树的每一层中，我们都必须选择要处理哪个变量，但我们永远不需要回溯这一选择。
chap2_para1079,1,,图6-5为CSP的回溯搜索过程。
chap2_para1079,2,,它不断选择未赋值变量，然后依次尝试该变量的域中的所有值，试图通过递归调用将每个值扩展为一个解。
chap2_para1079,3,,如果调用成功，则返回解，如果调用失败，则将赋值恢复到前一状态，然后尝试下一个值。
chap2_para1079,4,,如果所有值都不成功，则返回失败。
chap2_para1079,5,,澳大利亚地图着色问题的部分搜索树如图6-6所示，其中我们按照WA、 NT、Q……的顺序为变量赋值。
chap2_para108,1,Figure 2.,最简单的智能体是简单反射型智能体（simple reflex agent）。
chap2_para108,2,8The agent program for a simple reflex agent in the two-location vacuum environment.,这些智能体根据当前感知选择动作，忽略感知历史的其余部分。
chap2_para108,3,This program implements the agent function tabulated in Figure 2.,例如，真空吸尘器的智能体函数在图2-3所示，是一种简单反射型智能体，因为它的决策仅基于当前位置以及该位置是否有灰尘。
chap2_para108,4,3.,该智能体的智能体程序如图2-8所示。
chap2_para1080,1,,图6-5　约束满足问题的简单回溯算法。
chap2_para1080,2,,该算法以第3章的递归深度优先搜索为模型。
chap2_para1080,3,,函数Select-Unassigned- Variable和Order-Domain-Values实现了6.3.1节中讨论的通用启发式算法。
chap2_para1080,4,,函数Inference可以根据需要选择性地使用弧一致性、路径一致性或k一致性检测。
chap2_para1080,5,,如果一个赋值导致了失败（无论是在Inference还是在Backtrack中），那么该赋值（包括从Inference得到的值）将被撤销，然后重新尝试一个新的赋值
chap2_para1081,1,,图6-6　图6-1中地图着色问题的部分搜索树
chap2_para1082,1,,注意，Backtracking-Search只维护状态（赋值）的单个表示，然后对它进行修改，而不是创建一个新的表示（见3.4.3节）。
chap2_para1083,1,,第3章的无信息搜索算法只能通过提供领域特定的启发式算法来改进，然而，事实证明，回溯搜索可以使用领域无关的启发式算法进行改进，这些算法利用了CSP的因子化表示。
chap2_para1083,2,,在接下来的4节中，我们将介绍如何做到这一点。
chap2_para1084,1,,● （6.3.1节）下一步应该给哪个变量赋值（Select-Unassigned-Variable），以及应该以什么顺序尝试它的值（Order-Domain-Values）？
chap2_para1085,1,,● （6.3.2节）在每步搜索中应该执行怎样的推断（Inference）？
chap2_para1086,1,,● （6.3.3节）我们能在适当的时候回溯（Backtrack）不止一步吗？
chap2_para1087,1,,● （6.3.4节）我们可以保存和复用搜索的部分结果吗？
chap2_para1088,1,,6.3.1　变量排序和值排序
chap2_para1089,1,,回溯算法中包含这样一行：
chap2_para109,1,Notice that the vacuum agent program is very small indeed compared to the corresponding table.,图2-8　在只有两个位置的真空吸尘器环境中，简单反射型智能体的智能体程序，该程序实现图2-3中列出的智能体函数
chap2_para109,2,"The most obvious reduction comes from ignoring the percept history, which cuts down the number of relevant percept sequences from 4T to just 4.",
chap2_para109,3,"A further, small reduction comes from the fact that when the current square is dirty, the action does not depend on the location.",
chap2_para109,4,"Although we have written the agent program using if-then-else statements, it is simple enough that it can also be implemented as a Boolean circuit.",
chap2_para1090,1,,Select-Unassigned-Variable的最简单的策略是使用静态排序：按列表顺序选择变量。
chap2_para1090,2,,第二简单的策略是随机选择。
chap2_para1090,3,,这两种策略都不是最优的。
chap2_para1090,4,,例如，图6-6中，进行WA = red和NT = green赋值后，SA只有一个可能的值，因此接下来应该对SA赋值SA = blue而不是对Q赋值：事实上，对SA赋值后，Q、NSW和V的取值都是确定的。
chap2_para1091,1,,这种直观的想法——选择“合法”值最少的变量——称为最少剩余值（minimum-remaining-value，MRV）启发式算法，也被称为“最受约束变量”或“失败优先”启发式算法，后一个名字是因为它选择了最有可能马上导致失败的变量，从而可以对搜索树剪枝。
chap2_para1091,2,,如果某一变量X没有剩余合法值，那么MRV启发式算法将优先选择X然后马上检测到失败——避免遍历其他变量进行无意义地搜索。
chap2_para1091,3,,MRV启发式算法通常比随机或静态排序表现得更好，有时会带来数量级上的效率差异，尽管结果可能因问题而异。
chap2_para1092,1,,在选择澳大利亚地图的第一个着色区域时，MRV启发式算法完全不起作用，因为初始时每个区域都有3种合法颜色。
chap2_para1092,2,,在这种情况下，度启发式（degree heuristic）算法就派上用场了。
chap2_para1092,3,,它通过选择与其他未赋值变量的约束最多的变量来降低未来选择的分支因子。
chap2_para1092,4,,在图6-1中，SA的度最大，为5；除了变量T的度为0，其他变量的度为2或3。
chap2_para1092,5,,如果先赋值SA，我们就可以按顺时针或逆时针顺序访问5个陆地区域，并为每个区域赋予不同于SA和前一个区域的颜色。
chap2_para1092,6,,最少剩余值启发式算法通常效果更好，但度启发式算法可以打破僵局。
chap2_para1093,1,,一旦选择了一个变量，算法必须决定按什么顺序检验它的值。
chap2_para1093,2,,最少约束值（least-constraining-value）启发式算法对此非常有效。
chap2_para1093,3,,它优先选择那些为约束图中相邻变量留下最多选择的值。
chap2_para1093,4,,例如，假设在图6-1中，我们已经生成了部分赋值WA = red和NT = green，并且下一步是为Q选择赋值。
chap2_para1093,5,,此时蓝色是一个糟糕的选择，因为它消除了Q的邻居SA的最后一个可选的合法值。
chap2_para1093,6,,因此，最少约束值启发式算法会优先选择红色而不是蓝色。
chap2_para1093,7,,一般来说，启发式算法试图为后续变量赋值留下最大的灵活性。
chap2_para1094,1,,为什么变量选择是失败优先，而值选择是失败延后呢？
chap2_para1094,2,,每个变量最终都必须被赋值，因此通过选择那些有可能最先失败的变量，在统计意义上，需要通过回溯才能找到的成功赋值就会更少。
chap2_para1094,3,,对于值排序，关键在于我们只需要找到一个解；因此，先寻找最有可能的值是有意义的。
chap2_para1094,4,,如果我们的目标是枚举所有的解而不只是找到一个解，那么值排序就无关紧要了。
chap2_para1095,1,,6.3.2　交替进行搜索和推理
chap2_para1096,1,,我们已经讨论了AC-3算法如何在搜索前缩减变量的域。
chap2_para1096,2,,但在搜索过程中，推断的作用可能更大：每次我们为某个变量选择某个值时，都有一个全新的机会推断其相邻变量的新的域缩减。
chap2_para1097,1,,推断的最简单形式之一是前向检验（forward checking）。
chap2_para1097,2,,当变量X被赋值时，前向检验过程为其建立弧一致性：对于每个通过约束与X连接的未赋值变量Y，从它的域中删除与X的取值不一致的值。
chap2_para1098,1,,图6-7为在澳大利亚地图CSP上使用前向检验进行回溯搜索的过程。
chap2_para1098,2,,关于这一示例，有两点需要注意。
chap2_para1098,3,,首先，需要注意，在赋值WA = red和Q = green后，NT和SA的域缩减为单个值；通过从WA和Q传播信息，我们可以完全消除这些变量上的分支。
chap2_para1098,4,,其次，需要注意，赋值V= blue后，SA的域为空集。
chap2_para1098,5,,因此，前向检验检测到部分赋值与问题的约束不一致，算法立即回溯。
chap2_para1099,1,,图6-7　带前向检验的地图着色搜索过程。
chap2_para1099,2,,首先赋值WA = red；然后前向检验从其相邻变量NT和SA的域中删除red。
chap2_para1099,3,,赋值Q = green后，从NT、SA和NSW的域中删除green。
chap2_para1099,4,,赋值V = blue后，从NSW和SA的域中删除blue，此时SA没有合法值
chap2_para11,1,"To illustrate these ideas, we use a simple example—the vacuum-cleaner world, which consists of a robotic vacuum-cleaning agent in a world consisting of squares that can be either dirty or clean. Figure 2.2 shows a configuration with just two squares, A and B. The vacuum agent perceives which square it is in and whether there is dirt in the square. The agent starts in square A. The available actions are to move to the right, move to the left, suck up the dirt, or do nothing.2 One very simple agent function is the following: if the current square is dirty, then suck; otherwise, move to the other square. A partial tabulation of this agent function is shown in Figure 2.3 and an agent program that implements it appears in Figure 2.8 on page 67.",为了阐明这些想法，我们举一个简单的例子——真空吸尘器世界。
chap2_para11,2,,在一个由方格组成的世界中，包含一个机器人真空吸尘器智能体，其中的方格可以是脏的，也可以是干净的。
chap2_para11,3,,图2-2展示了只有两个方格——方格A和方格B——的情况。
chap2_para11,4,,真空吸尘器智能体可以感知它在哪个方格中，以及方格中是否干净。
chap2_para11,5,,智能体从方格A开始。
chap2_para11,6,,可选的操作包括向右移动、向左移动、吸尘或什么都不做。
chap2_para11,7,,[2]一个非常简单的智能体函数如下：如果当前方格是脏的，就吸尘；否则，移动到另一个方格。
chap2_para11,8,,该智能体函数的部分表格如图2-3所示，实现它的智能体程序如图2-8所示。
chap2_para110,1,"Simple reflex behaviors occur even in more complex environments. Imagine yourself as the driver of the automated taxi. If the car in front brakes and its brake lights come on, then you should notice this and initiate braking. In other words, some processing is done on the visual input to establish the condition we call “The car in front is braking.” Then, this triggers some established connection in the agent program to the action “initiate braking.” We call such a connection a condition–action rule,6 written as",注意，与之前对应的表相比，真空吸尘器的程序确实非常轻量。
chap2_para110,2,,最明显的简化来自忽略感知历史，这将相关感知序列的数量从4T减少到4。
chap2_para110,3,,进一步的简化基于以下事实：动作不依赖于位置，只依赖于当前方格是否有灰尘。
chap2_para110,4,,虽然我们已经使用if-then-else语句来编写智能体程序，但它非常简单，可以将其实现为布尔电路。
chap2_para1100,1,,对许多问题来说，将MRV启发式算法与前向检验相结合，可以使搜索更有效。
chap2_para1100,2,,考虑图6-7中的赋值。
chap2_para1100,3,,直观上，这一赋值似乎对它的相邻变量NT和SA有所约束，所以接下来应该先处理这些变量，然后是所有其他变量。
chap2_para1100,4,,MRV正是这么做的：NT和SA各有两个值，所以先选择其中一个，接着是另一个，然后依次是Q、NSW和V。
chap2_para1100,5,,最后T仍然有3个可能的值，任意一个都是有效的。
chap2_para1100,6,,我们可以将前向检验看作一种以增量方式计算MRV启发式算法完成其工作所需信息的有效途径。
chap2_para1101,1,,尽管前向检验能够检测出许多不一致，但它无法检测到所有的不一致。
chap2_para1101,2,,问题在于，它向前看得不够远。
chap2_para1101,3,,例如，考虑图6-7中的Q = green一行。
chap2_para1101,4,,我们已经使WA和Q弧一致，但此时NT和SA的唯一可能的值都是蓝色，这违反了一致性，因为它们是相邻变量，相邻变量不能取相同的值。
chap2_para1102,1,,维护弧一致性（maintaining arc consistency，MAC）算法能检测出这类不一致性。
chap2_para1102,2,,"当变量Xi被赋值后，Inference程序调用AC-3，但我们开始时只考虑所有与Xi相邻的未赋值变量Xj的弧(Xj, Xi)，而不是CSP中的所有弧。"
chap2_para1102,3,,从这出发，AC-3以通常的方式进行约束传播，如果任何变量的域缩减为空集，则AC-3调用失败，并立即回溯。
chap2_para1102,4,,我们可以看到，MAC严格来说比前向检验更强大，因为前向检验所做的事情与MAC对其队列的初始弧所做的相同；但与MAC不同的是，当变量的域发生变化时，前向检验不会递归地传播约束。
chap2_para1103,1,,6.3.3　智能回溯：向后看
chap2_para1104,1,,当搜索的一个分支失败时，图6-5中的Backtracking-Search算法将采取一种非常简单的策略：退回到上一个变量，并为其尝试一个不同的值。
chap2_para1104,2,,这称为时序回溯（chronological backtracking），因为时间上最近的决策点会被重新访问。
chap2_para1104,3,,在本节中，我们考虑更好的可能策略。
chap2_para1105,1,,考虑一下，当我们按照固定的变量顺序Q、NSW、V、 T、SA、WA、NT应用图6-1中的简单回溯时会发生什么。
chap2_para1105,2,,假设我们已经生成了部分赋值。
chap2_para1105,3,,当我们尝试下一个变量SA时，发现所有值都违反了约束。
chap2_para1105,4,,我们退回到T，为塔斯马尼亚州尝试一种新颜色！
chap2_para1105,5,,显然，这种做法是愚蠢的——重新给塔斯马尼亚州着色并不能解决南澳大利亚州的问题。
chap2_para1106,1,,一种更智能的方法是回溯到有可能求解这一问题的变量——导致SA的某个可能值变成不可能值的变量。
chap2_para1106,2,,为此，我们将记录与SA的某些值冲突的赋值集合。
chap2_para1106,3,,该集合（在本例中为）称为SA的冲突集（conflict set）。
chap2_para1106,4,,回跳（backjumping）方法将回溯到冲突集中最近的赋值，在本例中，回跳将越过塔斯马尼亚州，为V尝试一个新的值。
chap2_para1106,5,,通过修改Backtrack算法，可以很容易地实现上述方法，即在检验合法值时，同时维护冲突集。
chap2_para1106,6,,如果找不到合法值，算法应该返回失败指示和冲突集中最近的元素。
chap2_para1107,1,,眼尖的读者可能已经注意到，前向检验不需要额外工作就能提供冲突集：当前向检验根据赋值X = x从Y的域中删除一个值时，它应该将X = x添加到Y的冲突集中。
chap2_para1107,2,,如果Y的域中的最后一个值也被删除，那么Y的冲突集中的赋值也要被添加到X的冲突集中。
chap2_para1107,3,,也就是说，我们现在知道X = x导致了（Y中的）矛盾，因此应该为X尝试不同赋值。
chap2_para1108,1,,有眼力的读者可能已经注意到一些奇怪的事情：当域中的每个值都与当前赋值冲突时就会发生回跳，但前向检验能检测出这个事件并阻止搜索到达这样的节点！
chap2_para1108,2,,事实上，可以证明，每个被回跳剪除的分支也会被前向检验剪枝。
chap2_para1108,3,,因此，在前向检验搜索中，或者在使用更强一致性检验的搜索（如MAC）中，简单的回跳是多余的——你只需执行其中一项。
chap2_para1109,1,,尽管存在上一段中的观测结果，回跳背后的思想仍然值得借鉴：基于失败原因进行回溯。
chap2_para1109,2,,当变量的域变为空集时，回跳发现失败，但在许多情况下，在很早之前分支就注定要失败。
chap2_para1109,3,,再次考虑部分赋值（从我们前面的讨论来看，它是不一致的）。
chap2_para1109,4,,假设我们下一步尝试T = red，然后对NT、Q、V和SA赋值。
chap2_para1109,5,,我们知道，最后这4个变量不存在有效赋值，所以最终在NT处终止。
chap2_para1109,6,,现在，问题是，回溯到哪儿？
chap2_para1109,7,,回跳是不可行的，因为NT确实存在与前面赋值过的变量一致的值——NT没有导致失败的前面变量的完整冲突集。
chap2_para1109,8,,然而，我们知道，NT、Q、V和SA这4个变量放在一起会失败，是因为前面的一组变量一定与这4个变量有直接冲突。
chap2_para111,1,if car-in-front-is-braking then initiate-braking.,即使在更复杂的环境中，也会出现简单的反射行为。
chap2_para111,2,,想象自己是自动驾驶出租车司机。
chap2_para111,3,,如果前面的汽车刹车并且刹车灯亮起，那么你应该注意到这一点并开始刹车。
chap2_para111,4,,换句话说，你通过对视觉输入进行一些处理来建立我们称之为“前面的汽车正在刹车”的条件。
chap2_para111,5,,然后，这会触发智能体程序中的既定联结，对应动作“启动刹车”。
chap2_para111,6,,我们称这样的联结为条件-动作规则（condition-action rule）[6]，写作：
chap2_para1110,1,,这引出了（对于NT这样的变量的）一种不同的、更深层次的冲突集概念：正是前面一组变量共同导致了NT连同任何后续变量都不存在一致解。
chap2_para1110,2,,在本例中，该集合是WA和NSW，所以算法应该跳过塔斯马尼亚州回溯到NSW。
chap2_para1110,3,,使用以这种方式定义的冲突集的回跳算法称为冲突导向回跳（conflict-directed backjumping）。
chap2_para1111,1,,现在我们必须解释如何计算这些新的冲突集。
chap2_para1111,2,,方法其实很简单。
chap2_para1111,3,,搜索分支的“终端”失败总是因为某个变量的域变为空集，该变量对应一个标准冲突集。
chap2_para1111,4,,在我们的例子中，SA失败，它的冲突集是（例如）。
chap2_para1111,5,,我们回溯到Q，Q将SA的冲突集（当然要减去Q本身）吸收到它自己的直接冲突集，新的冲突集是。
chap2_para1111,6,,也就是说，给定前面对的赋值，从Q向前是没有解的。
chap2_para1111,7,,因此，我们回溯到最近的变量NT。
chap2_para1111,8,,NT将吸收到它自己的直接冲突集中，得到（如上一段所述）。
chap2_para1111,9,,现在算法回跳到NSW，这正是我们所希望的。
chap2_para1111,10,,总结一下：设Xj表示当前变量，conf(Xj)表示它的冲突集。
chap2_para1111,11,,如果Xj的每个可能值都失败了，则回跳到conf(Xj)中最近的变量Xi，并使用下列公式重新计算Xi的冲突集：
chap2_para1112,1,,6.3.4　约束学习
chap2_para1113,1,,当我们遇到矛盾时，回跳可以告诉我们要退回多远，这样我们就不会浪费时间去改变那些无法求解问题的变量。
chap2_para1113,2,,但我们也希望不要再遇到同样的问题。
chap2_para1113,3,,当搜索得出一个矛盾时，我们知道这是冲突集的某个子集引起的。
chap2_para1113,4,,约束学习（constraint learning）的思想是从冲突集中找出引起问题的最小变量集。
chap2_para1113,5,,这组变量及其相应值称为无用赋值（no-good）。
chap2_para1113,6,,如果想要记录无用赋值，要么通过向CSP中添加一个新的约束禁止这种赋值组合，要么通过维护一个单独的缓存。
chap2_para1114,1,,例如，考虑图6-6最下面一行中的状态。
chap2_para1114,2,,前向检验告诉我们这个状态是一个无用赋值，因为SA不存在有效赋值。
chap2_para1114,3,,在这种特定情况下，记录该无用赋值是没有意义的，因为一旦从搜索树中剪掉了这一分支，我们再也不会遇到这种组合。
chap2_para1114,4,,但假设图6-6中的搜索树实际上是更大的搜索树的一部分，该搜索树是从V和T的赋值开始的。
chap2_para1114,5,,那么将记录为无用赋值是有意义的，因为对于V和T的每一组可能赋值，我们都会再次遇到同样的问题。
chap2_para1115,1,,前向检验或回跳可以有效地利用无用赋值。
chap2_para1115,2,,约束学习是现代CSP求解器用以提高复杂问题求解效率的最重要技术之一。
chap2_para1116,1,,6.4　CSP的局部搜索
chap2_para1117,1,,局部搜索算法（见4.1节）对于许多CSP的求解都非常有效。
chap2_para1117,2,,它们使用完整状态形式（见4.1.1节），即每一状态为所有变量赋值，搜索一次改变一个变量的值。
chap2_para1117,3,,例如，考虑6.1.3节中定义为CSP的8皇后问题。
chap2_para1117,4,,在图6-8中，我们从左边开始，对8个变量进行了完整赋值，通常该赋值会违反一些约束。
chap2_para1117,5,,然后我们随机选择一个发生冲突的变量，在此是最右边一列的Q8。
chap2_para1117,6,,我们希望改变它的值，从而更接近问题的解。
chap2_para1117,7,,最明显的方法是选择与其他变量冲突数最少的值——最少冲突（min-conflict）启发式算法。
chap2_para1118,1,,图6-8　使用最少冲突法求解8皇后问题的示例。
chap2_para1118,2,,每步选择一个皇后，在其所在列重新分配位置。
chap2_para1118,3,,每个方格标有冲突数（在本例中是互相攻击的皇后个数）。
chap2_para1118,4,,算法随机选择发生冲突的皇后，将皇后移动到冲突最少的方格
chap2_para1119,1,,在图6-8中，我们看到有两行都只违反了一个约束，我们选择让Q8 = 3（也就是说，我们将皇后移动到第8列、第3行）。
chap2_para1119,2,,下一次迭代，在图6-8的中间棋盘上，我们选择Q6作为要改变的变量，然后发现将该皇后移动到第8行不会发生冲突。
chap2_para1119,3,,此时不再有发生冲突的变量，所以我们找到了一个解。
chap2_para1119,4,,最少冲突算法如图6-9所示。
chap2_para1119,5,,[4]
chap2_para112,1,"Humans also have many such connections, some of which are learned responses (as for driving) and some of which are innate reflexes (such as blinking when something approaches the eye).",
chap2_para112,2,"In the course of the book, we show several different ways in which such connections can be learned and implemented.",
chap2_para1121,1,,[4]　局部搜索可以很容易地扩展到约束优化问题（COP）。
chap2_para1121,2,,在这种情况下，爬山法和模拟退火的所有技术都可以用于优化目标函数。
chap2_para1122,1,,图6-9　CSP的Min-Conflicts局部搜索算法。
chap2_para1122,2,,初始状态可以随机选择，也可以通过基于贪心法的赋值过程依次为每个变量选择最少冲突值。
chap2_para1122,3,,在给定当前赋值的其余部分后，Conflicts函数统计特定值违反约束的数量
chap2_para1123,1,,对许多CSP来说，最少冲突法都相当有效。
chap2_para1123,2,,神奇的是，在n皇后问题上，如果不计入皇后的初始布局，最少冲突法的运行时间基本上与问题规模无关。
chap2_para1123,3,,它甚至可以在（初始赋值后）平均50步内求解百万皇后问题。
chap2_para1123,4,,这一不同寻常的现象是20世纪90年代大量研究局部搜索和难易问题间区别的动力，我们将在7.6.3节中讨论这些问题。
chap2_para1123,5,,粗略地说，用局部搜索求解n皇后问题非常简单，因为解密集地分布在整个状态空间上。
chap2_para1123,6,,最少冲突法也适用于困难问题。
chap2_para1123,7,,例如，它已经被用于哈勃太空望远镜的观测调度，安排一周的观测调度所花费的时间可以从3周减少到大约10分钟。
chap2_para1124,1,,4.1节中的所有局部搜索技术都可以应用于CSP，有些技术已被证实相当有效。
chap2_para1124,2,,最少冲突启发式算法下的CSP地形图通常存在一系列平台区。
chap2_para1124,3,,可能有数百万个变量赋值都只存在一个冲突。
chap2_para1124,4,,平台区搜索——允许横向移动到另一个得分相同的状态——可以帮助局部搜索走出平台区。
chap2_para1124,5,,这种在平台区的漫游可以由一种叫作禁忌搜索的技术导引：维护一个最近访问过的状态的列表，并禁止算法返回那些状态。
chap2_para1124,6,,模拟退火也可以用于逃离平台区。
chap2_para1125,1,,另一种技术称为约束加权（constraint weighting），旨在集中搜索重要约束。
chap2_para1125,2,,每个约束都有一个数值权重，初始时都为1。
chap2_para1125,3,,在每步搜索中，算法找出使其所违反的约束的总权重最低的变量，并修改其值。
chap2_para1125,4,,然后，增加当前赋值所违反的每个约束的权重。
chap2_para1125,5,,这种做法有两个好处：它为平台区增加了地形因素，确保从当前状态进行改进是有可能的；它还引入了学习策略，随着时间推移，难以求解的约束会被分配更高的权重。
chap2_para1126,1,,局部搜索的另一个优点是，当问题发生变化时，它可以用于在线设定的问题（见4.5节）。
chap2_para1126,2,,考虑一个航空公司每周航班调度问题。
chap2_para1126,3,,它可能涉及上千趟航班和上万名人员的分配，但机场的恶劣天气可能会打乱这一调度。
chap2_para1126,4,,我们希望以最少的改动修正日程表。
chap2_para1126,5,,这可以通过从当前调度开始的局部搜索算法轻松完成。
chap2_para1126,6,,使用新约束集的回溯搜索通常要花费更多时间，而且找到的解可能要对当前调度进行很多改动。
chap2_para1128,1,,在这一节中，我们将研究如何利用由约束图表示的问题的结构来快速找到解。
chap2_para1128,2,,这里的大多数方法也适用于CSP之外的其他问题，例如概率推理。
chap2_para1129,1,,处理复杂的真实世界问题的唯一可能方法是将其分解为若干子问题。
chap2_para1129,2,,回顾澳大利亚问题的约束图（图6-1b和图6-12a），可以发现一个问题：塔斯马尼亚州和大陆不相连。
chap2_para1129,3,,[5]直观上看，对塔斯马尼亚州着色和对大陆着色显然是两个独立子问题（independent subproblem）——任何对大陆着色的解和任何对塔斯马尼亚州着色的解相结合都能得到整个地图的解。
chap2_para113,1,"The program in Figure 2.8 is specific to one particular vacuum environment. A more general and flexible approach is first to build a general-purpose interpreter for condition–action rules and then to create rule sets for specific task environments. Figure 2.9 gives the structure of this general program in schematic form, showing how the condition–action rules allow the agent to make the connection from percept to action. Do not worry if this seems trivial; it gets more interesting shortly.",[6]　也称为情境-动作规则、产生式系统或 if-then规则。
chap2_para1131,1,,[5]　细心的制图师或热爱塔斯马尼亚州的塔斯马尼亚人可能会反对将塔斯马尼亚州和离它最近的大陆邻域涂上相同的颜色，以免给人留下它可能是那个州的一部分的印象。
chap2_para1132,1,,可以简单地通过寻找约束图的连通分量（connected component）来确定独立性。
chap2_para1132,2,,每个连通分量对应一个子问题CSPi。
chap2_para1132,3,,如果赋值Si是CSPi的解，那么就是的解。
chap2_para1132,4,,为什么这很重要？
chap2_para1132,5,,假设每个CSPi具有所有n个变量中的c个变量，其中c是一个常数。
chap2_para1132,6,,那么共有n/c个子问题，求解每个子问题最多需要d c工作量，其中d是域的大小。
chap2_para1132,7,,因此，总的工作量为O(dcn/c)，关于n是线性的；如果不进行问题分解，总的工作量为O(d n)，关于n是指数级的。
chap2_para1132,8,,让我们更具体地说：将一个具有100个变量的布尔CSP分解为4个子问题，那么最坏情况下的求解时间将从宇宙生命周期减少到不到1秒。
chap2_para1133,1,,完全独立的子问题很好，但很少见。
chap2_para1133,2,,幸运的是，其他一些图结构也很容易求解。
chap2_para1133,3,,例如，当任意两个变量都只由一条路径连接时，约束图是一棵树。
chap2_para1133,4,,我们将证明任何树状结构的CSP都可以在变量个数的线性时间内求解。
chap2_para1133,5,,[6]这里的关键是一种新的一致性概念——定向弧一致性（directional arc consistency）或DAC。
chap2_para1133,6,,"变量顺序为X1, X2, …, Xn的CSP称为定向弧一致的，当且仅当，时，每个Xi相对于每个Xj都是弧一致的。"
chap2_para1135,1,,[6]　遗憾的是，除了苏拉威西岛（Sulawesi）的地图比较接近树状外，世界上几乎没有一个地区是树状结构的地图。
chap2_para1136,1,,为了求解树状结构的CSP，首先选择任一变量作为树的根节点，然后选择变量顺序，每个变量必须在其父节点之后。
chap2_para1136,2,,这种排序称为拓扑排序（topological sort）。
chap2_para1136,3,,图6-10a为一棵树，图6-10b为一种可能的排序。
chap2_para1136,4,,任何有n个节点的树都有n−1条边，所以可以在O(n)步内使得该图具有定向弧一致性，每一步都必须比较两个变量的最多d个可能的值，总时间为O(nd2)。
chap2_para1136,5,,一旦我们有了一个定向弧一致的图，就可以沿着变量列表选择任意剩余值。
chap2_para1136,6,,因为从父节点到其子节点的每条边都是弧一致的，所以，对于父节点选择的任何值，子节点都存在一个可选的有效值。
chap2_para1136,7,,这意味着我们不必回溯，可以沿着变量线性移动。
chap2_para1136,8,,完整算法如图6-11所示。
chap2_para1137,1,,图6-10　（a）树状结构CSP的约束图。
chap2_para1137,2,,（b）与以A为根节点的树一致的变量的线性排序。
chap2_para1137,3,,这称为变量的拓扑排序
chap2_para1138,1,,既然我们有了关于树的高效算法，可以考虑更一般的约束图是否可以以某种方式简化为树结构。
chap2_para1138,2,,有两种方法可以做到这一点：删除节点（6.5.1节）或合并节点（6.5.2节）。
chap2_para1139,1,,图6-11　用于求解树状结构CSP的Tree-CSP-Solver算法。
chap2_para1139,2,,如果CSP有解，我们可以在线性时间内找到它；如果无解，将检测到矛盾
chap2_para114,1,"Figure 2.9 Schematic diagram of a simple reflex agent. We use rectangles to denote the current internal state of the agent’s decision process, and ovals to represent the background information used in the process.",如果前面的车正在刹车，则启动刹车。
chap2_para1140,1,,6.5.1　割集调整
chap2_para1141,1,,将约束图简化为树的第一种方法是为部分变量赋值使得剩余变量能够形成一棵树。
chap2_para1141,2,,考虑澳大利亚问题的约束图，如图6-12a所示。
chap2_para1141,3,,如果没有南澳大利亚州，这个图就会变成如图6-12b所示的一棵树。
chap2_para1141,4,,幸运的是，我们可以通过将SA固定为某个值并从其他变量的域中删除任何与SA取值不一致的值来从图中删除南澳大利亚州。
chap2_para1142,1,,图6-12　（a）图6-1中的原始约束图。
chap2_para1142,2,,（b）除去SA后，约束图变成由两棵树组成的森林
chap2_para1143,1,,现在，删除SA及其约束后，CSP的任意一个解都与SA的值一致。
chap2_para1143,2,,（这适用于二元CSP，在高阶约束下，情况会更加复杂。
chap2_para1143,3,,）因此，我们可以用上面给出的算法求解剩余的树，从而求解整个问题。
chap2_para1143,4,,当然，在一般情况下（与地图着色不同），为SA选择的值可能是错误的，因此我们需要尝试每个可能的值。
chap2_para1143,5,,一般算法如下。
chap2_para1144,1,,（1）选择CSP变量的一个子集S，使得约束图在删除S后成为一棵树。
chap2_para1144,2,,S称为环割集（cycle cutset）。
chap2_para1145,1,,（2）对于满足S上所有约束的S中变量的每种可能赋值，
chap2_para1146,1,,a. 从剩余变量的域中删除任何与S赋值不一致的值，并且
chap2_para1147,1,,b. 如果剩余的CSP存在一个解，那么将其连同S的赋值一起返回。
chap2_para1148,1,,如果环割集的大小为c，那么总运行时间为：我们需要尝试S中变量的值的所有d c种组合，对于每种组合，我们需要求解一个大小为(n −c)的树问题。
chap2_para1148,2,,如果约束图“几乎是一棵树”，那么c将会非常小，相比于直接使用回溯法，将省掉巨大的开销——对100个布尔变量的示例来说，如果我们能找到一个大小为c = 20的割集，时间开销可以从宇宙生命周期缩短到几分钟。
chap2_para1148,3,,然而，在最坏情况下，c可能高达(n −2)。
chap2_para1148,4,,寻找最小环割集问题是NP困难的，但有一些高效的近似算法。
chap2_para1148,5,,算法的总体过程称为割集调整（cutset conditioning），我们将在第13章详细讨论，在那里它将用于概率推理。
chap2_para115,1,"An agent program for Figure 2.9 is shown in Figure 2.10. The INTERPRET-INPUT function generates an abstracted description of the current state from the percept, and the RULE-MATCH function returns the first rule in the set of rules that matches the given state description. Note that the description in terms of “rules” and “matching” is purely conceptual; as noted above, actual implementations can be as simple as a collection of logic gates implementing a Boolean circuit. Alternatively, a “neural” circuit can be used, where the logic gates are replaced by the nonlinear units of artificial neural networks (see Chapter 22).",人类也有许多这样的联结，其中一些是习得反应（如驾驶），而另一些则是先天反射（如在有东西接近眼睛时眨眼）。
chap2_para115,2,,在本书中，我们展示了学习和实现这种联结的几种不同方式。
chap2_para1150,1,,将约束图简化为树的第二种方法基于构建约束图的树分解（tree decomposition）：将原始图转换为树，树中的每个节点由一组变量组成，如图6-13所示。
chap2_para1150,2,,树分解必须满足以下3个要求。
chap2_para1151,1,,● 原始问题中的每个变量必须至少出现在一个树节点中。
chap2_para1152,1,,● 如果两个变量在原始问题中由一个约束连接，那么它们必须同时出现（连同约束）在至少一个树节点中。
chap2_para1153,1,,● 如果一个变量出现在两个树节点中，那么它必须出现在连接这两个节点的路径上的所有节点中。
chap2_para1154,1,,前两个条件保证了所有变量和约束在树分解中都有表示。
chap2_para1154,2,,第三个条件似乎更具技术性，但保证了原始问题的任何变量无论在哪出现都具有相同的值：树中的约束表明一个树节点中的变量必须与其相邻节点中的相应变量具有相同的值。
chap2_para1154,3,,例如，图6-13中SA出现在相连的所有4个节点中，因此树分解中的每条边都包含一个约束，一个节点中SA的值必须与下个节点中SA的值相同。
chap2_para1154,4,,你可以从图6-12中验证这种分解是有意义的。
chap2_para1155,1,,图6-13　图6-12a中约束图的一个树分解
chap2_para1156,1,,一旦我们有了一个树状结构图，我们可以应用Tree-CSP-Solver在O(nd 2)时间内得到解，其中n是树节点的个数，d是最大域的大小。
chap2_para1156,2,,但是要注意，在树中，域是一组值元组，而不只是单个值。
chap2_para1157,1,,例如，图6-13中的左上节点表示在原始问题层级上，变量为，域为，约束为、和的子问题。
chap2_para1157,2,,"而在树的层级上，节点表示单个变量，我们可以将其称为SANTWA，它的值必须是一个由颜色组成的三元组，如(red, green, blue)，但不能是(red, red, blue)，因为违反了原始问题中的约束。"
chap2_para1157,3,,"然后我们可以从这个节点移动到相邻节点，其变量为SANTQ，此时只有一个元组(red, green, blue)与SANTWA的选择一致。"
chap2_para1157,4,,对后两个节点重复完全相同的过程，但可以独立地为T作出任何选择。
chap2_para1158,1,,使用Tree-CSP-Solver算法可以在O(nd2)时间内求解任何树分解问题，只要d保持较小值，它都是高效的。
chap2_para1158,2,,回到100个布尔变量的示例，如果每个节点有10个变量，那么d = 210，我们可以在几秒内找到解。
chap2_para1158,3,,但如果有一个节点包含30个变量，则需要几个世纪的时间。
chap2_para1159,1,,一个给定的图允许多种树分解，在选择分解时，目标是使子问题尽可能小。
chap2_para1159,2,,（将所有变量放在同一个节点中在技术上也是一棵树，但对求解问题没有帮助。
chap2_para1159,3,,）图的树分解的树宽（tree width）为最大节点的大小减1，图本身的树宽定义为其所有树分解的最小宽度。
chap2_para1159,4,,如果一个图的树宽为w，那么给定相应的树分解，该问题可以在O(ndw+1)时间内求解。
chap2_para1159,5,,因此，如果CSP的约束图树宽有界，则该CSP在多项式时间内是可解的。
chap2_para116,1,Figure 2.,图2-8所示的程序限定于一个特定的真空吸尘器环境。
chap2_para116,2,10A simple reflex agent.,一种更通用、更灵活的方法是，首先为条件操作规则构建通用解释器，然后为特定任务环境创建规则集。
chap2_para116,3,"It acts according to a rule whose condition matches the current state, as defined by the percept.",图2-9给出了通用程序的结构示意图，展示条件-动作规则如何在智能体中建立从感知到动作的联结。
chap2_para116,4,,如果这看起来普通，不要担心，很快就会变得更加有趣。
chap2_para1160,1,,遗憾的是，找出树宽最小的分解是 一个NP困难问题，但有一些启发式方法在实践中效果很好。
chap2_para1160,2,,时间为的割集分解和时间为O(ndw+1)的树分解哪个更好？
chap2_para1160,3,,每当有一个大小为c的环割集时，也会有一个大小为的树宽，并且在某些情况下它可能要小得多。
chap2_para1160,4,,所以从时间上考虑，应该选择树分解，但环割集方法的优点是，它可以在线性内存中执行，而树分解需要关于w的指数级内存。
chap2_para1162,1,,到目前为止，我们已经讨论了约束图的结构。
chap2_para1162,2,,在变量的值中，或在约束关系本身的结构中，也可能存在重要的结构。
chap2_para1162,3,,考虑有d种颜色的地图着色问题。
chap2_para1162,4,,对于每个一致解，实际上都有一组通过排列颜色名形成的d!个解。
chap2_para1162,5,,例如，在澳大利亚地图中，我们知道WA、NT和SA肯定具有不同颜色，但实际上，将3种颜色分配给3个区域有3! = 6种方法。
chap2_para1162,6,,这称为值对称（value symmetry）。
chap2_para1162,7,,我们希望通过打破这种赋值对称性将搜索空间缩小d!倍。
chap2_para1162,8,,可以通过引入对称性破缺约束（symmetry-breaking constraint）做到这一点。
chap2_para1162,9,,对于我们的例子，可以施加一个任意的排序约束，，即要求3个值按字母顺序排列。
chap2_para1162,10,,这个约束保证了d!个解中只有一个是可能解：。
chap2_para1163,1,,对于地图着色问题，很容易找到一个消除对称性的约束。
chap2_para1163,2,,一般来说，要消除所有的对称性是NP困难的，但打破值对称已被证明在许多问题上都是重要和有效的。
chap2_para1165,1,,● 约束满足问题（CSP）的状态为一组变量/值对，解的条件为一组变量约束。
chap2_para1165,2,,许多重要的真实问题都可以用CSP描述。
chap2_para1166,1,,● 许多推断技术利用约束排除某些变量赋值。
chap2_para1166,2,,这些约束包括节点一致性、弧一致性、路径一致性和k一致性。
chap2_para1167,1,,● 回溯搜索是深度优先搜索的一种形式，通常用于求解CSP。
chap2_para1167,2,,推断可以与搜索交替进行。
chap2_para1168,1,,● 最少剩余值启发式算法和度启发式算法是领域无关的方法，用于决定在回溯搜索中下一步选择哪个变量。
chap2_para1168,2,,最少约束值启发式算法有助于决定对于给定变量首先尝试哪个值。
chap2_para1168,3,,回溯发生在某个变量找不到合法赋值时。
chap2_para1168,4,,冲突导向回跳直接回溯到问题的根源。
chap2_para1168,5,,约束学习记录在搜索过程中遇到的冲突，以免在以后的搜索中出现相同的冲突。
chap2_para1169,1,,● 使用最少冲突启发式算法的局部搜索也已成功地应用于约束满足问题。
chap2_para117,1,"Simple reflex agents have the admirable property of being simple, but they are of limited intelligence. The agent in Figure 2.10 will work only if the correct decision can be made on the basis of just the current percept—that is, only if the environment is fully observable.",图2-9　简单反射型智能体的示意图。
chap2_para117,2,,我们使用矩形表示智能体决策过程的当前内部状态，使用椭圆表示过程中使用的背景信息
chap2_para1170,1,,● CSP求解的复杂性与其约束图的结构密切相关。
chap2_para1170,2,,树状结构问题可以在线性时间内求解。
chap2_para1170,3,,割集调整可以将一般的CSP简化为树状结构的CSP，如果能找到一个较小的割集，算法会非常高效（只需线性内存）。
chap2_para1170,4,,树分解技术将CSP转化为由子问题构成的树，当约束图的树宽较小时，算法是高效的；然而，它们需要约束图树宽的指数级的内存。
chap2_para1170,5,,将割集调整和树分解相结合可以更好地权衡所需内存和时间。
chap2_para1173,1,,第三部分　知识、推理和规划
chap2_para1175,1,,在本章中，我们设计能够表示复杂世界的智能体，它使用推断过程来获取关于这个世界的新表示，并使用这种表示来推导下一步该怎么做。
chap2_para1176,1,,人类似乎具有知识，人类的知识能够帮助他们做事。
chap2_para1176,2,,在人工智能中，基于知识的智能体（knowledge-based agent）对知识的内部表示（representation）进行推理（reasoning）来确定要采取的动作。
chap2_para1177,1,,第3章和第4章的问题求解智能体具有知识，但这种知识是非常有限且死板的。
chap2_para1177,2,,它们知道可以采取哪些动作，也知道在某个状态采取某个动作将得到哪种结果，但它们不知道一般事实。
chap2_para1177,3,,例如，寻路智能体不知道一条路的长度不可能是负数公里，而8数码智能体也不知道两块瓷砖无法放置在同一个空格当中。
chap2_para1177,4,,问题求解智能体具有的知识对寻找从起点到终点的路径这种问题非常有用，但也仅限于此。
chap2_para1178,1,,问题求解智能体所使用的原子表示也有很大的局限性。
chap2_para1178,2,,例如，在部分可观测的环境中，问题求解智能体表示它对当前状态的了解的唯一选项是列出所有可能的具体状态。
chap2_para1178,3,,我可以让一个人驱车前往一个人口不超过1万的美国小镇，但如果要让问题求解智能体来做这件事，我只能明确地将目标描述为大约1.6万个符合条件的小镇的集合。
chap2_para1179,1,,第6章引入了我们的第一个因子化表示，其中状态被表示为对变量的赋值。
chap2_para1179,2,,这是朝正确方向前进的一步，它能使智能体的某些部分以与领域无关的方式运作，并支持更高效的算法。
chap2_para1179,3,,在本章中，我们将这一步延伸到它的逻辑结论，可以说，我们将逻辑扩展为一类通用的表示，以支持基于知识的智能体。
chap2_para1179,4,,这些智能体可以组合或重组信息以适应各种用途。
chap2_para1179,5,,它可以与我们当下的需要毫不相关，就像数学家证明定理或天文学家计算地球的预期寿命一样。
chap2_para1179,6,,基于知识的智能体能够接受明确描述的目标作为任务，能够通过主动学习或被告知关于环境的新知识快速地获得完成任务的能力，也能够通过更新相关知识适应环境的变化。
chap2_para118,1,"Even a little bit of unobservability can cause serious trouble. For example, the braking rule given earlier assumes that the condition car-in-front-is-braking can be determined from the current percept—a single frame of video. This works if the car in front has a centrally mounted (and hence uniquely identifiable) brake light. Unfortunately, older models have different configurations of taillights, brake lights, and turn-signal lights, and it is not always possible to tell from a single image whether the car is braking or simply has its taillights on. A simple reflex agent driving behind such a car would either brake continuously and unnecessarily, or, worse, never brake at all.",图2-9中智能体对应的智能体程序如图2-10所示。
chap2_para118,2,,Interpret-Input函数根据percept生成当前状态的抽象描述。
chap2_para118,3,,给定状态描述，Rule-Match函数返回规则集中匹配的第一条规则。
chap2_para118,4,,注意，关于“规则”和“匹配”的描述纯粹是概念性的。
chap2_para118,5,,如上所述，实际实现可以像实现布尔电路的逻辑门集合一样简单。
chap2_para118,6,,或者，也可以使用“神经”电路，其中逻辑门由人工神经网络中的非线性单元代替（见第21章）。
chap2_para1180,1,,我们在7.1节开始介绍智能体的总体设计。
chap2_para1180,2,,7.2节新引入了一个名为wumpus世界的简单环境，以便在不涉及任何技术细节的前提下，阐明基于知识的智能体的运作方式。
chap2_para1180,3,,随后我们在7.3节解释逻辑的一般原理，在7.4节介绍命题逻辑的具体细节。
chap2_para1180,4,,命题逻辑是一种因子化表示，尽管它的表达能力不如一阶逻辑（第8章）这种标准的结构化表示，但却能够阐明逻辑的所有基本概念。
chap2_para1180,5,,命题逻辑还具有丰富的推断方法，我们将在7.5节和7.6节中描述这些内容。
chap2_para1180,6,,最后，7.7节将基于知识的智能体的概念与命题逻辑的技术结合起来，为wumpus世界构建了一个简单的智能体。
chap2_para1181,1,,7.1　基于知识的智能体
chap2_para1182,1,,基于知识的智能体的核心部件是它的知识库（knowledge base，KB）。
chap2_para1182,2,,知识库是一个语句集。
chap2_para1182,3,,（此处“语句”是一个术语。
chap2_para1182,4,,它与英语或其他自然语言的语句类似，但不完全相同。
chap2_para1182,5,,）这些语句用知识表示语言（knowledge representation language）表达，代表了关于世界的某种断言。
chap2_para1182,6,,如果一条语句是直接给出的，而不是从其他语句推导而来的，我们就称它为公理（axiom）。
chap2_para1183,1,,向知识库添加新语句以及从知识库查询已知语句的方法是必不可少的。
chap2_para1183,2,,这些操作的标准名称分别是Tell（告知）和Ask（询问）。
chap2_para1183,3,,这两个操作都可能涉及推断（inference），也就是从原有语句中推导出新语句。
chap2_para1183,4,,推断必须符合以下要求：当向知识库询问（Ask）时，答案应当遵循先前已经告知（Tell）知识库的内容而生成。
chap2_para1183,5,,我们将在本章后续部分仔细讲解何为“遵循”。
chap2_para1183,6,,现在，我们暂且将其理解为在推断过程中不能进行捏造。
chap2_para1184,1,,图7-1展示了基于知识的智能体程序。
chap2_para1184,2,,与所有的智能体一样，基于知识的智能体以一个感知作为输入，返回一个动作。
chap2_para1184,3,,该智能体维护一个知识库KB，这个知识库最初可能包括一些背景知识（background knowledge）。
chap2_para1185,1,,图7-1　通用的基于知识的智能体。
chap2_para1185,2,,给定一个感知，智能体将这一感知添加进知识库，向知识库询问最优动作，并告知知识库它已经采取了这一动作
chap2_para1186,1,,每次调用智能体程序时，程序会做3件事。
chap2_para1186,2,,首先，它告知知识库它所感知到的东西。
chap2_para1186,3,,然后，它询问知识库它应当采取什么动作。
chap2_para1186,4,,在回答这一查询时，可能会对关于世界的当前状态、可能的动作序列的执行结果等进行大量推理。
chap2_para1186,5,,最后，智能体程序告知知识库它选择的动作，并返回这一动作以便执行。
chap2_para1187,1,,表示语言的细节隐藏在3个函数中，这3个函数一方面实现了传感器与执行器之间的接口，另一方面又实现了核心表示与推理系统的接口。
chap2_para1187,2,,Make-Percept-Sentence构建了一个语句，断言智能体在给定时间接收到给定的感知。
chap2_para1187,3,,Make-Action-Query构建了一个语句，询问当前时刻应当采取何种动作。
chap2_para1187,4,,最后，Make-Action-Sentence构建了一个语句，断言选定的动作已经执行。
chap2_para1187,5,,推断机制的细节隐藏在Tell与Ask中。
chap2_para1187,6,,后续章节将阐明这些细节。
chap2_para1188,1,,图7-1所示的基于知识的智能体看起来与第2章所述的具有内部状态的智能体非常相似。
chap2_para1188,2,,而由于Tell和Ask的定义，基于知识的智能体并不仅是普通的用来计算动作的程序。
chap2_para1188,3,,它受到位于知识层面（knowledge level）的描述的操控，我们只需要在知识层面明确智能体所具有的知识和它的目标，就可以决定它的行为。
chap2_para1189,1,,例如，一辆自动驾驶出租车的任务是将一名乘客从旧金山送往马林县，它或许知道金门大桥是两地间的唯一通路。
chap2_para1189,2,,因此，我们可以猜测出租车将驶过金门大桥，因为它知道这样能达成目标。
chap2_para1189,3,,注意，这一分析与出租车在实现层面（implementation level）的工作原理毫无关系。
chap2_para1189,4,,不论它是用链表或点阵图来实现地理知识，还是通过操纵寄存器中的符号串或在神经元网络中传递有噪声的信号来进行推理，都与我们的分析无关。
chap2_para119,1,We can see a similar problem arising in the vacuum world.,图2-10　简单反射型智能体。
chap2_para119,2,Suppose that a simple reflex vacuum agent is deprived of its location sensor and has only a dirt sensor.,它根据一条规则进行操作，该规则的条件与感知定义的当前状态相匹配
chap2_para119,3,Such an agent has just two possible percepts: [Dirty] and [Clean].,
chap2_para119,4,It can Suck in response to [Dirty]; what should it do in response to [Clean]?,
chap2_para119,5,"Moving Left fails (forever) if it happens to start in square A, and moving Right fails (forever) if it happens to start in square B.",
chap2_para119,6,Infinite loops are often unavoidable for simple reflex agents operating in partially observable environments.,
chap2_para1190,1,,我们可以仅通过告知智能体必需的知识来构建基于知识的智能体。
chap2_para1190,2,,智能体设计者可以从空知识库开始，逐条告知智能体语句，直到它明白如何在它的环境中运作。
chap2_para1190,3,,我们称之为陈述性（declarative）系统构建方法。
chap2_para1190,4,,相对地，过程性（procedural）方法将所需的行为直接编码为程序代码。
chap2_para1190,5,,在20世纪70年代和80年代，两种方法的提倡者进行了激烈的辩论。
chap2_para1190,6,,我们现在明白，成功的智能体在设计中常常需要将陈述性和过程性这两种方法的元素结合起来，而陈述性的知识也往往能够被编译成更有效的过程性代码。
chap2_para1191,1,,我们还可以给基于知识的智能体赋予自主学习的机制，我们将在第19章讲解的这些机制。
chap2_para1191,2,,智能体能够利用这些机制从一系列感知中创建关于环境的一般知识。
chap2_para1191,3,,进行学习的智能体可以是完全自主的。
chap2_para1192,1,,7.2　wumpus世界
chap2_para1193,1,,本节我们将描述一个能够体现基于知识的智能体的价值的环境。
chap2_para1193,2,,wumpus世界（wumpus world）是一个洞穴，其中有许多房间，房间之间有走廊连接。
chap2_para1193,3,,在洞穴的某处潜伏着可怕的wumpus，这是一只会吃掉任何进入其房间的人的怪兽。
chap2_para1193,4,,智能体可以射杀wumpus，但智能体只有一支箭。
chap2_para1193,5,,一些房间有无底洞，能困住任何漫游到这些房间中的人（wumpus除外，它体型大得无法落入无底洞）。
chap2_para1193,6,,这个阴森环境的唯一回报是可能找到的金块。
chap2_para1193,7,,尽管以现代电子游戏的眼光来看，wumpus世界相当乏味，但它却能展示出智能的一些重要属性。
chap2_para1194,1,,图7-2展示了一个简单的wumpus世界示例。
chap2_para1194,2,,任务环境的精确定义用2.3节所述的PEAS描述法给出。
chap2_para1195,1,,图7-2　一个典型的wumpus世界。
chap2_para1195,2,,智能体位于左下角，面朝东（向右）
chap2_para1196,1,,● 性能度量：带着金块从洞穴爬出+1000，跌入无底洞或被wumpus吞食−1000，每采取一个动作−1，用尽箭支−10。
chap2_para1196,2,,如果智能体死亡或爬出洞穴，游戏结束。
chap2_para1197,1,,● 环境：一个4×4的房间网格，网格四周环绕着围墙。
chap2_para1197,2,,"智能体始终从标为[1, 1]的方格开始，面向东方。"
chap2_para1197,3,,金块和wumpus的位置是根据均匀分布从除了起始方格的所有方格中随机选定的。
chap2_para1197,4,,另外，除起始方格外的每个方格都可能是无底洞，出现的概率为0.2。
chap2_para1198,1,,● 执行器：智能体可以向前（Forward）、左转（TurnLeft）90°和右转（TurnRight）90°。
chap2_para1198,2,,如果智能体进入有活着的wumpus或者有无底洞的方格，它将悲惨地死去。
chap2_para1198,3,,（但进入有死掉的wumpus的方格是安全的，尽管气味会很臭。
chap2_para1198,4,,）如果智能体试图前进并撞到墙，则智能体会原地不动。
chap2_para1198,5,,如果智能体与金块在同一个方格，抓取（Grab）动作可以用于捡起金块。
chap2_para1198,6,,射击（Shoot）动作可以用于向智能体面对的方向笔直地发射一支箭，这支箭会一直飞行，直到它命中wumpus（此时wumpus将被杀死）或击中墙壁。
chap2_para1198,7,,智能体只有一支箭，因此只有第一次射击动作有效。
chap2_para1198,8,,"最后，攀爬（Climb）动作可以用于爬出洞穴，但智能体仅能从方格[1, 1]爬出。"
chap2_para1199,1,,● 传感器：该智能体有5个传感器，每个传感器给出一个单一信息。
chap2_para12,1,"Description A robotic vacuum-cleaning agent and dirt are shown in block ""A"".",
chap2_para12,2,Dirt is shown in block B.,
chap2_para120,1,Escape from infinite loops is possible if the agent can randomize its actions.,简单反射型智能体具有值得赞扬的简单特性，但它们的智能有限。
chap2_para120,2,"For example, if the vacuum agent perceives [Clean], it might flip a coin to choose between Right and Left.",图2-10中的智能体只有在当前感知的基础上才能做出正确的决策，也就是说，只有在环境完全可观测的情况下才可行。
chap2_para120,3,It is easy to show that the agent will reach the other square in an average of two steps.,
chap2_para120,4,"Then, if that square is dirty, the agent will clean it and the task will be complete.",
chap2_para120,5,"Hence, a randomized simple reflex agent might outperform a deterministic simple reflex agent.",
chap2_para1200,1,,❏ 在与wumpus直接（非对角）相邻的方格中，智能体会感知到臭味（Stench）。
chap2_para1200,2,,[1]
chap2_para1202,1,,[1]　wumpus所在的方格恐怕也有臭味，但任何进入该方格的智能体在能够进行感知前就会被吞食。
chap2_para1203,1,,❏ 在与无底洞直接相邻的方格中，智能体会感知到微风（Breeze）。
chap2_para1204,1,,❏ 在金块所在的方格中，智能体会感知到闪光（Glitter）。
chap2_para1205,1,,❏ 智能体走向墙壁会感知到碰撞（Bump）。
chap2_para1206,1,,❏ 如果wumpus被杀死，它将发出惨叫（Scream），智能体可以在洞穴的任意位置感知到。
chap2_para1207,1,,感知将以由5个符号组成的列表的形式传给智能体程序。
chap2_para1207,2,,"例如，如果有臭味和微风，但没有闪光、碰撞和惨叫，智能体程序将收到[Stench, Breeze, None, None, None]。"
chap2_para1208,1,,我们可以在第2章所述的多个维度上描述wumpus环境。
chap2_para1208,2,,显然，它是确定性的、离散的、静态的且单智能体的。
chap2_para1208,3,,（好在wumpus不移动。
chap2_para1208,4,,）它是序贯的，因为只有采取很多动作后才可能得到奖励。
chap2_para1208,5,,它是部分可观测的，因为状态的一些方面是无法直接感知到的，如智能体的位置、wumpus的健康状况以及是否还有箭支可用。
chap2_para1208,6,,对于无底洞和wumpus的位置，我们可以将其看作状态中没有观测到的部分，在这种情况下，环境的转移模型是完全已知的，找出无底洞和wumpus的位置就能补全智能体对状态的知识；抑或，我们也可以说转移模型本身是未知的，因为智能体不知道哪些向前动作是致命的，在这种情况下，找出无底洞和wumpus的位置能够补全智能体对于转移模型的知识。
chap2_para1209,1,,对于环境中的智能体，主要的挑战是它起初并不知道环境的配置。
chap2_para1209,2,,克服这种无知似乎需要逻辑推理。
chap2_para1209,3,,在wumpus世界的大多数情况中，智能体是有可能安全地拾取金块的。
chap2_para1209,4,,但智能体偶尔也需要在空手而归和冒死寻宝之间做出选择。
chap2_para1209,5,,大约21%的环境是极不公平的，因为这时金块位于无底洞中，或被无底洞包围。
chap2_para121,1,We mentioned in Section 2.,即使是轻微的不可观测性也会造成严重的问题。
chap2_para121,2,3 that randomized behavior of the right kind can be rational in some multiagent environments.,例如，前面给出的刹车规则假设前车正在刹车的条件可以通过当前的感知（视频的单帧）确定。
chap2_para121,3,"In single-agent environments, randomization is usually not rational.",如果前车有一个安装在中间的（因此是唯一可识别的）刹车灯，这是可行的。
chap2_para121,4,"It is a useful trick that helps a simple reflex agent in some situations, but in most cases we can do much better with more sophisticated deterministic agents.",但是，旧款车型的尾灯、刹车灯和转向灯的配置各不相同，而且从单幅图像中分辨出汽车是在刹车还是仅仅打开了尾灯不是总能做到的。
chap2_para121,5,,一个简单反射型智能体在这样一辆车后面行驶，要么会连续不必要地刹车，或者更糟的是根本就不刹车。
chap2_para1210,1,,我们来看一个基于知识的智能体是如何探索图7-2所示的wumpus世界的环境的。
chap2_para1210,2,,此处使用一种非形式化的知识表示语言，在网格中写下符号来表示（如图7-3和图7-4所示）。
chap2_para1211,1,,图7-3　智能体在wumpus世界迈出的第一步。
chap2_para1211,2,,"（a）在感知到[None, None, None, None, None]后的初始状态。"
chap2_para1211,3,,"（b）在移动到[2, 1]后感知到[None, Breeze, None, None, None]"
chap2_para1212,1,,智能体的初始知识库包括前述的环境规则。
chap2_para1212,2,,"具体来说，智能体知道自己位于[1, 1]且[1, 1]是安全的方格。"
chap2_para1212,3,,"我们在方格[1, 1]中用“A”和“OK”分别进行表示。"
chap2_para1213,1,,"第一个感知是[None, None, None, None, None]，据此智能体可以认定它的相邻方格[1, 2]和[2, 1]是安全的——它们是“OK”的。"
chap2_para1213,2,,图7-3a展示了此时智能体的知识状态。
chap2_para1214,1,,图7-4　智能体运作时的两个后续状态。
chap2_para1214,2,,"（a）回到[1, 1]再移动到[1, 2]后，感知到[Stench, None, None, None, None]。"
chap2_para1214,3,,"（b）来到[2, 2]再移动到[2, 3]，感知到[Stench, Breeze, Glitter, None, None]"
chap2_para1215,1,,一个谨慎的智能体只会移动到它所知的OK方格。
chap2_para1215,2,,"我们假设智能体决定前进到[2, 1]。"
chap2_para1215,3,,"这个智能体在[2, 1]感受到微风（用“B”表示），因此在相邻方格中必然存在无底洞。"
chap2_para1215,4,,"根据游戏规则，无底洞不可能在[1, 1]，因此[2, 2]和[3, 1]其中之一必然有无底洞或二者都有。"
chap2_para1215,5,,图7-3b中的记号“P?”表示这些方格中可能存在无底洞。
chap2_para1215,6,,此时，仅有一个已知的且未访问过的“OK”方格。
chap2_para1215,7,,"因此这个心思缜密的智能体将扭头，回到[1, 1]，然后移步[1, 2]。"
chap2_para1216,1,,"智能体在[1, 2]感知到臭味，导致知识状态变为图7-4a所示的状况。"
chap2_para1216,2,,"[1, 2]有臭味表明附近肯定有wumpus。"
chap2_para1216,3,,"但根据游戏规则wumpus不可能在[1, 1]，也不在[2, 2]（否则智能体先前在[2, 1]时会探测到臭味）。"
chap2_para1216,4,,"因此，智能体可以推断出wumpus在[1, 3]。"
chap2_para1216,5,,记号“W!”表示这一推断。
chap2_para1216,6,,"而[1, 2]没有微风表明[2, 2]没有无底洞。"
chap2_para1216,7,,"考虑到智能体先前已经推断出[2, 2]或[3, 1]中必然有无底洞，因此无底洞必然位于[3, 1]。"
chap2_para1216,8,,这是一次相当复杂的推断，因为它结合了在不同时间、不同地点获取的信息，并在缺乏感知的情况下迈出了关键的一步。
chap2_para1217,1,,"现在智能体已经证明了[2, 2]中既没有无底洞也没有wumpus，因此可以移动到那里。"
chap2_para1217,2,,"我们没有展示智能体在[2, 2]的知识状态，姑且假设智能体转向并移动到[2,3]，形成了图7-4b所示的情况。"
chap2_para1217,3,,"在[2, 3]中，智能体探测到闪光，因此它应该抓取金块然后回家。"
chap2_para1218,1,,注意，在智能体从可用信息中得出结论的每个情形下，如果可用信息是正确的，则可以保证结论都是正确的。
chap2_para1218,2,,这是逻辑推理的一个重要性质。
chap2_para1218,3,,本章剩余部分将描述如何构建能够表示信息并得出类似前述的结论的逻辑智能体。
chap2_para122,1,2.,我们在真空吸尘器世界中也可以看到类似的问题。
chap2_para122,2,4.,假设一个简单的真空吸尘器反射型智能体没有位置传感器，只有一个灰尘传感器。
chap2_para122,3,3Model-based reflex agents,这样的智能体只有两种可能的感知：[Dirty]和[Clean]。
chap2_para122,4,,它可以用吸尘（Suck）来响应[Dirty]，它该如何响应[Clean]呢？
chap2_para122,5,,如果碰巧从方格A开始，向左（Left）移动会（永远）失败，如果从方格B开始，向右（Right）移动会（永远）失败。
chap2_para122,6,,对在部分可观测环境中工作的简单反射型智能体而言，无限循环通常是不可避免的。
chap2_para1220,1,,本节综述逻辑表示和推理的基本概念。
chap2_para1220,2,,这些漂亮的想法独立于逻辑的具体形式。
chap2_para1220,3,,因此，我们将形式的技术细节推后到7.4节介绍，本节代之以熟悉的普通算术问题作为示例。
chap2_para1221,1,,在7.1节，我们说过知识库由语句组成。
chap2_para1221,2,,这些语句是根据表示语言的语法（syntax）表达的，语法规定了所有的合规语句。
chap2_para1221,3,,用简单的算术就能清晰地说明语法这个概念：“x + y = 4”是合规的语句，而“x4y+=”不是。
chap2_para1222,1,,一种逻辑还必须定义语句的语义，或者说语句的含义。
chap2_para1222,2,,语义定义每条语句在每个可能世界中的真值。
chap2_para1222,3,,例如，算术的语义指明“x + y = 4”在一个x为2且y为2的世界为真，但在一个x为1且y为1的世界中为假。
chap2_para1222,4,,在标准的逻辑学中，每个可能世界中的每条语句要么为真，要么为假——没有中间地带。
chap2_para1222,5,,[2]
chap2_para1224,1,,[2]　第13章讨论的模糊逻辑（fuzzy logic）允许存在不同程度的真值。
chap2_para1225,1,,当需要精确描述时，我们用模型来代替“可能世界”。
chap2_para1225,2,,可能世界可以被认为是（潜在的）真实环境，智能体可能在也可能不在其中，而模型是数学抽象，对于每个相关的语句，每个模型都有固定的真值（真或假）。
chap2_para1225,3,,非正式地举个例子：我们可以认为一个可能世界是让x个男士和y个女士坐在一张桌子边上玩桥牌，如果总共有4个人，则语句x+y=4为真。
chap2_para1225,4,,正式地说，可能的模型是对变量x和y进行非负整数赋值的所有可能。
chap2_para1225,5,,每个这样的赋值都确定了任何一个变量为x和y的算术语句的真值。
chap2_para1225,6,,如果语句在模型m中为真，我们说m满足，有时也可以说m是的一个模型。
chap2_para1225,7,,我们使用记号来代表的所有模型的集合。
chap2_para1226,1,,有了真值的概念，我们就可以讨论逻辑推理了。
chap2_para1226,2,,这涉及语句之间的逻辑蕴含（entailment），即一个语句逻辑上引发另一语句。
chap2_para1226,3,,数学上，我们用
chap2_para1227,1,,来表示语句蕴含语句。
chap2_para1227,2,,蕴含的形式化定义是：当且仅当在为真的每个模型中也为真。
chap2_para1227,3,,用刚才介绍的记法，我们可以将其写作
chap2_para1229,1,,（注意此处⊆的方向：若，则是比更强的断言，它排除了更多的可能世界。
chap2_para1229,2,,）蕴含关系用算术来说明会更为亲切一些：我们很容易理解语句x=0蕴含语句xy=0。
chap2_para1229,3,,显然，在任一x为0的模型中，xy也必然为0（而无论y的值是多少）。
chap2_para123,1,"The most effective way to handle partial observability is for the agent to keep track of the part of the world it can’t see now. That is, the agent should maintain some sort of internal state that depends on the percept history and thereby reflects at least some of the unobserved aspects of the current state. For the braking problem, the internal state is not too extensive—just the previous frame from the camera, allowing the agent to detect when two red lights at the edge of the vehicle go on or off simultaneously. For other driving tasks such as changing lanes, the agent needs to keep track of where the other cars are if it can’t see them all at once. And for any driving to be possible at all, the agent needs to keep track of where its keys are.",如果智能体可以随机化（randomize）其操作，则可以跳出无限循环。
chap2_para123,2,,例如，如果真空吸尘器智能体感知到[Clean]，它可能会通过抛硬币来选择左右。
chap2_para123,3,,我们很容易就能证明智能体将平均通过两步到达另一个方格。
chap2_para123,4,,如果方格是脏的，智能体将清理它，任务就会完成。
chap2_para123,5,,因此，随机化的简单反射型智能体可能优于确定性的简单反射型智能体。
chap2_para1230,1,,我们可以将同样的分析应用于7.2节所述的wumpus世界推理的例子。
chap2_para1230,2,,"考虑图7-3b所示的情形：智能体在[1, 1]中什么都没有探测到，在[2, 1]中探测到微风。"
chap2_para1230,3,,这些感知与智能体所具有的wumpus世界规则的知识一同构成了知识库。
chap2_para1230,4,,"智能体所感兴趣的是相邻的方格[1, 2]、[2, 2]和[3, 1]是否有无底洞。"
chap2_para1230,5,,这3个方格中的每一个都可能有或没有无底洞，因此（暂且忽略这个世界的其他方面），总共有23=8个可能的模型。
chap2_para1230,6,,图7-5展示了这8个模型。
chap2_para1230,7,,[3]
chap2_para1232,1,,"[3]　尽管该图用部分wumpus世界来表示模型，但模型实际上只是对类似“[1, 2]中有无底洞”这样的语句进行真或假的赋值。"
chap2_para1232,2,,从数学的角度来看，模型中并不需要有可怕的长毛wumpus。
chap2_para1233,1,,"图7-5　方格[1, 2]、[2, 2]和[3, 1]中无底洞存在性的可能的模型。"
chap2_para1233,2,,"在[1, 1]中没有观测到任何东西且在[2, 1]中观测到微风的知识库用实线表示。"
chap2_para1233,3,,"（a）虚线表示的模型（[1, 2]中没有无底洞）。"
chap2_para1233,4,,"（b）虚线表示的模型（[2, 2]中没有无底洞）"
chap2_para1234,1,,KB可以理解为一个语句的集合，或断言了所有单个语句的单个语句。
chap2_para1234,2,,在与智能体已知相矛盾的模型中，KB为假。
chap2_para1234,3,,"例如，在所有[1, 2]含有无底洞的模型中，KB都为假，因为[1, 1]中没有微风。"
chap2_para1234,4,,实际上，使KB为真的模型只有3个，这些模型在图7-5中用实线包围。
chap2_para1234,5,,我们现在考虑两个可能的结论：
chap2_para1235,1,,"=“[1, 2]中没有无底洞”　=“[2, 2]中没有无底洞”"
chap2_para1236,1,,在图7-5a和图7-5b中分别用虚线包围了和的模型。
chap2_para1236,2,,仔细观察后，我们可以得出
chap2_para1237,1,,在所有KB为真的模型中，也为真
chap2_para1238,1,,"因此，，即[1,2]中没有无底洞。"
chap2_para1238,2,,我们还可以得出
chap2_para1239,1,,在一些KB为真的模型中，为假
chap2_para124,1,"Updating this internal state information as time goes by requires two kinds of knowledge to be encoded in the agent program in some form. First, we need some information about how the world changes over time, which can be divided roughly into two parts: the effects of the agent’s actions and how the world evolves independently of the agent. For example, when the agent turns the steering wheel clockwise, the car turns to the right, and when it’s raining the car’s cameras can get wet. This knowledge about “how the world works”—whether implemented in simple Boolean circuits or in complete scientific theories—is called a transition model of the world.",我们在2.3节中提到，在某些多智能体环境中，正确的随机行为是理性的。
chap2_para124,2,,在单智能体环境中，随机化通常是不理性的。
chap2_para124,3,,在某些情况下，这是一个有用的技巧，可以帮助简单反射型智能体，但在大多数情况下，我们可以使用更复杂的确定性智能体以做得更好。
chap2_para1240,1,,"因此，KB不蕴含，即智能体无法断定[2,2]中没有无底洞。"
chap2_para1240,2,,"（也无法断定[2,2]中有无底洞。"
chap2_para1240,3,,）[4]
chap2_para1242,1,,"[4]　智能体可以计算[2,2]中有无底洞的概率，第12章将介绍如何计算。"
chap2_para1243,1,,前述的例子不仅阐明了什么是蕴含，还展示了如何用蕴含的定义来推导出结论，即进行逻辑推断。
chap2_para1243,2,,图7-5所示的推断算法被称为模型检验，因为这个示例枚举了所有可能的模型来检验在所有KB为真的模型中都为真，即。
chap2_para1244,1,,将KB的所有推论的集合比作干草堆而将比做一根针或许有助于理解蕴含和推断。
chap2_para1244,2,,蕴含正如草堆中的针一样，而推断就像找到这根针的过程。
chap2_para1244,3,,一些形式化记法体现了这种区别：如果一个推断算法i可以从KB中推导出，则记为
chap2_para1245,1,,读作“是由i从KB中推得的”或“i从KB推得”。
chap2_para1246,1,,一个仅推导蕴含语句的推断算法被称为是可靠的或保真的。
chap2_para1246,2,,可靠性是极为重要的属性。
chap2_para1246,3,,一个不可靠的推断过程在运作时本质上会编造事实——它会声称发现了并不存在的针。
chap2_para1246,4,,我们很容易看出，模型检验在适用时[5]是一个可靠的程序。
chap2_para1248,1,,[5]　如果模型空间是有限的，则模型检验是有效的，例如，在固定大小的wumpus世界中。
chap2_para1248,2,,而对算术来说，模型空间是无限的：即使我们局限于整数范围，语句x+y=4中x和y的值也是有无限多对的。
chap2_para1249,1,,完备性也是很重要的属性：如果一个推断算法能够推导出所有蕴含的语句，则它是完备的。
chap2_para1249,2,,真正的草堆大小是有限的，对其进行全面仔细的检查就一定能确定针在不在草堆里，这似乎是很显然的道理。
chap2_para1249,3,,然而，对许多知识库来说，推论的草堆是无限的，因而完备性就成了一个重大问题。
chap2_para1249,4,,[6]幸运的是，逻辑学中有完备的推断过程，其表达能力足以处理许多知识库。
chap2_para125,1,"Second, we need some information about how the state of the world is reflected in the agent’s percepts. For example, when the car in front initiates braking, one or more illuminated red regions appear in the forward-facing camera image, and, when the camera gets wet, droplet-shaped objects appear in the image partially obscuring the road. This kind of knowledge is called a sensor model.",2.4.3　基于模型的反射型智能体
chap2_para1251,1,,[6]　比如说，在第3章的无限搜索空间的情形中，深度优先搜索就是不完备的。
chap2_para1252,1,,我们已经描述了一个推理过程，在前提为真的任何世界中都保证结论为真。
chap2_para1252,2,,具体来说，如果KB在真实世界中为真，则用可靠的推断过程从KB中推出的所有语句在真实世界中也为真。
chap2_para1252,3,,因此，当推断过程在“语法”（例如，寄存器中的位或大脑中的电信号模式这样的内部物理结构）上进行操作时，这个过程对应于一个真实世界的关系，即真实世界的某个部分为真是因为真实世界的其他一些部分为真。
chap2_para1252,4,,[7]这种世界与表示的对应如图7-6所示。
chap2_para1254,1,,"[7]　正如路德维希•维特根斯坦（Ludwig Wittgenstein）在其著名的《逻辑哲学论》（Tractatus）（Wittgenstein, 1922）中所述：“世界就是所有为真的一切。"
chap2_para1254,2,,”
chap2_para1255,1,,最后要考虑的问题是落地，也就是逻辑推理过程与智能体所存在的真实环境的联系。
chap2_para1255,2,,尤其是，我们如何知道KB在真实世界中为真？
chap2_para1255,3,,（毕竟KB只是存在于智能体头脑中的“语法”。
chap2_para1255,4,,）这是一个哲学问题，众多的书籍都对此进行了讨论（见第27章）。
chap2_para1255,5,,一个简单的回答是，智能体的传感器创建了这个联系。
chap2_para1255,6,,例如，我们的wumpus世界智能体有嗅觉传感器。
chap2_para1255,7,,一旦有气味，智能体程序就会创建一条合适的语句。
chap2_para1255,8,,因此，一旦这条语句被包含在知识库中，就意味着它在真实世界中也为真。
chap2_para1255,9,,这样，感知语句的含义和真值就是由产生这些语句的感知过程和语句构建过程定义的。
chap2_para1255,10,,那么智能体知识的其他部分呢？
chap2_para1255,11,,例如，它对于“wumpus相邻的方格有臭味”这件事的信念呢？
chap2_para1255,12,,这不是单个感知的直接表示，而是一项一般规则，它可能是从感知的经验推导出的，却与经验陈述并不完全相同。
chap2_para1255,13,,这种一般规则是通过被称为学习的语句构建过程产生的，这是第五部分的主题。
chap2_para1255,14,,学习是难免会出错的。
chap2_para1255,15,,一种可能的情况是，wumpus有臭味但闰年2月29日这一天除外，因为这一天它要洗澡。
chap2_para1255,16,,因此，KB在真实世界中可能并不为真，但因为有很好的学习过程，我们对此就有理由乐观。
chap2_para1256,1,,图7-6　语句是智能体的物理结构，而推理是从旧结构构建新结构的过程。
chap2_para1256,2,,逻辑推理应当确保新结构所表示的部分世界确实能够从旧结构所表示的部分世界推得
chap2_para1257,1,,7.4　命题逻辑：一种非常简单的逻辑
chap2_para1258,1,,本节讲解命题逻辑（propositional logic）。
chap2_para1258,2,,我们将阐述其语法（即语句的结构）和语义（确定语句真值的方法）。
chap2_para1258,3,,由此，我们将推导出一个简单的、语法的逻辑推断算法，它能够实现蕴含的语义概念。
chap2_para1258,4,,当然，这一切都仍将发生在wumpus世界中。
chap2_para126,1,"Together, the transition model and sensor model allow an agent to keep track of the state of the world—to the extent possible given the limitations of the agent’s sensors. An agent that uses such models is called a model-based agent.",处理部分可观测性的最有效方法是让智能体追踪它现在观测不到的部分世界。
chap2_para126,2,,也就是说，智能体应该维护某种依赖于感知历史的内部状态（internal state），从而至少反映当前状态的一些未观测到的方面。
chap2_para126,3,,对于刹车问题，内部状态范围不仅限于摄像头拍摄图像的前一帧，要让智能体能够检测车辆边缘的两个红灯何时同时亮起或熄灭。
chap2_para126,4,,对于其他驾驶任务，如变道，如果智能体无法同时看到其他车辆，则需要追踪它们的位置。
chap2_para126,5,,为了在任何时候都能驾驶，智能体需要追踪其钥匙的位置。
chap2_para1260,1,,命题逻辑的语法定义合法的语句。
chap2_para1260,2,,原子语句（atomic sentence）由单个命题符号（proposition symbol）构成。
chap2_para1260,3,,每个这样的符号代表一个为真或假的命题。
chap2_para1260,4,,"我们使用以大写字母开头的、可能包含其他字母或下标的符号来表示，例如P、Q、R、W1,3以及FacingEast等。"
chap2_para1260,5,,"我们可以任意地进行命名，但通常选择一些有助记功能的名字，例如，使用W1,3代表“wumpus位于[1, 3]”。"
chap2_para1260,6,,"请记住，像W1,3这样的符号是原子的，也就是说分开的W、1、3并非符号的有意义的部分。"
chap2_para1260,7,,）有两个命题符号有固定的含义：True是永真命题，False是永假命题。
chap2_para1260,8,,使用括号和被称作逻辑联结词（logical connective）的运算符可以将简单语句构造成复合语句（complex sentence）。
chap2_para1260,9,,常用的联结词有5个。
chap2_para1261,1,,● （非）。
chap2_para1261,2,,"类似这样的语句称为W1,3的否定。"
chap2_para1261,3,,一个文字要么是原子语句，即正文字，要么是原子语句的否定，即负文字。
chap2_para1262,1,,● ∧（与）。
chap2_para1262,2,,主要联结词是∧的语句称为合取式，例如，其各部分称为合取子句。
chap2_para1262,3,,（∧看起来像是“And”中的“A”。
chap2_para1262,4,,）
chap2_para1263,1,,● ∨（或）。
chap2_para1263,2,,"主要联结词是∨的语句称为析取式，例如，其各部分为析取子句，本例中分别为和W2,2。"
chap2_para1264,1,,● （蕴涵）。
chap2_para1264,2,,如这样的语句称为蕴涵式（implication）或条件式，其前提（premise）或前件（antecedent）是，其结论（conclusion）或后件（consequent）是。
chap2_para1264,3,,蕴涵式也被称为规则（rule）或if-then声明。
chap2_para1264,4,,有时，蕴涵符号在一些书籍中写作或。
chap2_para1265,1,,● （当且仅当）。
chap2_para1265,2,,语句是双向蕴涵式（biconditional）。
chap2_para1266,1,,图7-7给出了命题逻辑的形式文法。
chap2_para1266,2,,［附录B将会介绍巴克斯-诺尔范式（Backus-Naur form，BNF）的概念。
chap2_para1266,3,,］我们在BNF文法上附加了运算符优先级，以避免在使用多个运算符时出现歧义。
chap2_para1266,4,,“非”运算符的优先级最高，这意味着在语句中，的结合力更强，因此它等价于而不是。
chap2_para1266,5,,（这与普通算术一样：−2+4等于2而不是−6。
chap2_para1266,6,,）我们也会适时地使用圆括号和方括号来明确语句结构，以改善可读性。
chap2_para1267,1,,图7-7　命题逻辑中语句的BNF文法以及从高到低排列的运算符优先级
chap2_para1269,1,,了解了命题逻辑的语法后，我们来说明其语义。
chap2_para1269,2,,语义定义了用于判定特定模型中语句真值的规则。
chap2_para1269,3,,命题逻辑中，模型就是对每个命题符号设定真值，即真（true）或假（false）。
chap2_para1269,4,,"例如，如果知识库中的语句使用了命题符号P1,2、P2,2和P3,1，则一个可能模型为"
chap2_para127,1,"Figure 2.11 gives the structure of the model-based reflex agent with internal state, showing how the current percept is combined with the old internal state to generate the updated description of the current state, based on the agent’s model of how the world works. The agent program is shown in Figure 2.12. The interesting part is the function UPDATE-STATE, which is responsible for creating the new internal state description. The details of how models and states are represented vary widely depending on the type of environment and the particular technology used in the agent design.",随着时间的推移，更新这些内部状态信息需要在智能体程序中以某种形式编码两种知识。
chap2_para127,2,,首先，需要一些关于世界如何随时间变化的信息，这些信息大致可以分为两部分：智能体行为的影响和世界如何独立于智能体而发展。
chap2_para127,3,,例如，当智能体顺时针转动方向盘时，汽车就会向右转；而下雨时，汽车的摄像头就会被淋湿。
chap2_para127,4,,这种关于“世界如何运转”的知识（无论是在简单的布尔电路中还是在完整的科学理论中实现）被称为世界的转移模型（transition model）。
chap2_para1270,1,,由于含有3个命题符号，因此有23=8种可能的模型，与图7-5所示的完全相同。
chap2_para1270,2,,但要注意，这些模型是纯粹的数学对象，不必与wumpus世界有关。
chap2_para1270,3,,"P1,2只是符号，它可能代表“[1, 2]中有无底洞”，也可能代表“我今天和明天都在巴黎”。"
chap2_para1271,1,,命题逻辑的语义必须指定在给定模型下如何计算任一语句的真值。
chap2_para1271,2,,这是以递归的方式实现的。
chap2_para1271,3,,所有语句都是由原子语句和5个联结词构建的。
chap2_para1271,4,,因此，我们需要指定如何计算原子语句的真值和用5个联结词构建的语句的真值。
chap2_para1271,5,,对原子语句来说这很简单。
chap2_para1272,1,,● true在每个模型里都为真，false在每个模型里都为假。
chap2_para1273,1,,● 其余命题符号的真值必须在模型中直接指定。
chap2_para1273,2,,"例如，在先前给出的模型m1中，P1,2为假。"
chap2_para1274,1,,对于复合语句，有5条规则，它们对任一模型m中的任一子句P和Q（原子语句或复合语句）都成立。
chap2_para1275,1,,● 为真，当且仅当在m中P为假。
chap2_para1276,1,,● 为真，当且仅当在m中P和Q都为真。
chap2_para1277,1,,● 为真，当且仅当在m中P或Q中至少一个为真。
chap2_para1278,1,,● 为真，除非在m中P为真而Q为假。
chap2_para1279,1,,● 为真，当且仅当在m中P和Q都为真或都为假。
chap2_para128,1,Figure 2.,其次，我们需要一些关于世界状态如何反映在智能体感知中的信息。
chap2_para128,2,11A model-based reflex agent.,例如，当前面的汽车开始刹车时，前向摄像头的图像中会出现一个或多个亮起的红色区域；当摄像头被淋湿时，图像中会出现水滴状物体并部分遮挡道路。
chap2_para128,3,,这种知识称为传感器模型（sensor model）。
chap2_para1280,1,,这些规则也可以用真值表表示。
chap2_para1280,2,,真值表指明在对复合语句的组成部分进行每种可能的真值赋值后，该复合语句的真值。
chap2_para1280,3,,图7-8给出了5个联结词的真值表。
chap2_para1280,4,,任一语句s关于任一模型m的真值都可以用简单的递归求值来计算。
chap2_para1280,5,,例如，在模型m1中求语句的值，得到。
chap2_para1280,6,,"习题7.TRUV要求写出算法PL-True?(s, m)，用于计算命题逻辑语句s在模型m中的真值。"
chap2_para1281,1,,图7-8　5个逻辑联结词的真值表。
chap2_para1281,2,,若要使用真值表计算在P为真、Q为假时的值，首先在左边找到P为true而Q为false的行（第3行），然后找到该行位于列处的值，得到结果true
chap2_para1282,1,,“与”“或”“非”的真值表与我们对这些词的直观认识非常接近。
chap2_para1282,2,,可能会混淆的关键点是当P为真或Q为真，或者二者同时为真时，为真。
chap2_para1282,3,,而另一个联结词“排他或”（简称“异或”）则会在两个子句都为真时为假。
chap2_para1282,4,,[8]排他或没有公认的符号，有些人选择使用、或者⊕。
chap2_para1284,1,,[8]　在拉丁语中，“或”用两个词表示：“vel”是相容或，“aut”是排他或。
chap2_para1285,1,,⇒的真值表可能不太符合人们对“P蕴涵Q”或“若P则Q”的直观理解。
chap2_para1285,2,,一种解释是，命题逻辑并不要求P和Q之间有任何因果关系或相关性。
chap2_para1285,3,,（在一般的理解下）语句“5是奇数蕴涵东京是日本的首都”是命题逻辑中的真语句，尽管这句话相当奇怪。
chap2_para1285,4,,另一个容易混淆之处在于前件为假的所有蕴涵式都为真。
chap2_para1285,5,,例如，“5是偶数蕴涵Sam很聪明”为真，而不论Sam是否聪明。
chap2_para1285,6,,这似乎很怪异，但如果你将“”当作“如果P为真，则我可以断言Q为真，否则我无法断言”的话，就可以理解了。
chap2_para1285,7,,这条语句为假的唯一情形是当P为真而Q为假时。
chap2_para1286,1,,当与均为真时，双向蕴涵式为真，英语中常写作“P if and only if Q”（P当且仅当Q）。
chap2_para1286,2,,wumpus世界的大部分规则都可以用很好地表示。
chap2_para1286,3,,例如，当一个方格的相邻方格中有无底洞，该方格有微风，而且，仅当一个方格的某个相邻方格中有无底洞，该方格有微风。
chap2_para1286,4,,因此，我们需要使用双向蕴涵式
chap2_para1287,1,,"其中B1, 1代表[1, 1]有微风。"
chap2_para1288,1,,7.4.3　一个简单的知识库
chap2_para1289,1,,我们已经定义了命题逻辑的语义，现在可以为wumpus世界构建一个知识库了。
chap2_para1289,2,,首先关注wumpus世界的不变部分，后面章节再处理其可变部分。
chap2_para1289,3,,"对于每个位置[x, y]，需要用到下列符号："
chap2_para129,1,Figure 2.,转移模型和传感器模型结合在一起让智能体能够在传感器受限的情况下尽可能地跟踪世界的状态。
chap2_para129,2,12A model-based reflex agent.,使用此类模型的智能体称为基于模型的智能体（model-based agent）。
chap2_para129,3,"It keeps track of the current state of the world, using an internal model.",
chap2_para129,4,It then chooses an action in the same way as the reflex agent.,
chap2_para1290,1,,"当[x, y]有无底洞，Px, y为真。"
chap2_para1291,1,,"当wumpus在[x, y]，不论其死活Wx, y都为真。"
chap2_para1292,1,,"当[x, y]有微风，Bx, y为真。"
chap2_para1293,1,,"当[x, y]处有臭味，Sx, y为真。"
chap2_para1294,1,,"当智能体位于位置[x, y]，Lx, y为真。"
chap2_para1295,1,,"我们写下的语句将足以推得（[1, 2]中没有无底洞），正如7.3节用非形式化的方法所做的那样。"
chap2_para1295,2,,我们用Ri代表每个语句，以便推导。
chap2_para1296,1,,"● [1, 1]中没有无底洞："
chap2_para1297,1,,● 一个方格有微风，当且仅当其相邻方格中有无底洞。
chap2_para1297,2,,必须对每个方格都进行这样的表示，在此我们只写出相关方格的表示：
chap2_para1298,1,,● 上述语句在所有wumpus世界中都为真。
chap2_para1298,2,,我们现在为智能体在这个特定世界中已访问过的前两个方格引入微风感知，以形成图7-3b所示的情形：
chap2_para1299,1,,7.4.4　一个简单的推断过程
chap2_para13,1,Figure 2.,[2]　真正的机器人不太可能会有“向右移动”和“向左移动”这样的动作，而是采用“向前旋转轮子”和“向后旋转轮子”这样的动作。
chap2_para13,2,2A vacuum-cleaner world with just two locations.,我们选择的动作更易于在书本上理解，而不是为了在实际的机器人中易于实现。
chap2_para13,3,"Each location can be clean or dirty, and the agent can move left or right and can clean the square that it occupies.",
chap2_para13,4,"Different versions of the vacuum world allow for different rules about what the agent can perceive, whether its actions always succeed, and so on.",
chap2_para130,1,"Regardless of the kind of representation used, it is seldom possible for the agent to determine the current state of a partially observable environment exactly. Instead, the box labeled “what the world is like now” (Figure 2.11) represents the agent’s “best guess” (or sometimes best guesses, if the agent entertains multiple possibilities). For example, an automated taxi may not be able to see around the large truck that has stopped in front of it and can only guess about what may be causing the hold-up. Thus, uncertainty about the current state may be unavoidable, but the agent still has to make a decision.",图2-11给出了基于模型的反射型智能体的结构，它具有内部状态，展示了当前感知如何与旧的内部状态相结合，并基于世界如何运转的模型生成当前状态的更新描述。
chap2_para130,2,,智能体程序如图2-12所示。
chap2_para130,3,,有趣的部分是函数Update-State，它负责创建新的内部状态描述。
chap2_para130,4,,模型和状态的表示方式的细节因环境类型和智能体设计中使用的特定技术而异。
chap2_para1300,1,,我们现在的目标是确定对于一些语句，是否成立。
chap2_para1300,2,,例如，我们的KB是否蕴含？
chap2_para1300,3,,我们的第一个推理算法是模型检验方法，它直接实现了蕴含的定义：枚举所有模型，检验在KB为真的每个模型中是否为真。
chap2_para1300,4,,模型是对每个命题符号进行真或假的赋值。
chap2_para1300,5,,"回到例子中的wumpus世界，它涉及的命题符号是B1, 1、B2, 1、P1, 1、P1, 2、P2, 1、P2, 2和P3, 1。"
chap2_para1300,6,,在有7个符号的情况下，总共有27=128个可能的模型，KB在其中3个模型中为真（如图7-9所示）。
chap2_para1300,7,,"在这3个模型中，为真，因此[1, 2]中没有无底洞。"
chap2_para1300,8,,"但是，在3个模型中，P2, 2在其中两个模型中为真，在另一个模型中为假，因此我们还无法确定[2, 2]中是否有无底洞。"
chap2_para1301,1,,图7-9以更准确的形式再现了图7-5所示的推理。
chap2_para1301,2,,图7-10描述了一个确定命题逻辑中蕴含关系的通用算法。
chap2_para1301,3,,与6.3节所示的Backtracking-Search算法类似，TT-Entails?在符号赋值的有限空间中进行递归枚举。
chap2_para1301,4,,这个算法是可靠的，因为它直接实现了蕴含的定义；这个算法也是完备的，因为它对所有KB和都适用，并且算法最后都会终止——因为需要检验的模型数量是有限的。
chap2_para1302,1,,图7-9　根据文中所述的知识库构建的真值表。
chap2_para1302,2,,如果从R1到R5都为true，则KB为true。
chap2_para1302,3,,这种情况在全部128行中只出现了3次（在最右侧的列中用下划线标出）。
chap2_para1302,4,,"在这3行中，P1, 2均为false，因此[1, 2]中没有无底洞。"
chap2_para1302,5,,"但是，[2, 2]中可能有（也可能没有）无底洞"
chap2_para1303,1,,图7-10　用于确定命题蕴含的真值表枚举算法（TT代表真值表）。
chap2_para1303,2,,当语句在一个模型中成立，PL-True?返回true。
chap2_para1303,3,,变量model代表部分模型——对于部分符号的赋值。
chap2_para1303,4,,此处的关键字and不是命题逻辑中的运算符，而是伪代码编程语言中的中缀；如果其两个参数中的任意一个为true，则返回true
chap2_para1304,1,,当然，“有限数量”并不总是等同于“少量”。
chap2_para1304,2,,如果KB和总共含有n个符号，那么就会有2n个模型。
chap2_para1304,3,,这样，算法的时间复杂性就会达到O(2n)。
chap2_para1304,4,,（空间复杂性仅为O(n)，因为枚举是深度优先的。
chap2_para1304,5,,）在本章稍后部分，我们将展示一个在大多数情况下更高效的算法。
chap2_para1304,6,,遗憾的是，命题蕴含是余NP完全的（即很可能不比NP完全简单，见附录A），因此命题逻辑所有已知推断算法的最坏情况复杂性都是输入规模的指数量级。
chap2_para1305,1,,7.5　命题定理证明
chap2_para1306,1,,至此，我们已经展示了如何用模型检验判定蕴含关系：枚举模型，并验证语句在所有模型中必须成立。
chap2_para1306,2,,本节将展示如何通过定理证明找出蕴含关系。
chap2_para1306,3,,定理证明对知识库中的语句直接应用推断规则，它能够在不检验模型的情况下，构建对所需语句的证明。
chap2_para1306,4,,如果模型的数量很多，但其证明很短，则定理证明会比模型检验更为高效。
chap2_para1307,1,,在深入定理证明算法的细节之前，我们还需要了解一些与蕴含相关的概念。
chap2_para1307,2,,第一个概念是逻辑等价（logical equivalence）：如果两个语句和在相同的模型集合中都为真，则这两个语句逻辑等价，可以写作。
chap2_para1307,3,,（注意，用于对语句进行声明，而则用作语句的一部分。
chap2_para1307,4,,）例如，我们可以很容易地（用真值表）证明与是逻辑等价的。
chap2_para1307,5,,其他逻辑等价见图7-11。
chap2_para1307,6,,这些等价关系在逻辑中扮演的角色与算术恒等式在普通数学中的角色非常相似。
chap2_para1307,7,,等价的另一种定义为“任意两条语句和是等价的，当且仅当它们互相蕴含”：
chap2_para1309,1,,第二个概念是有效性（validity）。
chap2_para1309,2,,如果一条语句在所有模型中都为真，则这条语句是有效的。
chap2_para1309,3,,例如，语句是有效的。
chap2_para1309,4,,有效的语句也被称为重言式（tautology）——它们必然为真。
chap2_para1309,5,,由于语句True在所有模型中都为真，所有有效的语句都逻辑等价于True。
chap2_para1309,6,,有效语句有什么用？
chap2_para1309,7,,从蕴含的定义可以推导出古希腊人早已懂得的演绎定理（deduction theorem）：
chap2_para131,1,2.,无论使用哪种表示，智能体几乎不可能准确地确定部分可观测环境的当前状态。
chap2_para131,2,4.,相反，标有“现在的世界是什么样子”（图2-11）的框表示智能体的“最佳猜测”（或者在具有多种可能性的情况下的最佳猜测）。
chap2_para131,3,4Goal-based agents,例如，一辆自动驾驶出租车可能无法看到停在它前面的大卡车周围的情况，只能猜测是什么导致了拥堵。
chap2_para131,4,,因此，关于当前状态的不确定性可能是不可避免的，但智能体仍然需要做出决定。
chap2_para1310,1,,对于任意语句和，当且仅当语句是有效的。
chap2_para1311,1,,（习题7.DEDU要求对其进行证明。
chap2_para1311,2,,）因此，可以像图7-10所示的推断算法那样，通过检验是否在每个模型中为真来确定是否成立，或者通过证明等价于True来确定是否成立。
chap2_para1311,3,,反过来，演绎定理表明每条有效的蕴涵语句都描述一个合法的推断。
chap2_para1312,1,,图7-11　标准的逻辑等价。
chap2_para1312,2,,符号、、代表任意命题逻辑语句
chap2_para1313,1,,最后一个概念是可满足性（satisfiability）。
chap2_para1313,2,,如果一条语句在某些模型中为真或能够被满足，则这条语句是可满足的。
chap2_para1313,3,,例如，前述的知识库中，是可满足的，因为如图7-9所示，它在3个模型中为真。
chap2_para1313,4,,可以通过枚举可能的模型，直到找出满足语句的模型来验证可满足性。
chap2_para1313,5,,在命题逻辑中确定语句的可满足性的问题——SAT问题——是第一个被证明为NP完全的问题。
chap2_para1313,6,,计算机科学中的许多问题实际上都是可满足性问题。
chap2_para1313,7,,例如，第6章的所有约束满足问题询问约束是否可以通过某种赋值来满足。
chap2_para1314,1,,有效性和可满足性当然是有联系的：是有效的，当且仅当是不可满足的；换言之，是可满足的，当且仅当不是有效的。
chap2_para1314,2,,我们还能得出下述非常有用的结论：
chap2_para1315,1,,当且仅当语句是不可满足的
chap2_para1316,1,,通过检验的不可满足性，可以从证明，这正是数学证明方法中标准的归谬法（reductio ad absurdum，意为“归结为荒谬之物”）。
chap2_para1316,2,,它也被称为反证法或矛盾法。
chap2_para1316,3,,假设为假，并证明这会导致与已知公理矛盾，这个矛盾的含义与声明语句是不可满足的完全相同。
chap2_para1317,1,,7.5.1　推断与证明
chap2_para1318,1,,本节介绍可以用于推导证明的推断规则。
chap2_para1318,2,,证明是一系列可以引向所需目标的结论。
chap2_para1318,3,,最著名的规则是肯定前件（Modus Ponens，mode that affirms的拉丁语），写作
chap2_para1319,1,,它的意思是，当给出和具有形式的语句时，可以推导出语句。
chap2_para1319,2,,例如，如果给出，并且已知，可以推导出Shoot。
chap2_para132,1,"Knowing something about the current state of the environment is not always enough to decide what to do. For example, at a road junction, the taxi can turn left, turn right, or go straight on. The correct decision depends on where the taxi is trying to get to. In other words, as well as a current state description, the agent needs some sort of goal information that describes situations that are desirable—for example, being at a particular destination. The agent program can combine this with the model (the same information as was used in the model-based reflex agent) to choose actions that achieve the goal. Figure 2.13 shows the goal-based agent’s structure.",图2-11　基于模型的智能体
chap2_para1320,1,,另一个有用的推断规则是合取消去（and-elimination），即可以从一个合取式推导出任一合取子句：
chap2_para1321,1,,例如，由，可推导出WumpusAlive。
chap2_para1322,1,,通过考虑和的可能真值，可以证明肯定前件和合取消去是可靠的。
chap2_para1322,2,,这些规则可用于任意适用的实例，不必枚举所有模型就可以生成可靠的推断。
chap2_para1323,1,,图7-11所示的所有逻辑等价都可以用作推断规则。
chap2_para1323,2,,例如，等价消去可以产生两条推断规则：
chap2_para1324,1,,并非所有推断规则都能像上面这样双向适用。
chap2_para1324,2,,例如，不能反向运用肯定前件规则，从得出和。
chap2_para1325,1,,让我们来看看这些推断规则和等价关系是如何应用于wumpus世界的。
chap2_para1325,2,,"我们从含有R1到R5的知识库开始，演示如何证明，即证明[1, 2]中没有无底洞。"
chap2_para1326,1,,（1）对R2使用等价消去，得到
chap2_para1327,1,,（2）对R6使用合取消去，得到
chap2_para1328,1,,（3）假言易位逻辑等价关系得到
chap2_para1329,1,,（4）对R8和感知R4（即）使用肯定前件，得到
chap2_para133,1,Figure 2.,图2-12　基于模型的反射型智能体。
chap2_para133,2,"13A model-based, goal-based agent.",它使用内部模型追踪世界的当前状态，然后以与反射型智能体相同的方式选择动作
chap2_para133,3,"It keeps track of the world state as well as a set of goals it is trying to achieve, and chooses an action that will (eventually) lead to the achievement of its goals.",
chap2_para1330,1,,（5）使用德摩根律，得到结论
chap2_para1331,1,,"也就是，[1, 2]和[2, 1]都没有无底洞。"
chap2_para1332,1,,应用第3章的任意搜索算法都可以找到构成这种证明的一系列步骤。
chap2_para1332,2,,只需要定义如下的证明问题。
chap2_para1333,1,,● 初始状态（Initial State）：最初的知识库。
chap2_para1334,1,,● 动作（Actions）：动作的集合，它包含所有推断规则应用于所有符合上半部分推断规则的语句。
chap2_para1335,1,,● 结果（Result）：一个动作的结果是将推断规则下半部分的语句实例加入知识库。
chap2_para1336,1,,● 目标（Goal）：目标是含有我们试图证明的语句的状态。
chap2_para1337,1,,这样，搜索证明就可以替代枚举模型。
chap2_para1337,2,,在许多实际案例中，找出某种证明的效率更高，因为证明可以忽略许多无关的命题，不论这种命题有多少。
chap2_para1337,3,,"例如，刚才给出的，得出的证明并没有提及命题B2,1、P1,1、P2,2或P3,1。"
chap2_para1337,4,,"由于目标命题P2,1只出现于语句R2，因此可以忽略它们；而R2中的其他命题只出现在R4和R2中，因此R1、R3和R5与证明无关。"
chap2_para1337,5,,即使在知识库中再添加一百万条语句，这一结果依然成立。
chap2_para1337,6,,而简单的真值表算法将无法承受这种模型的指数级爆炸式增长。
chap2_para1338,1,,逻辑系统的最后一个属性是单调性，它表明蕴含的语句集只能随着信息被加入知识库而增长。
chap2_para1338,2,,[9]对于任意语句和，
chap2_para134,1,"Sometimes goal-based action selection is straightforward—for example, when goal satisfaction results immediately from a single action. Sometimes it will be more tricky—for example, when the agent has to consider long sequences of twists and turns in order to find a way to achieve the goal. Search (Chapters 3, 4, and 6) and planning (Chapter 11) are the subfields of AI devoted to finding action sequences that achieve the agent’s goals.",2.4.4　基于目标的智能体
chap2_para1340,1,,[9]　违反单调性的非单调逻辑刻画了人类推理的常见性质：改变想法。
chap2_para1340,2,,我们将在10.6节对其进行讨论。
chap2_para1342,1,,例如，假设知识库含有额外的断言，它表明世界中恰好有8个无底洞。
chap2_para1342,2,,"这条知识可能有助于智能体得出额外的结论，但它不能使任何已经得出的结论失效，例如[1,2]中没有无底洞这样的结论。"
chap2_para1342,3,,单调性意味着只要在知识库中找到合适的前提，就可以使用推断规则——规则的结论必然是合理的，不论知识库中还有什么东西。
chap2_para1343,1,,7.5.2　通过归结证明
chap2_para1344,1,,我们已经论证了目前所说的推断规则是可靠的，但还没讨论过使用这些规则的推断算法的完备性问题。
chap2_para1344,2,,像迭代加深搜索（3.4.4节）这样的搜索算法能够找到任意的可达目标，从这种意义上说它是完备的；但如果可用的推断规则不充分，则目标是不可达的——仅使用这些推断规则的证明是不存在的。
chap2_para1344,3,,例如，如果去掉等价消去规则，7.5.1节所述的证明就行不通了。
chap2_para1344,4,,本节我们只介绍一个推断规则——归结（resolution），当它与任意完备的搜索算法结合后，可以产生一个完备的推断算法。
chap2_para1345,1,,我们从在wumpus世界使用简单的归结规则入手。
chap2_para1345,2,,"考虑导致图7-4a所示状态的步骤开始：智能体从[2, 1]返回到[1, 1]，然后走到[1, 2]，它在此处感知到臭味，但没有微风。"
chap2_para1345,3,,我们将如下事实添加到知识库中：
chap2_para1346,1,,"用先前推得R10时使用的相同步骤，可以推出[2, 2]和[1, 3]中没有无底洞（别忘了已知[1, 1]中没有无底洞）："
chap2_para1347,1,,"还可以对R3使用等价消去，然后对R5使用肯定前件，以得到[1, 1]、[2, 2]或[3, 1]中有无底洞的事实："
chap2_para1348,1,,"现在我们首次运用归结规则：R13中的文字与R15中的文字P2,2归结，得到归结句（resolvent）"
chap2_para1349,1,,"用自然语言描述：如果[1, 1]、[2, 2]或[3, 1]中必有无底洞，而[2, 2]中没有无底洞，则无底洞在[1, 1]或[3, 1]中。"
chap2_para1349,2,,"类似地，R1中的文字与R16中的文字P1,1归结，得到"
chap2_para135,1,"Notice that decision making of this kind is fundamentally different from the condition–action rules described earlier, in that it involves consideration of the future—both “What will happen if I do such-and-such?” and “Will that make me happy?” In the reflex agent designs, this information is not explicitly represented, because the built-in rules map directly from percepts to actions. The reflex agent brakes when it sees brake lights, period. It has no idea why. A goal-based agent brakes when it sees brake lights because that’s the only action that it predicts will achieve its goal of not hitting other cars.",了解环境的现状并不总是足以决定做什么。
chap2_para135,2,,例如，在一个路口，出租车可以左转、右转或直行。
chap2_para135,3,,正确的决定取决于出租车要去哪里。
chap2_para135,4,,换句话说，除了当前状态的描述之外，智能体还需要某种描述理想情况的目标信息，例如设定特定的目的地。
chap2_para135,5,,智能体程序可以将其与模型（与基于模型的反射型智能体中使用的信息相同）相结合，并选择实现目标的动作。
chap2_para135,6,,图2-13展示了基于目标的智能体结构。
chap2_para1350,1,,"用自然语言描述：如果[1, 1]或[3, 1]中有无底洞，无底洞又不在[1, 1]中，则它在[3, 1]中。"
chap2_para1350,2,,最后两步推断采用了单元归结（unit resolution）规则
chap2_para1351,1,,其中每个都是文字，而和m是互补文字（即各自是对方的否定）。
chap2_para1351,2,,这样，单元归结推断规则使用一个子句（文字的析取式）以及一个文字，生成一个新的子句。
chap2_para1351,3,,注意，单个文字可看作是一个文字的析取式，也被称为单元子句。
chap2_para1352,1,,单元归结规则可以推广为全归结规则
chap2_para1353,1,,其中，li和mj是互补文字。
chap2_para1353,2,,这表明归结使用两个子句并产生一个新的子句，该新子句包含除一对互补文字以外的原始子句的所有文字，例如，我们有
chap2_para1354,1,,可以一次只归结一对互补文字。
chap2_para1354,2,,例如，可以归结P和推得
chap2_para1355,1,,但不能同时归结P和Q来推得R。
chap2_para1355,2,,归结规则还有一个技术细节：结果子句只能含有每个文字的一个副本。
chap2_para1355,3,,[10]去除文字的多个副本被称为因子提取。
chap2_para1355,4,,例如，如果我们用归结，得到，通过因子提取简化为A。
chap2_para1357,1,,[10]　如果一个子句被视作文字的集合，则这条限制自然地适用。
chap2_para1357,2,,对子句使用集合的概念可以使归结规则更简洁，但代价是引入了额外的记号。
chap2_para1358,1,,通过对文字和另一个子句中的互补文字mj的讨论，我们可以很容易理解归结规则的可靠性。
chap2_para1358,2,,如果为真，则mj为假，因此必然为真，因为已知。
chap2_para1358,3,,如果为假，则必为真，因为已知。
chap2_para1358,4,,现无论为真还是为假，结论必然成立，这与归结法则所述的完全相同。
chap2_para1359,1,,归结法则更为惊人的部分在于，它形成了一类完备推断过程的基础。
chap2_para1359,2,,基于归结的定理证明器可以对命题逻辑中的任意语句和确定是否成立。
chap2_para1359,3,,接下来的“合取范式”和“归结算法”两小节将解释归结是如何完成这项任务的。
chap2_para136,1,"Although the goal-based agent appears less efficient, it is more flexible because the knowledge that supports its decisions is represented explicitly and can be modified. For example, a goal-based agent’s behavior can easily be changed to go to a different destination, simply by specifying that destination as the goal. The reflex agent’s rules for when to turn and when to go straight will work only for a single destination; they must all be replaced to go somewhere new.",有时，基于目标的动作选择很直接，例如，单个动作能够立刻实现目标的情况。
chap2_para136,2,,有时会更棘手，例如，智能体为了找到实现目标的方法而不得不考虑很长的复杂序列。
chap2_para136,3,,搜索（第3～5章）和规划（第11章）是人工智能的子领域，专门用于寻找实现智能体目标的动作序列。
chap2_para1361,1,,归结规则仅适用于子句（也就是文字的析取式），因此它似乎只能用于含有子句的知识库和查询。
chap2_para1361,2,,那么对于所有命题逻辑，它如何实现完备的推断过程？
chap2_para1361,3,,答案是，命题逻辑的所有语句逻辑上都等价于子句合取式。
chap2_para1362,1,,形式为子句合取式的语句被称为合取范式（conjunctive normal form）或CNF（见图7-12）。
chap2_para1362,2,,下面介绍把语句转换为CNF的过程。
chap2_para1362,3,,我们通过将语句 转换为CNF来阐明这一过程。
chap2_para1362,4,,转换的步骤如下。
chap2_para1363,1,,（1）消去，将替换为：
chap2_para1364,1,,（2）消去，将替换为
chap2_para1365,1,,（3）CNF要求只能在文字前出现，因此我们反复应用图7-11的如下等价关系“将内移”：
chap2_para1369,1,,本例中，我们只需运用最后一条规则一次：
chap2_para137,1,2.,注意，这类决策从根本上不同于前面描述的条件-动作规则，因为它涉及对未来的考虑，包括“如果我这样做会发生什么？
chap2_para137,2,4.,”和“这会让我快乐吗？
chap2_para137,3,5Utility-based agents,”在反射型智能体设计中，这种信息并没有被明确地表示出来，因为内置规则直接从感知映射到动作。
chap2_para137,4,,反射型智能体在看到刹车灯时刹车，但它不知道为什么。
chap2_para137,5,,基于目标的智能体在看到刹车灯时会刹车，因为这是它预测的唯一动作，这个动作可以实现不撞到其他汽车的目标。
chap2_para1370,1,,（4）现在我们得到了一个∧和∨嵌套、运算符直接作用于文字的语句。
chap2_para1370,2,,运用图7-11的分配律，尽可能地对∧分配∨：
chap2_para1371,1,,原始语句现在已经成为CNF，是3个子句的合取式。
chap2_para1371,2,,它读起来难了很多，但它可以作为归结过程的输入。
chap2_para1372,1,,图7-12　合取范式、霍恩子句、确定子句、目标子句的文法。
chap2_para1372,2,,形式如这样的CNF子句可以写成确定子句
chap2_para1374,1,,基于归结的推断过程使用7.5.1节介绍的反证法来进行证明。
chap2_para1374,2,,也就是说，为了证明，我们要证明是不可满足的。
chap2_para1374,3,,我们通过证明矛盾来做到这一点。
chap2_para1375,1,,图7-13展示了一个归结算法。
chap2_para1375,2,,首先，被转换为CNF。
chap2_para1375,3,,然后，归结规则被应用在得到的子句上。
chap2_para1375,4,,每一对互补文字都被归结生成新的子句，如果新子句没有出现过，就将其加入子句集合。
chap2_para1375,5,,这一过程不断持续，直到发生下述的两件事情之一。
chap2_para1376,1,,● 没有可供添加的新子句，此时KB不蕴含；
chap2_para1377,1,,● 两个子句归结为空子句，此时KB蕴含。
chap2_para1378,1,,图7-13　简单的命题逻辑归结算法。
chap2_para1378,2,,PL-Resolve返回对其两个输入进行归结得到的所有可能子句集合
chap2_para1379,1,,空子句是一个没有析取子句的析取式，它等价于False，因为仅当至少一个析取子句为真时析取式为真。
chap2_para1379,2,,另外，空子句仅在归结两个矛盾的单元子句（如P和）时出现。
chap2_para138,1,"Goals alone are not enough to generate high-quality behavior in most environments. For example, many action sequences will get the taxi to its destination (thereby achieving the goal), but some are quicker, safer, more reliable, or cheaper than others. Goals just provide a crude binary distinction between “happy” and “unhappy” states. A more general performance measure should allow a comparison of different world states according to exactly how happy they would make the agent. Because “happy” does not sound very scientific, economists and computer scientists use the term utility instead.7",图2-13　基于模型、基于目标的智能体。
chap2_para138,2,,它追踪世界状态以及它试图实现的一系列目标，并选择一项最终能够实现目标的动作
chap2_para1380,1,,我们可以将归结过程用在wumpus世界中一个很简单的推断中。
chap2_para1380,2,,"当智能体位于[1,1]时，该处没有微风，因此相邻的方格没有无底洞。"
chap2_para1380,3,,相关的知识库是
chap2_para1381,1,,我们要证明，即。
chap2_para1381,2,,如果将转换为CNF，我们就能得到在图7-14顶部所示的子句。
chap2_para1381,3,,该图的第二行列出了归结第一行后的子句。
chap2_para1381,4,,"随后，当P1,2与归结后，我们得到了空子句，用小方块表示。"
chap2_para1381,5,,观察图7-14，可以发现许多归结是毫无意义的。
chap2_para1381,6,,例如，子句等价于，进而等价于True。
chap2_para1381,7,,推出True为真并没有什么用处。
chap2_para1381,8,,因此，我们可以忽略所有含有两个互补文字的子句。
chap2_para1382,1,,图7-14　对wumpus世界的一个简单推断部分运用PL-Resolution来证明查询。
chap2_para1382,2,,顶行最左侧的4个子句的每一个与其他3个都互相成对，运用归结规则产生底行的子句。
chap2_para1382,3,,"顶行的第3个和第4个子句结合生成，它继而与P1,2归结，生成空子句，表明查询被证明"
chap2_para1384,1,,作为对归结的讨论的总结，现在来了解为何PL-Resolution是完备的。
chap2_para1384,2,,为此，我们引入子句集合S的归结闭包（resolution closure）RC(S)，即对S中子句及其生成子句反复使用归结规则可推得的所有子句的集合。
chap2_para1384,3,,归结闭包就是RL-Resolution计算所得的变量clauses的最终值。
chap2_para1384,4,,"易知RC(S)必然是有限的：得益于因子提取，由S中出现的符号P1, …, Pk得出的子句数量是有限的。"
chap2_para1384,5,,因此，PL-Resolution总是能够终止。
chap2_para1385,1,,命题逻辑中归结的完备性定理被称为基本归结定理（ground resolution theorem）：
chap2_para1386,1,,如果一个子句集是不可满足的，则这些子句的归结闭包含有空子句。
chap2_para1387,1,,定理的证明是通过其假言易位进行的：如果闭包RC(S)不含有空子句，则S可满足。
chap2_para1387,2,,"实际上，可以为S构建一个在P1, …, Pk上有适当真值的模型。"
chap2_para1387,3,,构建过程如下：
chap2_para1389,1,,"● 如果RC(S)中的子句含有文字且所有其他文字在对P1, …, Pi−1选定的赋值下为假，则对Pi赋值为false；"
chap2_para139,1,"We have already seen that a performance measure assigns a score to any given sequence of environment states, so it can easily distinguish between more and less desirable ways of getting to the taxi’s destination. An agent’s utility function is essentially an internalization of the performance measure. Provided that the internal utility function and the external performance measure are in agreement, an agent that chooses actions to maximize its utility will be rational according to the external performance measure.",尽管基于目标的智能体看起来效率较低，但它更灵活，因为支持其决策的知识是显式表示的，并且可以修改。
chap2_para139,2,,例如，只要将目的地指定为目标，就可以很容易地更改基于目标的智能体的行为，以到达不同的目的地。
chap2_para139,3,,反射型智能体关于何时转弯和何时直行的规则只适用于单一目的地，这些规则必须全部更换才能去新的目的地。
chap2_para1390,1,,● 否则，对Pi赋值为true。
chap2_para1391,1,,"对P1, …, Pk的赋值是S的一个模型。"
chap2_para1391,2,,要搞清楚这一点，我们假设其反面——在序列中的某处i，对符号Pi赋值使得某个子句C为假。
chap2_para1391,3,,"此时，情况必然是C中所有其他文字都已经被对P1, …, Pi−1的赋值定为假。"
chap2_para1391,4,,因此，C的形式必然类似或。
chap2_para1391,5,,如果只有其中一个在RC(S)中，则算法将对Pi赋适当的值以使C为真，因此仅在这两个子句都在RC(S)中时，C才会为假。
chap2_para1392,1,,"现在，由于RC(S)在归结时是闭的，它会含有这两个子句的归结句，且这个归结句的所有文字已经被对P1, …, Pi−1的赋值定为假。"
chap2_para1392,2,,这与我们的假设，即第一个为假的子句出现在i处矛盾。
chap2_para1392,3,,因此，我们证明了这种构建永远无法使RC(S)中的子句为假，也就是说它创建了一个RC(S)的模型。
chap2_para1392,4,,最后，由于S包含在RC(S)中，因此任意RC(S)的模型也是S本身的模型。
chap2_para1393,1,,7.5.3　霍恩子句与确定子句
chap2_para1394,1,,归结的完备性使其成为一种非常重要的推断方法。
chap2_para1394,2,,而许多实际情形并不需要用到归结的全部能力。
chap2_para1394,3,,一些真实世界的知识库中的语句满足某些限制，这使得它们可以使用更为受限而更高效的推断算法。
chap2_para1395,1,,其中一种受限形式是确定子句（definite clause），它是文字的析取式，其中只有一个为正文字。
chap2_para1395,2,,例如，子句是确定子句而不是，因为它含有两个正文字。
chap2_para1396,1,,更一般性的是霍恩子句（Horn clause），它是文字的析取式，其中最多只有一个为正文字。
chap2_para1396,2,,因此所有的确定子句都是霍恩子句，没有正文字的子句也是霍恩子句——也被称为目标子句（goal clause）。
chap2_para1396,3,,霍恩子句在归结时是闭的：如果归结两个霍恩子句，仍然会得到霍恩子句。
chap2_para1396,4,,还有一种类型是k-CNF语句，它是每个子句最多含有k个文字的CNF语句。
chap2_para1397,1,,仅含有确定子句的知识库很有意义，原因有3个。
chap2_para1398,1,,（1）每个确定子句都可以写成一个蕴涵式，前提是正文字的合取式，结论是一个正文字。
chap2_para1398,2,,（见习题7.DISJ。
chap2_para1398,3,,）例如，确定子句可以写成蕴涵式。
chap2_para1398,4,,"蕴涵形式的语句更容易理解：它说明如果智能体位于[1, 1]，且感知到微风，则[1, 1]有微风。"
chap2_para1398,5,,在霍恩形式中，前提被称为体（body）而结论被称为头（head）。
chap2_para1398,6,,"由单个正文字构成的语句，例如L1,1，被称为事实（fact）。"
chap2_para1398,7,,"它也可以写成形式的蕴涵式，但只写成L1,1更为简洁。"
chap2_para1399,1,,（2）用霍恩子句进行推断可以通过前向链接（forward-chaining）算法和反向链接（backward-chaining）算法完成，我们稍后会介绍。
chap2_para1399,2,,这些算法都很自然，因为它们的推断步骤很直观，便于人类理解。
chap2_para1399,3,,这类推断是逻辑编程（logic programming）的基础，我们将在第9章进行讨论。
chap2_para14,1,Looking at Figure 2.,图2-2　一个只有两个方格的真空吸尘器世界。
chap2_para14,2,"3, we see that various vacuum-world agents can be defined simply by filling in the right-hand column in various ways.",每个位置可以是干净的，也可以是脏的，智能体可以向左移动或向右移动，可以清理它所占据的方格。
chap2_para14,3,"The obvious question, then, is this: What is the right way to fill out the table?",不同版本的真空吸尘器世界允许不同的规则，例如智能体可以感知什么，它的动作是否总是成功等
chap2_para14,4,"In other words, what makes an agent good or bad, intelligent or stupid?",
chap2_para14,5,We answer these questions in the next section.,
chap2_para140,1,"Let us emphasize again that this is not the only way to be rational—we have already seen a rational agent program for the vacuum world (Figure 2.8) that has no idea what its utility function is—but, like goal-based agents, a utility-based agent has many advantages in terms of flexibility and learning. Furthermore, in two kinds of cases, goals are inadequate but a utility-based agent can still make rational decisions. First, when there are conflicting goals, only some of which can be achieved (for example, speed and safety), the utility function specifies the appropriate tradeoff. Second, when there are several goals that the agent can aim for, none of which can be achieved with certainty, utility provides a way in which the likelihood of success can be weighed against the importance of the goals.",2.4.5　基于效用的智能体
chap2_para1400,1,,（3）用霍恩子句确定蕴含关系所需的时间与知识库大小呈线性关系，这格外令人满意。
chap2_para1401,1,,7.5.4　前向链接与反向链接
chap2_para1402,1,,"前向链接算法PL-FC-Entails?(KB,q)确定单个命题符号q（即查询）是否被确定子句的知识库所蕴含。"
chap2_para1402,2,,它从知识库中的已知事实（正文字）开始。
chap2_para1402,3,,如果一个蕴涵式的所有前提都已知，则将其结论添加到已知事实的集合中。
chap2_para1402,4,,"例如，如果L1,1和Breeze已知，且在知识库中，则在知识库中添加B1,1。"
chap2_para1402,5,,这一过程持续进行，直到查询q被添加，或直到无法进一步进行推断。
chap2_para1402,6,,这一算法在图7-15中展示，我们要记住的要点是它的运行时间是线性的。
chap2_para1403,1,,用图和示例来理解算法是最好的办法。
chap2_para1403,2,,图7-16a展示了一个简单的霍恩子句知识库，其中有A和B两个已知事实。
chap2_para1403,3,,图7-16b展示了绘制为与或图（见第4章）的同一个知识库。
chap2_para1403,4,,在与或图中，用曲线连接的多个边表示一个合取式，每个边都要证明；而没有曲线连接的多个边表示一个析取式，证明任一边即可。
chap2_para1403,5,,图上很容易看懂前向链接是如何运作的。
chap2_para1403,6,,已知的叶节点（此处为A和B）具有真值之后，推断就会沿着图尽可能远地向上传递。
chap2_para1403,7,,当出现合取式时，传递过程开始等待，直到所有合取子句都已知。
chap2_para1403,8,,我们鼓励读者细致地研究这个示例。
chap2_para1404,1,,图7-15　命题逻辑的前向链接算法。
chap2_para1404,2,,queue记录了已知为真但还没“处理过”的符号。
chap2_para1404,3,,表count记录每个蕴涵式尚未证明的前提数量。
chap2_para1404,4,,一旦queue中的新符号p被处理，count就会为每个前提中出现p的蕴涵式减1（使用合适的索引方法，很容易在常数时间内完成）。
chap2_para1404,5,,如果count为0，则蕴涵式的所有前提都已知，因此其结论可以添加到queue。
chap2_para1404,6,,最后，我们还需要记录哪个符号已经被处理过，如此在已推断符号集inferred中的符号就无需被再次加入queue。
chap2_para1404,7,,这避免了重复的工作，也避免了由类似P⇒Q和Q⇒P这样的蕴涵式引起的循环
chap2_para1405,1,,图7-16　（a）一个霍恩子句集。
chap2_para1405,2,,（b）相应的与或图
chap2_para1406,1,,显然，前向链接是可靠的：每个推断实际上都是对肯定前件的运用。
chap2_para1406,2,,前向链接也是完备的：所有蕴含的原子语句都将被推得。
chap2_para1406,3,,要理解这一点，最简单的方法是考虑（在算法到达不动点，无法产生新推断的时候）inferred表格的最终状态。
chap2_para1406,4,,该表中每个推得的符号都为真，所有其他符号都为假。
chap2_para1406,5,,我们可以将这个表看作一个逻辑模型，且原始KB的每条确定子句在这个模型中都为真。
chap2_para1407,1,,为理解这一点，可以假设其反面，即存在子句在模型中为假。
chap2_para1407,2,,则在模型中必然为真，且b在模型中必然为假。
chap2_para1407,3,,这与我们假设的算法已经到达不动点相矛盾，因为我们此时可以将b加入知识库。
chap2_para1407,4,,因此我们可以断定，不动点处推得的原子语句集定义了一个原始知识库的模型。
chap2_para1407,5,,更进一步地，知识库蕴含的任意原子语句q必然在其所有模型中都为真，在这个特定模型中也一样。
chap2_para1407,6,,因此，所有蕴含的原子语句q必然会被算法推得。
chap2_para1408,1,,前向链接是数据驱动（data-driven）推理这一更广泛概念的例子，也就是其注意力开始集中在已知数据的推理。
chap2_para1408,2,,它可以用于智能体，以便从收到的感知推导出结论，且常常是在没有特定查询的情况下。
chap2_para1408,3,,例如，wumpus世界的智能体可以用递增前向链接算法（即新的事实可以被加入队列来启动新的推断）将它的感知告知知识库。
chap2_para1408,4,,对人类来说，当获取新信息后会出现一定数量的数据驱动推理。
chap2_para1408,5,,例如，如果我在屋子里听到外面开始下雨，则我可能会想到取消野餐；但是，我大概不会想到邻居花园里最大的一朵玫瑰的第17片花瓣会淋湿——人类会对前向链接进行精心地控制，以免被无关的结果淹没。
chap2_para1409,1,,反向链接算法如其名称所示，从查询开始反向运作。
chap2_para1409,2,,如果查询q已知为真，则不需要做任何操作。
chap2_para1409,3,,否则，算法将在知识库中找寻结论为q的蕴涵式。
chap2_para1409,4,,如果这些蕴涵式的所有前提都可以（用反向链接）证明为真，则q为真。
chap2_para1409,5,,将反向链接算法用于图7-16的查询Q时，它反向地向图的下方运行，直到到达构成证明基础的已知事实集，即A和B。
chap2_para1409,6,,算法实质上与图4-11的And-Or-Graph-Search算法完全相同。
chap2_para1409,7,,与前向链接一样，它的高效实现的时间复杂性是线性的。
chap2_para141,1,"Partial observability and nondeterminism are ubiquitous in the real world, and so, therefore, is decision making under uncertainty. Technically speaking, a rational utility-based agent chooses the action that maximizes the expected utility of the action outcomes—that is, the utility the agent expects to derive, on average, given the probabilities and utilities of each outcome. (Appendix A defines expectation more precisely.) In Chapter 15, we show that any rational agent must behave as if it possesses a utility function whose expected value it tries to maximize. An agent that possesses an explicit utility function can make rational decisions with a general-purpose algorithm that does not depend on the specific utility function being maximized. In this way, the “global” definition of rationality—designating as rational those agent functions that have the highest performance—is turned into a “local” constraint on rational-agent designs that can be expressed in a simple program.",在大多数环境中，仅靠目标并不足以产生高质量的行为。
chap2_para141,2,,例如，许多动作序列都能使出租车到达目的地（从而实现目标），但有些动作序列比其他动作序列更快、更安全、更可靠或更便宜。
chap2_para141,3,,目标只是在“快乐”和“不快乐”状态之间提供了一个粗略的二元区别。
chap2_para141,4,,更一般的性能度量应该允许根据不同世界状态的“快乐”程度对智能体进行比较。
chap2_para141,5,,经济学家和计算机科学家通常用效用（utility）这个词来代替“快乐”，因为“快乐”听起来不是很科学。
chap2_para141,6,,[7]
chap2_para1410,1,,反向链接是一种目标导向推理（goal-directed reasoning）。
chap2_para1410,2,,它对于回答类似“我现在该做什么？
chap2_para1410,3,,”和“我的钥匙在哪里？
chap2_para1410,4,,”这样的特定问题非常有用。
chap2_para1410,5,,通常，反向链接的代价远小于知识库规模的线性变化，因为这个过程仅涉及相关的事实。
chap2_para1411,1,,7.6　高效命题模型检验
chap2_para1412,1,,本节，我们介绍两种高效的、基于模型检验的一般命题推断的算法，其中一种是基于回溯搜索的，另一种则基于局部爬山搜索。
chap2_para1412,2,,这些算法是命题逻辑的“技术”部分。
chap2_para1412,3,,首次阅读本章时可以略过本节内容。
chap2_para1413,1,,我们描述的算法是用于可满足性检验的，即SAT问题。
chap2_para1413,2,,（如7.5节所述，可以通过检验的不可满足性来检验蕴含。
chap2_para1413,3,,）我们在7.5节中提到过找到满足逻辑语句的模型与找到约束满足问题的解的关系，因此这两种命题可满足性算法与6.3节的回溯算法和6.4节的局部搜索算法非常相似并不令人意外。
chap2_para1413,4,,尽管如此，这些算法本身还是极为重要的，因为许多计算机科学中的组合问题都可以被归为检验命题语句的可满足性。
chap2_para1413,5,,对可满足性算法的任何改进对于我们处理复杂性的能力都有巨大的作用。
chap2_para1414,1,,7.6.1　完备的回溯算法
chap2_para1415,1,,"我们要探讨的第一个算法常称为戴维斯-普特南算法（Davis-Putnam algorithm），得名于马丁·戴维斯（Martin Davis）和希拉里·普特南（Hilary Putnam）的重要论文（Davis and Putnam, 1960）。"
chap2_para1415,2,,"这个算法实际上采用的是戴维斯、洛吉曼和洛夫兰所描述的版本（Davis, Logemann, and Loveland, 1962），因此我们用所有4位作者姓氏的首字母DPLL命名这个算法。"
chap2_para1415,3,,DPLL使用一个合取范式形式（即一个子句集）的语句作为输入。
chap2_para1415,4,,类似于Backtracking-Search和TT-Entails?，它本质上是递归地、深度优先地枚举可能的模型。
chap2_para1415,5,,它在TT-Entails?的基础上进行了3项改进。
chap2_para1416,1,,● 提前终止：算法可以用部分完成的模型来检测语句是否必然为真或为假。
chap2_para1416,2,,如果任一文字为真则子句为真，即使其他文字还没有真值；这样，整条语句在模型完成之前就可以断定其真值。
chap2_para1416,3,,例如，若A为真则语句为真，无论B和C的值是什么。
chap2_para1416,4,,类似地，若任一子句为假，即其所有文字为假，则语句为假。
chap2_para1416,5,,同样，这种情形可能会在模型完成前很久就发生。
chap2_para1416,6,,提前终止避免了在搜索空间中检查全部子树。
chap2_para1417,1,,● 纯符号启发式方法：纯符号是指在所有子句中“符号位”都相同的符号。
chap2_para1417,2,,例如，在3个子句、和中，A是纯符号，因为它只以正文字的形式出现；B也是纯符号，因为它总以负文字的形式出现。
chap2_para1417,3,,而C是不纯的。
chap2_para1417,4,,易知如果一条语句有模型，则存在一个模型对纯符号的赋值使其文字为真，因为这样做不会使子句为假。
chap2_para1417,5,,注意，在确定符号是否为纯时，算法可以忽略当前已构建的模型中已知为真的子句。
chap2_para1417,6,,例如，如果上述模型含有B=false，则子句已经为真，且在剩余子句中C仅作为正文字出现，因此C变为纯符号。
chap2_para1418,1,,● 单元子句启发式方法：之前对单元子句的定义是只有一个文字的子句。
chap2_para1418,2,,在DPLL中，它也指那些除了一个文字外，其余文字都被模型赋值为false的子句。
chap2_para1418,3,,例如，如果模型含有B = true，则简化为，这是一个单元子句。
chap2_para1418,4,,显然，要使这个子句为真，C必须赋值为false。
chap2_para1418,5,,单元子句启发式方法在余下的部分出现分支前对所有这样的符号赋值。
chap2_para1418,6,,这种启发式的一个重要结果是，所有对知识库中的已有文字进行的证明（通过反证法）将立刻得证（见习题7. KNOW）。
chap2_para1418,7,,还要注意的是，对一个单元子句赋值可能会创建另一个单元子句，例如，当C被置为假，也变成了单元子句，使得A被赋值为真。
chap2_para1418,8,,这种强制赋值的“级联”被称为单元传播（unit propagation）。
chap2_para1418,9,,这类似于确定子句的前向链接。
chap2_para1418,10,,实际上，如果CNF表达式仅含有确定子句，则DPLL本质上复制了前向链接。
chap2_para1418,11,,（见习题7. DPLL。
chap2_para1418,12,,）
chap2_para1419,1,,DPLL算法如图7-17所示，它给出了搜索程序的主要结构，但并未实现其细节。
chap2_para142,1,The utility-based agent structure appears in Figure 2.,
chap2_para142,2,14.,
chap2_para142,3,"Utility-based agent programs appear in Chapters 15 and 16, where we design decision-making agents that must handle the uncertainty inherent in nondeterministic or partially observable environments.",
chap2_para142,4,"Decision making in multiagent environments is also studied in the framework of utility theory, as explained in Chapter 17.",
chap2_para1420,1,,图7-17　用于检验命题逻辑语句可满足性的DPLL算法。
chap2_para1420,2,,Find-Pure-Symbol和Find-Unit-Clause背后的思路在正文中进行了介绍。
chap2_para1420,3,,这两个函数都返回一个符号（或返回空）以及要赋给这个符号的真值。
chap2_para1420,4,,和TT-Entails?一样，DPLL在部分模型上运行
chap2_para1421,1,,图7-17没有展示使SAT求解器能够用于大规模问题的技巧。
chap2_para1421,2,,有趣的是，这些技巧实际上都很寻常，我们之前已经见过它们的其他形式。
chap2_para1422,1,,（1）分量分析（如CSP中的塔斯马尼亚岛问题所见）：当DPLL为变量赋真值时，子句集可能会被分割成不相交的子集，我们称之为分量，它们没有共同的未赋值变量。
chap2_para1422,2,,给定一个高效探测这一状况的方法，求解器就可以通过对每个分量独立求解来加快速度。
chap2_para1423,1,,（2）变量排序与值排序（如在6.3.1节的CSP中所见）：我们对DPLL的简单实现使用任意的变量顺序，并在赋值时总是先尝试赋真再尝试赋假。
chap2_para1423,2,,度启发式算法（6.3.1节）建议在所有剩余子句中优先选择最常出现的变量。
chap2_para1424,1,,（3）智能回溯（如在6.3.3节的CSP中所见）：许多用按时序回溯几小时都求解不了的问题，如果改用智能回溯直接回溯到导致冲突的相关点上，那么问题可以在几秒内求解。
chap2_para1424,2,,所有运用智能回溯的SAT求解器都使用冲突子句学习的某种形式来记录冲突，以避免在后续的搜索中重复出现。
chap2_para1424,3,,通常只保留有限大小的冲突集，丢弃极少使用的冲突。
chap2_para1425,1,,（4）随机重启（在4.1.1节用于爬山法）：有时单次运行似乎无法取得进展。
chap2_para1425,2,,此时，我们可以从搜索树的顶端重新开始，而非尝试继续搜索。
chap2_para1425,3,,重启后（对变量和值选取）进行不同的随机选择。
chap2_para1425,4,,第一次运行中学习到的子句在重启后依然被保留，这有助于对搜索空间进行剪枝。
chap2_para1425,5,,重启并不保证能更快地找到解，但它能够减小求解时间的方差。
chap2_para1426,1,,（5）聪明索引（在许多算法中可以见到）：DPLL和其他现代求解器用到的加速方法需要快速索引“Xi作为正文字出现的子句集合”。
chap2_para1426,2,,这一任务相当复杂，因为算法所感兴趣的只是先前的变量赋值尚未满足的子句，因此索引结构必须在计算过程中动态更新。
chap2_para1427,1,,有了这些改进，现代求解器可以处理有数千万个变量的问题。
chap2_para1427,2,,它们为诸如硬件验证和安全协议验证这样的领域带来革命性的变化。
chap2_para1427,3,,在此之前，这些领域需要十分费力的、手动证明。
chap2_para1428,1,,7.6.2　局部搜索算法
chap2_para1429,1,,我们已经在本书中见过了一些局部搜索算法，包括Hill-Climbing（4.1.1节）和Simulated-Annealing（4.1.2节）。
chap2_para1429,2,,只要我们选择了正确的评价函数，这些算法可就以被直接用于可满足性问题。
chap2_para1429,3,,由于目标是找出满足所有子句的赋值，一个对未满足的子句进行计数的评价函数就可以胜任这项工作。
chap2_para1429,4,,实际上，这正是用于CSP的Min-Conflict算法所使用的量度（见6.4节）。
chap2_para1429,5,,这些算法都在完全赋值的空间采取动作，每次只翻转一个符号的真值。
chap2_para1429,6,,这个空间通常含有许多局部极小值，要跳出这些极小值，需要各种形式的随机方法。
chap2_para1429,7,,近年来，人们进行了大量实验，试图在贪婪性与随机性之间找到一个良好的平衡。
chap2_para143,1,Figure 2.,[7]　这里的“utility”一词指的是“实用的品质”，而不是电力公司或自来水厂等公共设施。
chap2_para143,2,"14A model-based, utility-based agent.",
chap2_para143,3,"It uses a model of the world, along with a utility function that measures its preferences among states of the world.",
chap2_para143,4,"Then it chooses the action that leads to the best expected utility, where expected utility is computed by averaging over all possible outcome states, weighted by the probability of the outcome.",
chap2_para1430,1,,这些算法中最为简单和有效的算法之一是WalkSAT（如图7-18所示）。
chap2_para1430,2,,算法每次循环都选择一个未满足的子句，并在该子句中选择一个符号来翻转。
chap2_para1430,3,,选择要翻转的符号的方法有两种：（1）最小化新状态中未满足子句的数量的“最小冲突”方法；（2）随机挑选一个符号的“随机游走”方法。
chap2_para1430,4,,算法随机选取一种。
chap2_para1431,1,,图7-18　通过随机翻转变量的值来检验可满足性的WalkSAT算法。
chap2_para1431,2,,这个算法有很多版本
chap2_para1432,1,,当WalkSAT返回一个模型时，输入语句就是可满足的。
chap2_para1432,2,,但当它返回failure时，则有两种可能的原因：语句不可满足，或我们需要多给算法一些时间。
chap2_para1432,3,,如果我们设定且p 0，WalkSAT最终将返回一个模型（如果存在的话），因为随机游走步骤终将遇到一个解。
chap2_para1432,4,,如果max_flips为无穷大，而语句不可满足，则算法永远不会终止！
chap2_para1433,1,,因此，当我们预计问题有解的时候，WalkSAT最为有用。
chap2_para1433,2,,例如，第3章和第6章讨论过的问题通常有解。
chap2_para1433,3,,但是，WalkSAT并不总是能检测到不可满足性，而对判定蕴含来说这是必备的。
chap2_para1433,4,,例如，wumpus世界中，一个智能体不能使用WalkSAT来可靠地证明一个方格是安全的。
chap2_para1433,5,,不过，它可以说：“我思考了一小时，都想不出存在一种这个方格不安全的可能世界。
chap2_para1433,6,,”这也许是个不错的经验性指示，表明方格是安全的，但它绝对不是一种证明。
chap2_para1434,1,,7.6.3　随机SAT问题概览
chap2_para1435,1,,某些SAT问题比其他要难。
chap2_para1435,2,,简单的问题可以用任意老算法求解，但由于我们知道SAT是NP完全的，至少有一些问题必须需要指数级的运行时间。
chap2_para1435,3,,在第6章中，我们见过一些针对某种问题的惊人发现。
chap2_para1435,4,,例如，对于回溯搜索算法，n皇后问题被认为是相当困难的，而对于局部搜索方法，如最小冲突法，求解这一问题却非常容易。
chap2_para1435,5,,这是由于在赋值空间中，解的分布非常密集，任意初始赋值都能保证在其附近存在解。
chap2_para1435,6,,因此，n皇后问题很简单，因为它是欠约束的（underconstrained）。
chap2_para1436,1,,当我们考虑合取范式的可满足性问题时，一个欠约束的问题是约束变量的子句非常少的情形。
chap2_para1436,2,,例如，下面是一条随机生成的3-CNF语句，它有5个符号和5个子句：
chap2_para1437,1,,在32个可能的赋值中，有16个是这条语句的模型。
chap2_para1437,2,,因此，平均而言，只需进行两次随机猜测就可以找到一个模型。
chap2_para1437,3,,与大部分这样的欠约束问题一样，这是一个简单的可满足性问题。
chap2_para1437,4,,但是，一个过约束的问题很可能没有解，因为相对于其变量数量，其子句数量过多。
chap2_para1437,5,,过约束问题通常很容易求解，因为这些约束将很快导致算法找出一个解，或进入无法逃离的死胡同。
chap2_para1438,1,,要超越这些基本的直观理解，我们必须明确定义如何生成随机语句。
chap2_para1438,2,,"记法CNFk(m, n)表示一个有m个子句、n个符号的k-CNF语句，其中子句是均匀地、独立地、无放回地从所有有k个文字的子句中选取的，文字的正负也是随机的。"
chap2_para1438,3,,（一个符号在子句中不能多次出现，一个子句也不能在语句中多次出现。
chap2_para1438,4,,）
chap2_para1439,1,,给定一个随机语句源，我们就可以测量可满足性的概率。
chap2_para1439,2,,"图7-19a绘制了CNF3(m, 50)的概率，也就是有50个变量、每条子句有3个文字的语句，这一概率被绘制为子句/符号，即m/n的函数。"
chap2_para1439,3,,如我们预期，对于较小的m/n，可满足性的概率接近0，而在较大的m/n处这一概率接近0。
chap2_para1439,4,,概率在m/n = 4.3左右急剧下降。
chap2_para1439,5,,经验上，我们发现这一“峭壁”出现在大致相同的位置（对于k = 3），并随着n的增长越来越陡峭。
chap2_para144,1,"At this point, the reader may be wondering, “Is it that simple? We just build agents that maximize expected utility, and we’re done?” It’s true that such agents would be intelligent, but it’s not simple. A utility-based agent has to model and keep track of its environment, tasks that have involved a great deal of research on perception, representation, reasoning, and learning. The results of this research fill many of the chapters of this book. Choosing the utility-maximizing course of action is also a difficult task, requiring ingenious algorithms that fill several more chapters. Even with these algorithms, perfect rationality is usually unachievable in practice because of computational complexity, as we noted in Chapter 1. We also note that not all utility-based agents are model-based; we will see in Chapters 23 and 26 that a model-free agent can learn what action is best in a particular situation without ever learning exactly how that action changes the environment.",我们已经看到，性能度量会给任何给定的环境状态序列打分，因此它可以很容易地区分到达出租车目的地所采取的更可取和更不可取的方式。
chap2_para144,2,,智能体的效用函数（utility function）本质上是性能度量的内部化。
chap2_para144,3,,如果内部效用函数和外部性能度量一致，那么根据外部性能度量选择动作，以使其效用最大化的智能体是理性的。
chap2_para1440,1,,"理论上，可满足性阈值猜想（satisfiability threshold conjecture）表明对所有，存在一个阈值比rk，使得当n接近无穷时CNFk(rn, n)可满足的概率对于所有低于阈值的r接近于1，对于所有高于阈值的r接近于0。"
chap2_para1440,2,,即便对于如k = 3这样的特例，这一猜想仍未被证明。
chap2_para1440,3,,不论这是不是一个定理，这样的阈值效应在可满足性问题和其他类型的NP困难问题中都是相当寻常的。
chap2_para1441,1,,现在我们对可满足和不可满足问题分别会出现在什么地方有了很好的了解，接下来的问题是，困难的问题会出现在什么地方？
chap2_para1441,2,,其实它们也经常位于阈值处。
chap2_para1441,3,,图7-19b显示，阈值4.3处的50个符号的问题比阈值3.3处的相同问题大约难20倍。
chap2_para1441,4,,欠约束问题很好求解（因为很容易就能猜到一个解），而过约束问题不如欠约束问题简单，却仍然比恰好在阈值处的问题简单得多。
chap2_para1442,1,,图7-19　（a）有n个符号的随机3-CNF语句的可满足概率图，概率是子句/符号比m/n的函数。
chap2_para1442,2,,（b）DPLL和WalkSAT在随机3-CNF语句上的（多次运行后测量的）运行时间中位数图。
chap2_para1442,3,,最为困难的问题的子句/符号比约为4.3
chap2_para1443,1,,7.7　基于命题逻辑的智能体
chap2_para1444,1,,本节我们将目前所学的内容结合起来构建使用命题逻辑的wumpus世界智能体。
chap2_para1444,2,,首先我们要使智能体能够根据其历史感知对世界的状态尽可能地进行推导。
chap2_para1444,3,,这需要写出动作效果的完整逻辑模型。
chap2_para1444,4,,随后我们介绍智能体在wumpus世界中如何使用逻辑推断。
chap2_para1444,5,,我们还会介绍智能体如何在不查看每次推断的历史感知的情况下有效地跟踪世界的变化。
chap2_para1444,6,,最后，我们介绍在已知其知识库在实际世界中为真的情况下，智能体如何使用逻辑推断来构建能确保达到目标的规划。
chap2_para1445,1,,7.7.1　世界的当前状态
chap2_para1446,1,,如本章开头所述，逻辑智能体通过用关于世界的语句知识库推导接下来的动作来运作。
chap2_para1446,2,,知识库由公理（也就是关于世界如何运行的一般知识）和从智能体在某个特定世界获得的感知语句构成。
chap2_para1446,3,,本节，我们聚焦于推导wumpus世界的当前状态这一问题，如我在哪里、方格是否安全等。
chap2_para1447,1,,我们从7.4.3节开始收集公理。
chap2_para1447,2,,智能体知道起始方格没有无底洞（）也没有wumpus（）。
chap2_para1447,3,,此外，对于每个方格，它知道当且仅当一个方格的相邻方格有无底洞，该方格有微风；当且仅当一个方格的相邻方格有wumpus，该方格有臭味。
chap2_para1447,4,,由此，我们引入了具有如下形式的大量语句：
chap2_para1448,1,,智能体还知道恰恰只有一个wumpus。
chap2_para1448,2,,我们用两部分表示。
chap2_para1448,3,,首先，我们说至少有一个wumpus：
chap2_para1449,1,,然后我们必须说最多只有一个wumpus。
chap2_para1449,2,,我们对每对方格添加一个语句，来表明其中至少一个方格没有wumpus：
chap2_para145,1,"Finally, all of this assumes that the designer can specify the utility function correctly; Chapters 16, 17, and 23 consider the issue of unknown utility functions in more depth.",再次强调，这不是理性的唯一实现方式，我们已经看到了一个适用于真空吸尘器世界的理性智能体程序（图2-8），但并不知道它的效用函数是什么。
chap2_para145,2,,与基于目标的智能体一样，基于效用的智能体在灵活性和学习方面有很多优势。
chap2_para145,3,,此外，在两种情况下，仅靠目标是不充分的，但基于效用的智能体仍然可以做出理性的决策。
chap2_para145,4,,首先，当存在相互冲突的目标时，只能实现其中的一部分（例如速度和安全），效用函数会进行适当的权衡。
chap2_para145,5,,其次，当智能体有多个目标实现，但没有一个目标可以确定地实现时，效用提供了一种方法，可以权衡目标的重要性和成功的可能性。
chap2_para1450,1,,到目前为止都还不错。
chap2_para1450,2,,现在让我们考虑智能体的感知。
chap2_para1450,3,,"我们使用了S1,1来表示[1, 1]有臭味，那么我们可以只用一个命题Stench来表示智能体感知到臭味吗？"
chap2_para1450,4,,遗憾的是，不行。
chap2_para1450,5,,如果在之前的时间步中没有臭味，就已经被断言，那么新的断言将与之矛盾。
chap2_para1450,6,,我们发现，如果感知只对当前时间的事情进行断言，这个问题就很容易求解。
chap2_para1450,7,,如此，假如时间步（与输入图7-1中Make-Percept-Sentence的一样）是4，则我们在知识库中添加Stench4而非Stench，这样就能轻松地避免与矛盾。
chap2_para1450,8,,对微风、碰撞、闪光和惨叫等感知也同样处理。
chap2_para1451,1,,这个将命题与时间步相关联的思路可以拓展到这个世界中所有随时间变化的部分。
chap2_para1451,2,,"例如，最初知识库中有——智能体在时刻0位于[1, 1]，以及FacingEast 0、HaveArrow 0和WumpusAlive0。"
chap2_para1452,1,,我们使用流（fluent，源于拉丁语fluens，意为流动）来表示世界随时间变化的部分。
chap2_para1452,2,,“流”与2.4.7节所述的对因子化表示的讨论中的“状态变量”同义。
chap2_para1452,3,,与世界的不变部分相关的符号不需要时间上标，它们有时被称为非时序变量（atemporal variable）。
chap2_para1453,1,,我们可以将微风和臭味直接与体验到这些感知的方格的属性连接。
chap2_para1453,2,,"[11]对任意时间步t和任意方格[x, y]，我们断言"
chap2_para1455,1,,[11]　7.4.3节出于简便考虑，隐藏了这项要求。
chap2_para1456,1,,当然，现在我们需要能够使智能体跟进像这样的流的公理。
chap2_para1456,2,,智能体采取动作会改变这些流，因此，用第3章的术语来说，我们需要将wumpus世界的转移模型写成逻辑语句的集合。
chap2_para1457,1,,首先我们需要表示发生动作的命题符号。
chap2_para1457,2,,与感知一样，这些符号用时间索引。
chap2_para1457,3,,因此Forward 0表示智能体在时刻0执行前进动作。
chap2_para1457,4,,习惯上，给定时间步的感知先发生，然后是这个时间步上的动作，然后是到下一个时间步的转移。
chap2_para1458,1,,为描述世界如何变化，我们可以试着写出指明动作在下一个时间步产生的结果的效应公理（effect axiom）。
chap2_para1458,2,,"例如，如果智能体位于[1, 1]，在时刻0时面朝东并向前走，结果是智能体位于方格[2, 1]且不再在[1, 1]："
chap2_para146,1,2.,部分可观测性和非确定性在真实世界中普遍存在，因此，不确定性下的决策也普遍存在。
chap2_para146,2,4.,从技术上讲，基于效用的理性智能体会选择能够最大化其动作结果期望效用（expected utility）的动作，也就是在给定每个结果的概率和效用的情况下，智能体期望得到的平均效用（附录A更精确地定义了期望）。
chap2_para146,3,6Learning agents,在第16章中，我们证明，任何理性智能体的行为都必须表现得好像拥有一个效用函数，并试图最大化其期望值。
chap2_para146,4,,具有显式效用函数的智能体可以使用通用算法做出理性决策，该算法不依赖于特定效用函数的最大化。
chap2_para146,5,,通过这种方式，理性的“全局”定义（将那些具有最高性能的智能体函数指定为理性）变成了对理性智能体设计的“局部”约束，并可以通过一个简单的程序来表示。
chap2_para1460,1,,对每个可能的时间步、16个方格中的每一个方格、4个方向中的每一个方向我们都需要类似这样的语句。
chap2_para1460,2,,对于其他动作，即抓取、射击、攀爬、左转、右转我们也需要类似的语句。
chap2_para1461,1,,假设智能体在时刻0决定向前移动，并在其知识库对此进行了断言。
chap2_para1461,2,,"给定式（7-1）的效应公理，结合时刻0时对状态的初始断言，智能体可以推得它位于[2, 1]。"
chap2_para1461,3,,也就是，Ask。
chap2_para1461,4,,到目前为止，一切还好。
chap2_para1461,5,,"遗憾的是，如果我们Ask(KB, HaveArrow1)，答案会是假，也就是智能体无法证明它仍然有箭，它也无法证明它没有箭！"
chap2_para1461,6,,信息丢失了，因为效应公理没有说明动作的结果未改变哪些状态。
chap2_para1461,7,,对这项功能的需求引出了框架问题。
chap2_para1461,8,,[12]框架问题的一个可能的求解办法是明确地添加断言所有不变命题的框架公理。
chap2_para1461,9,,例如，对于每个时刻t，我们有
chap2_para1463,1,,[12]　“框架问题”（frame problem）的名字来源于物理学中的参照系（frame of reference），也就是测量运动时假设的静止背景。
chap2_para1463,2,,电影的帧（frame）也借用了它的含义，其中前景变化时，大部分背景保持静止。
chap2_para1464,1,,其中明确地提到了在采取前进动作时所有从时刻t到时刻t+1维持不变状态的命题。
chap2_para1464,2,,尽管智能体现在已经知道它在前进后仍然有箭，且wumpus没有死去或复活，但激增的框架公理似乎相当低效。
chap2_para1464,3,,在有m个不同动作和n个流的世界，框架公理集的大小为O(mn)。
chap2_para1464,4,,这种框架问题被称作表示框架问题。
chap2_para1464,5,,这个问题在人工智能史上扮演过重要的角色，我们在本章最后的参考文献与历史注释中将进行进一步探索。
chap2_para1465,1,,表示框架问题很重要，因为即便保守来说，真实世界中的流也很多。
chap2_para1465,2,,幸运的是，对我们人类来说，每个动作改变的流通常不多于k个（k是某个较小的值），也就是说世界具有局部性。
chap2_para1465,3,,求解表示框架问题需要定义公理集大小为O(mk)而非O(mn)的转移模型。
chap2_para1465,4,,还有一个问题是推断框架问题：将t步动作规划的结果在O(kt)时间而非O(nt)时间内前向推进的问题。
chap2_para1466,1,,问题的解是关注于写出关于流而非动作的公理。
chap2_para1466,2,,这样的话，对于每个流F，以时刻t时的所有流（包括F本身）和时刻t时可能发生的动作来定义Ft+1的真值的公理。
chap2_para1466,3,,现在，Ft+1的真值可以用两种方法之一来确定：一种是时刻t的动作导致F在t+1为真，另一种是F在时刻t已经为真而时刻t的动作没有导致它为假。
chap2_para1466,4,,这种形式的公理叫作后继状态公理（successor-state axiom），具有如下形式：
chap2_para1467,1,,有箭（HaveArrow）的公理是最简单的后继状态公理。
chap2_para1467,2,,因为没有重新装填箭支的行动，ActionCausesFt部分可以去掉，所以我们有
chap2_para1469,1,,对智能体的位置来说，后继状态公理要更为复杂。
chap2_para1469,2,,"例如，如果（a）智能体在面向南方时从[1, 2]，或面向西方时从[2, 1]向前移动，或者（b）已经为真且动作未产生移动（因为动作不是向前或动作导致撞墙），则为真。"
chap2_para1469,3,,用命题逻辑写出，就是
chap2_para147,1,"We have described agent programs with various methods for selecting actions. We have not, so far, explained how the agent programs come into being. In his famous early paper, Turing (1950) considers the idea of actually programming his intelligent machines by hand. He estimates how much work this might take and concludes, “Some more expeditious method seems desirable.” The method he proposes is to build learning machines and then to teach them. In many areas of AI, this is now the preferred method for creating state-of-the-art systems. Any type of agent (model-based, goal-based, utility-based, etc.) can be built as a learning agent (or not).",基于效用的智能体结构如图2-14所示。
chap2_para147,2,,基于效用的智能体程序见第16章和第17章，其中设计了决策型智能体，必须处理非确定性或部分可观测环境中固有的不确定性。
chap2_para147,3,,如第18章所述，多智能体环境中的决策也在效用理论的框架下进行了研究。
chap2_para1471,1,,习题7.SSAX要求写出剩余的wumpus世界的流的公理。
chap2_para1472,1,,给定完整的后继状态公理和本节开始列出的其他公理，智能体就能够询问和回答世界当前状态的所有可解答问题。
chap2_para1472,2,,例如，在7.2节，感知和动作的初始序列是
chap2_para1473,1,,此时，有Ask，因此智能体知道它在什么位置。
chap2_para1473,2,,而且，Ask和Ask，因此智能体已经找到了wumpus和一个无底洞。
chap2_para1473,3,,对于智能体最重要的问题是一个方格是否能够进入，也就是这个方格是否没有无底洞也没有wumpus。
chap2_para1473,4,,为此添加公理很容易，形式如下：
chap2_para1474,1,,"最后，Ask，因此方格[2, 2]可以安全进入。"
chap2_para1474,2,,实际上，给定一个如DPLL的可靠且完备的推断算法，智能体可以回答关于哪个方格安全的任意可解答问题，而且对于小型到中型的wumpus世界可以在几毫秒内完成回答。
chap2_para1475,1,,求解表示框架问题和推断框架问题是一步重大的前进，但仍有一个亟待解决的问题：我们需要确认一个动作的所有必要的前提都成立才能保证结果效应。
chap2_para1475,2,,我们说过向前动作使智能体向前方移动，除非前方有墙，但也有许多其他意外会导致动作失败：智能体可能会被绊倒，会犯心脏病，会被巨型蝙蝠抓走，诸如此类。
chap2_para1475,3,,明确所有这些意外被称为资格问题（qualification problem）。
chap2_para1475,4,,它在逻辑学的范畴内没有完备的解，在决定要多么详细地明确模型以及要忽略哪些细节时，系统设计者必须做出很好的判断。
chap2_para1475,5,,我们将在第12章中看到，概率论允许以非显式的方式总结所有意外。
chap2_para1476,1,,7.7.2　混合智能体
chap2_para1477,1,,推导世界状态的多个方面的能力可以直接与条件-动作规则（见2.4.2节）以及第3章和第4章的问题求解算法结合，产生一个wumpus世界的混合智能体。
chap2_para1477,2,,图7-20展示了达成这个目标的一种可能方式。
chap2_para1477,3,,智能体程序维护并更新一个知识库和一个当前规划。
chap2_para1477,4,,初始知识库含有非时变公理——不依赖于时间t的公理，例如将方格的微风与无底洞的存在联系起来的公理。
chap2_para1477,5,,在每个时间步，新的感知和所有依赖于t的公理，如后继状态公理，被加入知识库。
chap2_para1477,6,,（7.7.3节将解释为何智能体不需要未来时间步的公理。
chap2_para1477,7,,）然后，智能体通过向知识库询问来使用逻辑推断，以找出哪些方格是安全的且未被访问过。
chap2_para1478,1,,智能体程序的主体根据目标优先级降序创建一个规划。
chap2_para1478,2,,首先，如果存在闪光，则程序创建一个抓取金块、原路返回初始位置并爬出洞穴的规划。
chap2_para1478,3,,否则，如果没有当前规划，程序会规划一个前往最近的、未被访问过的安全方格的路线，并确保路线仅经过安全方格。
chap2_para1479,1,,路径规划使用A*搜索算法完成，而没有用Ask。
chap2_para1479,2,,如果没有可探索的安全方格，下一步——如果智能体还有箭的话——就是试图对一个可能有wumpus的位置射击来创造一个安全方格。
chap2_para1479,3,,这是通过询问Ask在何处为假完成的，也就是智能体还不知道的没有wumpus的地方。
chap2_para1479,4,,函数Plan-Shot（图中未展示）使用Plan-Route规划一系列动作来完成这次射击。
chap2_para1479,5,,如果失败，则程序寻找尚未证明是不安全的方格，也就是询问Ask返回假的方格。
chap2_para1479,6,,"如果不存在这样的方格，则任务不可能完成，智能体撤退到[1, 1]并爬出洞穴。"
chap2_para148,1,"Learning has another advantage, as we noted earlier: it allows the agent to operate in initially unknown environments and to become more competent than its initial knowledge alone might allow.",图2-14　基于模型、基于效用的智能体。
chap2_para148,2,"In this section, we briefly introduce the main ideas of learning agents.",它使用了一个世界模型以及一个效用函数来衡量它在各状态之间的偏好，然后选择产生最佳期望效用的动作，其中期望效用是通过对所有可能的结果状态和对应概率加权所得
chap2_para148,3,"Throughout the book, we comment on opportunities and methods for learning in particular kinds of agents.",
chap2_para148,4,"Chapters 19, 21, 22, and 23 go into much more depth on the learning algorithms themselves.",
chap2_para1480,1,,图7-20　wumpus世界的一个混合智能体。
chap2_para1480,2,,它使用命题知识库来推断世界的状态，结合问题求解搜索和论域特定代码来选择动作。
chap2_para1480,3,,每次调用Hybrid-Wumpus-Agent，它都会将感知添加到知识库，然后依据先前定义的规划或创建一个新规划，弹出这个规划的第一步作为下一个要采取的动作
chap2_para1481,1,,7.7.3　逻辑状态估计
chap2_para1482,1,,图7-20所示的智能体工作得不错，但它有一个重大弱点：随着时间流逝，涉及对Ask调用的计算开销不断增大。
chap2_para1482,2,,这主要是由于所需的推断不得不回到越来越早的时间点，并涉及越来越多的命题符号。
chap2_para1482,3,,显然，这是不可持续的——我们不能让一个智能体处理每次感知的时间随着其寿命的增长成比例地增加！
chap2_para1482,4,,我们真正需要的是常数更新时间，也就是，与t无关。
chap2_para1482,5,,一个显然的答案是保存或缓存（cache）推断的结果，以便下一个时间步的推断过程构建在先前的结果上，而非必须从零开始。
chap2_para1483,1,,如我们在4.4节所见，感知的历史和所有其后果都可以用信念状态代替，即对所有可能的当前世界状态集合的某种表示[13]。
chap2_para1483,2,,在新感知到来时更新信念的过程被称为状态估计（见4.4.4节）。
chap2_para1483,3,,而在4.4节，信念状态是状态的显式列表，此处我们可以使用含有关于当前时间步的命题符号，以及非时变符号的逻辑语句。
chap2_para1483,4,,例如，逻辑语句
chap2_para1485,1,,[13]　我们可以认为感知历史本身就是一个信念状态的表示，但它是一个随着历史变长使得推断代价逐渐增加的表示。
chap2_para1487,1,,"代表时刻1的所有状态的集合，这时wumpus还活着，智能体位于[2, 1]，方格中有微风，[3, 1]或[2, 2]其中之一有无底洞或两个都有无底洞。"
chap2_para1488,1,,维护一个精确的、逻辑公式形式的信念状态并不简单。
chap2_para1488,2,,如果对于时刻t有n个流符号，则会有2n个可能的状态，也就是对这些符号的所有赋值。
chap2_para1488,3,,而现在，信念状态的集合是物理状态的超集（所有子集的集合）。
chap2_para1488,4,,总共有2n个物理状态，因此有个信念状态。
chap2_para1488,5,,即便我们对逻辑公式尽可能地使用紧凑的编码方式，即每个信念状态用一个二进制数表示，我们也需要位来标记当前的信念状态。
chap2_para1488,6,,也就是说，精确的状态估计需要的逻辑公式的规模可能是符号数量的指数级别的。
chap2_para1489,1,,一个用于近似状态估计的常见且自然的方法是用文字的合取式表示信念状态，即1-CNF公式。
chap2_para1489,2,,为此，智能体程序只需要在给定时刻t−1的信念状态的情况下，为每个符号X t证明X t和 （以及真值未知的非时变符号）即可。
chap2_para1489,3,,可证明文字的合取式成为了新的信念状态，先前的信念状态被丢弃。
chap2_para149,1,"A learning agent can be divided into four conceptual components, as shown in Figure 2.",说到这里，读者可能会想，“这么简单吗？
chap2_para149,2,15.,只需要构建能够最大化期望效用的智能体，我们就完成了？
chap2_para149,3,"The most important distinction is between the learning element, which is responsible for making improvements, and the performance element, which is responsible for selecting external actions.",”这类智能体确实是智能的，但这并不简单。
chap2_para149,4,The performance element is what we have previously considered to be the entire agent: it takes in percepts and decides on actions.,基于效用的智能体必须对其环境进行建模和跟踪，这些任务涉及大量关于感知、表示、推理和学习的研究。
chap2_para149,5,The learning element uses feedback from the critic on how the agent is doing and determines how the performance element should be modified to do better in the future.,这些研究结果填满了本书的许多章节。
chap2_para149,6,,选择效用最大化的行动方案也是一项艰巨的任务，需要更多的章节描述精巧的算法。
chap2_para149,7,,即使使用这些算法，由于计算复杂性，完美理性在实践中通常是无法实现的（正如我们在第1章中所指出的）。
chap2_para149,8,,我们还应该注意到，并非所有基于效用的智能体都是基于模型的。
chap2_para149,9,,我们将在第22章和第26章中看到，无模型的智能体（model-free agent）可以学习在特定情况下什么样的动作是最好的，而不必确切地了解该动作如何改变环境。
chap2_para1490,1,,要了解的是，随着时间流逝，这个方法可能会损失一些信息。
chap2_para1490,2,,"例如，如果式（7-4）的语句是真正的信念状态，则P3,1和P2,2都无法被单独证明，也都不会出现在1-CNF信念状态中。"
chap2_para1490,3,,（习题7.HYBR探索了这一问题的一个可行的解法。
chap2_para1490,4,,）另外，由于1-CNF信念状态中的每一个文字都是由前一信念状态证得的，而且初始信念状态是一个真实的断言，可得出整个1-CNF信念状态必然为真。
chap2_para1490,5,,因此，1-CNF信念状态所表示的可能状态的集合包含了给定全部感知历史时的所有确实可能的状态。
chap2_para1490,6,,如图7-21所示，1-CNF信念状态就是准确信念状态的一个外包络，即保守近似（conservative approximation）。
chap2_para1490,7,,我们可以在人工智能的许多领域反复见到复杂集合的保守近似这一概念。
chap2_para1491,1,,图7-21　1-CNF信念状态（粗实线外轮廓）作为对准确信念状态（虚线轮廓的深色区域）的简单的、可表示的保守近似。
chap2_para1491,2,,每个可能世界都使用圆圈表示，深色圆圈与所有感知一致
chap2_para1492,1,,7.7.4　用命题推断进行规划
chap2_para1493,1,,图7-20所示的智能体使用逻辑推断来确定哪个方格是安全的，但使用了A*搜索来进行规划。
chap2_para1493,2,,本节展示如何通过逻辑推断来进行规划。
chap2_para1493,3,,它的思想非常简单。
chap2_para1494,1,,（1）构建一个语句，它含有：
chap2_para1495,1,,a. 对于初始状态的断言集Init0；
chap2_para1496,1,,b. 到最大为时刻t为止的每一时间步的所有可能动作的后继状态公理 ；
chap2_para1497,1,,c. 目标在时刻t达成的断言。
chap2_para1498,1,,（2）将所有语句提供给SAT求解器。
chap2_para1498,2,,如果求解器找到一个可满足的模型，则目标是可达成的；如果语句不可满足，则问题无解。
chap2_para1499,1,,（3）假设找到了一个模型，从模型中提取代表动作并被赋值为true的变量。
chap2_para1499,2,,它们代表一个达成目标的规划。
chap2_para15,1,Description The block diagram starts with a block labeled Agent.,从图2-3中可以看到，通过以各种方式填充右边的列可以简单地定义各种真空世界的智能体。
chap2_para15,2,Three blocks are shown inside the Agent block.,那么，显而易见的问题是：填充表格的正确方法是什么？
chap2_para15,3,"The first block inside the agent block is labeled, What the world is like now.",换句话说，是什么使智能体表现好或坏、聪明或愚蠢？
chap2_para15,4,"An arrow from the first block points to the second block labeled, What action I should do now.",我们将在2.2节中回答这些问题。
chap2_para15,5,The third block is labeled Condition action rules and an arrow from the third block points to the second block.,
chap2_para15,6,An arrow from the second block points to the Actuators.,
chap2_para15,7,"An arrow from the actuators points to a block labeled Environment, which is outside the agent block.",
chap2_para15,8,An arrow from the environment block points to the sensors in the Agent block.,
chap2_para15,9,An arrow from the sensors points back to the first block.,
chap2_para150,1,"Figure 2.15A general learning agent. The “performance element” box represents what we have previously considered to be the whole agent program. Now, the “learning element” box gets to modify that program to improve its performance.",最后，所有这些都假设设计者能够正确地指定效用函数，第17章、第18章和第22章将更深入讨论未知效用函数的问题。
chap2_para1500,1,,图7-22展示了一个命题规划程序SATPlan。
chap2_para1500,2,,它实现了上述的想法，仅做了一点改变。
chap2_para1500,3,,由于智能体并不知道它需要多少步才能达成目标，算法会尝试每个可能的t步，直到某个可行的最大规划长度Tmax。
chap2_para1500,4,,这样，如果这一规划存在的话，它能够确保找到最短的规划。
chap2_para1500,5,,由于SATPlan搜索解的特定方式，它无法在部分可观测的环境中使用；SATPlan只能将不可观测的变量设定为它所需的值来求解。
chap2_para1501,1,,图7-22　SATPlan算法。
chap2_para1501,2,,规划问题被转换为CNF语句，其中目标被断言在固定的时间步t时成立，到t为止的每个时间步都含有公理。
chap2_para1501,3,,如果可满足性算法找到了一个模型，则通过查看指向动作并在模型中被赋值为true的命题符号来提取规划。
chap2_para1501,4,,如果模型不存在，则将目标后移一步，重复这一过程
chap2_para1502,1,,使用SATPlan的关键步骤是构建知识库。
chap2_para1502,2,,大体来看，7.7.1节所述的wumpus世界公理似乎足以构成上述步骤1中的a和b。
chap2_para1502,3,,但蕴含（正如用Ask来检验的那些）和可满足性对公理的要求有重要的区别。
chap2_para1503,1,,"例如，考虑智能体的位置初始为[1, 1]，假设智能体的目标仅为在时刻1时移动到[2, 1]。"
chap2_para1503,2,,初始知识库含有，目标为。
chap2_para1503,3,,如果断言Forward0，则我们可以使用Ask证得；如果被断言的是Shoot0，则我们无法证得。
chap2_para1503,4,,现在，SATPlan会找到规划[Forward0]，目前看起来没什么问题。
chap2_para1504,1,,遗憾的是，SATPlan也会找到规划[Shoot0]。
chap2_para1504,2,,为什么会这样呢？
chap2_para1504,3,,"要找出其原因，先检查一下SATPlan构建的模型：它包括赋值，也就是智能体可以在时刻0时就位于[2, 1]并进行射击，故而在时刻1时也会在[2, 1]。"
chap2_para1504,4,,"有人会问：“我们不是刚说过智能体在时刻0时位于[1, 1]吗？"
chap2_para1504,5,,”的确如此，但我们没有告诉智能体它不能同时位于两个位置！
chap2_para1504,6,,对蕴含来说，是未知的，因此不能被用于证明；而对于可满足性，是未知的，因此可以被设定为任意有助于达成目标的值。
chap2_para1505,1,,对知识库来说，SATPlan是很好的调试工具，因为它能够暴露出知识缺失的地方。
chap2_para1505,2,,在这个例子中，我们可以使用类似于用来断言恰恰只存在一个wumpus的语句集，来断言在每个时刻智能体只能位于一个位置，以修复知识库。
chap2_para1505,3,,"或者，我们可以对除[1, 1]之外的所有位置断言；关于位置的后继状态公理用于处理之后的时刻。"
chap2_para1505,4,,相同的修复方式也可以用于确保智能体在一个时刻有且仅有一个朝向。
chap2_para1506,1,,但SATPlan还有更怪异的表现。
chap2_para1506,2,,首先是，它会找出含有不可能采取的动作的模型，例如在没有箭支的时候射击。
chap2_para1506,3,,要理解其原因，我们需要更为仔细地查看后继状态公理，如式（7-3），对于前提无法满足的动作的描述。
chap2_para1506,4,,公理的确正确地预测了执行这种动作不会产生任何结果（见习题7.SATP），但它没有表明这一动作不能被执行！
chap2_para1506,5,,要避免生成含有不合规动作的规划，我们必须加入表明动作的出现需要满足其前提的前提公理（precondition axiom）。
chap2_para1506,6,,[14]例如，我们需要说，对于每个时刻t，有
chap2_para1508,1,,[14]　注意，加入前提公理意味着我们不再需要在后继状态公理中包含动作的前提条件。
chap2_para1509,1,,这就确保了如果规划在某一时刻选择采取动作Shoot，则此时智能体必然有一支箭。
chap2_para151,1,"The design of the learning element depends very much on the design of the performance element. When trying to design an agent that learns a certain capability, the first question is not “How am I going to get it to learn this?” but “What kind of performance element will my agent use to do this once it has learned how?” Given a design for the performance element, learning mechanisms can be constructed to improve every part of the agent.",2.4.6　学习型智能体
chap2_para1510,1,,SATPlan的另一个怪异的行为是它会创建具有多个同时进行的动作的规划。
chap2_para1510,2,,例如，它会生成一个Fotward0和Shoot0都为真的模型，而这是不允许的。
chap2_para1510,3,,要解决这个问题，我们引入动作排除公理（action exclusion axiom）：对于每对动作和，我们加入公理
chap2_para1511,1,,可能有人会提出同时向前走并射击并不是很困难，但如果是同时抓取并射击的话就相当不现实了。
chap2_para1511,2,,通过只对相互冲突的每对动作施以动作排除公理，可以使规划同时含有多个动作——而由于SATPlan能找出最短的合规规划，我们就可以确定它能够利用同时动作这个能力。
chap2_para1512,1,,总之，SATPlan能对含有初始状态、目标、后继状态公理、前提公理和动作排除公理的语句找出模型。
chap2_para1512,2,,由于不再存在任何错误的“解”，我们可以证明这一公理集是充分的。
chap2_para1512,3,,所有满足命题语句的模型都将是原始问题的有效解。
chap2_para1512,4,,现代SAT求解技术使得这一方法相当实用。
chap2_para1512,5,,例如，一个DPLL风格的求解器可以毫不费力地生成图7-2所示的wumpus世界的解。
chap2_para1513,1,,本节已经讲过构建智能体的一个陈述性方法：智能体通过结合在知识库中断言语句和执行逻辑推断运行。
chap2_para1513,2,,"这种方法有一些弱点，它们就隐含于类似“对于每个时刻t”和“对于每个方格[x, y]”这样的表述中。"
chap2_para1513,3,,对于所有实用的智能体，这些表述必须用从一般语句模式中自动生成实例的代码来实现，这些实例被用于插入知识库中。
chap2_para1513,4,,对于一个规模适中（相当于小型计算机游戏的大小）的wumpus世界，我们可能需要一个100×100的场地和1000个时间步，这样的话知识库中的语句就会有上亿条之多。
chap2_para1514,1,,这种情况不仅相当不现实，也揭露了一个深层次的问题：我们对wumpus世界的理解（即它的“物理学”在所有方格和所有时刻都一样）不能直接用命题逻辑的语言来表示。
chap2_para1514,2,,"要解决这个问题，我们需要更有表达能力的语言，也就是那种可以自然地写出像“对于每个时刻t”和“对于每个方格[x, y]”这种表述的语言。"
chap2_para1514,3,,第8章所述的一阶逻辑就是一种这样的语言。
chap2_para1514,4,,在一阶逻辑中，任意大小、任意时长的wumpus世界都可以用大约10条逻辑语句来描述，而非1000万条乃至1万亿条。
chap2_para1516,1,,我们已经介绍了基于知识的智能体，也展示了如何定义一种逻辑，以便使这种智能体能够对世界进行推理。
chap2_para1516,2,,本章重点如下。
chap2_para1517,1,,● 智能体需要关于世界的知识来获得良好的决策。
chap2_para1518,1,,● 知识包含在智能体中，其形式为存储于知识库中的、用知识表示语言表述的语句。
chap2_para1519,1,,● 一个基于知识的智能体由一个知识库和一套推断机制组成。
chap2_para1519,2,,它的运作方式是在知识库中存储关于世界的语句，使用推断机制推断新语句，并使用这些语句来决定采取何种动作。
chap2_para152,1,"The critic tells the learning element how well the agent is doing with respect to a fixed performance standard. The critic is necessary because the percepts themselves provide no indication of the agent’s success. For example, a chess program could receive a percept indicating that it has checkmated its opponent, but it needs a performance standard to know that this is a good thing; the percept itself does not say so. It is important that the performance standard be fixed. Conceptually, one should think of it as being outside the agent altogether because the agent must not modify it to fit its own behavior.",我们已经描述了一些智能体程序和选择动作的方法。
chap2_para152,2,,到目前为止，我们还没有解释智能体程序是如何产生的。
chap2_para152,3,,在图灵（Turing，1950）早期的著名论文中，他考虑手动编程实现智能机器的想法。
chap2_para152,4,,他估计了这可能需要多少工作量，并得出结论，“似乎需要一些更快捷的方法”。
chap2_para152,5,,他提出的方法是构造学习型机器，然后教它们。
chap2_para152,6,,在人工智能的许多领域，这是目前创建最先进系统的首选方法。
chap2_para152,7,,任何类型的智能体（基于模型、基于目标、基于效用等）都可以构建（或不构建）成学习型智能体。
chap2_para1520,1,,● 一种表示语言是用其语法和语义来定义的，语法规定了语句的结构，语义定义了每个可能世界或模型中每条语句的真值。
chap2_para1521,1,,● 语句之间的蕴含关系对于我们对推理的理解非常重要。
chap2_para1521,2,,在所有为真的世界中也为真，则语句蕴含语句。
chap2_para1521,3,,其等价定义包括语句的有效性和语句的不可满足性。
chap2_para1522,1,,● 推断是从旧语句推得新语句的过程。
chap2_para1522,2,,可靠的推断算法只推出蕴含的语句，完备的算法则可以推得所有蕴含的语句。
chap2_para1523,1,,● 命题逻辑是由命题符号和逻辑联结词构成的简单语言。
chap2_para1523,2,,它可以处理已知为真、为假或完全未知的命题。
chap2_para1524,1,,● 给出固定命题词汇表的前提下，可能的模型的集合是有限的，因此蕴含可以用枚举模型来检验。
chap2_para1524,2,,用于命题逻辑的高效模型检验推断算法包括回溯和局部搜索方法，它们通常能快速求解大规模问题。
chap2_para1525,1,,● 推断规则是可靠推断的模式，它可以用于证明。
chap2_para1525,2,,归结规则能产生一个用于知识库的完备推断算法，以合取范式的形式表示。
chap2_para1525,3,,前向链接和反向链接是霍恩形式知识库的非常自然的推理算法。
chap2_para1526,1,,● 如WalkSAT这样的局部搜索方法可以用于问题求解。
chap2_para1526,2,,这种算法是可靠的，但不是完备的。
chap2_para1527,1,,● 逻辑状态估计需要使描述可能状态集的逻辑语句与历史观测保持一致。
chap2_para1527,2,,每一步更新都需要使用环境的转移模型进行推断，转移模型是根据规定流的变化方式的后继状态公理构建的。
chap2_para1528,1,,● 逻辑智能体内部的决策可以用求解SAT的方式进行：找出描述能达到目标的未来动作序列的可能的模型。
chap2_para1528,2,,这个方法仅能用于完全可观测或无传感器环境。
chap2_para1529,1,,● 命题逻辑无法扩大到大小无限制的环境中，因为它有限的表达能力不能简洁地处理时间、空间和对象间关系的通用模式。
chap2_para153,1,"The last component of the learning agent is the problem generator. It is responsible for suggesting actions that will lead to new and informative experiences. If the performance element had its way, it would keep doing the actions that are best, given what it knows, but if the agent is willing to explore a little and do some perhaps suboptimal actions in the short run, it might discover much better actions for the long run. The problem generator’s job is to suggest these exploratory actions. This is what scientists do when they carry out experiments. Galileo did not think that dropping rocks from the top of a tower in Pisa was valuable in itself. He was not trying to break the rocks or to modify the brains of unfortunate pedestrians. His aim was to modify his own brain by identifying a better theory of the motion of objects.",正如我们之前提到的，学习还有另一个优势：它让智能体能够在最初未知的环境中运作，并变得比其最初的知识可能允许的能力更强。
chap2_para153,2,,在本节中，我们简要介绍学习型智能体的主要思想。
chap2_para153,3,,在整本书中，我们对特定类型智能体中的学习因素和方法的评论贯穿全书。
chap2_para153,4,,第19～22章将更加深入地介绍学习算法本身。
chap2_para1533,1,,在本章中，我们将注意到世界被赋予了许多对象，其中一些对象与另一些对象相关，而我们努力对其进行推理。
chap2_para1534,1,,命题逻辑足以展示逻辑、推断和基于知识的智能体的基本概念。
chap2_para1534,2,,遗憾的是，命题逻辑的表达能力有限。
chap2_para1534,3,,本章我们介绍一阶逻辑，[1]它可以简洁地表达更多东西。
chap2_para1534,4,,我们在8.1节中总体上讨论表示语言，在8.2节中介绍一阶逻辑的语法和语义，然后在8.3节和8.4节中展示一阶逻辑在简单表示中的运用。
chap2_para1536,1,,[1]　一阶逻辑也称为一阶谓词演算（first-order predicate calculus），可缩写为FOL或FOPC。
chap2_para1538,1,,本节我们讨论表示语言的特性。
chap2_para1538,2,,编程语言（如C++、Java或Python）是常用的最大一类形式化语言。
chap2_para1538,3,,程序中的数据结构可以用来表示事实，例如，程序可以使用一个4×4数组表示wumpus世界的内容。
chap2_para1538,4,,"这样的话，编程语言中的语句就是断言在方格[2, 2]中有无底洞的一种很自然的方式。"
chap2_para1538,5,,将一系列这样的语句合起来，就足以对wumpus世界进行模拟。
chap2_para1539,1,,编程语言欠缺的是从其他事实推导事实的通用机制：对数据结构的每次更新都要使用领域特定的过程，而过程中的具体细节是由程序员根据其自身所具有的该领域的知识进行推导的。
chap2_para1539,2,,这种过程性的方法可与命题逻辑的陈述性（declarative）特性相对比，在命题逻辑中知识与推断是独立的，而推断完全是领域无关的。
chap2_para1539,3,,SQL数据库融合了陈述性与过程性知识。
chap2_para154,1,"The learning element can make changes to any of the “knowledge” components shown in the agent diagrams (Figures 2.9, 2.11, 2.13, and 2.14). The simplest cases involve learning directly from the percept sequence. Observation of pairs of successive states of the environment can allow the agent to learn “What my actions do” and “How the world evolves” in response to its actions. For example, if the automated taxi exerts a certain braking pressure when driving on a wet road, then it will soon find out how much deceleration is actually achieved, and whether it skids off the road. The problem generator might identify certain parts of the model that are in need of improvement and suggest experiments, such as trying out the brakes on different road surfaces under different conditions.",学习型智能体可分为4个概念组件，如图2-15所示。
chap2_para154,2,,最重要的区别在于负责提升的学习元素（learning element）和负责选择外部行动的性能元素（performance element）。
chap2_para154,3,,性能元素是我们之前认为的整个智能体：它接受感知并决定动作。
chap2_para154,4,,学习元素使用来自评估者（critic）对智能体表现的反馈，并以此确定应该如何修改性能元素以在未来做得更好。
chap2_para1540,1,,"程序（以及数据库）中数据结构的另一个缺点是缺少简便的表示方式来描述像“在方格[2, 2]或[3, 1]中有无底洞”或“如果wumpus在[1, 1]中，则它不在[2, 2]中”这样的概念。"
chap2_para1540,2,,程序可以为每个变量存储一个值，一些系统也允许这个值为“未知”，但它们缺乏直接处理部分信息的表达能力。
chap2_para1541,1,,命题逻辑是说明性语言，因为它的语义是基于语句与可能世界之间的真值关系的。
chap2_para1541,2,,使用析取和否定，命题逻辑有了足够的表达能力来处理部分信息。
chap2_para1541,3,,命题逻辑还有一个在表示语言中很有用的特性，即合成性（compositionality）。
chap2_para1541,4,,在合成语言中，一条语句的含义是其各个组成部分的含义的一个函数。
chap2_para1541,5,,"例如，“S1,4 ∧ S1,2”的含义与“S1,4”和“S1,2”的含义有关。"
chap2_para1541,6,,"如果“S1,4”表示方格[1, 4]有臭味，“S1,2”表示方格[1, 2]有臭味，而“S1,4 ∧ S1,2”却表示法国与波兰在上周的冰球资格赛1∶1打平，就显得非常奇怪。"
chap2_para1542,1,,然而，命题逻辑作为一种因子化表示，缺乏能够简洁描述具有多个对象的环境的表达能力。
chap2_para1542,2,,例如，我们不得不为每个方格分别写出关于微风和无底洞的规则，如：
chap2_para1543,1,,而在英语中，我们似乎可以简单地用一句“Squares adjacent to pits are breezy.”（与无底洞相邻的方格有微风）来一举解决问题。
chap2_para1543,2,,英语的语法和语义使它能够简洁地描述环境：英语是结构化表示，一阶逻辑也是。
chap2_para1544,1,,8.1.1　思想的语言
chap2_para1545,1,,自然语言（如英语或西班牙语）确实富有表达能力。
chap2_para1545,2,,我们设法用自然语言写作这一整本书的几乎全部内容，只偶尔地转用其他语言（主要是数学和图表）。
chap2_para1545,3,,语言学和语言哲学将自然语言视为说明性知识表示语言由来已久。
chap2_para1545,4,,如果我们能够揭示自然语言的规则，我们就能将其用于表示和推理系统，并获益于数十亿页已经用自然语言写就的文字。
chap2_para1546,1,,自然语言的现代观点是将其视作交流的媒介而非单纯的表示。
chap2_para1546,2,,当说者指向一处并说“看！
chap2_para1546,3,,”听者就会明白他说的是超人终于出现在房顶了。
chap2_para1546,4,,但我们不能说是语句“看！
chap2_para1546,5,,”表示了这一事实。
chap2_para1546,6,,实际上，语句的含义既取决于语句本身，也取决于说出这一语句时的语境。
chap2_para1546,7,,显然，如果不在知识库中存储语句语境的表示而是仅存储像“看！
chap2_para1546,8,,”这样的语句，我们就无法搞清其含义——这就引发了语境本身该如何表示的问题。
chap2_para1547,1,,自然语言也受制于模糊性，这也是表示语言面临的问题。
chap2_para1547,2,,"正如平克（Pinker, 1995）所述：“当人们想到spring时，他们绝对不会困惑于他们到底是想到了一个季节还是想到了那个发出‘啵嘤’声的东西——如果一个词语可以对应于两种思想，那么思想就不能是词语。"
chap2_para1547,3,,”[2]
chap2_para1549,1,,[2]　表示“春天”和“弹簧”的英语单词都是spring。
chap2_para1549,2,,——译者注
chap2_para155,1,"Improving the model components of a model-based agent so that they conform better with reality is almost always a good idea, regardless of the external performance standard.",图2-15　通用学习型智能体。
chap2_para155,2,"(In some cases, it is better from a computational point of view to have a simple but slightly inaccurate model rather than a perfect but fiendishly complex model.",“性能元素”框表示我们之前认为的整个智能体程序，现在“学习元素”框可以修改该程序以提升其性能
chap2_para155,3,) Information from the external standard is needed when trying to learn a reflex component or a utility function.,
chap2_para1550,1,,"著名的萨丕尔-沃尔夫假说（Sapir-Whorf hypothesis）（Whorf, 1956）宣称，我们对世界的理解深受我们所说的语言的影响。"
chap2_para1550,2,,不同的语言群体以不同的方式划分世界。
chap2_para1550,3,,对英语使用者来说，“chair”一词囊括法语中“chaise”和“fauteuil”两个单词的概念，但英语使用者可以轻易地认出fauteuil这个类别，并给它命名——大概是“扶手椅”（open-arm chair）。
chap2_para1550,4,,那么语言真的会对理解有影响吗？
chap2_para1550,5,,沃尔夫主要依靠直觉和猜测，他的想法也已经基本被摒弃，但多年以来我们其实有来自人类学、心理学和神经科学研究的真实数据。
chap2_para1551,1,,例如，你是否还记得下列表述中的哪一个构成了8.1节的开头？
chap2_para1552,1,,“本节我们讨论表示语言的特性……”
chap2_para1553,1,,“本节讲述表示语言的相关知识……”
chap2_para1554,1,,"维纳（Wanner, 1974）进行了类似的实验并发现，实验对象做出正确选择的概率处于随机水平——大概为50%，但对阅读内容记忆的准确率却超过90%。"
chap2_para1554,2,,这意味着，人们会解读其阅读过的文字并形成内在的非文字表示，而确切的用词并不重要。
chap2_para1555,1,,当某个概念在一种语言里根本不存在时，情况就更加有趣。
chap2_para1555,2,,澳大利亚的土著语言Guugu Yimithirr的使用者没有词语来表示如前、后、左、右这样的相对（或自我中心）方向。
chap2_para1555,3,,他们只使用绝对方向，例如“我北边的胳膊有点疼”。
chap2_para1555,4,,这种语言上的区别就导致了行为的区别：Guugu Yimithirr使用者在开阔地形上的定向能力更好，而英语使用者则更擅长于将叉子放在盘子右侧。
chap2_para1556,1,,语言似乎也会通过类似名词的性这种看起来毫无规律的文法特征来影响思维。
chap2_para1556,2,,例如，“桥”在西班牙语中是阳性词，而在德语中是阴性词。
chap2_para1556,3,,"博罗迪茨基（Boroditsky, 2003）要求实验对象选取英语形容词来描述某座桥的照片。"
chap2_para1556,4,,西班牙语使用者选择了大（big）、危险（dangerous）、坚固（strong）、耸立（towering），而德语使用者则选择了优美（beautiful）、优雅（elegant）、脆弱（fragile）、纤细（slender）。
chap2_para1557,1,,词语可以充当我们感知世界的锚点。
chap2_para1557,2,,洛夫特斯和帕尔默（Loftus and Palmer，1974）向实验对象展示了汽车事故的影片，被问及“车辆接触时的车速是多少？
chap2_para1557,3,,”的实验对象报告的平均速度为51.5 km/h，而使用“撞击”替代问题中的“接触”后，对于同一部影片的同一辆车，被提问的实验对象报告的平均速度则为66 km/h。
chap2_para1557,4,,总体来看，不同语言的使用者在认知处理上有微小却可测出的区别，但并没有令人信服的证据能够说明这会引起世界观的重大区别。
chap2_para1558,1,,在使用合取范式（CNF）的逻辑推理系统中，我们知道语言表达式“”和“”是等价的，因为我们可以看到系统的内部，并能够了解到这两条语句是以完全相同的标准CNF形式存储的。
chap2_para1558,2,,而对人类的大脑进行类似的操作正在成为可能。
chap2_para1558,3,,"米切尔等人（Mitchell et al., 2008）让实验对象进入功能性磁共振成像（fMRI）仪，然后向他们展示如“芹菜”之类的词语，并对他们的大脑进行成像。"
chap2_para1558,4,,"使用(词语, fMRI图像)数据对训练而成的机器学习程序能够在二选一任务（例如，是“芹菜”还是“飞机”）中达到77%的准确率。"
chap2_para1558,5,,这套系统甚至能够对其先前从未见过fMRI图像的词语（通过考虑相关词语的图像）和从未见过的人（证明fMRI揭示了人脑的表示方式具有某种共性）达到超过随机猜测的准确率。
chap2_para1558,6,,"尽管这类研究还相当原始，但fMRI以及其他成像技术，例如颅内电生理学（Sahin et al., 2009），有望将人类的知识表示形式探究得更为详尽。"
chap2_para1559,1,,从形式化逻辑的观点来看，用两种不同的方式表示相同的知识一点区别都没有，无论从何种表示出发都能推出相同的事实。
chap2_para1559,2,,但在实际中，从其中一种表示推出结论的步骤可能更少，这意味着资源有限的推理机只能从这一种表示得出结论，而非其他表示。
chap2_para1559,3,,对于类似从经验中学习这样的非演绎任务，其结果必然地依赖于其所使用的表示。
chap2_para1559,4,,我们在第19章阐述了当学习程序考虑两种关于世界的理论时，如果这两种理论与所有数据都是一致的，那么最为常见的破局方式就是选择最简洁的理论，而这取决于用来表示理论的语言。
chap2_para1559,5,,那么，对任何进行学习的智能体来说，语言对思想的影响就是不可避免的。
chap2_para156,1,"For example, suppose the taxi-driving agent receives no tips from passengers who have been thoroughly shaken up during the trip. The external performance standard must inform the agent that the loss of tips is a negative contribution to its overall performance; then the agent might be able to learn that violent maneuvers do not contribute to its own utility. In a sense, the performance standard distinguishes part of the incoming percept as a reward (or penalty) that provides direct feedback on the quality of the agent’s behavior. Hard-wired performance standards such as pain and hunger in animals can be understood in this way.",学习元素的设计在很大程度上取决于性能元素的设计。
chap2_para156,2,,当设计者试图设计一个学习某种能力的智能体时，第一个问题不是“我要如何让它学习这个？
chap2_para156,3,,”而是“一旦智能体学会了如何做，它将使用什么样的性能元素？
chap2_para156,4,,”给定性能元素的设计，可以构造学习机制来改进智能体的每个部分。
chap2_para1560,1,,8.1.2　结合形式语言和自然语言的优点
chap2_para1561,1,,我们可以采用形式逻辑的基础——一种上下文无关的、无歧义的说明性、合成式语义——来构建一种更有表达能力的逻辑，同时又从自然语言中借鉴表示方法并避免其缺点。
chap2_para1561,2,,当我们考察自然语言时，最为显眼的元素就是指代对象的名词和名词性短语（方格、无底洞、wumpus）和动词与动词性短语以及表示对象关系的形容词和副词（有微风、相邻、射击）。
chap2_para1561,3,,这些关系当中有的是函数，即对于一个给定“输入”只有一个“值”的关系。
chap2_para1561,4,,很容易就能列出一些对象、关系和函数。
chap2_para1562,1,,● 对象：人、房屋、数字、理论、麦当劳叔叔、颜色、棒球游戏、战争、世纪等。
chap2_para1563,1,,● 关系：可以是一元关系或属性，如红色的、圆的、伪造的、主要的、多层的等，或更为普适的n元关系，如是……的兄弟、大于、在……里、是……的一部分、有……颜色、发生于……之后、拥有、在……中间等。
chap2_para1564,1,,● 函数： ……的父亲、……最好的朋友、……的第三局比赛、比……多一个、……的开始等。
chap2_para1565,1,,实际上，几乎所有断言都可以看作对对象和属性的指代或关系。
chap2_para1565,2,,下面是一些例子。
chap2_para1566,1,,● “1加2等于3”。
chap2_para1567,1,,对象：1、2、3、1加2。
chap2_para1567,2,,关系：等于。
chap2_para1567,3,,函数：加。
chap2_para1567,4,,（“1加2”是对对象“1”和“2”应用函数“加”后得到的对象的名称。
chap2_para1567,5,,“3”是这个对象的另一个名称。
chap2_para1567,6,,）
chap2_para1568,1,,● “与wumpus相邻的方格有臭味”。
chap2_para1569,1,,对象：wumpus、方格。
chap2_para1569,2,,属性：有臭味。
chap2_para1569,3,,关系：相邻。
chap2_para157,1,"More generally, human choices can provide information about human preferences. For example, suppose the taxi does not know that people generally don’t like loud noises, and settles on the idea of blowing its horn continuously as a way of ensuring that pedestrians know it’s coming. The consequent human behavior—covering ears, using bad language, and possibly cutting the wires to the horn—would provide evidence to the agent with which to update its utility function. This issue is discussed further in Chapter 23.",评估者告诉学习元素：智能体在固定性能标准方面的表现如何。
chap2_para157,2,,评估者是必要的，因为感知本身并不会指示智能体是否成功。
chap2_para157,3,,例如，国际象棋程序可能会收到一个感知，提示它已将死对手，但它需要一个性能标准来知道这是一件好事；感知本身并没有这么说。
chap2_para157,4,,确定性能标准很重要。
chap2_para157,5,,从概念上讲，应该把它看作完全在智能体之外，因为智能体不能修改性能标准以适应自己的行为。
chap2_para1570,1,,● “邪恶的约翰国王在1200年统治英格兰”。
chap2_para1571,1,,对象：约翰、英格兰、1200年。
chap2_para1571,2,,关系：统治。
chap2_para1571,3,,属性：邪恶的、国王。
chap2_para1572,1,,一阶逻辑语言是围绕对象和关系构建的，我们于下一节定义其语法和语义。
chap2_para1572,2,,它对于数学、哲学和人工智能乃至人类生活的很多方面都非常重要，因为这些领域要处理的正是对象和对象之间的关系。
chap2_para1572,3,,一阶逻辑也可以表示关于全域中的一些和全部对象的事实。
chap2_para1572,4,,这就使我们可以表示各种法则和规则，例如陈述“与wumpus相邻的方格很臭”。
chap2_para1573,1,,命题逻辑和一阶逻辑的主要区别在于其各自的本体论约定（ontological commitment），即它对真实世界性质的假设。
chap2_para1573,2,,数学上来说，这一约定是通过语句真值确定的形式化模型的性质来表示的。
chap2_para1573,3,,例如，命题逻辑假设世界中存在要么成立要么不成立的事实。
chap2_para1573,4,,每个事实都可以为真或假这两种状态中的一个，而每个模型为每个命题符号进行true或false的赋值（见7.4.2节）。
chap2_para1573,5,,一阶逻辑则进行了更多假设，它假设世界是由具有关系的对象组成的，这些关系要么成立要么不成立（见图8-1）。
chap2_para1573,6,,因此，一阶逻辑的形式化模型也就比命题逻辑更为复杂。
chap2_para1574,1,,图8-1　形式化语言及其本体论约定和认识论约定
chap2_para1575,1,,这种本体论约定是逻辑（包括命题逻辑和一阶逻辑）的强项，因为它允许我们从真实的陈述出发来推断其他真实的陈述。
chap2_para1575,2,,这对于每条命题都有清晰边界的领域非常有效，例如数学或wumpus世界。
chap2_para1575,3,,在wumpus世界中，一个方格要么有无底洞要么没有无底洞，那种有个像无底洞一样的大坑的方格是不存在的。
chap2_para1575,4,,但在真实世界中，许多命题的边界是模糊的：维也纳是大城市吗？
chap2_para1575,5,,那家餐厅的菜好吃吗？
chap2_para1575,6,,这个人高吗？
chap2_para1575,7,,这都取决于被你提问的人，而他们的回答可能是“还行吧”。
chap2_para1576,1,,对此，一种解决办法是细化表示：如果将城市分为“大”和“不大”的标准太粗略，使我们上述的应用中存在太多疑问，那么我们可以增加分类的个数，或使用Population这样的函数符号。
chap2_para1576,2,,另一种解决方案来源于模糊逻辑（fuzzy logic），它使用的本体论约定使得命题具有在0到1之间的真实度（degree of truth）。
chap2_para1576,3,,例如，语句“维也纳是大城市”在模糊逻辑中可能真实度是0.8，而“巴黎是一个大城市”则可能真实度是0.9。
chap2_para1576,4,,这更符合我们对真实世界的直观理解，但也更难进行推断：不同于确定A∧B真值的唯一规则，模糊逻辑在不同领域需要不同的规则。
chap2_para1576,5,,还有一个解决办法（将在24.1节阐述）是在多维空间中为每个概念分配一个点，并测量概念“大城市”与概念“巴黎”或“维也纳”的距离。
chap2_para1577,1,,不少特定用途的逻辑还进一步地进行了本体论约定，例如时态逻辑（temporal logic）假设事实在特定的时间成立，而这些时间（可能是时间点或时间区间）是有序的。
chap2_para1577,2,,这样，特定用途的逻辑就使某种对象（以及关于它们的公理）在这种逻辑内更“高级”，而非只是在知识库中对其进行定义。
chap2_para1577,3,,高阶逻辑（higher-order logic）将一阶逻辑中的关系和函数视作其自身的对象。
chap2_para1577,4,,这使我们能对所有关系进行断言，例如，我们可能想定义具有传递性的关系意味着什么。
chap2_para1577,5,,不同于大多数特定用途的逻辑，高阶逻辑的表达能力全面高于一阶逻辑，因为高阶逻辑的一些语句无法用有限数量的一阶逻辑语句来表示。
chap2_para1578,1,,一种逻辑的特性还包括其认识论约定（epistemological commitment），即这种逻辑允许每个事实所具有的可能知识状态。
chap2_para1578,2,,在命题逻辑和一阶逻辑中，一条语句表示一个事实，智能体只能选择相信其为真、相信其为假或没有意见。
chap2_para1578,3,,因此，这两种逻辑对于任何语句都具有3种可能的知识状态。
chap2_para1579,1,,而使用概率论（probability theory）的系统则可以有信任度或主观可能性，其值可以是从0（完全不信任）到1（完全信任）的任何值。
chap2_para1579,2,,千万不要将概率论中的信任度与模糊逻辑中的真实度搞混了。
chap2_para1579,3,,实际上，一些模糊系统允许对真实度具有不确定性（信任度）。
chap2_para1579,4,,"例如，一个概率的wumpus世界智能体可能相信wumpus在[1, 3]中的概率是0.75，而在[2, 3]中的概率是0.25（尽管wumpus肯定在某一个特定的方格中）。"
chap2_para158,1,"In summary, agents have a variety of components, and those components can be represented in many ways within the agent program, so there appears to be great variety among learning methods.",学习型智能体的最后一个组件是问题生成器（problem generator）。
chap2_para158,2,"There is, however, a single unifying theme.",它负责建议动作，这些动作将获得全新和信息丰富的经验。
chap2_para158,3,"Learning in intelligent agents can be summarized as a process of modification of each component of the agent to bring the components into closer agreement with the available feedback information, thereby improving the overall performance of the agent.",如果性能元素完全根据自己的方式，它会继续选择已知最好的动作。
chap2_para158,4,,但如果智能体愿意进行一些探索，并在短期内做一些可能不太理想的动作，那么从长远来看，它可能会发现更好的动作。
chap2_para158,5,,问题生成器的工作是建议这些探索性行动。
chap2_para158,6,,这就是科学家在进行实验时所做的。
chap2_para158,7,,伽利略并不认为从比萨斜塔顶端扔石头本身有价值。
chap2_para158,8,,他并不是想要打碎石头或改造不幸行人的大脑。
chap2_para158,9,,他的目的是通过确定更好的物体运动理论来改造自己的大脑。
chap2_para1580,1,,8.2　一阶逻辑的语法和语义
chap2_para1581,1,,本节我们先更为确切地阐述一阶逻辑的可能世界是如何反映其关于对象和关系的本体论约定的。
chap2_para1581,2,,随后我们介绍这种语言的几个组成部分，并解释其语义。
chap2_para1581,3,,本节的主旨是弄清这种语言如何进行简洁的表示，以及其语义如何形成完备的推理过程。
chap2_para1582,1,,8.2.1　一阶逻辑模型
chap2_para1583,1,,第7章讲过，逻辑语言的模型是组成目前正在考虑的可能世界的形式化结构。
chap2_para1583,2,,每个模型都将逻辑语句的词汇表连接到可能世界的元素，使得任意语句的真值可以被确定。
chap2_para1583,3,,因此，命题逻辑的模型将命题符号连接到预定义的真值表。
chap2_para1584,1,,一阶逻辑模型要有趣得多。
chap2_para1584,2,,首先，它们具有对象！
chap2_para1584,3,,模型的域（domain）是它包含的对象集或域元素的集合。
chap2_para1584,4,,域应当是非空的——每个可能世界至少要含有一个对象。
chap2_para1584,5,,（见习题8.EMTP了解关于空世界的讨论。
chap2_para1584,6,,）数学上来说，对象是什么无所谓——有意义的只是每个特定模型中有多少对象。
chap2_para1584,7,,但出于教学的考虑，我们会使用一个具体的例子。
chap2_para1584,8,,图8-2展示了一个具有5个对象的模型，这5个对象分别是英格兰1189年至1199年的国王狮心理查、1199年至1215年统治英格兰的邪恶的约翰国王（理查的弟弟）、理查的左腿、约翰的左腿和王冠。
chap2_para1585,1,,图8-2　含有5个对象、2个二元关系（兄弟和在头顶）、3个一元关系（人、国王和王冠）和1个一元函数（左腿）的模型
chap2_para1586,1,,这个模型中的对象可能有多方面的关系。
chap2_para1586,2,,图中，理查和约翰是兄弟。
chap2_para1586,3,,从形式上来看，关系就是相关对象的元组集。
chap2_para1586,4,,（一个元组是以固定顺序排列的一系列对象，使用尖括号将对象括起来表示。
chap2_para1586,5,,）这样，模型中的兄弟关系就是集合
chap2_para1588,1,,（此处我们已经命名了对象，但如果你愿意的话，你可以用图片代替对象名称。
chap2_para1588,2,,"）王冠在约翰国王的头顶，因此关系“在头顶”仅含有一个元组，〈王冠, 约翰国王〉。"
chap2_para1588,3,,“兄弟”关系和“在头顶”关系都是二元关系，也就是说，它们关联了一对对象。
chap2_para1588,4,,该模型还含有一元关系，或称为属性：“人”属性对于理查和约翰都为真；“国王”属性仅对于约翰为真（假设此时理查已经去世）；而“王冠”属性则仅对王冠为真。
chap2_para1589,1,,最好将某些类型的关系视为函数，因为这样的话给定一个对象，它必然仅关联到一个对象。
chap2_para1589,2,,例如，每个人都有一条左腿，因此模型含有一个一元“左腿”函数，即从一个单元素元组到一个对象的映射，它包括如下的映射：
chap2_para159,1,2.,学习元素可以对智能体图（图2-9、图2-11、图2-13和图2-14）中显示的任何“知识”组件进行更改。
chap2_para159,2,4.,最简单的情况是直接从感知序列学习。
chap2_para159,3,7How the components of agent programs work,观察成对相继的环境状态可以让智能体了解“我的动作做了什么”以及“世界如何演变”以响应其动作。
chap2_para159,4,,例如，如果自动驾驶出租车在湿滑路面上行驶时进行一定程度的刹车，那么它很快就会发现实际减速多少，以及它是否滑出路面。
chap2_para159,5,,问题生成器可能会识别出模型中需要改进的某些部分，并建议进行实验，例如在不同条件下的不同路面上尝试刹车。
chap2_para1591,1,,严格来说，一阶逻辑中的模型需要全函数（total function），也就是对于所有输入的元组都要有值。
chap2_para1591,2,,这样，王冠必须要有一条左腿，每条左腿也一样。
chap2_para1591,3,,对于这种尴尬的问题有一个技术解决方案，它需要增加一个“不可见”的对象来作为一切没有左腿的东西的左腿，包括它自己。
chap2_para1591,4,,幸运的是，只要没人对没有左腿的东西的左腿进行断言，这些技术细节就不重要。
chap2_para1592,1,,目前为止，我们已经描述了组成一阶逻辑模型所需的元素。
chap2_para1592,2,,模型的另一个重要部分是这些元素与逻辑语句的词汇表的联系，我们接下来进行介绍。
chap2_para1593,1,,8.2.2　符号与解释
chap2_para1594,1,,我们现在来了解一阶逻辑的语法。
chap2_para1594,2,,不耐烦的读者可以通过图8-3获得对形式化文法的完整描述。
chap2_para1595,1,,图8-3　包含等价关系的一阶逻辑语法，使用巴克斯-诺尔范式（如果你对此不熟悉，见附录B.1）。
chap2_para1595,2,,运算符优先级从高到低定义。
chap2_para1595,3,,量词的优先级为一个量词的优先级高于其右边的一切
chap2_para1596,1,,一阶逻辑的基本语法元素是代表对象、关系和函数的符号。
chap2_para1596,2,,因此，符号分为3种：代表对象的常量符号（constant symbol）、代表关系的谓词符号（predicate symbol）和代表函数的函数符号（function symbol）。
chap2_para1596,3,,我们采用的习惯是用大写字母开头来书写这些符号。
chap2_para1596,4,,例如，我们可以使用常量符号Richard（理查）和John（约翰），谓词符号Brother（是兄弟）、OnHead（在头顶）、Person（是人）、King（是国王）和Crown（是王冠），函数符号LeftLeg（……的左腿）。
chap2_para1596,5,,与命题符号一样，如何命名完全取决于使用者的意愿。
chap2_para1596,6,,每个谓词和函数符号都有一个决定参数数量的元数（arity）。
chap2_para1597,1,,每个模型必须提供所需的信息来确定任意给定语句为真还是为假。
chap2_para1597,2,,因此，除了它的对象、关系和函数，每个模型还要包含一套确切指明常量、谓词和函数符号指代的是哪个对象、关系和函数的解释（interpretation）。
chap2_para1597,3,,在我们的例子中，下面是一种可能的解释，也就是逻辑学家所说的预期解释（intended interpretation）。
chap2_para1598,1,,● Richard指狮心理查，John指邪恶的约翰国王。
chap2_para1599,1,,● Brother指兄弟关系，也就是式（8-1）给出的对象元组集，Onhead是连接王冠和约翰国王的关系，Person、King和Crown是识别人、国王和王冠的一元关系。
chap2_para16,1,Figure 2.,在结束本节之前，我们应该强调，智能体这一概念旨在成为分析系统的工具，而不是将世界划分为智能体和非智能体的绝对表征。
chap2_para16,2,3Partial tabulation of a simple agent function for the vacuum-cleaner world shown in Figure 2.,人们可以将手持计算器视为一个智能体，它在给定感知序列“2+2=”时选择显示“4”的动作，但这样的分析很难帮助我们理解计算器。
chap2_para16,3,2.,在某种意义上，工程的所有领域都可以被视为设计与世界互动的人工制品，人工智能运行在（作者认为是）这个系列最有趣的一端，在这一端，人工制品具有重要的计算资源，任务环境需要非凡的决策。
chap2_para16,4,"The agent cleans the current square if it is dirty, otherwise it moves to the other square.",
chap2_para16,5,Note that the table is of unbounded size unless there is a restriction on the length of possible percept sequences.,
chap2_para160,1,"We have described agent programs (in very high-level terms) as consisting of various components, whose function it is to answer questions such as: “What is the world like now?” “What action should I do now?” “What do my actions do?” The next question for a student of AI is, “How on Earth do these components work?” It takes about a thousand pages to begin to answer that question properly, but here we want to draw the reader’s attention to some basic distinctions among the various ways that the components can represent the environment that the agent inhabits.",无论外部性能标准如何，改进基于模型的智能体的组件，使其更好地符合现实几乎总是一个好主意。
chap2_para160,2,,（从计算的角度来看，在某些情况下简单但稍微不准确的模型比完美但极其复杂的模型更好。
chap2_para160,3,,）当智能体试图学习反射组件或效用函数时，需要外部标准的信息。
chap2_para1600,1,,● LeftLeg指式（8-2）定义的“左腿”函数。
chap2_para1601,1,,当然，模型还有很多种可能的解释。
chap2_para1601,2,,例如，一种解释将Richard映射到王冠而将John映射到约翰国王的左腿。
chap2_para1601,3,,模型中有5个对象，因此仅对常量符号Richard和John就有25种可能的解释。
chap2_para1601,4,,注意，并非所有对象都有名称。
chap2_para1601,5,,例如，预期解释并没有为王冠和腿命名。
chap2_para1601,6,,一个对象也可以有多个名称，在一种可能的解释中Richard和John都指代王冠。
chap2_para1601,7,,[3]如果你觉得这令人困惑，记住，在命题逻辑中，一个Cloudy（阴天）和Sunny（晴天）都为真的模型是完全可以存在的；排除与我们的知识不符的模型是知识库要做的事情。
chap2_para1603,1,,[3]　在随后的8.2.8节，我们会考察一种语义，其中每个对象只能有一个名称。
chap2_para1604,1,,总之，一阶逻辑中的模型包含一个对象集和一种解释，这种解释将常量符号映射到对象、将函数符号映射到关于这些对象的函数，将谓词符号映射到关系。
chap2_para1604,2,,与命题逻辑一样，蕴含、有效性等都是用所有可能模型来定义的。
chap2_para1604,3,,要大致了解可能模型集是什么样子的，见图8-4。
chap2_para1604,4,,图中显示，模型的区别在于它们包含的对象数量不同（从一到无穷多个），以及常量符号映射到对象的方式不同。
chap2_para1605,1,,图8-4　含有两个常量符号的语言中全部模型的集合的部分成员、R和J以及一个二元关系符号。
chap2_para1605,2,,每种常量符号的解释用灰色箭头标明。
chap2_para1605,3,,每个模型中，相关的对象用箭头连接
chap2_para1606,1,,由于一阶逻辑模型数量没有上限，我们无法通过枚举所有模型的方式（像我们对命题逻辑做的那样）来检验蕴含。
chap2_para1606,2,,即便对象的数量是有限的，其组合也会是巨量的。
chap2_para1606,3,,（见习题8.MCNT。
chap2_para1606,4,,）对图8-4中的例子来说，使用不超过6个对象就会产生137 506 194 466个模型。
chap2_para1608,1,,项（term）是指代对象的逻辑表达式。
chap2_para1608,2,,常量符号是项，但对每个对象都使用不同的符号命名往往不太方便。
chap2_para1608,3,,在语言中我们使用表达“约翰国王的左腿”而不是给他的腿起个名称来称呼。
chap2_para1608,4,,这就是函数符号存在的意义：我们使用LeftLeg(John)，而不是使用常量符号来命名这条腿。
chap2_para1608,5,,[4]
chap2_para161,1,"Roughly speaking, we can place the representations along an axis of increasing complexity and expressive power—atomic, factored, and structured. To illustrate these ideas, it helps to consider a particular agent component, such as the one that deals with “What my actions do.” This component describes the changes that might occur in the environment as the result of taking an action, and Figure 2.16 provides schematic depictions of how those transitions might be represented.",例如，假设出租车司机因为乘客在旅途中感到非常不适，没有收到小费。
chap2_para161,2,,外部性能标准必须告知智能体，小费的损失对其整体性能有负面影响；然后，该智能体可能会了解到暴力操作有损其自身的效用。
chap2_para161,3,,从某种意义上说，性能标准将传入感知的一部分区分为奖励（reward）或惩罚（penalty），以提供对智能体行为质量的直接反馈。
chap2_para161,4,,动物的疼痛和饥饿等固有的性能标准可以通过这种方式理解。
chap2_para1610,1,,[4]　表达式（-expression，lambda表达式）提供了一种很有用的记法，使得新的函数符号可以“即时”构建。
chap2_para1610,2,,例如，对参数进行平方操作的函数可以写作，并可以像其他函数符号那样直接用于参数。
chap2_para1610,3,,一个表达式也可以被定义为谓语符号并用作谓词符号。
chap2_para1610,4,,这与Lisp和Python中的lambda操作符的作用完全一致。
chap2_para1610,5,,注意，像这样使用并不能增加一阶逻辑的形式化表达能力，因为所有含有表达式的语句都能通过“插入”其参数的方式重写，生成一个等价的语句。
chap2_para1611,1,,通常情况下，复合项的组成是一个函数符号后跟随一个括号，括号中是一系列项，作为该函数符号的参数。
chap2_para1611,2,,需要注意的是，复合项只是复杂一些的名称，而非“返回一个值”的“子程序调用”。
chap2_para1611,3,,并不存在以一个人作为输入，返回一条腿的LeftLeg子程序。
chap2_para1611,4,,我们甚至可以在不定义LeftLeg的情况下就进行关于左腿的推理（例如，陈述一条一般规则“每个人都有左腿”，并进而推导出约翰必然有左腿）。
chap2_para1611,5,,这是无法在编程语言中用子程序实现的。
chap2_para1612,1,,项的形式化语义非常直白。
chap2_para1612,2,,"考虑项f(t1, …, tn)。"
chap2_para1612,3,,"函数符号f指代模型中的某个函数（不妨称为F），参数项指代域中的对象（称为d1, …, dn)），整个项就指代将函数F应用于d1, …, dn产生的对象，即函数的值。"
chap2_para1612,4,,例如，假设LeftLeg函数符号代表式（8-2）所示的函数，John代表约翰国王，则LeftLeg(John)代表约翰国王的左腿。
chap2_para1612,5,,这样，解释就确定了每个项的被指代物。
chap2_para1613,1,,8.2.4　原子语句
chap2_para1614,1,,我们现在已经有了指代对象的项以及指代关系的谓词符号，将它们结合起来可以构成陈述事实的原子语句。
chap2_para1614,2,,原子语句（或简称原子）是由谓词符号以及其后可能存在的括号中的一系列项组成的，例如：
chap2_para1615,1,,在先前给定的预期解释下，这条语句表明狮心理查是约翰国王的兄弟。
chap2_para1615,2,,[5]原子语句的参数可以是复合项，如
chap2_para1617,1,,"[5]　我们一般遵循P(x, y)读作“x是y的P”这样的参数排序习惯。"
chap2_para1618,1,,表明狮心理查的父亲娶了约翰国王的母亲（再次强调，在合适的解释下）。
chap2_para1618,2,,[6]
chap2_para162,1,,更一般地说，人类的选择可以提供有关人类偏好的信息。
chap2_para162,2,,例如，假设出租车不知道人们通常不喜欢噪声，于是决定不停地按喇叭以确保行人知道它即将到来。
chap2_para162,3,,随之而来的人类行为，如盖住耳朵、说脏话甚至可能剪断喇叭上的电线，将为智能体提供更新其效用函数的证据。
chap2_para162,4,,这个问题将在第22章进一步讨论。
chap2_para1620,1,,[6]　这个本体论认为每个人只有一位父亲和一位母亲。
chap2_para1620,2,,更为复杂的本体论可以识别出生物学母亲、生母、养母等。
chap2_para1621,1,,如果谓词符号所指代的关系在参数所指代的对象之间成立，则在给定模型中原子句为真。
chap2_para1622,1,,8.2.5　复合语句
chap2_para1623,1,,我们可以使用逻辑联结词构建更为复杂的语句，这与命题演算的语法和语义一样。
chap2_para1623,2,,下面是4条在我们的预期解释下在图8-2的模型中为真的语句：
chap2_para1625,1,,当我们有了支持对象的逻辑后，就很自然地想要表达很多对象的整体属性而非根据名称逐个列举对象。
chap2_para1625,2,,量词能使我们达到这一目的。
chap2_para1625,3,,一阶逻辑含有两个标准量词——全称量词和存在量词。
chap2_para1627,1,,回想我们在第7章用命题逻辑表示一般规则时面临的困难。
chap2_para1627,2,,像“与wumpus相邻的方格有臭味”和“所有国王都是人”这样的规则对一阶逻辑来说是最基本的。
chap2_para1627,3,,我们将在8.3节中解决第一条规则。
chap2_para1627,4,,而第二条规则“所有国王都是人”在一阶逻辑中写作
chap2_para1628,1,,全称量词∀通常读作“对所有……”。
chap2_para1628,2,,［记住，上下颠倒的A表示“all”（所有）。
chap2_para1628,3,,］因此，这条语句表示“对所有x，如果x是国王，则x是人”。
chap2_para1628,4,,符号x被称为变量。
chap2_para1628,5,,习惯上，变量用小写字母表示。
chap2_para1628,6,,一个变量本身就是一个项，因此也可以作为函数的参数，例如LeftLeg(x)。
chap2_para1628,7,,一个没有变量的项被称为基本项（ground term）。
chap2_para1629,1,,直观上来说，语句∀x P，其中P为任意逻辑语句，表明P对每个对象x都为真。
chap2_para1629,2,,更确切地说，如果P在根据一个模型的给定解释构建的所有可能扩展解释（extended interpretation）下为真，则∀x P在该模型中为真，其中每个扩展解释给出了x指代的域元素。
chap2_para163,1,Figure 2.,总之，智能体有各种各样的组件，这些组件可以在智能体程序中以多种方式表示，因此学习方法之间似乎存在很大差异。
chap2_para163,2,16Three ways to represent states and the transitions between them.,然而，主题仍然是统一的：智能体中的学习可以概括为对智能体的各个组件进行修改的过程，使各组件与可用的反馈信息更接近，从而提升智能体的整体性能。
chap2_para163,3,"(a) Atomic representation: a state (such as B or C) is a black box with no internal structure; (b) Factored representation: a state consists of a vector of attribute values; values can be Boolean, real-valued, or one of a fixed set of symbols.",
chap2_para163,4,"(c) Structured representation: a state includes objects, each of which may have attributes of its own as well as relationships to other objects.",
chap2_para1630,1,,这听起来很复杂，但它实际上只是陈述全称量词的直观含义的一种严谨的方式。
chap2_para1630,2,,考虑图8-2所示的模型及其相应的预期解释。
chap2_para1630,3,,我们可以用5种方式扩展这个解释：
chap2_para1636,1,,全称量化语句在原模型中为真的前提是语句在这5种扩展解释下都为真。
chap2_para1636,2,,也就是说，全称量化语句等价于如下5个断言：
chap2_para1637,1,,狮心理查是一位国王⇒ 狮心理查是一个人
chap2_para1638,1,,约翰国王是一位国王 ⇒ 约翰国王是一个人
chap2_para1639,1,,理查的左腿是一位国王 ⇒ 理查的左腿是一个人
chap2_para164,1,"In an atomic representation each state of the world is indivisible—it has no internal structure. Consider the task of finding a driving route from one end of a country to the other via some sequence of cities (we address this problem in Figure 3.1 on page 82). For the purposes of solving this problem, it may suffice to reduce the state of the world to just the name of the city we are in—a single atom of knowledge, a “black box” whose only discernible property is that of being identical to or different from another black box. The standard algorithms underlying search and game-playing (Chapters 3, 4, and 6), hidden Markov models (Chapter 14), and Markov decision processes (Chapter 16) all work with atomic representations.",2.4.7　智能体程序的组件如何工作
chap2_para1640,1,,约翰的左腿是一位国王 ⇒ 约翰的左腿是一个人
chap2_para1641,1,,王冠是一位国王 ⇒ 王冠是一个人
chap2_para1642,1,,让我们仔细研究这些断言。
chap2_para1642,2,,在我们的模型中，由于约翰国王是唯一的国王，因而第二条语句断言他是人，正如我们所料。
chap2_para1642,3,,那么其他4条语句呢？
chap2_para1642,4,,那些声明了腿和王冠的语句呢？
chap2_para1642,5,,这也是“所有国王都是人”含义的一部分吗？
chap2_para1642,6,,实际上，其他4条断言在模型中都为真，但并未对腿、王冠乃至理查作为人的资格进行任何声明。
chap2_para1642,7,,这是因为这些对象都不是国王。
chap2_para1642,8,,回顾⇒的真值表（图7-8），我们可以看到当前提为假时蕴涵式为真——无论其结论的真值是什么。
chap2_para1642,9,,因此，通过断言全称量化语句——它等价于断言每一条蕴涵式，我们最终仅对前提为真的对象断言规则的结论，而对前提为假的对象什么也不说。
chap2_para1642,10,,因此，⇒的真值表定义被证明非常适合用来编写含有全称量词的一般规则。
chap2_para1643,1,,即使是勤奋地将本节读了好几遍的读者也可能会犯的常见错误是使用合取式而非蕴涵式与全称量词搭配。
chap2_para1643,2,,语句
chap2_para1645,1,,狮心理查是国王∧狮心理查是人
chap2_para1646,1,,约翰国王是国王∧约翰国王是人
chap2_para1647,1,,理查的左腿是国王∧理查的左腿是人
chap2_para1649,1,,显然，这并不是我们想要表达的。
chap2_para165,1,"A factored representation splits up each state into a fixed set of variables or attributes, each of which can have a value. Consider a higher-fidelity description for the same driving problem, where we need to be concerned with more than just atomic location in one city or another; we might need to pay attention to how much gas is in the tank, our current GPS coordinates, whether or not the oil warning light is working, how much money we have for tolls, what station is on the radio, and so on. While two different atomic states have nothing in common—they are just different black boxes—two different factored states can share some attributes (such as being at some particular GPS location) and not others (such as having lots of gas or having no gas); this makes it much easier to work out how to turn one state into another. Many important areas of AI are based on factored representations, including constraint satisfaction algorithms (Chapter 5), propositional logic (Chapter 7), planning (Chapter 11), Bayesian networks (Chapters 12, 13, 14, 15, and 18), and various machine learning algorithms.",我们已经将智能体程序（用非常高级的术语）描述为由各种组件组成，其功能是回答诸如“现在的世界是什么样的？
chap2_para165,2,,”“我现在应该采取什么动作？
chap2_para165,3,,”“我的动作将导致什么？
chap2_para165,4,,”等问题。
chap2_para165,5,,人工智能学生的下一个问题是，“这些组件究竟是如何工作的？
chap2_para165,6,,”要正确回答这个问题大约需要一千页的篇幅，但在这里我们希望读者能够注意一些基本区别，即组件表示智能体所处环境的各种方式之间的区别。
chap2_para1651,1,,全称量词对所有对象进行陈述。
chap2_para1651,2,,反之，我们也可以对某些对象进行陈述而不需指明其名称。
chap2_para1651,3,,使用存在量词就可以实现这一点。
chap2_para1651,4,,例如，要说约翰国王的头顶有王冠，我们写作
chap2_para1652,1,,∃x读作“存在x使得……”或“对于一些x……”。
chap2_para1653,1,,直观上来说，语句∃x P说的是P至少对于一个对象x为真。
chap2_para1653,2,,更准确地说，如果P在至少一个将x分配给域元素的扩展解释下为真，则∃x P在给定模型中为真。
chap2_para1653,3,,也就是，下列语句中至少有一个为真：
chap2_para1654,1,,狮心理查是王冠 ∧ 狮心理查在约翰的头顶
chap2_para1655,1,,约翰国王是王冠 ∧ 约翰国王在约翰的头顶
chap2_para1656,1,,理查的左腿是王冠 ∧ 理查的左腿在约翰的头顶
chap2_para1657,1,,约翰的左腿是王冠 ∧ 约翰的左腿在约翰的头顶
chap2_para1658,1,,王冠是王冠 ∧ 王冠在约翰的头顶
chap2_para1659,1,,第五个断言在模型中为真，因此先前的存在量化语句在模型中为真。
chap2_para1659,2,,注意，根据我们的定义，这条语句在约翰国王戴了两顶王冠的模型中也为真。
chap2_para1659,3,,这与原始语句“约翰国王的头顶有王冠”完全不矛盾。
chap2_para1659,4,,[7]
chap2_para166,1,"For many purposes, we need to understand the world as having things in it that are related to each other, not just variables with values. For example, we might notice that a large truck ahead of us is reversing into the driveway of a dairy farm, but a loose cow is blocking the truck’s path. A factored representation is unlikely to be pre-equipped with the attribute TruckAheadBackinglntoDairyFarmDrivewayBlockedByLooseCow with value true or false. Instead, we would need a structured representation, in which objects such as cows and trucks and their various and varying relationships can be described explicitly (see Figure 2.16(c)). Structured representations underlie relational databases and first-order logic (Chapters 8, 9, and 10), first-order probability models (Chapter 18), and much of natural language understanding (Chapters 24 and 25). In fact, much of what humans express in natural language concerns objects and their relationships.",粗略地说，我们可以通过一个复杂性和表达能力不断增加的横轴来描述表示，即原子表示、因子化表示和结构化表示。
chap2_para166,2,,为了辅助说明这些观点，我们可以考虑特定的智能体组件，例如处理“我的动作会导致什么”。
chap2_para166,3,,这个组件描述了作为采取动作的结果可能在环境中引起的变化，图2-16展示了如何表示这些转移的示意图。
chap2_para1661,1,,[7]　存在量词有一个变种，通常写作∃1或∃!，意思是“恰好存在一个”。
chap2_para1661,2,,相同的含义可以用等词陈述表示。
chap2_para1662,1,,正如⇒是能自然地与∀合用的联结词一样，∧是与∃自然合用的联结词。
chap2_para1662,2,,使用∧作为∀的主要联结词会导致前面示例中的过强陈述，而使用⇒搭配∃则会导致过弱的陈述。
chap2_para1662,3,,考虑如下语句：
chap2_para1663,1,,表面来看，这似乎是对我们的语句的一种合理的表示。
chap2_para1663,2,,使用语义规则，我们发现该语句表达的是如下断言中至少一条为真：
chap2_para1664,1,,狮心理查是一顶王冠 ⇒ 狮心理查在约翰的头顶
chap2_para1665,1,,约翰国王是一顶王冠 ⇒ 约翰国王在约翰的头顶
chap2_para1666,1,,理查的左腿是一顶王冠 ⇒ 理查的左腿在约翰的头顶
chap2_para1668,1,,蕴涵式为真的条件是其前提和结论都为真，或其前提为假。
chap2_para1668,2,,因此，如果狮心理查不是一顶王冠，则第一条断言为真，存在量化语句被满足。
chap2_para1668,3,,因此，只要任一对象不能满足前提，存在量化的蕴涵式语句就为真。
chap2_para1668,4,,因而这种语句其实基本上什么都没说。
chap2_para167,1,"As we mentioned earlier, the axis along which atomic, factored, and structured representations lie is the axis of increasing expressiveness.",在原子表示（atomic representation）中，世界的每一个状态都是不可分割的，它没有内部结构。
chap2_para167,2,"Roughly speaking, a more expressive representation can capture, at least as concisely, everything a less expressive one can capture, plus some more.",考虑这样一个任务：通过城市序列找到一条从某个国家的一端到另一端的行车路线（我们在图3-1中会解决这个问题）。
chap2_para167,3,"Often, the more expressive language is much more concise; for example, the rules of chess can be written in a page or two of a structured-representation language such as first-order logic but require thousands of pages when written in a factored-representation language such as propositional logic and around 1038 pages when written in an atomic language such as that of finite-state automata.",为了解决这个问题，将世界状态简化为所处城市的名称就足够了，这就是单一的知识原子，也是一个“黑盒”，它唯一可分辨的属性是与另一个黑盒相同或不同。
chap2_para167,4,"On the other hand, reasoning and learning become more complex as the expressive power of the representation increases.",搜索和博弈中的标准算法（第3～5章）、隐马尔可夫模型（第14章）以及马尔可夫决策过程（第17章）都基于原子表示。
chap2_para167,5,"To gain the benefits of expressive representations while avoiding their drawbacks, intelligent systems for the real world may need to operate at all points along the axis simultaneously.",
chap2_para1670,1,,我们经常希望用多个量词表示更复杂的语句。
chap2_para1670,2,,最简单的情形是量词种类相同的情形。
chap2_para1670,3,,例如，“兄弟是同胞”可以写成
chap2_para1671,1,,连续的同类量词可以写成有多个变量的单个量词。
chap2_para1671,2,,例如，要表示同胞是对称关系，可以写成
chap2_para1672,1,,其他情况下，我们得混用量词。
chap2_para1672,2,,“每个人都喜爱一些人”意思是，对所有人都存在其喜爱的人：
chap2_para1673,1,,相反，要说“有人被所有人喜爱”，就写成
chap2_para1674,1,,因此，量词的顺序非常重要。
chap2_para1674,2,,添加括号会使语句看起来更清晰。
chap2_para1674,3,,表明每个人都有某种属性，也就是他们喜爱一些人的属性。
chap2_para1674,4,,反之，则表示世界上的一些人具有某种属性，即每个人都喜爱他们的属性。
chap2_para1675,1,,当两个量词与相同的变量名合用时会引起一些混淆。
chap2_para1675,2,,考虑语句
chap2_para1676,1,,"此处Brother(Richard, x)中的x是被存在量化的。"
chap2_para1676,2,,规则是，变量属于提及它的最内层量词，随后便不再受任何其他量词约束。
chap2_para1676,3,,"另一种考虑方式是，∃x Brother(Richard, x)是关于理查（有一个兄弟）的语句，不是关于x的语句；因此在外层放一个∀x并无效果。"
chap2_para1676,4,,"该语句一个等价的写法是∃z Brother (Richard, z)。"
chap2_para1676,5,,因为这可能是导致混淆的源头，所以我们会始终在嵌套量词中使用不同的变量名。
chap2_para1678,1,,∀与∃两个量词实际上通过否定词紧密相关。
chap2_para1678,2,,断言每个人都讨厌欧洲萝卜与断言不存在喜欢欧洲萝卜的人是等价的，反之亦然：
chap2_para168,1,"Another axis for representation involves the mapping of concepts to locations in physical memory, whether in a computer or in a brain.",因子化表示（factored representation）将每个状态拆分为一组固定的变量或属性，每个变量或属性都可以有一个值。
chap2_para168,2,"If there is a one-to-one mapping between concepts and memory locations, we call that a localist representation.",考虑同一驾驶问题更真实的描述，即我们需要关注的不仅仅是一个城市或另一个城市的原子位置，可能还需要关注油箱中的汽油量、当前的GPS坐标、油量警示灯是否工作、通行费、收音机上的电台等。
chap2_para168,3,"On the other hand, if the representation of a concept is spread over many memory locations, and each memory location is employed as part of the representation of multiple different concepts, we call that a distributed representation.",两个不同的原子状态没有任何共同点（只是不同的黑盒），但两个不同的因子化状态可以共享某些属性（如位于某个特定的GPS位置），而其他属性不同（如有大量汽油或没有汽油），这使得研究如何将一种状态转换为另一种状态变得更加容易。
chap2_para168,4,Distributed representations are more robust against noise and information loss.,人工智能的许多重要领域都基于因子化表示，包括约束满足算法（第6章）、命题逻辑（第7章）、规划（第11章）、贝叶斯网络（第12～16章）以及各种机器学习算法。
chap2_para168,5,"With a localist representation, the mapping from concept to memory location is arbitrary, and if a transmission error garbles a few bits, we might confuse Truck with the unrelated concept Truce.",
chap2_para168,6,"But with a distributed representation, you can think of each concept representing a point in multidimensional space, and if you garble a few bits you move to a nearby point in that space, which will have similar meaning.",
chap2_para1680,1,,我们可以更进一步——“每个人都喜欢冰激凌”意思是没有人不喜欢冰激凌：
chap2_para1682,1,,由于∀实际上是对全体对象的合取而∃则是析取，因此它们遵循德摩根律就不足为奇了。
chap2_para1682,2,,量化语句和非量化语句的德摩根律如下：
chap2_para1683,1,,因此，我们实际上并不同时需要∀和∃，正如我们不同时需要∧和∨一样。
chap2_para1683,2,,不过，可读性比简洁性更重要，因此我们同时保留这两种量词。
chap2_para1685,1,,除了使用前述的谓词和项，一阶逻辑还有一种构成原子语句的方式。
chap2_para1685,2,,我们可以使用等词符号（equality symbol）来表示两个项指代相同的对象。
chap2_para1685,3,,例如：
chap2_para1686,1,,Father(John) = Henry
chap2_para1687,1,,表示Father(John)指代的对象与Henry指代的对象是相同的。
chap2_para1687,2,,由于解释会固定所有项的被指代物，确定等词语句的真值就只需要观察两项的被指代物是否为相同的对象即可。
chap2_para1688,1,,等词符号可以用于陈述关于给定函数的事实，正如我们对Father符号所做的那样。
chap2_para1688,2,,它也可以与否定合用，表示两项不是相同的对象。
chap2_para1688,3,,要表示理查至少有两个兄弟，我们可以写成
chap2_para169,1,"This chapter has been something of a whirlwind tour of AI, which we have conceived of as the science of agent design.",图2-16　表示状态及其之间转移的3种方法：（a）原子表示一个状态（如B或C）是没有内部结构的黑盒；（b）因子化表示状态由属性值向量组成，值可以是布尔值、实值或一组固定符号中的一个；（c）结构化表示状态包括对象，每个对象可能有自己的属性以及与其他对象的关系
chap2_para169,2,The major points to recall are as follows:,
chap2_para1690,1,,就不能表示我们所期望的含义。
chap2_para1690,2,,具体来说，这条语句在图8-2的模型中也为真，尽管其中理查只有一个兄弟。
chap2_para1690,3,,要弄清楚这一点，考虑x和y都被指定到约翰国王的扩展解释。
chap2_para1690,4,,附加的排除了这种模型。
chap2_para1690,5,,记法可以用作的简写。
chap2_para1691,1,,8.2.8　数据库语义
chap2_para1692,1,,继续8.2.7节中的例子，假设我们相信理查有2个兄弟——约翰和杰弗里[8]，我们可以写
chap2_para1694,1,,[8]　实际上理查有4个兄弟，另外两个是威廉和亨利。
chap2_para1696,1,,但这并不能完全反映我们要表示的状态。
chap2_para1696,2,,首先，这条断言在理查只有一个兄弟的模型中也为真——我们需要加上。
chap2_para1696,3,,其次，这条语句没有剔除理查除了约翰和杰弗里还有很多其他兄弟的模型。
chap2_para1696,4,,因此，对“理查的兄弟是约翰和杰弗里”的正确翻译如下：
chap2_para1697,1,,这条逻辑语句似乎比对应的自然语言表述烦琐很多。
chap2_para1697,2,,如果不能恰当地翻译自然语言，我们的逻辑推理系统就会犯错。
chap2_para1697,3,,我们能否构思一种语义，使逻辑语句更加直白呢？
chap2_para1698,1,,一种在数据库系统中非常流行的做法的工作方式如下。
chap2_para1698,2,,首先，我们确定每个常量符号都指代一个唯一的对象——唯一名称假设（unique-names assumption）。
chap2_para1698,3,,然后，我们假设未知其为真的原子语句事实上都为假——封闭世界假设（closed world assumption）。
chap2_para1698,4,,最后，我们调用域闭包（domain closure），意味着每个模型中的域元素不多于常量符号指代的那些。
chap2_para1699,1,,在由此产生的语义中，式（8-3）的确能表明理查仅有两个兄弟，约翰和杰弗里。
chap2_para1699,2,,我们称之为数据库语义（database semantics），以区别于标准的一阶逻辑语义。
chap2_para1699,3,,数据库语义也用于逻辑编程系统中，在9.4.4节我们对此进行解释。
chap2_para17,1,"Before closing this section, we should emphasize that the notion of an agent is meant to be a tool for analyzing systems, not an absolute characterization that divides the world into agents and non-agents. One could view a hand-held calculator as an agent that chooses the action of displaying “4” when given the percept sequence “2 + 2 =,” but such an analysis would hardly aid our understanding of the calculator. In a sense, all areas of engineering can be seen as designing artifacts that interact with the world; AI operates at (what the authors consider to be) the most interesting end of the spectrum, where the artifacts have significant computational resources and the task environment requires nontrivial decision making.",图2-3　图2-2所示的真空吸尘器世界的简单智能体函数的部分表项。
chap2_para17,2,,如果当前方格是脏的，智能体就会进行清理，否则它将移到另一个方格。
chap2_para17,3,,注意，除非限制可能感知序列的长度，否则该表的大小是无限的
chap2_para170,1,•An agent is something that perceives and acts in an environment. The agent function for an agent specifies the action taken by the agent in response to any percept sequence.,出于许多目的，我们需要将世界理解为存在着相互关联的事物，而不仅仅是具有值的变量。
chap2_para170,2,,例如，我们可能会注意到前面有一辆卡车正在倒车进入一个奶牛场的车道，但一头散养的奶牛挡住了卡车的路。
chap2_para170,3,,因子化表示不太可能为属性TruckAheadBackingIntoDairyFarmDrivewayBlockedByLooseCow预先配备true或false的值。
chap2_para170,4,,这就需要一个结构化表示（structured representation），在这种表示中可以明确地描述诸如奶牛和卡车之类的对象及其各种不同的关系（见图2-16c）。
chap2_para170,5,,结构化表示是关系数据库和一阶逻辑（第8～10章）、一阶概率模型（第15章）和大部分自然语言理解（第23章和第24章）的基础。
chap2_para170,6,,事实上，人类用自然语言表达的大部分内容都与对象及其关系有关。
chap2_para1700,1,,在数据库语义里考虑图8-4所示的情形中的所有可能的模型是很有指导性的。
chap2_para1700,2,,图8-5展示了其中一些模型，从没有元组满足关系的模型到所有元组都满足关系的模型。
chap2_para1700,3,,在有两个对象的情况下，有4种可能的二元素元组，存在24 = 16种不同的元组子集满足关系。
chap2_para1700,4,,因此，总共有16种可能模型——大大少于标准一阶逻辑语法下巨量的模型数量。
chap2_para1700,5,,不过，数据库语义需要世界中包含的东西的确定知识。
chap2_para1701,1,,图8-5　在数据库语义下，含有两个常量符号R和J以及一个二元关系符号的语言中的全部模型集的一部分成员。
chap2_para1701,2,,常量符号的解释是固定的，每个常量符号有唯一的对象
chap2_para1702,1,,这个例子引发了一个重要的观点：逻辑中不存在“正确的”语义。
chap2_para1702,2,,提出的语义的有用性取决于它对我们想要记录的知识的表示是否简洁和直观，以及相应的推断规则的生成是否容易和自然。
chap2_para1702,3,,当我们明确了知识库中描述的所有对象的身份，并且掌握了所有事实的时候，数据库语义最有用，而在其他情况下，数据库语义就很棘手。
chap2_para1702,4,,本章剩余部分，我们默认使用标准语义，并会在这种语义使表达变得非常繁琐的实例中另行标注。
chap2_para1703,1,,8.3　使用一阶逻辑
chap2_para1704,1,,现在我们已经定义了一种很有表达能力的逻辑语言，接下来我们学习如何使用它。
chap2_para1704,2,,本节，我们在一些简单的论域（domain）中给出范例语句。
chap2_para1704,3,,在知识表示中，论域是指我们要表示其知识的那部分世界。
chap2_para1705,1,,我们从简要地解释一阶知识库中的Tell/Ask推断开始。
chap2_para1705,2,,随后我们考察家庭关系、数、集合、列表以及wumpus世界论域。
chap2_para1705,3,,8.4.2节展示一个更大规模的示例（电子电路），而第10章则涵盖了宇宙万物。
chap2_para1706,1,,8.3.1　一阶逻辑的断言与查询
chap2_para1707,1,,语句是通过Tell添加到知识库的，与在命题逻辑中完全一样。
chap2_para1707,2,,这种语句被称为断言（assertion）。
chap2_para1707,3,,例如，我们可以断言约翰是国王、理查是人以及所有的国王都是人：
chap2_para1708,1,,我们可以使用Ask对知识库提问。
chap2_para1708,2,,例如：
chap2_para1709,1,,返回true。
chap2_para1709,2,,使用Ask提出的问题被称为查询或目标。
chap2_para1709,3,,一般来说，知识库中逻辑蕴含的所有查询都应该得到肯定的回答。
chap2_para1709,4,,例如，给定上述3条断言，查询
chap2_para171,1,"•The performance measure evaluates the behavior of the agent in an environment. A rational agent acts so as to maximize the expected value of the performance measure, given the percept sequence it has seen so far.",如前所述，原子表示、因子化表示和结构化表示所在的轴是表达性（expressiveness）增强的轴。
chap2_para171,2,,粗略地说，可以通过简洁的描述捕捉到更具表达性的表示，表达性差的表示也可以捕捉到一切，但需要更多描述。
chap2_para171,3,,通常，表达性更强的语言更简洁；例如，国际象棋规则可以用一两页结构化表示语言（如一阶逻辑）来描述，但需要数千页因子化表示语言（如命题逻辑）来描述，而需要1038页的原子语言（如有限状态自动机）来描述。
chap2_para171,4,,但是，随着表示能力的增强，推理和学习变得更加复杂。
chap2_para171,5,,为了在避免缺点的同时获得表达性表示的好处，真实世界中的智能系统可能需要轴上的所有点同时运行。
chap2_para1710,1,,应该也返回true。
chap2_para1710,2,,我们可以提出量化的问题，例如：
chap2_para1711,1,,答案为true，但它可能并不是我们想要的答案。
chap2_para1711,2,,它就像用“可以”回答“你能告我现在几点了吗？
chap2_para1711,3,,”一样。
chap2_para1711,4,,如果我们想了解使语句为真的x的值，我们就需要另一个函数AskVars：
chap2_para1712,1,,将返回一系列答案。
chap2_para1712,2,,在这个例子中有两个答案：以及。
chap2_para1712,3,,这种回答叫作置换（substitution）或绑定表（binding list）。
chap2_para1712,4,,AskVars通常与仅由霍恩子句构成的知识库合用，因为在这种知识库中，每种使查询为真的方式都将变量绑定到特定的值。
chap2_para1712,5,,而一阶逻辑中并不存在这种状况：在KB仅被告知King(John)的情况下，不存在使得查询∃x King(x)为真的x的单个绑定，即使这条查询实际上为真。
chap2_para1713,1,,8.3.2　亲属关系论域
chap2_para1714,1,,我们第一个考虑的范例是家庭关系（或称亲属关系）论域。
chap2_para1714,2,,这个论域包括类似“伊丽莎白是查尔斯的母亲”和“查尔斯是威廉的父亲”这样的事实，以及类似“一个人的祖母（外祖母）是他父母的母亲”这样的规则。
chap2_para1715,1,,显然，这个论域的对象是人。
chap2_para1715,2,,一元谓词包括Male和Female等。
chap2_para1715,3,,亲属关系（父母、兄弟、婚姻等）使用二元谓词表示：Parent、Sibling、Brother、Sister、Child、Daughter、Son、Spouse、Wife、Husband、Grandparent、Grandchild、Cousin、Aunt和Uncle。
chap2_para1715,4,,我们用函数表示Mother和Father，因为从生物学角度来说，每个人只有一对父母（尽管我们可以引入更多函数来处理养母、代孕妈妈等）。
chap2_para1716,1,,我们可以考察每个函数和谓词，并就我们知道的写下它们与其他符号的关系。
chap2_para1716,2,,例如， 一个人的母亲就是他父母中的女性成员：
chap2_para1717,1,,一个人的丈夫是她的男性配偶：
chap2_para1718,1,,父母与孩子是反关系：
chap2_para1719,1,,祖父母（外祖父母）是一个人父母的父母：
chap2_para172,1,"•A task environment specification includes the performance measure, the external environment, the actuators, and the sensors. In designing an agent, the first step must always be to specify the task environment as fully as possible.",另一个表示轴涉及从概念到物理记忆中位置的映射，包括计算机的内存和大脑的记忆。
chap2_para172,2,,如果概念和记忆位置之间存在一对一的映射，我们称之为局部表示（localist representation）。
chap2_para172,3,,但是，如果一个概念的表示分布在多个记忆位置，并且每个记忆位置被用作多个不同概念表示的一部分，我们称之为分布式表示（distributed representation）。
chap2_para172,4,,分布式表示对噪声和信息丢失更健壮。
chap2_para172,5,,使用局部表示，从概念到记忆位置的映射是随机的，如果传输错误而导致几位乱码，我们可能会将卡车（Truck）与无关的概念停战（Truce）混淆。
chap2_para172,6,,但在分布式表示中，可以把每个概念想象成多维空间中的一个点，即使有一些乱码，也会移动到该空间中附近的点，其具有相似的含义。
chap2_para1720,1,,兄弟姐妹是一个人父母的其他孩子：
chap2_para1721,1,,我们可以像这样写出很多页，这正是习题8.KINS的题目。
chap2_para1722,1,,所有这些语句都可以看作亲属关系论域中的公理，如7.1节所阐述。
chap2_para1722,2,,公理通常与纯数学论域相关（我们很快就能看到一些关于数字的公理），但它们在所有论域都有用。
chap2_para1722,3,,它们提供了用于推导有用结论的基本因子化信息。
chap2_para1722,4,,我们的亲属关系公理同时也是定义，它们具有形式。
chap2_para1722,5,,公理用其他谓词定义了Mother函数以及Husband、Male、Parent、Grandparent和Sibling谓词。
chap2_para1722,6,,我们的定义从基本的谓词集（Child、Female等）发展而来，并以此最终定义其他谓词。
chap2_para1723,1,,这是构建一个论域的表示的自然方式，类似于用基本的库函数定义子程序，再用子程序构建软件包。
chap2_para1723,2,,注意，基本谓词集并不一定是唯一的，我们可以使用Parent而非Child来得到同样的结果。
chap2_para1723,3,,像我们所展示的一样，在一些论域中并不存在清晰可辨的基本谓词集。
chap2_para1724,1,,并非所有关于论域的逻辑语句都是公理，其中一些是定理，也就是说，它们被公理所蕴含。
chap2_para1724,2,,例如，考虑如下关于兄弟姐妹关系对称性的断言：
chap2_para1725,1,,这条语句是公理还是定理？
chap2_para1725,2,,实际上，它是与定义兄弟姐妹的公理逻辑一致的定理。
chap2_para1725,3,,如果我们用这条语句Ask知识库，它应当返回true。
chap2_para1726,1,,从纯逻辑的观点来看，知识库应当只包含公理并且不含有定理，因为定理并不能增加从知识库导出的结论集。
chap2_para1726,2,,从实用的角度来看，定理对于降低推导新语句的计算开销是很有意义的。
chap2_para1726,3,,没有定理，推理系统就不得不每次都从基本原则出发，就像物理学家每次求解问题时都要重新推导微积分的法则一样。
chap2_para1727,1,,并非所有的公理都是定义。
chap2_para1727,2,,一些公理提供了关于某些谓词的更一般的信息，却不构成定义。
chap2_para1727,3,,实际上，一些谓词并没有完整的定义，因为我们不具有完全刻画它们的知识。
chap2_para1727,4,,例如，没有显而易见的定义方式能够完成语句
chap2_para1728,1,,幸运的是，一阶逻辑允许我们使用Person谓词而无须对其进行完整定义。
chap2_para1728,2,,不过我们可以写出每个人具有的性质和使某物成为人的性质：
chap2_para1729,1,,"公理也可以是“直白的事实”，例如Male(Jim)和Spouse(Jim, Laura)。"
chap2_para1729,2,,这些来自特定问题实例描述的事实使特定的提问能够得到解答。
chap2_para1729,3,,如果一切顺利的话，这些问题的答案会成为与公理逻辑一致的定理。
chap2_para173,1,"•Task environments vary along several significant dimensions. They can be fully or partially observable, single-agent or multiagent, deterministic or nondeterministic, episodic or sequential, static or dynamic, discrete or continuous, and known or unknown.",
chap2_para1730,1,,"我们常常会发现期望的答案不是现成的，例如，从Spouse(Jim, Laura)出发，我们期望（根据很多国家的法律）能推得，但这并不能由先前给出的公理推导得出，即便在我们像8.2.8节所述的那样添加也不行。"
chap2_para1730,2,,这表明缺失了一条公理。
chap2_para1730,3,,习题8.HILL要求读者提供这条公理。
chap2_para1731,1,,8.3.3　数、集合与列表
chap2_para1732,1,,数可能是展示从一小部分核心公理构建庞大理论的最生动的示例。
chap2_para1732,2,,我们在此阐述自然数或称非负整数的理论。
chap2_para1732,3,,我们需要谓词NatNum对于自然数为真，我们还需要常量符号0，以及一个函数符号S（后继）。
chap2_para1732,4,,皮亚诺公理（Peano axioms）定义了自然数和加法。
chap2_para1732,5,,[9]自然数是递归定义的：
chap2_para1734,1,,[9]　皮亚诺公理还包括归纳法则，但它是二阶逻辑的语句而非一阶逻辑。
chap2_para1734,2,,这种区别的重要性将在第9章中进行解释。
chap2_para1735,1,,也就是说，0是自然数，对于每一个对象n，如果n是自然数，则S(n)是自然数。
chap2_para1735,2,,"因此自然数是0, S(0), S(S(0)), …。"
chap2_para1735,3,,我们还需要约束后继函数的公理：
chap2_para1736,1,,现在我们就可以用后继函数定义加法：
chap2_para1737,1,,这些公理中，第一个公理表示对任何自然数m加0等于m本身。
chap2_para1737,2,,"注意，在+(m, 0)项中二元函数符号“+”的使用：在普通数学中，这一项会使用中缀（infix）记法写作m + 0。"
chap2_para1737,3,,［我们在一阶逻辑中使用的记法称为前缀（prefix）。
chap2_para1737,4,,］为使我们关于数的语句更容易阅读，我们允许使用中缀记法。
chap2_para1737,5,,我们可以将S(n)写成n + 1，因此第二个公理变为
chap2_para1738,1,,这条公理将加法简化为对后继函数的反复应用。
chap2_para1739,1,,使用中缀记法是一个语法糖（syntactic sugar）的示例。
chap2_para1739,2,,语法糖是一种对标准语法的扩展或缩略，但不改变语义。
chap2_para1739,3,,所有使用糖的语句都可以“脱糖”生成普通一阶逻辑中的等价语句。
chap2_para1739,4,,还有一个示例是使用方括号而非圆括号来使左右括号的对应关系更易读。
chap2_para1739,5,,而另一个示例是量词折叠：用代替。
chap2_para174,1,"•In cases where the performance measure is unknown or hard to specify correctly, there is a significant risk of the agent optimizing the wrong objective. In such cases the agent design should reflect uncertainty about the true objective.",本章是人工智能的旋风之旅，在这个过程中我们认为人工智能是智能体设计的科学。
chap2_para174,2,,本章要回顾的要点如下。
chap2_para1740,1,,我们有了加法以后，将乘法定义为重复的加法、乘方定义为连续的乘法就是顺理成章的事情，同样我们可以定义整数除法和余数、质数等。
chap2_para1740,2,,这样，整个数论（包括密码学）就能从一个常量、一个函数、一个谓词和4条公理开始构建起来。
chap2_para1741,1,,集合的论域对数学和常识推理也是非常重要的。
chap2_para1741,2,,（实际上，可以用集合论来定义数论。
chap2_para1741,3,,）我们希望能够表示每个集合，包括空集。
chap2_para1741,4,,我们需要一种方法用其他集合的元素或对其他集合的操作构建集合。
chap2_para1741,5,,我们想知道一个元素是否是集合的成员，也需要区分一个对象是否是集合。
chap2_para1742,1,,我们将使用集合论中的一般词汇作为语法糖。
chap2_para1742,2,,空集是一个常量，写作{}。
chap2_para1742,3,,一元谓词Set对集合为真。
chap2_para1742,4,,二元谓词包括（x是集合s的成员）以及（集合s1是集合s2的子集，两个集合也可以相同）。
chap2_para1742,5,,"二元函数是（交集）、（并集）和Add(x, s)（将元素x添加到集合s生成的集合）。"
chap2_para1742,6,,下面是一个可能的公理集。
chap2_para1743,1,,（1）集合只能是空集和向集合中添加元素产生的集合：
chap2_para1744,1,,（2）空集没有被加入的元素。
chap2_para1744,2,,换言之，无法将空集分解为更小的集合和元素：
chap2_para1745,1,,（3）对集合添加已有元素没有作用：
chap2_para1746,1,,（4）集合中的成员只能是被添加到集合中的元素。
chap2_para1746,2,,我们用递归的形式表示它：声明x是s中的元素，当且仅当s等于某个将元素y添加到集合s2后的集合，其中y与x相同，或x是s2的成员：
chap2_para1747,1,,（5）一个集合是另一个集合的子集当且仅当第一个集合的所有成员都是第二个集合的成员：
chap2_para1748,1,,（6）两个集合相等当且仅当它们互为对方的子集：
chap2_para1749,1,,（7）一个对象在两个集合的交集中，当且仅当它同时是这两个集合的成员：
chap2_para175,1,"•The agent program implements the agent function. There exists a variety of basic agent program designs reflecting the kind of information made explicit and used in the decision process. The designs vary in efficiency, compactness, and flexibility. The appropriate design of the agent program depends on the nature of the environment.",● 智能体是在环境中感知和行动的事物。
chap2_para175,2,,智能体的智能体函数指定智能体在响应任意感知序列时所采取的动作。
chap2_para1750,1,,（8）一个对象在两个集合的并集中，当且仅当它同时是某个集合的成员：
chap2_para1751,1,,列表与集合类似。
chap2_para1751,2,,它们的区别是，列表是有序的，相同的元素在列表中可以出现多次。
chap2_para1751,3,,我们可以用Lisp语言的词汇表示列表：Nil是没有元素的常量列表；Cons、Append、First和Rest是函数；Find在列表中的作用与Member在集合中的作用相同。
chap2_para1751,4,,List是仅对列表为真的谓词。
chap2_para1751,5,,与集合一样，涉及列表的逻辑语句也常用到语法糖。
chap2_para1751,6,,空列表是[]。
chap2_para1751,7,,"Cons(x, Nil)项（即仅含有元素x，尾部没有其他元素的列表）写作[x]。"
chap2_para1751,8,,"含有若干元素的列表，如[A, B, C]，对应于嵌套项。"
chap2_para1751,9,,习题8.LIST要求你写出列表的公理。
chap2_para1752,1,,8.3.4　wumpus世界
chap2_para1753,1,,第7章给出了wumpus世界的一些命题逻辑公理。
chap2_para1753,2,,本节介绍的一阶公理简洁得多，自然、精确地刻画了我们的意图。
chap2_para1754,1,,如前所述，wumpus世界智能体接收一个含有5个元素的感知向量。
chap2_para1754,2,,知识库中存储的对应一阶语句必须包含感知和感知出现的时间，否则，智能体会搞不清何时接收到什么感知。
chap2_para1754,3,,我们使用整数表示时间步。
chap2_para1754,4,,一个典型的感知语句是
chap2_para1755,1,,此处，Percept是二元谓词，Stench等是列表中的常量。
chap2_para1755,2,,wumpus世界中的动作可以用逻辑项表示：
chap2_para1756,1,,要确定哪个动作最优，智能体程序执行查询
chap2_para1758,1,,将返回一个类似的绑定表。
chap2_para1758,2,,智能体程序将Grab作为要采取的动作。
chap2_para1758,3,,原始感知数据蕴涵了关于当前状态的某些事实。
chap2_para1758,4,,例如：
chap2_para1759,1,,这些规则展现了一个被称为感知的推理形式的细节，我们将在第25章进行深入研究。
chap2_para1759,2,,注意对时间t的量化。
chap2_para1759,3,,在命题逻辑中，我们需要每个时间步的每条语句的副本。
chap2_para176,1,"• Simple reflex agents respond directly to percepts, whereas model-based reflex agents maintain internal state to track aspects of the world that are not evident in the current percept. Goal-based agents act to achieve their goals, and utility-based agents try to maximize their own expected “happiness.”",● 性能度量评估智能体在环境中的行为。
chap2_para176,2,,给定到目前为止所看到的感知序列，理性智能体的动作是为了最大化性能度量的期望值。
chap2_para1760,1,,简单的“反射”行为也可以用量化蕴涵式语句来实现。
chap2_para1760,2,,例如，我们有
chap2_para1761,1,,"给定感知和先前几段给出的规则，就能得出所需的结论BestAction(Grab, 5)，也就是说，Grab是要做的正确的事。"
chap2_para1762,1,,我们已经表示了智能体的输入和输出，现在可以表示环境本身了。
chap2_para1762,2,,我们从对象开始。
chap2_para1762,3,,显然，候选的对象有方格、无底洞和wumpus。
chap2_para1762,4,,"我们可以命名方格，如Square1,2等，但接下来Square1,2与Square1,3相邻的事实就必须是“额外”的事实，我们要为每一对方格列出一条这样的事实。"
chap2_para1762,5,,"使用行和列为整数的复合项是更好的做法，例如，我们可以简单地使用列表项[1, 2]。"
chap2_para1762,6,,任意相邻的方格可以定义为
chap2_para1763,1,,我们也可以为每个无底洞命名，但不宜这么做另有原因：没有必要去区分每个无底洞。
chap2_para1763,2,,[10]使用一元谓词Pit并使其在含有无底洞的方格中为真是更简单的做法。
chap2_para1763,3,,最后，由于只存在一个wumpus，用常量Wumpus与使用一元谓词并没什么区别（从wumpus的视角看，使用常量可能更威严）。
chap2_para1765,1,,[10]　同样，大多数人也不会为冬天迁徙到温暖地区的每一只鸟命名。
chap2_para1765,2,,但想研究迁徙模式、生存率等的鸟类学家要追踪每一只鸟，因此会为每只鸟命名，方法是为鸟安装腿环。
chap2_para1766,1,,"智能体的位置随时间变化，因此我们用At(Agent, s, t)来表示智能体在时间t位于方格s。"
chap2_para1766,2,,我们可以用将wumpus永远固定在一个位置。
chap2_para1766,3,,然后我们就可以说对象在一个时刻只能在一个位置：
chap2_para1767,1,,给定智能体的当前位置，它就可以用当前的感知来推断方格的属性。
chap2_para1767,2,,例如，如果智能体在一个方格中并感知到微风，则这个方格是有微风的：
chap2_para1768,1,,知道一个方格有微风很有用，因为我们知道无底洞是不能移动的。
chap2_para1768,2,,注意，Breezy没有时间参数。
chap2_para1769,1,,发现了哪些位置有微风（或有臭味）以及同样重要的哪些位置没有微风（或没有臭味），智能体就可以推导出无底洞的位置（以及wumpus的位置）。
chap2_para1769,2,,在命题逻辑中每个方格都需要一条公理（见7.4.3节的R2和R3），并且对每种世界的地形布局都需要一套不同的公理。
chap2_para1769,3,,而在一阶逻辑中我们只需要一条公理：
chap2_para177,1,•All agents can improve their performance through learning.,● 任务环境规范包括性能度量、外部环境、执行器和传感器。
chap2_para177,2,,在设计智能体时，第一步必须始终是尽可能完整地指定任务环境。
chap2_para1771,1,,类似地，一阶逻辑中我们可以量化所有时间，因此，对于每个谓词我们只需要一个后继状态公理，而非对每个时间步都保留副本。
chap2_para1771,2,,例如，箭的公理［式（7-2）］变为
chap2_para1772,1,,从这两个例子的语句可以看出，一阶逻辑的表达方式并不比第7章给出的自然语言描述更复杂。
chap2_para1772,2,,我们鼓励读者对智能体的位置和朝向构建类似的公理——在这些情况下，公理需要量化时间和空间。
chap2_para1772,3,,如命题状态估计一样，智能体可以对这样的公理使用逻辑推断来了解不能直接观测的那部分世界。
chap2_para1772,4,,第11章会更深入地研究一阶逻辑的后继状态公理以及它在构建规划中的用处。
chap2_para1773,1,,8.4　一阶逻辑中的知识工程
chap2_para1774,1,,8.3节展示了如何用一阶逻辑在3个简单的论域中表示知识。
chap2_para1774,2,,本节描述知识库构建的一般过程，这一过程称作知识工程（knowledge engineering）。
chap2_para1774,3,,知识工程师是研究一个特定论域，了解这个论域中哪些概念是重要的，并创建该论域中对象和关系的形式化表示的人。
chap2_para1774,4,,我们会阐述在电子电路论域中进行知识工程的过程。
chap2_para1774,5,,我们采用的方法适于构建专用知识库，这种知识库的论域是精心划定的，其查询的范围也是已知的。
chap2_para1774,6,,通用知识库则涵盖了较大范围的人类知识，用于支持像自然语言理解这样的任务，我们在第10章对其进行讨论。
chap2_para1775,1,,8.4.1　知识工程的过程
chap2_para1776,1,,知识工程项目的内容、范围和难度各不相同，但所有这样的项目都包括如下的步骤。
chap2_para1777,1,,（1）确定问题。
chap2_para1777,2,,知识工程必须描述知识库要支持的问题范围，以及对每个特定问题实例可获取的事实类型。
chap2_para1777,3,,例如，wumpus知识库是需要能够选择动作，还是只需要回答关于环境内容的问题？
chap2_para1777,4,,传感器事实是否需要包括当前位置？
chap2_para1777,5,,任务将决定为了将问题实例连接到回答必须表示哪些知识。
chap2_para1777,6,,这一步类似于第2章用于设计智能体的PEAS过程。
chap2_para1778,1,,（2）收集相关知识。
chap2_para1778,2,,知识工程师可能已经是领域专家，也可能需要与真正的专家合作来获得他们的知识——这个过程叫作知识获取（knowledge acquisition）。
chap2_para1778,3,,在这一阶段，知识并非形式化表示的，这一步的主要目的是了解任务所确定的知识库的范围，以及了解这一领域的运行方式。
chap2_para1779,1,,对由人工产生的规则集定义的wumpus世界来说，我们很容易找出相关知识。
chap2_para1779,2,,（但是要注意，相邻关系的定义并不是由wumpus世界规则明确给出。
chap2_para1779,3,,）对于真实世界的论域，相关性问题可能非常困难，例如，仿真VLSI设计的系统可能需要，也可能不需要考虑杂散电容和集肤效应问题。
chap2_para178,1,Bibliographical and Historical Notes,● 任务环境在几个重要维度上有所不同。
chap2_para178,2,,它们可以是完全可观测的或部分可观测的、单智能体的或多智能体的、确定性的或非确定性的、回合式的或序贯的、静态的或动态的、离散的或连续的、已知的或未知的。
chap2_para1780,1,,（3）确定谓词、函数和常量的词汇表。
chap2_para1780,2,,也就是说，将重要的论域级概念翻译为逻辑级名称。
chap2_para1780,3,,这就涉及知识工程风格的许多问题。
chap2_para1780,4,,类似于编程风格，知识工程风格可能对项目最终成功与否产生重要影响。
chap2_para1780,5,,例如，无底洞应当被表示为对象还是表示为方格的一元谓词？
chap2_para1780,6,,智能体的朝向应当是函数还是谓词？
chap2_para1780,7,,wumpus的位置是否与时间相关？
chap2_para1780,8,,一旦做出这些决定，就会形成被称为论域的本体论（ontology）的词汇表。
chap2_para1780,9,,“本体论”一词是指关于存在或实存的本质的理论。
chap2_para1780,10,,本体论决定哪些东西存在，但不能决定它们的具体性质和相互关系。
chap2_para1781,1,,（4）对论域的通用知识编码。
chap2_para1781,2,,知识工程师为词汇表中的所有项写出公理。
chap2_para1781,3,,这就（尽可能地）固定了项的含义，使专家能够检查其内容。
chap2_para1781,4,,这一步经常会发现词汇表的概念误解或理解偏差，这必须返回第3步进行修正并重复这个过程。
chap2_para1782,1,,（5）对问题实例的描述编码。
chap2_para1782,2,,如果本体论确定得很恰当，这一步就相当容易。
chap2_para1782,3,,它涉及写出本体论中的概念实例的简单原子语句。
chap2_para1782,4,,对逻辑智能体来说，问题实例是由传感器提供的，而“无形”的知识库获取语句的方式与传统程序获取输入数据的方式相同。
chap2_para1783,1,,（6）向推断过程提出查询并获得答案。
chap2_para1783,2,,这是获得回报的一步：我们可以让推断过程在公理和问题相关的事实上运行来推导我们有兴趣了解的事实。
chap2_para1783,3,,这样，我们就不需要编写应用相关的求解算法了。
chap2_para1784,1,,（7）调试并评估知识库。
chap2_para1784,2,,很遗憾，查询得到的答案一开始往往是错误的。
chap2_para1784,3,,更准确地说，答案对于现有的知识库是正确的（如果假设推断过程是可靠的），但它们不是用户期望的答案。
chap2_para1784,4,,例如，如果缺失了一条公理，一些查询就不能从知识库中得到答案。
chap2_para1784,5,,这就需要大量的调试过程。
chap2_para1784,6,,关注推理链意外停止的地方可以轻易找出缺失或过弱的公理。
chap2_para1784,7,,例如，如果知识库为找到wumpus而含有诊断规则（见习题8.WUMD）：
chap2_para1785,1,,而没有采用双向蕴涵，智能体就永远不能证明wumpus不存在。
chap2_para1785,2,,不正确的公理是关于世界的错误陈述，因此可以被找出。
chap2_para1785,3,,例如，语句
chap2_para1786,1,,对爬行动物、两栖动物和桌子都不成立。
chap2_para1786,2,,判断这条语句的错误性可以不依赖于知识库的其他部分。
chap2_para1786,3,,但是，程序中的一个典型错误则如下：
chap2_para1787,1,,在不理解上下文的情况下，不可能判断offset应当是position还是position+1。
chap2_para1788,1,,当你的知识库中没有明显的错误时，似乎就要大功告成了。
chap2_para1788,2,,但最好还是通过在查询测试套件上运行系统并测量正确答案的数量来正式地评估系统，除非你的知识库明显没有错误。
chap2_para1788,3,,没有客观度量的话，你很容易就以为任务已经完成了。
chap2_para1788,4,,为了更好地理解这7个步骤，我们现在将其应用于一个扩展的示例——电子电路论域。
chap2_para1789,1,,8.4.2　电子电路论域
chap2_para179,1,"The central role of action in intelligence—the notion of practical reasoning—goes back at least as far as Aristotle’s Nicomachean Ethics. Practical reasoning was also the subject of McCarthy’s influential paper “Programs with Common Sense” (1958). The fields of robotics and control theory are, by their very nature, concerned principally with physical agents. The concept of a controller in control theory is identical to that of an agent in AI. Perhaps surprisingly, AI has concentrated for most of its history on isolated components of agents—question-answering systems, theorem-provers, vision systems, and so on—rather than on whole agents. The discussion of agents in the text by Genesereth and Nilsson (1987) was an influential exception. The whole-agent view is now widely accepted and is a central theme in recent texts (Padgham and Winikoff, 2004; Jones, 2007; Poole and Mackworth, 2017).",● 在性能度量未知或难以正确指定的情况下，智能体优化错误目标的风险很大。
chap2_para179,2,,在这种情况下，智能体设计应该反映真实目标的不确定性。
chap2_para1790,1,,我们将构建一个本体论和一个知识库，使我们能够进行关于图8-6所示的数字电路的推理。
chap2_para1790,2,,我们将遵循知识工程的7个步骤。
chap2_para1791,1,,图8-6　一位全加器的数字电路C1。
chap2_para1791,2,,前两个输入是要相加的两位，第三个输入是进位位。
chap2_para1791,3,,第一个输出是和，第二个输出是通往下一个加法器的进位位。
chap2_para1791,4,,电路包含两个异或门、两个与门和一个或门
chap2_para1793,1,,涉及数字电路的推理任务很多。
chap2_para1793,2,,最高层次的任务是分析电路的功能性。
chap2_para1793,3,,例如，图8-6的电路是否能够正确地做加法？
chap2_para1793,4,,如果所有输入都为高，A2门的输出是什么？
chap2_para1793,5,,关于电路结构的问题同样有趣。
chap2_para1793,6,,例如，连接到第一个输入端子的门有哪些？
chap2_para1793,7,,电路是否含有反馈回路？
chap2_para1793,8,,这都是这一步骤中的任务。
chap2_para1793,9,,还有更详细的分析层次，包括关于延迟、电路面积、功耗以及生产成本等的分析。
chap2_para1793,10,,所有这些层次的分析都需要额外的知识。
chap2_para1795,1,,我们对数字电路了解多少？
chap2_para1795,2,,根据我们的目的，这包括导线和门。
chap2_para1795,3,,信号沿着导线传输到门的输入端，每个门则在输出端产生一个信号沿着另一条导线传输。
chap2_para1795,4,,要确定这些信号是什么，我们需要了解门如何转换其输入信号。
chap2_para1795,5,,门有4种：具有两个输入端子的与门（AND）、或门（OR）和异或门（XOR），以及只有一个输入端子的非门（NOT）。
chap2_para1795,6,,所有门都只有一个输出端子。
chap2_para1795,7,,像门一样，电路本身也有输入端子和输出端子。
chap2_para1796,1,,要推理电路的功能性和连接性，我们不需要涉及导线本身、导线路径或导线连接点。
chap2_para1796,2,,重要的只有端子之间的连接——我们可以说某个输出端子连接到另一个输入端子，而不需要了解其实际的连接方式。
chap2_para1796,3,,其他因素，像元件的尺寸、形状、颜色或价格与我们的分析也不相关。
chap2_para1797,1,,如果我们的目的不是在门的层级验证设计，本体论就完全不同。
chap2_para1797,2,,例如，如果我们对于故障电路修复有兴趣，那么将导线纳入本体论就很可能是个好主意，因为导线的故障会妨碍在其中传输的信号。
chap2_para1797,3,,要解决时序故障，我们需要把门延迟加进本体论。
chap2_para1797,4,,如果我们要设计可盈利的产品，电路价格及其相对于市场上其他产品的速度就会很重要。
chap2_para1799,1,,我们现在已经知道我们要涉及电路、端子、信号和门。
chap2_para1799,2,,下一步选择用于表示它们的函数、谓词和常量。
chap2_para1799,3,,我们需要先将不同的门与其他对象区分开。
chap2_para1799,4,,每个门由常量命名的对象表示，我们用Gate(X1)来断言X1是门。
chap2_para1799,5,,每个门的行为由其类型决定，即常量AND、OR、XOR和NOT中的一种。
chap2_para1799,6,,由于一个门只能有一种类型，我们可以使用函数Type(X1) = XOR。
chap2_para1799,7,,电路与门类似，使用一个谓词来表示——Circuit(C1)。
chap2_para18,1,2.,2.2　良好行为：理性的概念
chap2_para18,2,2Good Behavior: The Concept of Rationality,
chap2_para180,1,Chapter 1 traced the roots of the concept of rationality in philosophy and economics.,● 智能体程序实现智能体函数。
chap2_para180,2,"In AI, the concept was of peripheral interest until the mid-1980s, when it began to suffuse many discussions about the proper technical foundations of the field.",存在各种基本的智能体编程，反映了决策过程中明确使用的信息类型。
chap2_para180,3,"A paper by Jon Doyle (1983) predicted that rational agent design would come to be seen as the core mission of AI, while other popular topics would spin off to form new disciplines.",这些设计在效率、紧凑性和灵活性方面各不相同。
chap2_para180,4,,智能体程序的适当设计取决于环境的性质。
chap2_para1800,1,,接下来我们考虑端子，使用谓词Terminal(x)表示。
chap2_para1800,2,,一个电路可以有一个或多个输入端子和一个或多个输出端子。
chap2_para1800,3,,"我们使用函数In(1, X1)来表示电路X1的第1个输入端子。"
chap2_para1800,4,,"相似的函数Out(n, c)用于输出端子。"
chap2_para1800,5,,"谓词Arity(c, i, j)断言电路c有i个输入端子和j个输出端子。"
chap2_para1800,6,,门之间的连接性可以用谓词Connected表示，它需要两个端子作为参数，如。
chap2_para1801,1,,最后，我们需要知道一个信号是通还是断。
chap2_para1801,2,,一种可能是使用一元谓词On(t)，在某个端子的信号通时为真。
chap2_para1801,3,,但这会增加提出类似“电路C1输出端子的所有可能信号值有哪些？
chap2_para1801,4,,”的问题的难度。
chap2_para1801,5,,因此我们引入两个信号值1和0作为对象，分别表示“通”和“断”，而用函数Signal(t)表示端子t的信号值。
chap2_para1802,1,,4. 对论域的通用知识编码
chap2_para1803,1,,好的本体论仅需要少量通用规则，并且可以简明地声明这些规则。
chap2_para1803,2,,如下是我们需要的全部公理。
chap2_para1804,1,,（1）如果两个端子连通，则它们信号相同：
chap2_para1805,1,,（2）每个端子的信号只能是1或0：
chap2_para1806,1,,（3）Connected具有交换性：
chap2_para1807,1,,（4）门的类型有4种：
chap2_para1808,1,,（5）与门的输出为0，当且仅当其任意输入为0：
chap2_para1809,1,,（6）或门的输出为1，当且仅当其任意输入为1：
chap2_para181,1,"Careful attention to the properties of the environment and their consequences for rational agent design is most apparent in the control theory tradition—for example, classical control systems (Dorf and Bishop, 2004; Kirk, 2004) handle fully observable, deterministic environments; stochastic optimal control (Kumar and Varaiya, 1986; Bertsekas and Shreve, 2007) handles partially observable, stochastic environments; and hybrid control (Henzinger and Sastry, 1998; Cassandras and Lygeros, 2006) deals with environments containing both discrete and continuous elements. The distinction between fully and partially observable environments is also central in the dynamic programming literature developed in the field of operations research (Puterman, 1994), which we discuss in Chapter 16.",● 简单反射型智能体直接响应感知，而基于模型的反射型智能体保持内部状态以跟踪当前感知中不明晰的世界状态。
chap2_para181,2,,基于目标的智能体采取行动来实现目标，而基于效用的智能体试图最大化自己期望的“快乐”。
chap2_para1810,1,,（7）异或门的输出为1，当且仅当其输入不相同：
chap2_para1811,1,,（8）非门的输出与其输入不同：
chap2_para1812,1,,（9）除了非门之外的所有门都有两个输入和一个输出：
chap2_para1813,1,,（10）电路有端子，数量不超过其输入和输出元数，不存在超出元数的任何东西：
chap2_para1814,1,,（11）门、端子和信号是不同的：
chap2_para1816,1,,5. 对特定问题实例编码
chap2_para1817,1,,图8-6所示的电路被编码为电路C1并有如下描述。
chap2_para1817,2,,首先我们对电路及其门元件进行分类：
chap2_para1818,1,,随后我们给出其连接情况：
chap2_para1819,1,,6. 向推断过程提出查询
chap2_para182,1,"Although simple reflex agents were central to behaviorist psychology (see Chapter 1), most AI researchers view them as too simple to provide much leverage.",● 所有智能体都可以通过学习提升性能。
chap2_para182,2,(Rosenschein (1985) and Brooks (1986) questioned this assumption; see Chapter 26.,
chap2_para182,3,) A great deal of work has gone into finding efficient algorithms for keeping track of complex environments (Bar-Shalom et al.,
chap2_para182,4,", 2001; Choset et al.",
chap2_para182,5,", 2005; Simon, 2006), most of it in the probabilistic setting.",
chap2_para1820,1,,哪种输入组合会使C1的第一个输出（求和位）为0，第二个输出（进位位）为1？
chap2_para1821,1,,答案是变量i1、i2和i3的置换，以使得语句被知识库所蕴含。
chap2_para1821,2,,AskVars将给我们3种这样的置换：
chap2_para1822,1,,加法器电路中所有端子的可能值的集合有哪些？
chap2_para1823,1,,最后这个查询将返回设备的完整输入输出表，可以用于检验它是否能正确做加法。
chap2_para1823,2,,这是电路验证（circuit verification）的一个简单示例。
chap2_para1823,3,,我们也可以使用电路的定义来构建更大的数字系统，并使用相同的验证方式。
chap2_para1823,4,,（见习题8.ADDR）许多论域都支持这种结构化的知识库创建方式，但需要在简单概念的基础上定义更为复杂的概念。
chap2_para1825,1,,我们可以以各种方式查询知识库以了解它会出现哪些错误行为。
chap2_para1825,2,,例如，假设我们没有阅读8.2.8节，因而忘记断言10。
chap2_para1825,3,,假设我们发现系统除了输入000和110的情况，无法证明电路的任何输出，我们可以通过询问每个门的输出的方式来找到问题。
chap2_para1825,4,,我们可以询问：
chap2_para1826,1,,结果显示在X1处对于输入10和01没有输出。
chap2_para1826,2,,因此，我们查看应用于X1的异或门的公理：
chap2_para1827,1,,如果输入已知为1和0，则上式简化为
chap2_para1828,1,,现在，问题就很明显了：系统不能推断出，因此，我们需要告诉它10。
chap2_para183,1,"Goal-based agents are presupposed in everything from Aristotle’s view of practical reasoning to McCarthy’s early papers on logical AI. Shakey the Robot (Fikes and Nilsson, 1971; Nilsson, 1984) was the first robotic embodiment of a logical, goal-based agent. A full logical analysis of goal-based agents appeared in Genesereth and Nilsson (1987), and a goal-based programming methodology called agent-oriented programming was developed by Shoham (1993). The agent-based approach is now extremely popular in software engineering (Ciancarini and Wooldridge, 2001). It has also infiltrated the area of operating systems, where autonomic computing refers to computer systems and networks that monitor and control themselves with a perceive–act loop and machine learning methods (Kephart and Chess, 2003). Noting that a collection of agent programs designed to work well together in a true multiagent environment necessarily exhibits modularity—the programs share no internal state and communicate with each other only through the environment—it is common within the field of multiagent systems to design the agent program of a single agent as a collection of autonomous sub-agents. In some cases, one can even prove that the resulting system gives the same optimal solutions as a monolithic design.",
chap2_para1830,1,,本章介绍了一阶逻辑，一种命题逻辑更具表达能力的表示语言。
chap2_para1830,2,,本章要点如下。
chap2_para1831,1,,● 知识表示语言应当是说明性的、合成式的、有表达能力的、上下文无关的且无歧义的。
chap2_para1832,1,,● 逻辑之间的区别在于其本体论约定和认识论约定，命题逻辑仅约定事实的存在，一阶逻辑则约定对象和关系的存在，因而增加了表达能力，适用于像wumpus世界和电子电路这样的论域。
chap2_para1833,1,,● 命题逻辑和一阶逻辑在表示模糊命题上都有困难。
chap2_para1833,2,,这一困难限制了它们在需要个人判断的论域的应用性，如政治或烹饪。
chap2_para1834,1,,● 一阶逻辑的语法构建于命题逻辑之上。
chap2_para1834,2,,它增加了项来表示对象，并且有全称量词和存在量词来构建关于被量化的变量的全部或部分可能值的断言。
chap2_para1835,1,,● 一阶逻辑的一个可能世界或模型包括一个对象集和一种将常量符号映射到对象、将谓词符号映射到对象的关系、将函数符号映射到对象上的函数的解释。
chap2_para1836,1,,● 一条原子语句为真，仅当谓词命名的关系在项命名的对象之间成立。
chap2_para1836,2,,扩展解释将量词变量映射到模型中的对象，定义了量化语句的真值。
chap2_para1837,1,,● 在一阶逻辑中构建知识库需要严谨的过程来分析论域、选择词汇表、编码能支持所需推断的公理。
chap2_para184,1,"The goal-based view of agents also dominates the cognitive psychology tradition in the area of problem solving, beginning with the enormously influential Human Problem Solving (Newell and Simon, 1972) and running through all of Newell’s later work (Newell, 1990). Goals, further analyzed as desires (general) and intentions (currently pursued), are central to the influential theory of agents developed by Michael Bratman (1987).",微信扫码关注【异步社区】微信公众号，回复“e59810”获取本书配套资源以及异步社区15天VIP会员卡，近千本电子书免费畅读。
chap2_para1840,1,,第9章　一阶逻辑中的推断
chap2_para1841,1,,在本章中，我们定义有效的过程来回答用一阶逻辑提出的问题。
chap2_para1842,1,,在本章中，我们阐述能够回答所有可解的一阶逻辑问题的算法。
chap2_para1842,2,,9.1节介绍量词的推断规则，并展示如何将一阶逻辑推断约简为命题逻辑推断，尽管这样做代价巨大。
chap2_para1842,3,,9.2节描述了如何用合一来构建直接用于一阶逻辑的推断规则。
chap2_para1842,4,,随后我们讨论一阶逻辑推断的3类主要算法：前向链接（9.3节）、反向链接（9.4节）和基于归结的定理证明（9.5节）。
chap2_para1843,1,,9.1　命题推断与一阶推断
chap2_para1844,1,,进行一阶推断的方法之一是将一阶知识库转换为命题逻辑并使用我们已知的命题推断。
chap2_para1844,2,,第一步是消去全称量词。
chap2_para1844,3,,例如，假设我们的知识库含有典型的朴素道德公理，认为所有贪婪的国王都是邪恶的：
chap2_para1845,1,,由此我们可以推断出下列任一语句：
chap2_para1846,1,,一般来说，全称量词实例化（universal instantiation，UI）表明我们可以通过用基本项（没有变量的项）置换全称量化的变量来推断任意语句。
chap2_para1846,2,,[1]
chap2_para1848,1,,[1]　不要把此处的置换与8.2.6节用于定义量词语义的扩展解释搞混了。
chap2_para1848,2,,置换用项（term，语法片段）代替变量来产生新的语句，而解释将变量映射到论域中的实例。
chap2_para1849,1,,我们使用8.3节介绍过的置换来形式化地写出推断规则。
chap2_para1849,2,,令表示对语句应用置换后的语句。
chap2_para1849,3,,则对于任意变量v和基本项g，规则写作
chap2_para185,1,"As noted in Chapter 1, the development of utility theory as a basis for rational behavior goes back hundreds of years.",
chap2_para185,2,"In AI, early research eschewed utilities in favor of goals, with some exceptions (Feldman and Sproull, 1977).",
chap2_para185,3,The resurgence of interest in probabilistic methods in the 1980s led to the acceptance of maximization of expected utility as the most general framework for decision making (Horvitz et al.,
chap2_para185,4,", 1988).",
chap2_para185,5,The text by Pearl (1988) was the first in AI to cover probability and utility theory in depth; its exposition of practical methods for reasoning and decision making under uncertainty was probably the single biggest factor in the rapid shift towards utility-based agents in the 1990s (see Chapter 15).,
chap2_para185,6,"The formalization of reinforcement learning within a decision-theoretic framework also contributed to this shift (Sutton, 1988).",
chap2_para185,7,"Somewhat remarkably, almost all AI research until very recently has assumed that the performance measure can be exactly and correctly specified in the form of a utility function or reward function (Hadfield-Menell et al.",
chap2_para185,8,", 2017a; Russell, 2019).",
chap2_para1850,1,,前述的3条语句就是分别用置换、和得到的。
chap2_para1851,1,,类似地，存在量词实例化（existential instantiation）用一个新的常量符号替换存在量化的变量。
chap2_para1851,2,,其形式化描述如下：对于任意语句、变量v和未在知识库其他地方出现的常量符号k，
chap2_para1854,1,,只要C1未在知识库的其他地方出现。
chap2_para1854,2,,简单来说，存在语句表明存在满足某个条件的对象，运用存在实例化就是给这个对象命名。
chap2_para1854,3,,当然，这个名称不能已经属于其他对象。
chap2_para1854,4,,数学中有一个很好的例子：假设我们发现有一个数字比2.718 28稍大，并满足等式中的x。
chap2_para1854,5,,我们可以将这个数字命名为e，但不能将其命名为已经存在的对象名，如。
chap2_para1854,6,,在逻辑中，新的名称被称为斯科伦常量（Skolem constant）。
chap2_para1855,1,,全称量词实例化可以多次用于同一条公理来产出许多不同结果，而存在量词实例化只需要使用一次，随后就可以丢掉存在量化的语句。
chap2_para1855,2,,"例如，一旦我们添加了语句Kill(Murderer, Victim)的话，就不再需要。"
chap2_para186,1,"The general design for learning agents portrayed in Figure 2.15 is classic in the machine learning literature (Buchanan et al., 1978; Mitchell, 1997). Examples of the design, as embodied in programs, go back at least as far as Arthur Samuel’s (1959, 1967) learning program for playing checkers. Learning agents are discussed in depth in Chapters 19, 21, 22, and 23.",第3章　通过搜索进行问题求解
chap2_para187,1,Some early papers on agent-based approaches are collected by Huhns and Singh (1998) and Wooldridge and Rao (1999).,在本章中，我们讨论一个智能体是如何向前搜索，找到一个动作序列来实现它的最终目标。
chap2_para187,2,"Texts on multiagent systems provide a good introduction to many aspects of agent design (Weiss, 2000a; Wooldridge, 2009).",
chap2_para187,3,"Several conference series devoted to agents began in the 1990s, including the International Workshop on Agent Theories, Architectures, and Languages (ATAL), the International Conference on Autonomous Agents (AGENTS), and the International Conference on Multi-Agent Systems (ICMAS).",
chap2_para187,4,"In 2002, these three merged to form the International Joint Conference on Autonomous Agents and Multi-Agent Systems (AAMAS).",
chap2_para187,5,From 2000 to 2012 there were annual workshops on Agent-Oriented Software Engineering (AOSE).,
chap2_para187,6,The journal Autonomous Agents and Multi-Agent Systems was founded in 1998.,
chap2_para187,7,"Finally, Dung Beetle Ecology (Hanski and Cambefort, 1991) provides a wealth of interesting information on the behavior of dung beetles.",
chap2_para187,8,YouTube has inspiring video recordings of their activities.,
chap2_para188,1,"1If the agent uses some randomization to choose its actions, then we would have to try each sequence many times to identify the probability of each action.",当要采取的正确动作不是很明显时，智能体可能需要提前规划：考虑一个形成通往目标状态路径的动作序列。
chap2_para188,2,"One might imagine that acting randomly is rather silly, but we show later in this chapter that it can be very intelligent.",这样的智能体被称为问题求解智能体（problem-solving agent），它所进行的计算过程被称为搜索（search）。
chap2_para189,1,"2In a real robot, it would be unlikely to have an actions like “move right” and “move left.” Instead the actions would be “spin wheels forward” and “spin wheels backward.” We have chosen the actions to be easier to follow on the page, not for ease of implementation in an actual robot.",如2.4.7节所述，问题求解智能体使用原子（atomic）表示，也就是说，世界状态被视为一个整体，其内部结构对问题求解算法来说是不可见的。
chap2_para189,2,,使用状态的因子化（factored）表示或结构化（structured）表示的智能体称为规划智能体（planning agent），第7章和第11章中将会讨论。
chap2_para19,1,A rational agent is one that does the right thing.,理性智能体（rational agent）是做正确事情的事物。
chap2_para19,2,"Obviously, doing the right thing is better than doing the wrong thing, but what does it mean to do the right thing?",显然，做正确的事情比做错误的事情要好，但是做正确的事情意味着什么呢？
chap2_para190,1,"3See N. Henderson, “New door latches urged for Boeing 747 jumbo jets,” Washington Post, August 24, 1989.",我们将在本书中介绍若干搜索算法。
chap2_para190,2,,在本章中，我们将只考虑最简单的环境，即回合式的、单智能体的、完全可观测的、确定性的、静态的、离散的和已知的环境，并对有信息（informed）算法和无信息（uninformed）算法进行区分。
chap2_para190,3,,在有信息算法中，智能体可以估计自己到目标的距离，而在无信息算法中不能进行这样的估计。
chap2_para190,4,,第4章会讨论更一般的环境中的问题，第5章则考虑了多智能体的情形。
chap2_para191,1,4The word “sequential” is also used in computer science as the antonym of “parallel.” The two meanings are largely unrelated.,本章使用了渐近复杂性的概念（即O(n)表示法）。
chap2_para191,2,,不熟悉这些概念的读者可以参阅附录A。
chap2_para192,1,"5There are other choices for the agent program skeleton; for example, we could have the agent programs be coroutines that run asynchronously with the environment.",3.1　问题求解智能体
chap2_para192,2,Each such coroutine has an input and output port and consists of a loop that reads the input port for percepts and writes actions to the output port.,
chap2_para193,1,"6Also called situation–action rules, productions, or if–then rules.",想象一下，一个智能体正在罗马尼亚度假。
chap2_para193,2,,它想参观景点，想学习罗马尼亚语，想享受罗马尼亚的夜生活但又不想宿醉，等等。
chap2_para193,3,,这一决策问题是复杂的。
chap2_para193,4,,现在，假设智能体目前位于Arad，并且买了一张第二天从Bucharest起飞且不能退款的机票。
chap2_para193,5,,智能体观察路牌后发现，从Arad出发有3条路：一条通往Sibiu，一条通往Timisoara，还有一条通往Zerind。
chap2_para193,6,,但这都不是它的目的地，所以除非智能体熟悉罗马尼亚的地理环境，不然它不知道该走哪条路。
chap2_para193,7,,[1]
chap2_para194,1,"7The word “utility” here refers to “the quality of being useful,” not to the electric company or waterworks.",
chap2_para195,1,,[1]　我们假设大多数读者都处于同样的处境，并且很容易想象自己和智能体一样毫无头绪。
chap2_para195,2,,我们向不能利用这一教学安排的罗马尼亚读者道歉，因为他们清楚地知晓哪条路更易到达Bucharest。
chap2_para196,1,,如果智能体没有额外信息，也就是说，如果环境是未知的（unknown），那么智能体只能随机执行一个动作。
chap2_para196,2,,这种情况将在第4章讨论。
chap2_para196,3,,在本章中，我们假设智能体总是能够访问与世界相关的信息，例如图3-1中的地图。
chap2_para196,4,,有了这些信息，智能体可以执行以下4个阶段的问题求解过程。
chap2_para197,1,,● 目标形式化（goal formulation）：智能体的目标为到达Bucharest。
chap2_para197,2,,目标通过限制智能体的目的和需要考虑的动作来组织其行为。
chap2_para198,1,,图3-1　罗马尼亚部分地区的简化道路图，道路距离单位为英里（1英里 = 1.61千米）
chap2_para199,1,,● 问题形式化（problem formulation）：智能体刻画实现目标所必需的状态和动作——进而得到这个世界中与实现目标相关的部分所构成的抽象模型。
chap2_para199,2,,对智能体来说，一个好的模型应该考虑从一个城市到其相邻城市的动作，这时，状态中只有“当前所在城市”会由于动作而改变。
chap2_para2,1,"In which we discuss the nature of agents, perfect or otherwise, the diversity of environments, and the resulting menagerie of agent types.",第1章将理性智能体（rational agent）的概念确定为研究人工智能的方法的核心。
chap2_para2,2,,本章将使这个概念更加具体。
chap2_para2,3,,我们将看到，在任何可以想象的环境中运行的各种智能体都可以应用理性的概念。
chap2_para2,4,,本书的计划是使用这个概念来制定一小组设计原则，并用于构建成功的智能体，可以合理地称之为智能系统。
chap2_para20,1,2.,2.2.1　性能度量
chap2_para20,2,2.,
chap2_para20,3,1Performance measures,
chap2_para200,1,,● 搜索（search）：在真实世界中采取任何动作之前，智能体会在其模型中模拟一系列动作，并进行搜索，直到找到一个能到达目标的动作序列。
chap2_para200,2,,这样的序列称为解（solution）。
chap2_para200,3,,智能体可能不得不模拟多个无法到达目标的序列，但最终它要么找到一个解（例如从Arad到Sibiu到Fagaras再到Bucharest），要么发现问题是无解的。
chap2_para201,1,,● 执行（execution）：现在智能体可以执行解中的动作，一次执行一个动作。
chap2_para202,1,,一个重要的性质是，在一个完全可观测的、确定性的、已知的环境中，任何问题的解都是一个固定的动作序列：开车到Sibiu，然后到Fagaras，最后到达Bucharest。
chap2_para202,2,,如果模型是正确的，那么一旦智能体找到了一个解，它就可以在执行动作时忽略它的感知（“闭上眼睛”），因为解一定会到达目标。
chap2_para202,3,,控制理论家称之为开环（open-loop）系统，因为忽略感知打破了智能体和环境之间的环路。
chap2_para202,4,,如果模型有可能是不正确的，或者环境是非确定性的，那么监控感知的闭环（closed-loop）方法会更安全（见4.4节）。
chap2_para203,1,,在部分可观测或非确定性环境中，问题的解将是一个根据感知推荐不同的未来动作的分支策略。
chap2_para203,2,,例如，智能体可能规划从Arad开车到Sibiu，但还需要一个应变规划，以防它不小心到了Zerind或者发现了“Drum Închis”（道路封闭）的标志。
chap2_para204,1,,3.1.1　搜索问题和解
chap2_para205,1,,搜索问题（problem）的形式化定义如下。
chap2_para206,1,,● 可能的环境状态（state）的集合，我们称之为状态空间（state space）。
chap2_para207,1,,● 智能体启动时的初始状态（initial state），例如Arad。
chap2_para208,1,,● 一个或多个目标状态（goal state）的集合。
chap2_para208,2,,有时问题只有一个目标状态（如Bucharest），有时存在若干个可供选择的目标状态，也有时目标是由一个适用于许多状态（可能是无限多个状态）的属性所定义的。
chap2_para208,3,,例如，在一个真空吸尘器世界里，目标可能是让任何位置都没有灰尘，而无论该状态的其他情况如何。
chap2_para208,4,,我们通过给问题指定一个Is-Goal方法来将这3种可能性都考虑在内。
chap2_para208,5,,在本章中，为了简单起见，我们有时会直接用“目标”一词，它表示“任一可能的目标状态”。
chap2_para209,1,,● 智能体可以采取的行动（action）。
chap2_para209,2,,给定一个状态s，Actions(s)将返回在s中可以执行的有限[2]动作集合。
chap2_para209,3,,我们称集合中的任一动作在s中都是适用的（applicable）。
chap2_para209,4,,例如：
chap2_para21,1,"Moral philosophy has developed several different notions of the “right thing,” but AI has generally stuck to one notion called consequentialism: we evaluate an agent’s behavior by its consequences. When an agent is plunked down in an environment, it generates a sequence of actions according to the percepts it receives. This sequence of actions causes the environment to go through a sequence of states. If the sequence is desirable, then the agent has performed well. This notion of desirability is captured by a performance measure that evaluates any given sequence of environment states.",道德哲学发展了几种不同“正确事情”的概念，但人工智能通常坚持一种称为结果主义（consequentialism）的概念：我们通过结果来评估智能体的行为。
chap2_para21,2,,当智能体进入环境时，它会根据接受的感知产生一个动作序列。
chap2_para21,3,,这一动作序列会导致环境经历一系列的状态。
chap2_para21,4,,如果序列是理想的，则智能体表现良好。
chap2_para21,5,,这种可取性的概念由性能度量（performance measure）描述，该度量评估任何给定环境状态的序列。
chap2_para211,1,,[2]　对于具有无限多个动作的问题，我们需要本章之外的其他技巧。
chap2_para212,1,,● 转移模型（transition model）用于描述每个动作所起到的作用。
chap2_para212,2,,"Result(s, a)将返回在状态s中执行动作a所产生的状态。"
chap2_para212,3,,例如：
chap2_para213,1,,"● 动作代价函数（action cost function），在编程中记作Action-Cost(s, a, s' )，在数学运算中记作c(s, a, s' )。"
chap2_para213,2,,它给出了在状态s中执行动作a从而转移到状态s'的数值代价。
chap2_para213,3,,问题求解智能体应该使用反映其自身性能指标的代价函数；例如，对于寻径智能体，动作代价可能是以英里为单位的长度（如图3-1所示），也可能是完成动作所花费的时间。
chap2_para214,1,,一个动作序列形成一条路径（path），而解（solution）是一条从初始状态到某个目标状态的路径。
chap2_para214,2,,我们假设动作代价是可累加的；也就是说，一条路径的总代价是各个动作代价的总和。
chap2_para214,3,,最优解（optimal solution）是所有解中路径代价最小的解。
chap2_para214,4,,在本章中，我们假设所有的动作代价都为正，以减少复杂性。
chap2_para214,5,,[3]
chap2_para216,1,,[3]　在任何存在负代价环的问题中，代价最优解为在这个环中循环无限次。
chap2_para216,2,,不存在负代价环时，Bellman-Ford算法和Floyd-Warshall算法（本章暂未涉及）可以处理负代价动作。
chap2_para216,3,,只要连续的零代价动作的数量是有限的，处理零代价动作就很容易。
chap2_para216,4,,例如，假设有一个机器人，其移动的代价为正，但旋转90°的代价为0；只要连续旋转90°动作的数量不超过3个，本章的算法就可以处理这个问题。
chap2_para216,5,,存在无限多个任意小的动作代价的问题也很复杂。
chap2_para216,6,,考虑Zeno悖论的情况，存在一个动作，它每次向目标移动剩余距离的二分之一，代价为上一次移动代价的二分之一。
chap2_para216,7,,这个问题不存在动作数量有限的解，但为了防止搜索在没有完全到达目标的情况下采取无限数量的动作，我们可以要求所有动作的代价至少为，为某个较小的正值。
chap2_para217,1,,状态空间可以用图（graph）来表示，图中的顶点表示状态，顶点之间的有向边表示动作。
chap2_para217,2,,图3-1所示的罗马尼亚地图就是这样一个图，每条道路表示两种动作，即两个方向各表示一种。
chap2_para218,1,,3.1.2　问题形式化
chap2_para219,1,,我们将前文中去往Bucharest的问题形式化为一个模型（model）——一种抽象的数学描述，而不是真实存在的实物。
chap2_para219,2,,与简单的原子状态描述Arad相比，实际的旅行的世界状态包括很多内容：旅行伙伴、当时的广播节目、窗外的风景、附近是否有执法人员、到下一个休息站的距离、道路状况、天气、交通等。
chap2_para219,3,,所有这些因素都被排除在我们的模型之外，因为它们与寻找前往Bucharest的路线问题无关。
chap2_para22,1,"Humans have desires and preferences of their own, so the notion of rationality as applied to humans has to do with their success in choosing actions that produce sequences of environment states that are desirable from their point of view. Machines, on the other hand, do not have desires and preferences of their own; the performance measure is, initially at least, in the mind of the designer of the machine, or in the mind of the users the machine is designed for. We will see that some agent designs have an explicit representation of (a version of) the performance measure, while in other designs the performance measure is entirely implicit—the agent may do the right thing, but it doesn’t know why.",人类有自己的欲望和偏好，因此，人类有适用于自身的理性概念。
chap2_para22,2,,这一概念与成功地选择产生环境状态序列的行动有关，这些环境状态序列从人类的角度来看是可取的。
chap2_para22,3,,但是，机器没有自己的欲望和偏好，至少在最初，性能度量是在机器设计者的头脑中或者是在机器受众的头脑中。
chap2_para22,4,,我们将看到，一些智能体设计具有性能度量的显式表示（一个版本），而在其他设计中，性能度量完全是隐式的，智能体可能会做正确的事情，但它不知道为什么。
chap2_para220,1,,从表示中剔除细节的过程称为抽象（abstraction）。
chap2_para220,2,,一个良好的问题形式化应该具有适度的细节层次。
chap2_para220,3,,如果智能体的动作细化到“右脚向前移动1厘米”或“方向盘向左转动1度”的层次上，那它可能永远都找不到走出停车场的路，更不用说去Bucharest了。
chap2_para221,1,,我们能更精确地定义合适的抽象层级（level of abstraction）吗？
chap2_para221,2,,我们所选择的抽象状态和动作对应于大量具体的世界状态和动作序列。
chap2_para221,3,,现在考虑抽象问题的解，例如，从Arad到Sibiu，到Rimnicu Vilcea，到Pitesti，再到Bucharest的路径。
chap2_para221,4,,这个抽象解对应于大量更详细的路径。
chap2_para221,5,,例如，从Sibiu开往Rimnicu Vilcea的途中，我们可以打开收音机，而在其他的旅程中关掉收音机。
chap2_para222,1,,如果我们能够将任何抽象解细化为更详细的世界中的解，那么这种抽象就是合理的；一个充分条件是，对于“in Arad”的每个详细状态，都有一条到达“in Sibiu”状态的详细路径，以此类推。
chap2_para222,2,,[4]如果执行解中的每个动作都比原始问题更容易，那么抽象是有用的；在我们的示例中，“从Arad开车到Sibiu”的动作，任何一个一般水平的司机都可以在不进一步搜索或规划的情况下完成。
chap2_para222,3,,因此，选择一个好的抽象需要删除尽可能多的细节，同时保留合理性，并确保抽象动作易于执行。
chap2_para222,4,,如果没有构造有用的抽象的能力，智能体将被真实世界完全淹没。
chap2_para224,1,,[4]　参见11.4节。
chap2_para226,1,,问题求解的方法已被应用于大量任务环境中。
chap2_para226,2,,我们在这里列出一些典型问题，区分为标准化问题和真实世界问题。
chap2_para226,3,,标准化问题（standardized problem）常用于说明或训练各种问题求解方法。
chap2_para226,4,,它具有简洁、准确的描述，因此适合作为研究人员比较算法性能的基准。
chap2_para226,5,,真实世界问题（real-world problem），如机器人导航，则意味着这一问题的解是人们实际使用的，且问题的形式化是独特的而非标准化的，因为例如在机器人导航问题中，每个机器人具有不同的传感器，产生不同的数据。
chap2_para227,1,,3.2.1　标准化问题
chap2_para228,1,,网格世界（grid world）问题是一个由正方形单元格组成的二维矩形阵列，在这个阵列中，智能体可以从一个单元格移动到另一个单元格。
chap2_para228,2,,一般来说，智能体可以水平或垂直地移动到任何无障碍的相邻单元格，在某些问题中还可以沿对角线移动。
chap2_para228,3,,单元格中可以包含智能体能拿起、推开或施加其他动作的物体，也可以存在阻止智能体进入单元格内的墙壁或其他不可逾越的障碍。
chap2_para228,4,,2.1节中的真空吸尘器世界（vacuum world）可以表示为一个网格世界问题。
chap2_para229,1,,● 状态：即哪些对象在哪些单元格中。
chap2_para229,2,,在真空吸尘器世界中，对象就是智能体和灰尘。
chap2_para229,3,,对于只有两个单元格的简单情形，智能体可以位于这两个单元格中的任何一个，每个单元格都可能存在灰尘，所以共有2×2×2 = 8个状态（见图3-2）。
chap2_para229,4,,一般来说，存在n个单元格的真空吸尘器环境有n×2n 个状态。
chap2_para23,1,"Recalling Norbert Wiener’s warning to ensure that “the purpose put into the machine is the purpose which we really desire” (page 51), notice that it can be quite hard to formulate a performance measure correctly. Consider, for example, the vacuum-cleaner agent from the preceding section. We might propose to measure performance by the amount of dirt cleaned up in a single eight-hour shift. With a rational agent, of course, what you ask for is what you get. A rational agent can maximize this performance measure by cleaning up the dirt, then dumping it all on the floor, then cleaning it up again, and so on. A more suitable performance measure would reward the agent for having a clean floor. For example, one point could be awarded for each clean square at each time step (perhaps with a penalty for electricity consumed and noise generated). As a general rule, it is better to design performance measures according to what one actually wants to be achieved in the environment, rather than according to how one thinks the agent should behave.",回顾诺伯特·维纳的警告，以确保“施以机器的目的是我们真正想要的目的”（1.5节），注意，正确地制定性能度量可能非常困难。
chap2_para23,2,,例如，考虑2.1节中的真空吸尘器智能体，我们可能会建议用单个8小时班次中清理的灰尘量来度量性能。
chap2_para23,3,,当然，有了理性的智能体，你所要求的就是你所得到的。
chap2_para23,4,,然而一个理性的智能体可以通过清理灰尘，然后将其全部倾倒在地板上，然后再次清理，如此反复，从而最大化这一性能度量。
chap2_para23,5,,更合适的性能度量是奖励拥有干净地板的智能体。
chap2_para23,6,,例如，在每个时间步中，每个干净的方格都可以获得1分（可能会对耗电和产生的噪音进行惩罚）。
chap2_para23,7,,作为一般规则，更好的做法是根据一个人在环境中真正想要实现的目标，而不是根据一个人认为智能体应该如何表现来设计性能度量。
chap2_para230,1,,● 初始状态：任一状态都可以被指定为初始状态。
chap2_para231,1,,● 动作：在只有两个单元格的情形中，我们可以定义3种动作，即吸尘（Suck）、向左（Left）移动和向右（Right）移动。
chap2_para231,2,,在二维多单元格世界中，我们则需要更多种移动动作。
chap2_para231,3,,我们可以增加向上（Upward）和向下（Downward）的动作，从而得到4种绝对的（absolute）移动动作，或者可以将其转换为以自我为中心的动作，即从相对于智能体的角度来定义，例如，向前（Forward）、向后（Backward）、右转（TurnRight）和左转（TurnLeft）。
chap2_para232,1,,● 转移模型：Suck将去除单元格内的任何灰尘；Forward将智能体朝它所面对的方向向前移动一个单元格，除非它撞到墙（在这种情况下，这个行动不起作用）。
chap2_para232,2,,Backward让智能体朝相反的方向移动一个单元格，而TurnRight和TurnLeft则将智能体的朝向旋转90°。
chap2_para233,1,,● 目标状态： 每个单元格都保持干净的状态。
chap2_para234,1,,● 动作代价： 每个动作的代价都是1。
chap2_para235,1,,图3-2　两个单元格的真空吸尘器世界的状态空间图。
chap2_para235,2,,共有8个状态，每个状态有3种动作：L = Left（向左）、R = Right（向右）、S = Suck（吸尘）
chap2_para236,1,,另一种类型的网格世界是推箱子问题（sokoban puzzle），在这个问题中，智能体的目标是将一些散落在网格中的箱子推到指定的存储位置。
chap2_para236,2,,每个单元格最多容纳一个箱子。
chap2_para236,3,,当智能体向前移动到放有一个箱子的单元格，而箱子另一侧的单元格为空时，箱子和智能体都向前移动一格。
chap2_para236,4,,智能体不能把一个箱子推到另一个箱子上或墙上。
chap2_para236,5,,对于存在n个无障碍单元格和b个箱子的世界，共有个状态；例如，在一个存在12个箱子的8×8网格中，有超过200万亿个状态。
chap2_para237,1,,在滑块问题（sliding-tile puzzle）中，若干滑块（有时称为块或片）排列在一个有若干空白区域的网格中，其中滑块可以滑进空白区域。
chap2_para237,2,,它的一个变体是汽车华容道问题（Rush Hour puzzle），在这个问题中，我们需要在6×6的网格中滑动汽车和卡车，目标是将一辆汽车从交通堵塞中解救出来。
chap2_para237,3,,滑块问题中最著名的变体是8数码问题（8-puzzle）（见图3-3），它由一个3×3的网格、8个带编号的滑块和一个空格组成，目标是达到指定的状态，如图3-3中右侧所示。
chap2_para237,4,,类似的还有由4×4的网格组成的15数码问题（15-puzzle）。
chap2_para237,5,,对8数码问题做如下形式化处理。
chap2_para238,1,,● 状态：指定每个滑块位置的状态描述。
chap2_para239,1,,● 初始状态：任何状态都可以被指定为初始状态。
chap2_para239,2,,注意，可以根据奇偶性划分状态空间——任何给定目标都可以从恰好一半的可能初始状态到达（见习题 3.PART）。
chap2_para24,1,"Even when the obvious pitfalls are avoided, some knotty problems remain. For example, the notion of “clean floor” in the preceding paragraph is based on average cleanliness over time. Yet the same average cleanliness can be achieved by two different agents, one of which does a mediocre job all the time while the other cleans energetically but takes long breaks. Which is preferable might seem to be a fine point of janitorial science, but in fact it is a deep philosophical question with far-reaching implications. Which is better—a reckless life of highs and lows, or a safe but humdrum existence? Which is better—an economy where everyone lives in moderate poverty, or one in which some live in plenty while others are very poor? We leave these questions as an exercise for the diligent reader.",即使避免了明显的缺陷，一些棘手的问题仍然存在。
chap2_para24,2,,例如，上一段中“干净地板”的概念是基于一段时间内的平均整洁度。
chap2_para24,3,,然而，两个不同的智能体可以达到相同的平均整洁度，其中一个智能体工作始终保持一般水平，而另一个智能体短时间工作效率很高但需要长时间的休息。
chap2_para24,4,,哪种工作方式更可取似乎是保洁科学的好课题，但实际上这是一个具有深远影响的深刻哲学问题。
chap2_para24,5,,大起大落、不计后果的生活，和安全但单调的生活，哪个更好？
chap2_para24,6,,一个人人都生活在中度贫困的经济体，和一个有些人生活富裕而另一些人非常贫困的经济体，哪个更好？
chap2_para24,7,,我们把这些问题留给勤奋的读者作为习题。
chap2_para240,1,,● 动作：虽然在真实世界中是滑块在移动，但描述动作的最简单方法是假设空格执行Left、Right、Up或Down动作。
chap2_para240,2,,如果空格位于边缘或角落，则不是所有的动作都可用。
chap2_para241,1,,● 转移模型：将状态和动作映射为一个结果状态；例如，图3-3中，对于初始状态，我们采取Left动作，那么结果状态中滑块5和空格将交换位置。
chap2_para242,1,,● 目标状态：尽管任何状态都可以作为目标状态，但我们通常用有序编号指定目标状态，如图3-3所示。
chap2_para243,1,,● 动作代价：每个动作的代价都为1。
chap2_para244,1,,注意，每个问题的形式化都涉及抽象。
chap2_para244,2,,8数码问题中的动作被抽象为它们的开始状态和结束状态，忽略滑块滑动的中间位置。
chap2_para244,3,,我们已经通过抽象除去了一些动作，例如，当滑块被卡住时需要晃动木板，并排除了用刀取出滑块然后再放回去的可能性。
chap2_para244,4,,最终只剩下对规则的描述，避免了实际操作的所有细节。
chap2_para245,1,,图3-3　8数码问题的一个典型实例
chap2_para246,1,,"我们介绍的最后一个标准化问题是由高德纳（Knuth, 1964）设计的，它说明了无限状态空间是如何产生的。"
chap2_para246,2,,高德纳推测，通过只由平方根、向下取整和阶乘操作组成的序列可以从数字4得到任何正整数。
chap2_para246,3,,例如，我们可以这样从4得到5：
chap2_para247,1,,问题定义很简单，如下所述。
chap2_para25,1,"For most of the book, we will assume that the performance measure can be specified correctly. For the reasons given above, however, we must accept the possibility that we might put the wrong purpose into the machine—precisely the King Midas problem described on page 51. Moreover, when designing one piece of software, copies of which will belong to different users, we cannot anticipate the exact preferences of each individual user. Thus, we may need to build agents that reflect initial uncertainty about the true performance measure and learn more about it as time goes by; such agents are described in Chapters 15, 17, and 23.",对于本书的大部分内容，我们将假设性能度量可以正确地指定。
chap2_para25,2,,然而，出于前面所述原因，我们必须接受这样一种可能性：我们可能会将错误的目的施加给机器，确切地说，就是1.5节描述的迈达斯国王问题。
chap2_para25,3,,此外，当设计一款软件（其副本将属于不同的用户）时，我们无法预测每个用户的确切偏好。
chap2_para25,4,,因此，我们可能需要构建相应的智能体，它能够反映真实性能度量的初始不确定性，并随着时间的推移对其了解更多，第16章、第18章和第22章介绍了此类智能体。
chap2_para250,1,,● 动作：应用平方根、向下取整或阶乘操作（阶乘仅用于整数）。
chap2_para251,1,,● 转移模型：根据运算的数学定义给出。
chap2_para252,1,,● 目标状态：所求的正整数。
chap2_para254,1,,这一问题的状态空间是无限的：对于任意大于2的整数，阶乘操作总是产生一个更大的整数。
chap2_para254,2,,这个问题很有趣，因为它探索了非常大的数字：从4到5的最短路径生成了数字(4!)! = 620 448 401 733 239 439 360 000。
chap2_para254,3,,无限状态空间经常出现在涉及数学表达式生成、电路、证明、程序和其他递归定义对象的任务中。
chap2_para255,1,,3.2.2　真实世界问题
chap2_para256,1,,我们已经了解了如何根据指定的位置和沿着它们之间的边进行的位置转移来定义寻径问题（route-finding problem）。
chap2_para256,2,,寻径算法有许多应用场景。
chap2_para256,3,,其中一些是上文中罗马尼亚例子的直接扩展，例如提供导航的网站和车载系统等。
chap2_para256,4,,（需要考虑的主要复杂因素是因与交通相关的延迟而导致的代价变化，以及因道路封闭而导致的路线变更。
chap2_para256,5,,）另一些例如计算机网络中的视频流路由、军事行动规划和飞机航线规划系统等，则更加复杂。
chap2_para256,6,,下面介绍旅行规划网站必须解决的航空旅行问题。
chap2_para257,1,,● 状态：每个状态显然包括当前位置（例如，某个机场）和当前时间。
chap2_para257,2,,此外，由于每个动作（一个航段）的代价可能依赖于之前的航段、票价基础以及它们是国内航班还是国际航班，状态必须记录这些额外的“历史”信息。
chap2_para258,1,,● 初始状态：用户家所在的机场。
chap2_para259,1,,● 动作：在当前时间之后，从当前位置乘坐任意航班任意舱位起飞，如果需要，还要留出足够的时间在机场中转。
chap2_para26,1,2.,
chap2_para26,2,2.,
chap2_para26,3,2Rationality,
chap2_para260,1,,● 转移模型：乘坐航班产生的结果状态将航班的目的地作为新的当前位置，将航班的到达时间作为新的当前时间。
chap2_para261,1,,● 目标状态：目的地城市。
chap2_para261,2,,有时目标可能更复杂一点，例如“乘坐直达航班到达目的地”。
chap2_para262,1,,● 动作代价：金钱成本、等待时间、飞行时间、海关和入境手续、舱位质量、当日时间、飞机类型、常旅客奖励积分等的组合。
chap2_para263,1,,商业旅行咨询系统使用的就是上述问题的形式化。
chap2_para263,2,,不过，在处理航空公司错综复杂的票价结构时，还会有许多额外的复杂因素。
chap2_para263,3,,例如，任何有经验的旅行者都知道，并不是所有的航空旅行都能按计划进行。
chap2_para263,4,,因此，一个真正好的系统应该包括应变规划——如航班延误或者错过转机时的应对方案。
chap2_para264,1,,旅行问题（touring problem）描述的是一组必须访问的地点，而非单一目的地。
chap2_para264,2,,旅行商问题（traveling salesperson problem，TSP），就是一个旅行问题，即地图上每个城市都必须被访问。
chap2_para264,3,,其目标是找到代价小于C的旅行路线（在优化版本中，目标是找到代价最低的旅行路线）。
chap2_para264,4,,为了提高TSP算法的性能，科研人员付出了大量的努力。
chap2_para264,5,,该算法也可以扩展到处理车队问题。
chap2_para264,6,,"例如，规划波士顿校车路线的搜索优化算法为人们节约了500万美元，减少了交通拥堵和空气污染，同时还为司机和学生节省了时间（Bertsimas et al., 2019）。"
chap2_para264,7,,除了规划行程，搜索算法还被用于规划自动电路板钻孔机钻头的运动和装料机在车间内的移动等任务。
chap2_para265,1,,超大规模集成电路布图（VLSI layout）问题需要在一个芯片上定位数百万个元件和连接点，以最小化芯片面积、电路延迟和杂散电容，并最大化成品率。
chap2_para265,2,,布图问题在逻辑设计阶段之后，通常分为两个部分：单元布图（cell layout）和通道布线（channel routing）。
chap2_para265,3,,在单元布图中，电路的基本元件分组为若干单元，每个单元执行一些特定功能。
chap2_para265,4,,每个单元都有固定的占用区域（大小和形状），并且需要与其他每个单元建立一定数量的连接。
chap2_para265,5,,单元布图的目的是将单元彼此不重叠地放置在芯片上，并且单元之间有足够的空间布置连线。
chap2_para265,6,,通道布线的目的则是通过单元之间的间隙为每条导线寻找特定的路线。
chap2_para265,7,,这些搜索问题极其复杂，但绝对值得研究。
chap2_para266,1,,机器人导航（robot navigation）是寻径问题的一个推广。
chap2_para266,2,,机器人不必沿着明确的路径（如罗马尼亚的道路）行走，而是可以四处游走，实际上是自己走自己的路。
chap2_para266,3,,对于在平面上移动的圆形机器人，空间本质上是二维的。
chap2_para266,4,,当机器人的手臂和腿也必须受到控制时，搜索空间就变成了多维的——每个关节角都是一个维度。
chap2_para266,5,,为了使基本上连续的搜索空间变成有限空间，需要一些更先进的技术（见第26章）。
chap2_para266,6,,除了问题的复杂性外，真正的机器人还必须处理传感器读取错误、电动机控制中的错误、部分可观测性以及可能改变环境的其他智能体等问题。
chap2_para267,1,,自20世纪70年代以来，由机器人对复杂物体（例如电动机）进行自动装配排序（automatic assembly sequencing）已成为标准的工业实践。
chap2_para267,2,,算法首先找到一个可行的装配序列，然后对装配过程进行优化。
chap2_para267,3,,将装配线上的人工劳动减少到最低限度可以节省大量时间和成本。
chap2_para267,4,,装配问题的目标是找到某个对象的各个零件的组装顺序。
chap2_para267,5,,如果顺序错误，那么只能撤消某些已完成的工序，否则无法在序列的后面添加其他部分。
chap2_para267,6,,检查序列中动作的可行性是与机器人导航问题密切相关的几何搜索难题。
chap2_para267,7,,因此，合法动作的生成是装配排序问题中代价较高的部分。
chap2_para267,8,,任何实用算法都必须尽量避免探索全部的状态空间，而应只探索状态空间中的很小一部分。
chap2_para267,9,,一类重要的装配问题是蛋白质设计（protein design），其目的是找到一种氨基酸序列，该序列能够折叠成具有正确特性的三维蛋白质结构，以治疗某些疾病。
chap2_para269,1,,搜索算法（search algorithm）将搜索问题作为输入并返回问题的解或报告failure（当解不存在时）。
chap2_para269,2,,在本章中，我们考虑在状态空间图上叠加一棵搜索树（search tree）的算法，该算法从初始状态形成各条路径，并试图找到一条可以达到某个目标状态的路径。
chap2_para269,3,,搜索树中的每个节点（node）对应于状态空间中的一个状态，搜索树中的边对应于动作。
chap2_para269,4,,树的根对应于问题的初始状态。
chap2_para27,1,What is rational at any given time depends on four things:,在任何时候，理性取决于以下4方面：
chap2_para270,1,,理解状态空间和搜索树之间的区别非常重要。
chap2_para270,2,,状态空间描述了世界的（可能无限的）状态集，以及允许从一个状态转移到另一个状态的动作。
chap2_para270,3,,搜索树描述了这些状态之间通向目标的路径。
chap2_para270,4,,搜索树可以有多条路径（因此可以有多个节点）到达任何给定状态，但树中的每个节点都只有唯一一条返回根的路径（与所有树一样）。
chap2_para271,1,,图3-4展示了寻找从Arad到Bucharest的路径的前几步。
chap2_para271,2,,搜索树的根节点位于初始状态，Arad。
chap2_para271,3,,我们可以按如下方式扩展（expand）节点：考虑该状态的可用动作Actions，使用Result函数查看这些动作指向何处，并为每个结果状态生成（generating）一个新节点，称为子节点（child node）或后继节点（successor node）。
chap2_para271,4,,每个子节点的父节点（parent node）都是Arad。
chap2_para272,1,,图3-4　3棵部分搜索树，用于寻找从Arad到Bucharest的路线。
chap2_para272,2,,已扩展节点用淡紫色和粗体字母表示；边界上已生成但未被扩展的节点用绿色表示；对应于这两种类型节点的状态集被称为已达。
chap2_para272,3,,接下来可能生成的节点用虚线表示。
chap2_para272,4,,注意，在最下面的树中，有一个从Arad到Sibiu再到Arad的环，这不可能是最优路径，因此搜索不应该从那里继续
chap2_para273,1,,现在我们必须从这3个子节点中选择一个考虑下一步扩展。
chap2_para273,2,,这就是搜索的本质——先跟踪一个选项，之后再考虑其他选项。
chap2_para273,3,,假定我们选择先扩展Sibiu。
chap2_para273,4,,结果如图3-4中最下面的搜索树所示，我们得到了6个未被扩展的节点（以绿色节点显示）。
chap2_para273,5,,我们称之为搜索树的边界（frontier）。
chap2_para273,6,,任何已经生成过节点的状态都称为已达（reached）状态（无论该节点是否被扩展）。
chap2_para273,7,,[5]图3-5为叠加在状态空间图上的搜索树。
chap2_para275,1,,[5]　一些作者将边界称为开节点表，这在地理学上不太容易引起共鸣，在计算上也不太合适，因为在这里，队列比表更有效。
chap2_para275,2,,这些作者还使用闭节点表一词来指代之前已扩展的节点的集合，在我们的术语中，这些节点为已达节点去掉边界节点后的剩余节点。
chap2_para276,1,,图3-5　由图3-1中的罗马尼亚问题的图搜索生成的搜索树序列。
chap2_para276,2,,在每一阶段，我们扩展边界上的每个节点，使用所有不指向已达状态的可用动作延伸每条路径。
chap2_para276,3,,需要注意的是，在第三阶段，最高位置的城市（Oradea）有两个后继城市，这两个城市都已经有其他路径到达，所以没有路径可以从Oradea延伸
chap2_para277,1,,注意，边界分离（separate）了状态空间图的两个区域，即内部区域（其中每个状态都已被扩展）和外部区域（尚未到达的状态）。
chap2_para277,2,,该属性如图3-6所示。
chap2_para278,1,,图3-6　以矩形网格问题为例说明图搜索的分离性质。
chap2_para278,2,,边界（绿色）分离了内部（淡紫色）和外部（虚线）。
chap2_para278,3,,边界是已达但尚未扩展的节点（及相应的状态）的集合；内部是已被扩展的节点（及相应的状态）的集合；外部是尚未到达的状态的集合。
chap2_para278,4,,在（a）中，只有根节点被扩展。
chap2_para278,5,,在（b）中，上面的边界节点被扩展。
chap2_para278,6,,在（c）中，按顺时针顺序扩展根节点的其他后继节点
chap2_para279,1,,3.3.1　最佳优先搜索
chap2_para28,1,•The performance measure that defines the criterion of success.,● 定义成功标准的性能度量；
chap2_para280,1,,我们如何决定下一步从边界扩展哪个节点？
chap2_para280,2,,最佳优先搜索（best-first search）是一种非常通用的方法，在这种方法中，我们选择使得某个评价函数（evaluation function）f(n)的值最小的节点n。
chap2_para280,3,,算法如图3-7所示。
chap2_para280,4,,在每次迭代中，选择边界上具有最小f(n)值的一个节点，如果它的状态是目标状态，则返回这个节点，否则调用Expand生成子节点。
chap2_para280,5,,对于每个子节点，如果之前未到达过该子节点，则将其添加到边界；如果到达该子节点的当前路径的代价比之前任何路径都要小，则将其重新添加到边界。
chap2_para280,6,,该算法要么返回failure，要么返回一个节点（表示一条通往目标的路径）。
chap2_para280,7,,通过使用不同的f(n)函数，可以得到不同的具体算法，本章将介绍这些算法。
chap2_para281,1,,图3-7　最佳优先搜索算法以及扩展节点的函数。
chap2_para281,2,,这里使用的数据结构将在3.3.2节中介绍。
chap2_para281,3,,yield的说明见附录B
chap2_para282,1,,3.3.2　搜索数据结构
chap2_para283,1,,搜索算法需要一个数据结构来跟踪搜索树。
chap2_para283,2,,树中的节点（node）由一个包含4个组成部分的数据结构表示。
chap2_para284,1,,● node.State：节点对应的状态。
chap2_para285,1,,● node.Parent：父节点，即树中生成该节点的节点。
chap2_para286,1,,● node.Action：父节点生成该节点时采取的动作。
chap2_para287,1,,● node.Path-Cost：从初始状态到此节点的路径总代价。
chap2_para287,2,,在数学公式中，一般使用g(node)表示Path-Cost。
chap2_para288,1,,通过从一个节点返回的Parent指针，我们可以复原到达该节点的路径上的状态和动作。
chap2_para288,2,,从一个目标节点开始复原，我们就可以得到问题的解。
chap2_para289,1,,我们需要一个数据结构来存储边界。
chap2_para289,2,,一个恰当的选择是某种队列（queue），因为边界上的操作有以下几个。
chap2_para29,1,•The agent’s prior knowledge of the environment.,● 智能体对环境的先验知识；
chap2_para290,1,,● Is-Empty( frontier)：返回true当且仅当边界中没有节点。
chap2_para291,1,,● Pop( frontier)：返回边界中的第一个节点并将它从边界中删除。
chap2_para292,1,,● Top( frontier)：返回（但不删除）边界中的第一个节点。
chap2_para293,1,,"● Add(node, frontier)：将节点插入队列中的适当位置。"
chap2_para294,1,,搜索算法使用了3种不同类型的队列。
chap2_para295,1,,● 优先队列（priority queue）首先弹出根据评价函数f计算得到的代价最小的节点。
chap2_para295,2,,它被用于最佳优先搜索。
chap2_para296,1,,● FIFO队列（FIFO queue），即先进先出队列（first-in-first-out queue），首先弹出最先添加到队列中的节点；它被用于广度优先搜索。
chap2_para297,1,,● LIFO队列（LIFO queue），即后进先出队列（last-in-first-out queue），也称为栈（stack），首先弹出最近添加的节点；它被用于深度优先搜索。
chap2_para298,1,,已达状态可以存储为一个查找表（例如，哈希表），其中每个键是一个状态，对应的值是该状态的节点。
chap2_para299,1,,3.3.3　冗余路径
chap2_para3,1,"Chapter 1 identified the concept of rational agents as central to our approach to artificial intelligence. In this chapter, we make this notion more concrete. We will see that the concept of rationality can be applied to a wide variety of agents operating in any imaginable environment. Our plan in this book is to use this concept to develop a small set of design principles for building successful agents—systems that can reasonably be called intelligent.",我们从检查智能体、环境以及它们之间的耦合开始。
chap2_para3,2,,观察到某些智能体比其他智能体表现得更好，可以自然而然地引出理性智能体的概念，即行为尽可能好。
chap2_para3,3,,智能体的行为取决于环境的性质。
chap2_para3,4,,我们将对环境进行粗略分类，并展示环境的属性如何影响智能体的设计。
chap2_para3,5,,我们描述一些基本的“框架”智能体设计，本书余下的部分将充实相关内容。
chap2_para30,1,•The actions that the agent can perform.,● 智能体可以执行的动作；
chap2_para300,1,,图3-4（最下面一排）所示的搜索树包含了一条从Arad到Sibiu再回到Arad的路径。
chap2_para300,2,,这时我们称Arad为搜索树中的一个重复状态（repeated state），在本例中该重复状态是由循环（cycle）［也称为环路（loopy path）］生成的。
chap2_para300,3,,因此，即使状态空间只有20种状态，完整的搜索树也是无限的，因为遍历循环的频率没有限制。
chap2_para301,1,,循环是冗余路径（redundant path）的一种特殊情况。
chap2_para301,2,,例如，我们可以通过路径Arad—Sibiu（总长140英里）或路径Arad—Zerind—Oradea—Sibiu（总长297英里）到达Sibiu。
chap2_para301,3,,第二条路径是冗余的——是到达相同状态的一种比较差的方式——在我们寻找最优路径时不需要考虑它。
chap2_para302,1,,考虑一个10×10网格世界中的智能体，它能够移动到8个相邻方格中的任何一个。
chap2_para302,2,,如果没有障碍，智能体可以在9步或更少的移动内到达100个方格中的任何一个。
chap2_para302,3,,但是长度为9的路径的数量几乎是89（由于网格边缘的存在，路径数稍微少了一点），超过了1亿条。
chap2_para302,4,,也就是说，平均意义下，有超过100万条长度为9的冗余路径到达同一个单元格，如果我们消除了冗余路径，搜索完成的速度可以快大约100万倍。
chap2_para302,5,,俗话说，不记得历史的算法注定要重复历史。
chap2_para302,6,,有3种方法可以解决这一问题。
chap2_para303,1,,第一，我们可以记住之前到达的所有状态（就像最佳优先搜索一样），这样能够检测到所有冗余路径，并只保留每个状态的最优路径。
chap2_para303,2,,这适用于存在大量冗余路径的状态空间，当内存可以容纳下已达状态表时，它是首选方法。
chap2_para304,1,,第二，我们不必担心对过去的重复。
chap2_para304,2,,在一些问题形式化中，很少或不可能出现两条路径到达相同状态。
chap2_para304,3,,以装配问题为例，每个动作都会将一个零件添加到一个不断发展的装配中，零件是有序的，因此可以先添加A，然后再添加B，但不能先添加B，然后再添加A。
chap2_para304,4,,"对于这些问题, 如果我们不记录已达状态也不检查冗余路径，则可以节省内存空间。"
chap2_para304,5,,如果搜索算法会检查冗余路径，我们称之为图搜索（graph search）；否则，称之为树状搜索（tree-like search）[6]。
chap2_para304,6,,图3-7中的Best-First-Search算法是一种图搜索算法；如果删除所有对reached的引用，即为树状搜索，它使用更少的内存，但会出现到达相同状态的冗余路径，因此运行速度会更慢。
chap2_para306,1,,[6]　我们称之为“树状搜索”，是因为无论如何搜索，状态空间仍然是相同的图；我们只是把它当作一棵树，从每个节点返回根只有一条路径。
chap2_para307,1,,第三，我们可以选择折中方法，检查循环，但通常不检查冗余路径。
chap2_para307,2,,由于每个节点都有一个父指针链，因此可以通过跟踪父指针链来查看路径末端的状态之前是否在路径中出现过，从而不需要额外内存即可检查是否存在循环。
chap2_para307,3,,某些算法实现一直沿着这个链向上移动，从而消除了所有循环。
chap2_para307,4,,另一些算法实现仅跟踪少数几个链接（例如，到父节点、祖父节点和曾祖父节点），因此仅需花费固定的时间就可以消除所有短循环（并依靠其他机制来处理长循环）。
chap2_para308,1,,3.3.4　问题求解性能评估
chap2_para309,1,,在开始设计各种搜索算法之前，需要考虑在这些算法中进行选择时所使用的标准。
chap2_para309,2,,我们可以从以下4个方面评价算法的性能。
chap2_para31,1,•The agent’s percept sequence to date.,● 智能体到目前为止的感知序列。
chap2_para310,1,,● 完备性（completeness）：当存在解时，算法是否能保证找到解，当不存在解时，是否能保证报告失败？
chap2_para311,1,,● 代价最优性（cost optimality）：它是否找到了所有解中路径代价最小的解？
chap2_para311,2,,[7]
chap2_para313,1,,[7]　一些作者使用“可容许性”这一术语表示寻找最小代价解的性质，还有一些作者仅使用“最优性”，但这可能与其他类型的最优性相混淆。
chap2_para314,1,,● 时间复杂性（time complexity）：找到解需要多长时间？
chap2_para314,2,,可以用秒数来衡量，或者更抽象地用状态和动作的数量来衡量。
chap2_para315,1,,● 空间复杂性（space complexity）：执行搜索需要多少内存？
chap2_para316,1,,为了理解完备性，考虑一个具有单一目标的搜索问题。
chap2_para316,2,,这个目标可能是状态空间的任何地方；因此，一个完备的算法必须能够系统地探索从初始状态可以到达的每一个状态。
chap2_para316,3,,在有限状态空间中，这是很容易实现的：只要我们跟踪路径并切断循环（例如，Arad到Sibiu再到Arad），最终我们将到达每一个可到达的状态。
chap2_para317,1,,在无限状态空间中，则需要更加小心。
chap2_para317,2,,例如，在高德纳的“4”问题中反复应用“阶乘”操作的算法将沿着从4到4!到(4!)!……的无限路径行进。
chap2_para317,3,,同样地，在一个没有障碍的无限网格上，沿着直线不停前进也会形成由新状态组成的无限路径。
chap2_para317,4,,在这两种情况下，算法永远不会返回它之前到达的状态，但它是不完备的，因为状态空间中的大部分状态永远都不会到达。
chap2_para318,1,,完备的搜索算法探索无限状态空间的方式必须是系统的（systematic），以确保它最终能够到达与初始状态相关的任何状态。
chap2_para318,2,,例如，在无限网格上，一种系统搜索方法是螺旋路径，它覆盖了距离原点s步远的所有单元格，然后移动到s + 1步远的单元格。
chap2_para318,3,,遗憾的是，在一个不存在解的无限状态空间中，一个合理的算法会一直搜索，它不会终止，因为它不知道下一个状态是否是目标状态。
chap2_para319,1,,时间复杂性和空间复杂性与问题的困难程度相关。
chap2_para319,2,,在理论计算机科学中，一种典型的度量方式是状态空间图的大小，，其中是图中顶点（状态节点）的数量，是边（不同的状态/动作对）的数量。
chap2_para319,3,,当状态空间图是显式的数据结构（如罗马尼亚地图）时，这种度量是合适的。
chap2_para319,4,,但在许多人工智能问题中，状态空间图只是由初始状态、动作和转移模型隐式地表示。
chap2_para319,5,,对于隐式的状态空间，复杂性可以用3个量来衡量：d，最优解的深度（depth）或动作数；m，任意路径的最大动作数；b，需要考虑的节点的分支因子（branching factor）或后继节点数。
chap2_para32,1,This leads to a definition of a rational agent:,这引出了理性智能体的定义：
chap2_para320,1,,3.4　无信息搜索策略
chap2_para321,1,,无信息搜索算法不提供有关某个状态与目标状态的接近程度的任何线索。
chap2_para321,2,,例如，考虑一个位于Arad且目标为Bucharest的智能体。
chap2_para321,3,,一个对罗马尼亚地理一无所知的无信息智能体无法判断第一步应该前往Zerind还是Sibiu。
chap2_para321,4,,相比之下，了解每个城市位置的有信息智能体（3.5节）则知道Sibiu距离Bucharest更近，因此Sibiu更有可能在最短路线上。
chap2_para322,1,,3.4.1　广度优先搜索
chap2_para323,1,,当所有动作的代价相同时，正确的策略是采用广度优先搜索（breadth-first search），即先扩展根节点，然后扩展根节点的所有后继节点，再扩展后继节点的后继，以此类推。
chap2_para323,2,,这是一种系统的搜索策略，因此即使在无限状态空间上也是完备的。
chap2_para323,3,,我们可以通过调用Best-First-Search实现广度优先搜索，其中评价函数f(n)是节点的深度，即到达该节点所需的动作数。
chap2_para324,1,,然而，我们可以通过一些技巧来提高算法效率。
chap2_para324,2,,先进先出队列比优先队列速度更快，并且能提供正确的节点顺序：新节点（总是比其父节点更深）进入队列的队尾，而旧节点，即比新节点浅的节点，首先被扩展。
chap2_para324,3,,此外，reached可以是一组状态，而不是状态到节点的映射，因为一旦到达某个状态，我们就再也找不到到达该状态的更好路径了。
chap2_para324,4,,这也意味着我们可以进行早期目标测试（early goal test），即在生成节点后立即检查该节点是否为一个解，而不是像最佳优先搜索使用的后期目标测试（late goal test）那样，等节点弹出队列后再检查该节点是否为一个解。
chap2_para324,5,,图3-8展示了在二叉树上进行广度优先搜索的过程，图3-9展示了使用早期目标测试来提高效率的算法。
chap2_para325,1,,图3-8　简单二叉树上的广度优先搜索。
chap2_para325,2,,每个阶段接下来要扩展的节点用三角形标记表示
chap2_para326,1,,图3-9　广度优先搜索和一致代价搜索算法
chap2_para327,1,,广度优先搜索总是能找到一个动作最少的解，因为当它生成深度为d的节点时，说明它已经生成了深度为d - 1的所有节点，如果其中一个节点是解，它应该已经被找到了。
chap2_para327,2,,这意味着，对于所有动作都具有相同代价的问题，它是代价最优的，但对于不具有该特性的问题，则不一定是最优的。
chap2_para327,3,,这两种情况都是完备的。
chap2_para327,4,,在时间和空间方面，想象我们在搜索一棵均衡树，其中每个状态都有b个后继。
chap2_para327,5,,搜索树的根生成b个节点，每个节点又生成b个节点，第二层总共是b2个节点。
chap2_para327,6,,每个节点又生成b个节点，从而在第三层产生b3个节点，以此类推。
chap2_para327,7,,现在假设解的深度为d，那么生成的节点总数为
chap2_para328,1,,所有节点都存储在内存中，所以时间复杂性和空间复杂性都是O(bd)。
chap2_para328,2,,这样的指数级上界是可怕的。
chap2_para328,3,,举一个典型的真实世界中的例子，考虑一个分支因子b = 10、处理速度为每秒100万节点、内存需求为1 KB/节点的问题。
chap2_para328,4,,深度d = 10的搜索将花费不到3小时的时间，但需要10 TB的内存。
chap2_para328,5,,对广度优先搜索来说，内存需求是一个比执行时间更严重的问题。
chap2_para328,6,,但时间仍然是一个重要因素。
chap2_para328,7,,深度d = 14时，即使有无限内存，搜索也需要3.5年。
chap2_para328,8,,一般来说，除了最小的问题实例，指数级复杂性的搜索问题无法通过无信息搜索求解。
chap2_para329,1,,3.4.2　Dijkstra算法或一致代价搜索
chap2_para33,1,"For each possible percept sequence, a rational agent should select an action that is expected to maximize its performance measure, given the evidence provided by the percept sequence and whatever built-in knowledge the agent has.",对于每个可能的感知序列，给定感知序列提供的证据和智能体所拥有的任何先验知识，理性智能体应该选择一个期望最大化其性能度量的动作。
chap2_para330,1,,当动作具有不同的代价时，一个显而易见的选择是使用最佳优先搜索，评价函数为从根到当前节点的路径的代价。
chap2_para330,2,,理论计算机科学界称之为Dijkstra算法，人工智能界则称之为一致代价搜索（uniform-cost search）。
chap2_para330,3,,不同于广度优先搜索在深度一致的波（首先是深度1，然后是深度2，以此类推）中展开，一致代价搜索算法的思想是在路径代价一致的波中展开。
chap2_para330,4,,该算法可以通过调用Best-First-Search实现，评价函数为Path-Cost，如图3-9所示。
chap2_para331,1,,考虑图3-10，问题是从Sibiu到达Bucharest。
chap2_para331,2,,Sibiu的后继是Rimnicu Vilcea和Fagaras，代价分别为80和99。
chap2_para331,3,,然后扩展代价最小的节点Rimnicu Vilcea，加入节点Pitesti，其代价为80 + 97 = 177。
chap2_para331,4,,此时代价最小的节点是Fagaras，所以接着扩展Fagaras，加入节点Bucharest，代价为99 + 211 = 310。
chap2_para331,5,,目标节点是Bucharest，但算法只在扩展节点时测试其是否为目标节点，而不是在生成节点时测试，因此它还没有检测到这是一条通往目标的路径。
chap2_para332,1,,图3-10　罗马尼亚问题状态空间的一部分，选择这部分来说明一致代价搜索
chap2_para333,1,,算法继续进行，接下来选择Pitesti进行扩展，添加到Bucharest的第二条路径，代价为80 + 97 + 101 = 278。
chap2_para333,2,,它的代价更低，因此用它取代reached中之前的路径，并添加到frontier中。
chap2_para333,3,,结果证明，这个节点目前具有最小代价，因此它被认为是下一个要扩展的节点，此时我们发现它是一个目标节点，从而返回该节点。
chap2_para333,4,,注意，如果我们在生成节点时检查目标，而不是在扩展代价最小的节点时检查，那么我们将返回一个代价更高的路径（即经过Fagaras的路径）。
chap2_para334,1,,一致代价搜索的复杂性用C*和表示，C*是最优解的代价[8]，是每个动作代价的下界，。
chap2_para334,2,,那么算法在最坏情况下的时间复杂性和空间复杂性是，比bd大得多。
chap2_para334,3,,这是因为一致代价搜索在探索包含一个可能有用的高代价动作的路径之前，可能会先探索具有低代价动作的大型树。
chap2_para334,4,,当所有动作代价相同时，等于bd+1，这时一致代价搜索类似于广度优先搜索。
chap2_para336,1,,[8]　在这里，以及整本书中，C*中的“*”表示C的最优值。
chap2_para337,1,,一致代价搜索是完备的，也是代价最优的，因为它找到的第一个解的代价至少与边界上的任何其他节点的代价一样小。
chap2_para337,2,,一致代价搜索会按照代价递增的顺序系统地考虑所有路径，而不会陷入一直沿单一无限路径探索的困境（假设所有动作的代价 ）。
chap2_para338,1,,3.4.3　深度优先搜索与内存问题
chap2_para339,1,,深度优先搜索（depth-first search）总是优先扩展边界中最深的节点。
chap2_para339,2,,它可以通过调用Best-First-Search来实现，其中评价函数f为深度的负数。
chap2_para339,3,,然而，它通常不是以图搜索的形式实现而是以树状搜索（不维护已达状态表）的形式实现。
chap2_para339,4,,搜索的过程如图3-11所示，搜索先直接到达搜索树的最深层，这里的节点不存在后继节点。
chap2_para339,5,,然后，搜索将“回退”到下一个仍存在未扩展后继节点的最深的节点。
chap2_para339,6,,深度优先搜索不是代价最优的，它会返回它找到的第一个解，即使这个解不是路径代价最小的。
chap2_para34,1,Consider the simple vacuum-cleaner agent that cleans a square if it is dirty and moves to the other square if not; this is the agent function tabulated in Figure 2.,考虑一个简单的真空吸尘器智能体，如果一个方格是脏的就清理它，如果不脏就移动到另一个方格，这就是图2-3中给出的智能体函数。
chap2_para34,2,3.,它是理性智能体吗？
chap2_para34,3,Is this a rational agent?,这需要看情况了！
chap2_para34,4,That depends!,首先，我们需要说明性能度量是什么，对环境了解多少，以及智能体具有哪些传感器和执行器。
chap2_para34,5,"First, we need to say what the performance measure is, what is known about the environment, and what sensors and actuators the agent has.",我们假设：
chap2_para34,6,Let us assume the following:,
chap2_para340,1,,图3-11　二叉树的深度优先搜索过程中，从开始状态A到目标M，共12步（从左到右，从上到下）。
chap2_para340,2,,边界节点为绿色，用三角形表示下一步要扩展的节点。
chap2_para340,3,,已扩展的节点为淡紫色，潜在的未来节点用模糊的虚线表示。
chap2_para340,4,,边界中没有后继的已扩展节点（用非常模糊的线表示）可以丢弃
chap2_para341,1,,对于树型的有限状态空间，算法是有效且完备的。
chap2_para341,2,,对于无环状态空间，算法可能会通过不同路径多次扩展同一状态，但是（最终）将系统地探索整个空间。
chap2_para342,1,,在有环状态空间中，深度优先搜索算法可能陷入无限循环；因此，一些深度优先搜索算法的实现会检查每个新节点是否存在循环。
chap2_para342,2,,在无限状态空间中，深度优先搜索不是系统性的：即使没有循环，它也可能陷入无限路径。
chap2_para342,3,,因此，深度优先搜索是不完备的。
chap2_para343,1,,那么，为什么还会有人选择使用深度优先搜索而不是广度优先搜索或最佳优先搜索呢？
chap2_para343,2,,答案是，对于使用树状搜索可以处理的问题，深度优先搜索对内存的需求要小得多。
chap2_para343,3,,深度优先搜索根本不保留reached表，并且边界集很小：如果将广度优先搜索中的边界集视为不断扩展的球体的表面，那么深度优先搜索中的边界集只是球体的半径。
chap2_para344,1,,对于图3-11所示的有限树状状态空间，深度优先的树状搜索所花费的时间与状态数成正比，其空间复杂性仅为O(bm)，其中b是分支因子，m是树的最大深度。
chap2_para344,2,,有些问题在广度优先搜索时需要EB量级的内存，而在深度优先搜索时仅需要KB量级。
chap2_para344,3,,由于其对内存的节约使用，深度优先树状搜索已经成为许多人工智能领域的基本工具，例如，约束满足（第6章）、命题可满足性（第7章）和逻辑编程（第9章）。
chap2_para345,1,,回溯搜索（backtracking search）是深度优先搜索的一种变体，它使用的内存更少。
chap2_para345,2,,（详见第6章。
chap2_para345,3,,）在回溯搜索中，一次只生成一个后继，而不是所有后继节点；每个部分扩展的节点会记住下一个要生成的后继节点。
chap2_para345,4,,此外，回溯通过直接修改当前状态描述而不是为一个全新的状态分配内存来生成后继状态。
chap2_para345,5,,这将内存需求减少到只有一个状态描述和一条具有O(m)个动作的路径；与深度优先搜索的O(bm)个状态相比，节省了大量资源。
chap2_para345,6,,通过回溯，我们还可以为当前路径上的状态维护一个有效的集合数据结构，从而使检查循环的时间从O(m)减少到O(1)。
chap2_para345,7,,为了使回溯起作用，我们必须能够在回溯时撤销每个动作。
chap2_para345,8,,回溯对许多具有大型状态描述的问题（例如机器人组装）的成功求解至关重要。
chap2_para346,1,,3.4.4　深度受限和迭代加深搜索
chap2_para347,1,,为了避免深度优先搜索陷入无限路径，我们可以使用深度受限搜索（depth-limited search）。
chap2_para347,2,,这是一个深度优先搜索的改进版本，在深度受限搜索中，我们设置深度界限，将深度上的所有节点视为其不存在后继节点（见图3-12）。
chap2_para347,3,,深度受限搜索算法的时间复杂性为O(b)，空间复杂性为O(b)。
chap2_para347,4,,遗憾的是，如果我们对的选择不当，算法将无法得到解，成为不完备的算法。
chap2_para348,1,,由于深度优先搜索是一种树状搜索，通常无法避免在冗余路径上浪费时间，但我们可以以一定的计算时间为代价来消除循环。
chap2_para348,2,,沿着父节点向上查看几个节点，就能检测出大多数循环；更长的循环则由深度界限处理。
chap2_para349,1,,有时可以根据对问题的了解选择一个较好的深度界限。
chap2_para349,2,,例如，罗马尼亚地图上有20个城市。
chap2_para349,3,,因此， = 19是一个有效的界限。
chap2_para349,4,,但是如果仔细研究地图，我们会发现，从任何一个城市到达另一个城市最多需要9步。
chap2_para349,5,,这个数值称为状态空间图的直径（diameter），它为我们提供了更好的深度界限，从而可以更有效地进行深度受限搜索。
chap2_para349,6,,然而，对于大多数问题，在求解问题之前，我们无法知道什么深度界限是好的。
chap2_para35,1,"•The performance measure awards one point for each clean square at each time step, over a “lifetime” of 1000 time steps.",● 在1000个时间步的“生命周期”内，性能度量在每个时间步为每个干净的方格奖励1分；
chap2_para350,1,,迭代加深搜索（iterative deepening search）解决了如何选择一个合适的的问题，方法是尝试所有值：首先是0，然后是1，然后是2，依次类推——直到找到一个解，或者深度受限搜索返回failure值（而不是cutoff值）。
chap2_para350,2,,算法如图3-12所示。
chap2_para350,3,,迭代加深搜索结合了深度优先和广度优先搜索的许多优点。
chap2_para350,4,,和深度优先搜索一样，它对内存的需求也不大：当问题存在解时，是O(bd)，在不存在解的有限状态空间上，是O(bm)。
chap2_para350,5,,与广度优先搜索一样，迭代加深搜索对于所有动作都具有相同代价的问题是最优的，并且在有限无环状态空间上是完备的，或者说在任何有限状态空间上，当我们检查路径节点上所有的循环时，它都是完备的。
chap2_para351,1,,图3-12　迭代加深和深度受限树状搜索。
chap2_para351,2,,迭代加深搜索反复调用界限递增的深度受限搜索。
chap2_para351,3,,它返回以下3种类型的值中的一种：一个解节点；当它搜索了所有节点，证明在任何深度都不存在解时，返回failure；当在比更深的层上可能存在解时，返回cutoff。
chap2_para351,4,,这是一种树状搜索算法，它不记录reached状态，因此比最佳优先搜索使用的内存要少得多，但存在通过不同路径多次访问相同状态的风险。
chap2_para351,5,,另外，如果Is-Cycle检验函数不检查所有环，那么算法可能会陷入一个无限循环
chap2_para352,1,,存在解时，时间复杂性为O(bd)，不存在解时，时间复杂性为O(bm)。
chap2_para352,2,,与广度优先搜索相同，迭代加深搜索的每次迭代也会生成一个新层级，但是广度优先搜索将所有节点都存储在内存中，而迭代加深搜索则会重复之前的层级，从而以花费更多的时间为代价节省了内存。
chap2_para352,3,,图3-13展示了二叉搜索树上的迭代加深搜索的4次迭代，在第4次迭代时找到了解。
chap2_para353,1,,迭代加深搜索可能看起来很浪费，因为搜索树顶端附近的状态被多次重复生成。
chap2_para353,2,,但是对于许多状态空间，大多数节点位于底层，所以上层是否重复并不重要。
chap2_para353,3,,在迭代加深搜索中，底层（深度d）的节点被生成一次，倒数第二层的节点被生成两次，以此类推，直到根节点的子节点（生成d次）。
chap2_para353,4,,所以在最坏情况下生成的节点总数是
chap2_para354,1,,时间复杂性为O(bd)——与广度优先搜索相近。
chap2_para354,2,,例如，当b = 10、d = 5时，生成的节点数分别为
chap2_para355,1,,如果你确实很在意重复的问题，可以使用一种混合方法，即先运行广度优先搜索，直到几乎消耗掉所有可用内存，然后对边界集中的所有节点应用迭代加深搜索。
chap2_para355,2,,通常，当搜索状态空间大于内存容量而且解的深度未知时，迭代加深搜索是首选的无信息搜索方法。
chap2_para356,1,,图3-13　二叉搜索树上的迭代加深搜索的4次迭代（目标为M），深度界限从0到3。
chap2_para356,2,,注意，内部节点形成了一条路径。
chap2_para356,3,,三角形标记下一步要扩展的节点，边界为加粗轮廓的绿色节点，非常模糊的节点可被证明不可能是这种深度界限下的解的一部分
chap2_para357,1,,3.4.5　双向搜索
chap2_para358,1,,到目前为止，我们介绍的算法都是从一个初始状态开始，最终到达多个可能目标状态中的任意一个。
chap2_para358,2,,另一种称为双向搜索（bidirectional search）的方法则同时从初始状态正向搜索和从目标状态反向搜索，直到这两个搜索相遇。
chap2_para358,3,,算法的动机是，要比bd小得多（例如，当b = d = 10时，复杂性不到之前算法的五万分之一）。
chap2_para359,1,,为此，我们需要维护两个边界集和两个已达状态表，并且要能反向推理：如果状态s'是s的正向后继，那么我们需要知道s是s'的反向后继。
chap2_para359,2,,当两个边界触碰到一起时，我们就找到了一个解。
chap2_para359,3,,[9]
chap2_para36,1,"•The “geography” of the environment is known a priori (Figure 2.2) but the dirt distribution and the initial location of the agent are not. Clean squares stay clean and sucking cleans the current square. The Right and Left actions move the agent one square except when this would take the agent outside the environment, in which case the agent remains where it is.",● 环境的“地理信息”是先验的（图2-2），但灰尘的分布和智能体的初始位置不是先验的，干净的方格会继续保持干净，吸尘（Suck）动作会清理当前方格，向左（Left）或向右（Right）的动作使智能体移动一个方格，如果该动作会让智能体移动到环境之外，智能体将保持在原来的位置；
chap2_para361,1,,[9]　在我们的实现中，reached数据结构支持查询给定状态是否为其成员，而边界数据结构（一个优先队列）不支持，因此我们使用reached检查是否互相触碰；但从概念上讲，我们查询的是这两个边界是否已经相遇。
chap2_para361,2,,通过将每个目标状态的节点加载到反向边界和反向已达表中，可以将实现扩展为处理多个目标状态。
chap2_para362,1,,双向搜索有很多不同版本，就像有很多不同的单向搜索算法一样。
chap2_para362,2,,在这一节中，我们将介绍双向最佳优先搜索。
chap2_para362,3,,尽管存在两个独立的边界，但接下来要扩展的节点始终是两个边界中的评价函数值最小的节点。
chap2_para362,4,,当函数为路径代价时，我们得到双向一致代价搜索，如果最优路径的代价是C*，则不扩展代价大于的节点。
chap2_para362,5,,这将使得速度大大提高。
chap2_para363,1,,一般的最佳优先双向搜索算法如图3-14所示。
chap2_para363,2,,我们传入问题和评价函数的两个版本，一个是正向的（下标F），另一个是反向的（下标B）。
chap2_para363,3,,当评价函数是路径代价时，找到的第一个解将是最优解，但是对于不同的评价函数，这一结论不一定是正确的。
chap2_para363,4,,因此，我们会记录迄今为止找到的最优解，并且可能不得不多次更新最优解，直到Terminated测试证明不可能再有更好的解。
chap2_para364,1,,图3-14　双向最佳优先搜索维护两个边界集和两个已达状态表。
chap2_para364,2,,当一个边界中的路径到达另一半搜索已达状态时，这两条路径（通过Join-Nodes函数）被连起来构成一个解。
chap2_para364,3,,我们得到的第一个解不一定是最优的；函数Terminated决定了什么时候停止寻找新的解
chap2_para365,1,,3.4.6　无信息搜索算法对比
chap2_para366,1,,图3-15根据3.3.4节中列出的4个评价标准对无信息搜索算法进行了比较。
chap2_para366,2,,这种比较适用于不检查重复状态的树状搜索版本。
chap2_para366,3,,对于检查重复状态的图搜索，主要区别在于，对于有限状态空间，深度优先搜索是完备的，并且空间复杂性和时间复杂性受到状态空间大小（顶点和边的数量，）的限制。
chap2_para367,1,,图3-15　搜索算法比较。
chap2_para367,2,,b是分支因子；m是搜索树的最大深度；d是最浅层解的深度，当不存在解时为m；是深度界限
chap2_para368,1,,3.5　有信息（启发式）搜索策略
chap2_para369,1,,本节将展示有信息搜索（informed search）策略——使用关于目标位置的特定领域线索——如何比无信息搜索策略更有效地找到解。
chap2_para369,2,,线索以启发式函数（heuristic function）的形式出现，记为h(n)：[10]
chap2_para37,1,"•The only available actions are Right, Left, and Suck.",● 可用的动作仅有向右（Right）、向左（Left）和吸尘（Suck）；
chap2_para371,1,,[10]　这看起来可能很奇怪，启发式函数真正需要的只是节点的状态，但作用对象却是节点。
chap2_para371,2,,一般使用h(n)而不是h(s)，是为了与评价函数f (n)和路径代价g(n)保持一致。
chap2_para372,1,,h(n) = 从节点n的状态到目标状态的最小代价路径的代价估计值
chap2_para373,1,,例如，在寻径问题中，我们可以通过计算地图上两点之间的直线距离来估计从当前状态到目标的距离。
chap2_para373,2,,我们将在3.6节中详细研究启发式函数及其来源。
chap2_para374,1,,3.5.1　贪心最佳优先搜索
chap2_para375,1,,贪心最佳优先搜索（greedy best-first search）是最佳优先搜索的一种形式，它首先扩展h(n)值最小的节点——看起来最接近目标的节点——因为这样可能可以更快找到解。
chap2_para375,2,,因此，评价函数f(n) = h(n)。
chap2_para376,1,,让我们看看这种算法如何求解罗马尼亚寻径问题；我们使用直线距离（straight-line distance）作为启发式函数，记为hSLD。
chap2_para376,2,,如果目标是Bucharest，我们需要知道到Bucharest的直线距离，如图3-16所示。
chap2_para376,3,,例如，hSLD(Arad) = 366。
chap2_para376,4,,注意，无法从问题描述本身（即Actions和Result函数）来计算hSLD的值。
chap2_para376,5,,此外，根据经验可知，hSLD与实际道路距离相关，因此是一个有用的启发式函数。
chap2_para377,1,,图3-17展示了使用hSLD搜索从Arad到Bucharest的路径的贪心最佳优先搜索的过程。
chap2_para377,2,,从Arad扩展的第一个节点是Sibiu，因为启发式函数认为它比Zerind或Timisoara更接近Bucharest。
chap2_para377,3,,下一个要扩展的节点是Fagaras，因为根据启发式函数，它现在最接近Bucharest。
chap2_para377,4,,Fagaras接着生成了Bucharest，即目标节点。
chap2_para377,5,,对于这一特定问题，使用hSLD的贪心最佳优先搜索无须扩展不在解路径上的节点就找到了解。
chap2_para377,6,,但是，它找到的解并不是代价最优的：经由Sibiu和Fagaras到达Bucharest的路径比经过Rimnicu Vilcea和Pitesti的路径长32英里。
chap2_para377,7,,这就是为什么这种算法会被称为“贪心的”——在每次迭代中，它都会做出在当前看来最优的（即可以最接近目标的）选择，但这也会导致贪心法在全局意义上可能产生比谨慎的算法更糟糕的结果。
chap2_para378,1,,图3-16　hSLD（到Bucharest的直线距离）的值
chap2_para379,1,,图3-17　基于直线距离启发式函数hSLD的贪心最佳优先树状搜索的各个阶段（目标为Bucharest）。
chap2_para379,2,,节点上标有h值
chap2_para38,1,•The agent correctly perceives its location and whether that location contains dirt.,● 智能体能够正确感知其位置以及该位置是否有灰尘。
chap2_para380,1,,贪心最佳优先图搜索在有限状态空间中是完备的，但在无限状态空间中是不完备的。
chap2_para380,2,,最坏情况下的时间复杂性和空间复杂性是。
chap2_para380,3,,然而，使用一个好的启发式函数，复杂性可以大大降低，对于某些问题可以达到O(bm)。
chap2_para381,1,,3.5.2　A*搜索
chap2_para382,1,,最常见的有信息搜索算法是A*搜索（A* search）（读为“A星搜索”），这是一种最佳优先搜索，评价函数为
chap2_para383,1,,其中g(n)是从初始状态到节点n的路径代价，h(n)是从节点n到一个目标状态的最短路径的代价估计值，因此我们有
chap2_para384,1,,f(n) = 经过n到一个目标状态的最优路径的代价估计值
chap2_para385,1,,在图3-18中，我们展示了目标为Bucharest的A*搜索过程。
chap2_para385,2,,g的值由图3-1中的动作代价计算得到，hSLD的值在图3-16中给出。
chap2_para385,3,,注意，Bucharest首先出现在图3-18的步骤e的边界中，但算法并没有选择它来进行扩展（因此它没有被检测为一个解），因为此时它不是边界中代价最小的节点（f = 450）——代价最小的节点是Pitesti（f = 417）。
chap2_para385,4,,换句话说，可能存在一个经过Pitesti的解，代价低至417，所以算法不会满足于一个代价为450的解。
chap2_para385,5,,在图3-18的步骤f中，另一条到Bucharest的路径此时代价最小（f = 418），因此它被选中并被检测为最优解。
chap2_para386,1,,A*搜索是完备的。
chap2_para386,2,,[11]它是否是代价最优则取决于启发式函数的某些性质。
chap2_para386,3,,一个关键性质是可容许性（admissibility）：一个可容许的启发式（admissible heuristic）函数永远不会高估到达某个目标的代价。
chap2_para386,4,,（因此，一个可容许的启发式函数是乐观的。
chap2_para386,5,,）
chap2_para388,1,,[11]　再强调一次，假设所有动作的代价都 ，状态空间要么有解，要么有限。
chap2_para389,1,,对于可容许的启发式函数，A*是代价最优的，我们可以通过反证法来证明这一点。
chap2_para389,2,,假设最优路径的代价为C*，但是该算法返回的路径代价为C C*，那么最优路径上一定存在某个未扩展的节点n（因为如果最优路径上的所有节点都已被扩展，那么算法返回的将是这个最优解）。
chap2_para389,3,,因此，使用符号g*(n)表示从起点到n的最优路径的代价，h*(n)表示从n到最近目标的最优路径的代价，我们将得到
chap2_para39,1,Under these circumstances the agent is indeed rational; its expected performance is at least as good as any other agent’s.,在这种情况下，智能体确实是理性的，它的预期性能至少与任何其他智能体一样。
chap2_para390,1,,第一行和最后一行矛盾，所以“算法可能返回次优路径”的假设一定是错误的——A*一定只返回代价最优路径。
chap2_para391,1,,另一个稍强的性质为一致性（consistency）。
chap2_para391,2,,如果对于每个节点n以及由动作a生成的n的每个后继节点n' 有以下条件，则启发式函数h(n)是一致的：
chap2_para392,1,,这是三角不等式（triangle inequality）的一种形式，它规定三角形的一条边不能大于其他两条边之和（见图3-19）。
chap2_para392,2,,一致的启发式函数的一个实例是上文中的直线距离hSLD。
chap2_para393,1,,图3-18　A*搜索的各个阶段（目标为Bucharest）。
chap2_para393,2,,节点上标有f = g + h，h值为图3-16中得到的到Bucharest的直线距离
chap2_para394,1,,"图3-19　三角不等式：如果启发式函数h是一致的，那么单个数值h(n)小于从n到n'的动作代价值c(n, a, n')加上启发式函数的估计值h(n')的和"
chap2_para395,1,,一致的启发式函数都是可容许的（反过来不成立），因此，使用一致的启发式函数的A*搜索都是代价最优的。
chap2_para395,2,,此外，如果使用一致的启发式函数，算法第一次到达某个状态时，它就在一条最优路径上，因此我们永远不需要将某个状态重复添加到边界中，也不必更改reached中的条目。
chap2_para395,3,,但是，如果使用不一致的启发式函数，最终可能导致多个路径到达相同状态，而且如果每条新路径的路径代价都小于前一条路径，最终在边界中该状态会有多个节点，这会耗费时间和空间。
chap2_para395,4,,因此，有些A*搜索算法的实现会注意让一个状态只进入边界一次，如果找到了到达该状态的更优路径，那么该状态的所有后继都会更新（这要求节点除了父指针外还要有子指针）。
chap2_para395,5,,"这些复杂性使得许多研究人员在实现A*搜索时避免使用不一致的启发式函数，但费尔纳等人（Felner et al., 2011）认为，最坏的结果在实践中很少发生，因此不应该害怕不一致的启发式函数。"
chap2_para396,1,,如果采用不可容许的启发式函数，那么A*搜索可能是代价最优的，也可能不是。
chap2_para396,2,,存在两种情况使得A*搜索是代价最优的：第一，如果存在一条代价最优路径，对于该路径上的所有节点n，h(n)都是可容许的，那么无论启发式函数在路径外状态上的值如何，算法都能找到这条路径。
chap2_para396,3,,第二，假设最优解的代价为C*，次优解的代价为C2，如果h(n)高估了部分代价但又没有高估太多，都不超过C2 − C*，那么也可以保证A*返回的解是代价最优的。
chap2_para397,1,,3.5.3　搜索等值线
chap2_para398,1,,一种对搜索进行可视化的方法是在状态空间中绘制等值线（contour），就像在地形图中绘制等高线一样。
chap2_para398,2,,如图3-20所示，在标记为400的等值线内，所有节点都有，以此类推。
chap2_para398,3,,因为A*扩展的是f代价最小的边界节点，所以它是从初始节点扇形地向外扩展，以f 值递增的同心带状方式添加节点。
chap2_para399,1,,一致代价搜索中也存在等值线，但是等值线表示g代价，而不是g + h。
chap2_para399,2,,一致代价搜索中，等值线将以初始状态为圆心呈“圆形”向各个方向均匀扩展，而不是偏向于目标状态。
chap2_para399,3,,对于具有好的启发式函数的A*搜索，g + h带将朝一个目标状态延伸（如图3-20所示），并且在最优路径周围收敛变窄。
chap2_para4,1,"We begin by examining agents, environments, and the coupling between them. The observation that some agents behave better than others leads naturally to the idea of a rational agent—one that behaves as well as possible. How well an agent can behave depends on the nature of the environment; some environments are more difficult than others. We give a crude categorization of environments and show how properties of an environment influence the design of suitable agents for that environment. We describe a number of basic “skeleton” agent designs, which we flesh out in the rest of the book.",2.1　智能体和环境
chap2_para40,1,One can see easily that the same agent would be irrational under different circumstances.,显而易见，同一个智能体在不同的情况下可能会变得不理性。
chap2_para40,2,"For example, once all the dirt is cleaned up, the agent will oscillate needlessly back and forth; if the performance measure includes a penalty of one point for each movement, the agent will fare poorly.",例如，一旦清除了所有灰尘，该智能体将会毫无必要地反复来回；如果性能度量考虑对每个动作罚1分，那么智能体的表现就会很差。
chap2_para40,3,A better agent for this case would do nothing once it is sure that all the squares are clean.,在确定所有方格都干净的情况下，一个更好的智能体不会做任何事情。
chap2_para40,4,"If clean squares can become dirty again, the agent should occasionally check and re-clean them if needed.",如果干净的方格可能再次变脏，智能体应该偶尔检查，并在必要时重新清理。
chap2_para40,5,"If the geography of the environment is unknown, the agent will need to explore it.",如果环境的地理信息是未知的，智能体则需要对其进行探索（explore）。
chap2_para40,6,Exercise 2.,习题2.VACR要求在这些情况下设计智能体。
chap2_para40,7,VACR asks you to design agents for these cases.,
chap2_para400,1,,需要清楚的是，扩展路径时，g代价是单调的（monotonic）：路径代价始终随着路径的延伸而不断增加，因为动作代价始终为正。
chap2_para400,2,,[12]因此，所得到的同心等值线彼此不会交叉，如果希望画出的等值线足够精细，则可以在任何路径上的任意两个节点之间画一条线。
chap2_para402,1,,[12]　从技术上讲，始终保持增加的代价称为“严格单调的”；永远不会减少但可能保持不变的代价称为“单调的”。
chap2_para403,1,,但代价是否单调递增则并不显然。
chap2_para403,2,,当你将一条路径从n扩展到n'时，代价从变为。
chap2_para403,3,,消去g(n)项，我们可以看到，当且仅当时，路径代价单调递增。
chap2_para403,4,,换句话说，当且仅当启发式函数是一致的时，路径代价单调递增。
chap2_para403,5,,[13]但需要注意的是，一条路径可能会在一行中贡献若干个具有相同g(n) + h(n)得分的节点；当h的减少量恰好等于刚刚采取的动作代价时，就会发生这种情况（例如，在一个网格问题中，当n与目标在同一行然后向目标迈进一步时，g增加1，h减少1）。
chap2_para403,6,,如果C*是最优解路径的代价，那么以下说法成立。
chap2_para405,1,,[13]　事实上，“单调启发式函数”这一术语是“一致的启发式函数”的同义词。
chap2_para405,2,,"这两种观点是独立发展的，但是之后被证明是等价的（Pearl, 1984）。"
chap2_para406,1,,● A*搜索将扩展从初始状态可以到达并且路径上的每个节点都满足的所有节点。
chap2_para406,2,,我们称这些节点为必然扩展节点（surely expanded node）。
chap2_para407,1,,● A*搜索可能会在选出目标节点之前扩展某些恰好在“目标等值线”（即f (n) = C*）上的节点。
chap2_para408,1,,● A*搜索不扩展的节点。
chap2_para409,1,,图3-20　罗马尼亚地图，其中等值线为f = 380、f = 400和f = 420，初始状态为Arad。
chap2_para409,2,,给定等值线内的节点的代价f = g + h小于或等于等值线值
chap2_para41,1,2.,2.2.3　全知、学习和自主
chap2_para41,2,2.,
chap2_para41,3,"3Omniscience, learning, and autonomy",
chap2_para410,1,,我们认为具有一致启发式函数的A*搜索是效率最优（optimally efficient）的，因为任何从初始状态扩展搜索路径并使用相同启发式信息的算法都必须扩展A*的所有必然扩展节点（因为任何一个必然扩展节点都可能是某个最优解的一部分）。
chap2_para410,2,,对于f(n)=C*的节点，某个算法可能运气好，首先选择了最优节点，而另一个算法就没这么幸运。
chap2_para410,3,,我们在定义最优效率时不考虑这种差异。
chap2_para411,1,,A*之所以高效，是因为它会对那些对于寻找最优解没有帮助的搜索树节点进行剪枝（pruning）。
chap2_para411,2,,在图3-18b中，我们看到，对于Timisoara，f = 447；对于Zerind，f = 449。
chap2_para411,3,,即使它们是根的子节点并且是采用一致代价搜索或广度优先搜索时首先扩展的节点，它们也永远不会被A*搜索扩展，因为A*会首先找到f = 418的解。
chap2_para411,4,,对许多人工智能领域来说，剪枝（不必进行检查就可以排除不正确的答案）非常重要。
chap2_para412,1,,在所有这些算法中，A*搜索都是完备的、代价最优的和效率最优的，这是相当令人满意的结果。
chap2_para412,2,,遗憾的是，这并不意味着A*适用于所有搜索需求。
chap2_para412,3,,问题在于，对于许多问题，所扩展的节点数可能是解路径长度的指数级。
chap2_para412,4,,例如，考虑一个具有超强吸力的真空吸尘器世界，它可以以单位代价清理任一方格却不需要访问该方格。
chap2_para412,5,,在这种情况下，可以按任何顺序清理方格。
chap2_para412,6,,如果开始时有N个脏的方格，则有2N种状态，其中某个子集已被清理；所有这些状态都在最优解路径上，因此满足，所以所有这些状态都会被A*搜索访问。
chap2_para413,1,,3.5.4　满意搜索：不可容许的启发式函数与加权A*搜索
chap2_para414,1,,A*搜索有很多好的性质，但它扩展了大量节点。
chap2_para414,2,,如果我们愿意接受次优但“足够好”的解——我们称之为满意（satisficing）解，则可以探索更少的节点（花费更少的时间和空间）。
chap2_para414,3,,如果我们允许A*搜索使用不可容许的启发式函数（inadmissible heuristic）（它可能会高估到达某个目标的代价），那么我们就有可能错过最优解，但是该启发式函数可能更准确，从而减少了需要扩展的节点数。
chap2_para414,4,,例如，道路工程师知道弯道指数（detour index）的概念，它是应用于直线距离的乘数，用来说明道路的典型曲率。
chap2_para414,5,,弯道指数1.3意味着如果两个城市的直线距离相距10千米，那么它们之间的最优路径的一个恰当的估计值是13千米。
chap2_para414,6,,对于大多数地区，弯道指数的范围是1.2到1.6。
chap2_para415,1,,不仅仅是与道路相关的问题，我们还可以将这一思想应用于任何问题，我们采用一种称为加权A*搜索（weighted A* search）的方法，对启发式函数的值进行更重的加权，评价函数为，其中。
chap2_para416,1,,图3-21为一个网格世界中的搜索问题。
chap2_para416,2,,在图3-21a中，A*搜索必须探索大部分状态空间才能找到最优解。
chap2_para416,3,,在图3-21b中，加权A*搜索找到一个代价稍高的解，但搜索时间要快得多。
chap2_para416,4,,我们看到，加权搜索使得已达状态的等值线专注于趋向某个目标。
chap2_para416,5,,这意味着需要探索的状态变少，但如果最优路径偏离加权搜索的等值线（就像在这种情况下一样），则无法找到最优路径。
chap2_para416,6,,一般来说，如果最优解的代价是C*，那么加权A*搜索将找到一个代价介于C*和W×C*之间的解；但在实践中，通常结果更接近于C*而不是W×C*。
chap2_para417,1,,图3-21　同一网格上的两种搜索：（a）A*搜索，（b）加权A*搜索，权重W = 2。
chap2_para417,2,,灰色线条表示障碍，紫色线是一条从绿色起始点到红色目标点的路径，较小的点是每次搜索到达的状态。
chap2_para417,3,,在这个特定问题上，加权A*搜索探索的状态数不到A*搜索探索的状态数的七分之一，找到的路径的代价只比最优代价大了5%
chap2_para418,1,,我们已经考虑过以各种方式组合g和h来评价状态的搜索方法；加权A*搜索可以看作是其他方法的一般化。
chap2_para42,1,"We need to be careful to distinguish between rationality and omniscience. An omniscient agent knows the actual outcome of its actions and can act accordingly; but omniscience is impossible in reality. Consider the following example: I am walking along the Champs Elysées one day and I see an old friend across the street. There is no traffic nearby and I’m not otherwise engaged, so, being rational, I start to cross the street. Meanwhile, at 33,000 feet, a cargo door falls off a passing airliner,3 and before I make it to the other side of the street I am flattened. Was I irrational to cross the street? It is unlikely that my obituary would read “Idiot attempts to cross street.”",我们需要仔细区分理性和全知（omniscience）。
chap2_para42,2,,全知的智能体能预知其行动的实际结果，并能据此采取行动，但在现实中，全知是不可能的。
chap2_para42,3,,考虑这样一个例子：有一天我正沿着香榭丽舍大街散步，我看到街对面的一位老朋友。
chap2_para42,4,,附近没有车流，我也没有别的事要做，所以理性上，我会开始过马路。
chap2_para42,5,,与此同时，在 10千米的高空，一架飞过的客机上有一扇货舱门脱落下来[3]，在我到达马路对面之前，我就被压扁了。
chap2_para42,6,,我过马路是不理性的吗？
chap2_para42,7,,我的讣告上不太可能写“试图过马路的白痴”。
chap2_para423,1,,你可以称加权A*搜索为“有点贪心的搜索”：就像贪心最佳优先搜索一样，它使得搜索专注于趋向一个目标；但是，它不会完全忽略路径代价，并且会暂停代价高昂但进展甚微的路径。
chap2_para424,1,,次优的搜索算法有很多，其区别在于“足够好”的标准。
chap2_para424,2,,在有界次优搜索（bounded suboptimal search）中，我们寻找一个能保证代价在最优代价的常数因子W倍内的解。
chap2_para424,3,,加权A*搜索提供了这一保证。
chap2_para424,4,,在有界代价搜索（bounded-cost search）中，我们寻找一个代价小于某个常数C的解。
chap2_para424,5,,在无界代价搜索（unbounded-cost search）中，我们接受任何代价的解，只要能快速找到它。
chap2_para425,1,,无界代价搜索算法的一个例子是快速搜索（speedy search），它是一种贪心最佳优先搜索，使用到达目标所需动作个数的估计值作为启发式函数，不考虑这些动作的代价。
chap2_para425,2,,因此，对于所有动作都具有相同代价的问题，它等于贪心最佳优先搜索，但当动作具有不同代价时，它往往会导致搜索快速找到一个代价可能很高的解。
chap2_para426,1,,3.5.5　内存受限搜索
chap2_para427,1,,A*搜索的主要问题是它对内存的使用较多。
chap2_para427,2,,在本节中，我们将介绍一些可以节省空间的实现技巧和一些能够更好地利用可用空间的全新算法。
chap2_para428,1,,内存被分为frontier状态和reached状态。
chap2_para428,2,,在我们所实现的最佳优先搜索中，边界上的状态存储在两个位置：边界中的一个节点（因此我们可以决定下一步扩展哪个节点）和已达状态表中的一个表项（因此我们知道之前是否访问过该状态）。
chap2_para428,3,,对于许多问题（例如探索网格），这种重复不是关注点，因为frontier要比reached小得多，所以复制边界中的状态所需内存相对较少。
chap2_para428,4,,但是有些算法实现只保留这两个位置中的其中一个，从而节省了一点空间，其代价是算法变得更复杂（可能会减慢速度）。
chap2_para429,1,,另一种可能性是，当我们能够证明不再需要某些状态时，就将它们从reached中删除。
chap2_para429,2,,对于某些问题，我们可以利用分离性质（图3-6），同时禁止掉头行动，以确保所有行动要么是从边界向外移动，要么是移动到另一个边界状态。
chap2_para429,3,,在这种情况下，我们只需检查边界就能判断是否有冗余路径，并且可以删除reached状态表。
chap2_para43,1,"This example shows that rationality is not the same as perfection. Rationality maximizes expected performance, while perfection maximizes actual performance. Retreating from a requirement of perfection is not just a question of being fair to agents. The point is that if we expect an agent to do what turns out after the fact to be the best action, it will be impossible to design an agent to fulfill this specification—unless we improve the performance of crystal balls or time machines.",
chap2_para430,1,,对于其他问题，我们可以维护引用计数（reference count）——到达某一状态的次数，并且在再也没有路径可以到达该状态时将其从reached表中删除。
chap2_para430,2,,例如，在网格世界中，每个状态只能从它的4个邻居状态到达，一旦我们已经到达了一个状态4次，就可以将它从表中删除。
chap2_para431,1,,现在，我们考虑旨在节省内存使用的新算法。
chap2_para432,1,,束搜索（beam search）对边界的大小进行了限制。
chap2_para432,2,,最简单的方法是只保留具有最优f值的k个节点，放弃其他已扩展节点。
chap2_para432,3,,这当然会导致搜索变成不完备的和次优的算法，但我们可以选取合适的k以充分利用可用内存，算法执行速度也会更快，因为它只扩展了较少的节点。
chap2_para432,4,,对于许多问题，它可以找到很好的近似最优解。
chap2_para432,5,,你可以将一致代价搜索或A*搜索看作在同心等值线的各个方向扩展，而将束搜索看作只探索这些等值线的主要部分，即包含k个最佳候选的部分。
chap2_para433,1,,另一种形式的束搜索并不严格限制边界的大小，而是保留f值在最优f值的范围内的所有节点。
chap2_para433,2,,这样的话，当存在几个强得分节点时，只会保留几个节点，但如果不存在强节点，则会保留更多节点，直到出现一个强节点。
chap2_para434,1,,迭代加深A*搜索（iterative-deepening A* search，IDA*）之于A*搜索，就像迭代加深搜索之于深度优先搜索一样：IDA*既拥有A*的优点，又不要求在内存中保留所有已达状态，这样做的代价是需要多次访问某些状态。
chap2_para434,2,,它是一种非常重要且常用的用于解决内存不足问题的算法。
chap2_para435,1,,在标准的迭代加深搜索中，截断值为深度，每次迭代深度增加1。
chap2_para435,2,,而在IDA*中，截断值是f代价（g + h）；在每次迭代中，新的截断值为超过上一次迭代截断值的节点中最小的f代价。
chap2_para435,3,,换句话说，每次迭代都会彻底地搜索一个f等值线，找到一个刚好超出该等值线的节点，并使用该节点的f代价作为下一个等值线。
chap2_para435,4,,像8数码这样的问题，每条路径的f代价都是整数，这非常有效地使得每次迭代都朝着目标稳步前进。
chap2_para435,5,,如果最优解的代价是C*，那么迭代的次数不可能超过C*（例如，最难的8数码问题的迭代次数不超过31）。
chap2_para435,6,,但对于每个节点的f代价都不相同的问题，每一个新的等值线可能只包含一个新节点，并且迭代次数可能等于状态数。
chap2_para436,1,,递归最佳优先搜索（recursive best-first search，RBFS）（见图3-22）试图模拟标准的最佳优先搜索的操作，但仅仅使用线性空间。
chap2_para436,2,,RBFS类似于递归深度优先搜索，但它不是沿着当前路径无限地向下搜索，而是使用f_limit变量跟踪从当前节点的任意祖先节点可得到的最优备选路径的f值。
chap2_para436,3,,如果当前节点超过了这个限制，那么递归将回到备选路径上。
chap2_para436,4,,随着递归的展开，RBFS将路径上每个节点的f值替换为一个倒推值（backed-up value）——其子节点的最优f值。
chap2_para436,5,,通过这种方式，RBFS可以记住被它遗忘的子树中最优叶节点的f值，因此，在之后的某个时刻，RBFS可以决定是否要重新扩展该子树。
chap2_para436,6,,图3-23展示了RBFS是如何到达Bucharest的。
chap2_para437,1,,图3-22　递归最佳优先搜索算法
chap2_para438,1,,在一定程度上，RBFS比IDA*更高效，但仍然存在重复生成大量节点的问题。
chap2_para438,2,,在图3-23的示例中，RBFS沿着经过Rimnicu Vilcea的路径，然后“改变主意”去尝试经过Fagaras，然后又“回心转意”。
chap2_para438,3,,之所以会发生这些改变，是因为每次扩展当前的最优路径时，它的f值很可能增加——对于靠近目标的节点，h值通常不那么乐观。
chap2_para438,4,,当这种情况发生时，次优路径可能会成为最优路径，因此搜索必须回溯。
chap2_para438,5,,每一次改变对应于IDA*的一次迭代，并且可能需要多次重新扩展已经遗忘的节点，以重建最优路径，并对该路径再扩展一个节点。
chap2_para439,1,,图3-23　使用RBFS搜索到Bucharest的最短路线的各个阶段。
chap2_para439,2,,每次递归调用的f_limit值标注在每个当前节点的上方，每个节点上都标有它的f代价。
chap2_para439,3,,（a）沿着经过Rimnicu Vilcea的路径前进，直到当前最优叶节点（Pitesti）的值比最优备选路径（Fagaras）差。
chap2_para439,4,,（b）递归回溯，被遗忘子树的最优叶节点值（417）被备份到Rimnicu Vilcea；接着扩展Fagaras，得到最优叶节点值450。
chap2_para439,5,,（c）递归回溯，被遗忘子树的最优叶节点值（450）被备份到Fagaras；然后扩展Rimnicu Vilcea。
chap2_para439,6,,这一次，因为最优备选路径（经由Timisoara）的代价至少为447，所以继续扩展Bucharest
chap2_para44,1,"Our definition of rationality does not require omniscience, then, because the rational choice depends only on the percept sequence to date. We must also ensure that we haven’t inadvertently allowed the agent to engage in decidedly underintelligent activities. For example, if an agent does not look both ways before crossing a busy road, then its percept sequence will not tell it that there is a large truck approaching at high speed. Does our definition of rationality say that it’s now OK to cross the road? Far from it!",[3]　参见N. Henderson，“波音747大型喷气式飞机迫切需要新门锁”，华盛顿邮报，1989年8月24日。
chap2_para440,1,,如果启发式函数h(n)是可容许的，那么RBFS是最优的。
chap2_para440,2,,它的空间复杂性在最深的最优解的深度上是线性的，但时间复杂性很难刻画：既取决于启发式函数的准确性，也取决于最优路径随节点扩展变化的频率。
chap2_para440,3,,它按照f得分递增的顺序来扩展节点，即使f是非单调的。
chap2_para441,1,,IDA*和RBFS使用内存太少，它们的时间复杂性会受到影响。
chap2_para441,2,,在两次迭代之间，IDA*只保留一个数值：当前的f代价限制。
chap2_para441,3,,RBFS在内存中保留了更多的信息，但它只使用线性空间：即使有更多的内存可用，RBFS也无法利用。
chap2_para441,4,,因为它们会遗忘它们所做的大部分事情，这两种算法都可能会多次重复探索相同状态。
chap2_para442,1,,因此，确定我们有多少可用内存并允许算法使用所有内存似乎是明智的。
chap2_para442,2,,执行这样操作的两种算法是MA*（memory-bounded A*，内存受限的A*）和SMA*（simplified MA*，简化的MA*）。
chap2_para442,3,,SMA*更简单一些，所以我们介绍SMA*。
chap2_para442,4,,SMA*很像A*算法，不断扩展最优叶节点，直到内存被填满。
chap2_para442,5,,此时，它不能再为搜索树添加新节点，除非删除旧节点。
chap2_para442,6,,SMA*总是丢弃最差的叶节点，即f值最大的叶节点。
chap2_para442,7,,和RBFS一样，SMA*将被遗忘节点的值备份到其父节点。
chap2_para442,8,,这样，被遗忘子树的祖先知道该子树中最优路径的质量。
chap2_para442,9,,有了这一信息，只有在所有其他路径看起来都比它已经遗忘的路径更差时，SMA*才会重新生成该子树。
chap2_para442,10,,这意味着如果节点n的所有后代都被遗忘了，那么尽管我们不知道从n开始应该走哪条路径，但我们仍知道是否应该从n开始走。
chap2_para443,1,,本书附带的在线代码库中描述了完整的SMA*算法。
chap2_para443,2,,有一点值得注意，我们之前提到SMA*将扩展最优叶节点，删除最差叶节点。
chap2_para443,3,,如果所有叶节点的f值都相同呢？
chap2_para443,4,,为了避免算法选择同一个节点进行删除和扩展操作，SMA*扩展最新的最优叶节点并删除最老的最差叶节点。
chap2_para443,5,,当只有一个叶节点时，这两者是同一个节点，但在这种情况下，当前的搜索树一定是一条从根节点到叶节点的占满所有内存的单一路径。
chap2_para443,6,,如果叶节点不是目标节点，那么即使它在最优解路径上，也无法在可用内存范围内得到这个解。
chap2_para443,7,,因此，完全可以丢弃该节点，就好像它没有后继节点一样。
chap2_para444,1,,如果存在任意可达解，也就是说，如果最浅的目标节点的深度d小于内存大小（用节点数表示），那么SMA*就是完备的。
chap2_para444,2,,如果存在可达的最优解，那么SMA*就是最优的；否则，就返回当前最优的可达解。
chap2_para444,3,,在实践中，SMA*是寻找最优解的一个相当稳健的选择，特别是当状态空间是一个图、行动代价不一致，并且生成节点的总开销相比维护边界集和已达集的总开销更大时。
chap2_para445,1,,然而，在非常困难的问题上，常常会出现SMA*被迫在许多候选解路径之间来回不断切换的情况，只有一小部分路径可以存入内存。
chap2_para445,2,,［这类似于磁盘分页系统中的抖动（thrashing）问题。
chap2_para445,3,,］那么，重复生成相同节点就需要额外的时间，这意味着，在给定无限内存的情况下可以用A*实际求解的问题，对于SMA*将变得难以处理。
chap2_para445,4,,也就是说，从计算时间的角度，内存限制会使问题变得难以处理。
chap2_para445,5,,虽然还没有现有理论解释如何在时间和内存之间权衡，但这似乎是一个不可避免的问题。
chap2_para445,6,,唯一的出路是放弃最优性要求。
chap2_para446,1,,3.5.6　双向启发式搜索
chap2_para447,1,,我们发现，在单向最佳优先搜索中，使用f(n) = g(n) + h(n)作为评价函数可以得到A*搜索，保证找到代价最优的解（假设h是可容许的），同时在所扩展的节点数上效率最优。
chap2_para448,1,,在双向最佳优先搜索中，我们也可以尝试使用f(n) = g(n) + h(n)，但遗憾的是，即使使用可容许的启发式函数，算法也不能保证可以找到代价最优的解，更不能保证效率最优。
chap2_para448,2,,"可以证明的是，在双向搜索中一定会被扩展的并不是单个的节点，而是节点对（分别来自两个边界），因此任何效率证明都必须考虑节点对（Eckerle et al., 2017）。"
chap2_para449,1,,我们先介绍一些新的符号。
chap2_para449,2,,对于正向搜索（以初始状态作为根节点）中的节点，我们用fF(n) = gF(n) + hF(n)作为评价函数；对于反向搜索（以某个目标状态作为根节点）中的节点，我们用fB(n) = gB(n) + hB(n)作为评价函数。
chap2_para449,3,,尽管正向搜索和反向搜索求解的是同一个问题，但它们具有不同的评价函数，这是因为，启发式函数依据其努力方向是目标状态还是初始状态而有所不同。
chap2_para449,4,,我们假设启发式函数是可容许的。
chap2_para45,1,"First, it would not be rational to cross the road given this uninformative percept sequence: the risk of accident from crossing without looking is too great. Second, a rational agent should choose the “looking” action before stepping into the street, because looking helps maximize the expected performance. Doing actions in order to modify future percepts—sometimes called information gathering—is an important part of rationality and is covered in depth in Chapter 15. A second example of information gathering is provided by the exploration that must be undertaken by a vacuum-cleaning agent in an initially unknown environment.",这个例子表明，理性不等同于完美。
chap2_para45,2,,理性使期望性能最大化，而完美使实际性能最大化。
chap2_para45,3,,不要求完美不仅仅是对智能体公平的问题。
chap2_para45,4,,关键是，如果我们期望一个智能体做事后证明是最好的行动，就不可能设计一个符合规范的智能体，除非我们改进占卜水晶球或时间机器的性能。
chap2_para450,1,,考虑从初始状态到节点m的正向路径和从目标到节点n的反向路径。
chap2_para450,2,,我们可以如下定义一个解代价的下界（这个解先沿着前向路径从初始状态到达m，然后以某种方式到达n，最后再沿着后向路径从n到达目标）。
chap2_para451,1,,换句话说，这样一条路径的代价一定不小于两部分路径代价之和（因为它们之间的剩余连接一定具有非负代价），而且也一定不小于任一部分的f代价估计值（因为启发式的估计是乐观的）。
chap2_para451,2,,"因此，有如下的定理：对于任意一对节点m和n，若lb(m, n)小于最优代价C*，那么算法必须扩展m或n，因为经过这两个节点的路径是一个潜在的最优解。"
chap2_para451,3,,然而，一个难题是我们无法确定扩展这两者中的哪个节点才是最优的，因此，没有一个双向搜索算法可以保证效率最优——如果算法总是首先选择一对节点中错误的那个进行扩展，那么任何算法都可能需要扩展到最小节点数两倍的节点。
chap2_para451,4,,"一些双向启发式搜索算法显式地管理一个(m, n)节点对队列，但我们将坚持双向最佳优先搜索（图3-14），它有两个边界优先队列，并使用模拟lb准则的评价函数："
chap2_para452,1,,接下来要扩展的节点将是f2值最小的节点；它可以来自任何一个边界。
chap2_para452,2,,这个f2函数保证算法永远不会扩展（来自任一边界的）的节点。
chap2_para452,3,,当两个边界相交时，任一边界内的节点都不存在超过C*/2的路径代价，在这种意义上，我们可以说搜索的两部分“在中间相遇”。
chap2_para452,4,,图3-24为一个双向搜索的示例。
chap2_para453,1,,图3-24　双向搜索维护两个边界：左半部分，节点A和B是开始状态的后继；右半部分，节点F是目标状态的逆向后继。
chap2_para453,2,,"每个节点都标有f = g + h值和f2 = max(2g, g + h)值。"
chap2_para453,3,,（g值是每个箭头上所显示的动作代价的总和；h值是任意的，而且不能从图中的任何内容推出。
chap2_para453,4,,）最优解“开始-A-F-目标”的代价C* = 4 + 2 + 4 = 10，这意味着一个在中间相遇的双向算法不应该扩展任何的节点；实际上，下一个要扩展的节点是A或F（g = 4），这将引导我们找到一个最优解。
chap2_para453,5,,如果我们首先扩展f代价最低的节点，那么下一个扩展的将是B和C，D和E将与A并列，但它们的，因此当f2是评价函数时它们永远不会被扩展
chap2_para454,1,,我们已经介绍了一种方法，即用hF估计到目标的距离（或者说，当问题有多个目标状态时，估计到最近目标的距离），用hB估计到开始状态的距离。
chap2_para454,2,,这就是所谓的front-to-end搜索。
chap2_para454,3,,另一种方法是front-to-front搜索，它试图估计到另一个边界的距离。
chap2_para454,4,,显然，如果边界内有数百万个节点，那么对每个节点应用启发式函数然后取最小值是非常低效的。
chap2_para454,5,,但它可以从边界中抽样几个节点。
chap2_para454,6,,在某些特定问题域中，可以对边界进行总结，例如，在网格搜索问题中，我们可以递增地计算边界的界限框，并使用到界限框的距离作为启发式函数。
chap2_para455,1,,双向搜索有时比单向搜索更有效，有时则不然。
chap2_para455,2,,一般来说，如果我们有一个很好的启发式函数，那么A*搜索会生成专注于目标的搜索等值线，使用双向搜索则增益不大。
chap2_para455,3,,使用一般的启发式函数时，在中间相遇的双向搜索往往会扩展较少的节点，因此双向搜索是首选方法。
chap2_para455,4,,在启发式函数较差的最坏情况下，搜索算法将不再专注于目标，并且双向搜索具有与A*相同的渐近复杂性。
chap2_para455,5,,使用f2评价函数和可容许的启发式函数h的双向搜索算法是完备且最优的。
chap2_para457,1,,在本节中，我们将研究启发式函数的准确性是如何影响搜索性能的，并考虑如何构造启发式函数。
chap2_para457,2,,我们将8数码问题作为主要示例。
chap2_para457,3,,如3.2节所述，它的目标是将滑块水平或竖直地滑动到空格中，直到棋盘布局与目标布局一致（图3-25）。
chap2_para458,1,,图3-25　8数码问题的典型实例。
chap2_para458,2,,最短的解需要26步动作
chap2_para459,1,,在一个8数码问题中，存在9!/2 = 181 400个可达状态，所以搜索算法可以轻松地将它们全部保存在内存中。
chap2_para459,2,,但是对于15数码问题，存在16!/2个状态（超过10万亿个），因此，为了搜索这个空间，我们需要借助一个较好的可容许的启发式函数。
chap2_para459,3,,对于15数码问题，这样的启发式函数有着悠久的历史。
chap2_para459,4,,下面介绍两个常用的选择。
chap2_para46,1,"Our definition requires a rational agent not only to gather information but also to learn as much as possible from what it perceives. The agent’s initial configuration could reflect some prior knowledge of the environment, but as the agent gains experience this may be modified and augmented. There are extreme cases in which the environment is completely known a priori and completely predictable. In such cases, the agent need not perceive or learn; it simply acts correctly.",因此，我们对理性的定义并不需要全知，因为理性决策只取决于迄今为止的感知序列。
chap2_para46,2,,我们还必须确保我们没有无意中允许智能体进行低智的行动。
chap2_para46,3,,例如，如果一个智能体在穿过繁忙的道路之前没有向两边看，那么它的感知序列将不会告诉它有一辆大卡车正在以高速接近。
chap2_para46,4,,我们对理性的定义是不是说现在就可以过马路了？
chap2_para46,5,,绝非如此！
chap2_para460,1,,● h1 = 错位滑块的数量（不包括空格）。
chap2_para460,2,,图3-25中，所有的8个滑块都不在原位，所以开始状态的h1 = 8。
chap2_para460,3,,h1是一个可容许的启发式函数，因为任何错位滑块都至少需要一次移动才能回到正确的位置。
chap2_para461,1,,● h2 = 滑块到其目标位置距离的总和。
chap2_para461,2,,因为滑块不能沿对角线移动，所以距离是水平距离和垂直距离之和——有时称为城市街区距离或曼哈顿距离（Manhattan distance）。
chap2_para461,3,,h2也是可容许的，因为任何移动操作所能做的就是将一个滑块向目标移近一步。
chap2_para461,4,,图3-25中开始状态的滑块1到滑块8得到的曼哈顿距离为
chap2_para462,1,,正如我们希望的那样，这两种方法都没有高估实际的解代价26。
chap2_para463,1,,3.6.1　启发式函数的准确性对性能的影响
chap2_para464,1,,一种描述启发式函数质量的方法是有效分支因子（effective branching factor）b*。
chap2_para464,2,,如果针对一个特定问题，A*搜索所生成的总节点数是n，而解的深度是d，那么b*就是深度为d的均衡树要包含n + 1个节点所必需的分支因子。
chap2_para464,3,,因此有
chap2_para465,1,,例如，如果A*用52个节点在第5层上找到了一个解，那么有效分支因子是1.92。
chap2_para465,2,,在不同的问题实例中，有效分支因子可能会发生变化，但通常对于特定领域（如8数码问题），在所有复杂的问题实例中它都是相当恒定的。
chap2_para465,3,,因此，对一小部分问题的b*进行实验测量可以为启发式函数的总体有用性提供良好的指导。
chap2_para465,4,,设计良好的启发式函数的b*接近1，使得我们能以合理的计算代价求解相当大的问题。
chap2_para466,1,,"科尔夫和里德（Korf and Reid, 1998）认为，对于一个使用给定启发式函数h的A*剪枝，刻画其效果的一个更好方式是：有效深度（effective depth）相比于真实深度的减少量kh（一个常数）。"
chap2_para466,2,,这意味着相较于无信息搜索的代价O(bd)，上述方法的总搜索代价为。
chap2_para466,3,,他们在魔方和n数码问题上的实验结果表明，这一公式可以准确地预测各种解长度范围内（至少对于大于kh的解长度）的抽样问题实例的总搜索代价。
chap2_para467,1,,在图3-26中，我们生成了随机8数码问题，并使用无信息广度优先搜索和使用h1或h2的A*搜索求解该问题，报告了每种搜索策略和每种解长度所生成的平均节点数及相应的有效分支因子。
chap2_para467,2,,结果表明，h2优于h1，两者都优于无启发式算法。
chap2_para468,1,,图3-26　使用广度优先搜索、使用h1（错位滑块）的A*搜索或使用h2（曼哈顿距离）的A*搜索求解8数码问题的搜索代价和有效分支因子的比较。
chap2_para468,2,,每个解长度d（6～28）的数据为100多个实例的平均结果
chap2_para469,1,,有人可能会问，h2是否总是优于h1。
chap2_para469,2,,答案是“基本上，是的”。
chap2_para469,3,,从这两种启发式函数的定义可以看出，对于任意节点n，都有。
chap2_para469,4,,因此我们说h2占优于（dominate）h1。
chap2_para469,5,,优势可以直接转化为效率：使用h2的A*永远不会比使用h1的A*扩展更多的节点（除了的节点）。
chap2_para469,6,,证明很简单。
chap2_para469,7,,回想一下3.5.3节观察到的，每个的节点都一定会被扩展。
chap2_para469,8,,也就是说，当h一致时，每个的节点都一定会被扩展。
chap2_para469,9,,但是，因为对于所有节点，h2至少和h1一样大，每个在h2下一定会被扩展的节点在h1下也一定会被扩展，而h1还可能导致其他的节点也被扩展。
chap2_para469,10,,因此，通常情况下，只要启发式函数是一致的并且其计算时间不太长，使用具有较高值的启发式函数效果都会更好。
chap2_para47,1,"Of course, such agents are fragile. Consider the lowly dung beetle. After digging its nest and laying its eggs, it fetches a ball of dung from a nearby heap to plug the entrance. If the ball of dung is removed from its grasp en route, the beetle continues its task and pantomimes plugging the nest with the nonexistent dung ball, never noticing that it is missing. Evolution has built an assumption into the beetle’s behavior, and when it is violated, unsuccessful behavior results.",首先，考虑到这种缺乏信息的感知序列，过马路是不理性的：不观察路况就过马路发生事故的风险太大。
chap2_para47,2,,其次，理性智能体在上街之前应该选择“观察”动作，因为观察有助于最大化期望性能。
chap2_para47,3,,采取行动来改变未来的感知，有时被称为信息收集（information gathering），这是理性的一个重要组成部分，将在第16章中详细介绍。
chap2_para47,4,,信息收集的另一个例子是真空吸尘器在最初未知的环境中必须进行的探索（exploration）。
chap2_para470,1,,3.6.2　从松弛问题出发生成启发式函数
chap2_para471,1,,我们已经看到，对于8数码问题，h1（错位滑块）和h2（曼哈顿距离）都是相当好的启发式函数，其中h2更好。
chap2_para471,2,,人们是怎么想出h2这样的启发式函数的？
chap2_para471,3,,计算机是否有可能自动地设计出这种启发式函数？
chap2_para472,1,,h1和h2是对8数码问题剩余路径长度的估计，但对简化版本的问题来说，它们也是非常精确的路径长度。
chap2_para472,2,,如果改变游戏规则，即滑块可以移动到任何地方，而不是只能移动到相邻的空格，那么h1将给出最短解的准确长度。
chap2_para472,3,,类似地，如果一个滑块可以向任意方向移动一个方格，甚至移动到一个被占用的方格上，那么h2将给出最短解的准确长度。
chap2_para472,4,,减少了对动作的限制条件的问题称为松弛问题（relaxed problem）。
chap2_para472,5,,松弛问题的状态空间图是原始状态空间的一个超图，因为删除限制条件会导致原图中边的增加。
chap2_para473,1,,因为松弛问题向状态空间图中添加了一些边，根据定义，原问题的任一最优解也是松弛问题的一个解；但是，如果增加的边提供了捷径，松弛问题可能有更好的解。
chap2_para473,2,,因此，松弛问题中最优解的代价可以作为原问题的一个可容许的启发式函数。
chap2_para473,3,,此外，因为得到的启发式函数是松弛问题的准确代价，所以它一定满足三角不等式，因此它是一致的（见3.5.2节）。
chap2_para474,1,,如果用形式语言定义一个问题，则可以自动构造它的松弛问题。
chap2_para474,2,,[14]例如，如果将8数码问题的行动描述为
chap2_para476,1,,[14]　在第8章和第11章中，我们将介绍适用于此任务的形式语言：有了可操纵的形式化描述，就可以自动化地构建松弛问题。
chap2_para476,2,,现在，我们先使用自然语言。
chap2_para477,1,,如果方格X与方格Y相邻，且Y是空格，那么滑块可以从方格X移动到方格Y。
chap2_para478,1,,我们可以通过删除一个或两个条件来生成3种松弛问题。
chap2_para479,1,,（a）如果方格X与方格Y相邻，那么滑块可以从方格X移动到方格Y。
chap2_para48,1,"Slightly more intelligent is the sphex wasp. The female sphex will dig a burrow, go out and sting a caterpillar and drag it to the burrow, enter the burrow again to check all is well, drag the caterpillar inside, and lay its eggs. The caterpillar serves as a food source when the eggs hatch. So far so good, but if an entomologist moves the caterpillar a few inches away while the sphex is doing the check, it will revert to the “drag the caterpillar” step of its plan and will continue the plan without modification, re-checking the burrow, even after dozens of caterpillar-moving interventions. The sphex is unable to learn that its innate plan is failing, and thus will not change it.",我们的定义要求理性智能体不仅要收集信息，还要尽可能多地从它所感知到的东西中学习（learn）。
chap2_para48,2,,智能体的初始配置可以反映对环境的一些先验知识，但随着智能体获得经验，这可能会被修改和增强。
chap2_para48,3,,在一些极端情况下，环境完全是先验已知的和完全可预测的。
chap2_para48,4,,在这种情况下，智能体不需要感知或学习，只需正确地运行。
chap2_para480,1,,（b）如果方格Y是空格，那么滑块可以从方格X移动到方格Y。
chap2_para481,1,,（c）滑块可以从方格X移动到方格Y。
chap2_para482,1,,由（a）可以推导出h2（曼哈顿距离）。
chap2_para482,2,,原因是，如果我们将每个滑块依次移动到其目标位置，那么h2就是准确的步数。
chap2_para482,3,,由（b）推导出的启发式函数将在习题3.GASC中讨论。
chap2_para482,4,,由（c）我们可以推导出h1（错位滑块），因为如果可以仅用一步就将滑块移动到其预期目标位置，那么h1就是准确的步数。
chap2_para482,5,,需要注意的是，通过这种方法生成的松弛问题本质上不需要搜索就能求解，因为松弛规则将问题分解为8个独立的子问题。
chap2_para482,6,,如果松弛问题本身很难求解，那么获取相应的启发式函数值的代价将非常高。
chap2_para483,1,,"Absolver程序可以通过“松弛问题”方法及各种其他技术从问题定义中自动生成启发式函数（Prieditis, 1993）。"
chap2_para483,2,,Absolver为8数码问题生成了一种新的启发式函数，它优于任何已有的启发式函数。
chap2_para483,3,,此外，Absolver为著名的魔方问题找到了第一种有效的启发式函数。
chap2_para484,1,,"如果一个可容许的启发式函数集合h1, …, hm可以求解同一个问题，但没有一个函数明显优于其他函数，那么我们应该选择哪个函数？"
chap2_para484,2,,事实证明，我们可以通过如下定义，得到最优的启发式函数：
chap2_para485,1,,这种复合启发式函数将选择对于所讨论节点最准确的函数。
chap2_para485,2,,因为hi都是可容许的，所以h也是可容许的（如果hi都是一致的，则h也是一致的）。
chap2_para485,3,,此外，h优于所有组成它的启发式函数。
chap2_para485,4,,唯一的缺点是h(n)的计算时间更长。
chap2_para485,5,,如果考虑这一问题，另一种选择是在每次评价时随机选择一个启发式函数，或者使用机器学习算法来预测哪个启发式函数是最优的。
chap2_para485,6,,这样做可能会导致启发式函数失去一致性（即使每个hi都是一致的），但在实践中，它通常能更快地求解问题。
chap2_para486,1,,3.6.3　从子问题出发生成启发式函数：模式数据库
chap2_para487,1,,可容许的启发式函数也可以由给定问题的子问题（subproblem）的解代价推导得到。
chap2_para487,2,,例如，图3-27为图3-25中8数码问题实例的一个子问题。
chap2_para487,3,,子问题涉及将滑块1、2、3、4和空格分别放置到正确位置。
chap2_para487,4,,显然，这个子问题最优解的代价是完整问题代价的一个下界。
chap2_para487,5,,在某些情况下，它比曼哈顿距离更准确。
chap2_para488,1,,图3-27　图3-25中所给出的8数码实例的子问题。
chap2_para488,2,,任务是将滑块1、2、3、4和空格放置到正确位置，而不考虑其他滑块的情况
chap2_para489,1,,模式数据库（pattern database）的思想是为每个可能的子问题（在我们的示例中，为4个滑块和空格的所有可能排列）存储准确的解代价。
chap2_para489,2,,（数据库中将有9×8×7×6×5 = 15 120种模式。
chap2_para489,3,,其他4个滑块与子问题的求解无关，但移动这些滑块将计入子问题的解代价。
chap2_para489,4,,）然后，通过在数据库中查找相应的子问题，为搜索过程中遇到的每个状态计算一个可容许的启发式函数hDB。
chap2_para489,5,,数据库本身是从目标状态反向搜索并记录所遇到的每个新模式的代价来构建的[15]；这一搜索的开销将分摊到后续的问题实例中，因此如果我们需要求解很多问题，那么这种方法是有意义的。
chap2_para49,1,"To the extent that an agent relies on the prior knowledge of its designer rather than on its own percepts and learning processes, we say that the agent lacks autonomy. A rational agent should be autonomous—it should learn what it can to compensate for partial or incorrect prior knowledge. For example, a vacuum-cleaning agent that learns to predict where and when additional dirt will appear will do better than one that does not.",当然，这样的智能体是脆弱的。
chap2_para49,2,,如卑微的粪甲虫例子，在挖出巢穴产卵后，它会从附近的一堆粪中取出一团粪来堵住入口。
chap2_para49,3,,如果粪球在途中被截下，粪甲虫根本不会注意到粪球已经不见了，仍会继续它的任务，并滑稽地用不存在的粪球堵住巢穴。
chap2_para49,4,,进化已经在粪甲虫的行为中建立了一个假设，当它被违反时，不成功的行为就会产生。
chap2_para491,1,,[15]　通过从目标反向回溯，可以立即获得所遇到的每个实例的准确的解代价。
chap2_para491,2,,这是动态规划的一个示例，我们将在第17章进一步讨论。
chap2_para492,1,,与空格搭配的滑块1-2-3-4的选择是相当随意的；我们还可以为5-6-7-8、2-4-6-8等建立数据库。
chap2_para492,2,,每个数据库产生一种可容许的启发式函数，正如前文所述，可以通过取最大值对这些启发式函数进行组合。
chap2_para492,3,,这种组合的启发式函数要比曼哈顿距离精确得多；求解随机15数码问题时所生成的节点数可以减少到千分之一。
chap2_para492,4,,然而，每增加一个数据库，收益会随之减少，内存和计算成本也会增加。
chap2_para493,1,,你们可能想知道从1-2-3-4数据库和5-6-7-8数据库中得到的启发式函数是否可以相加，因为这两个子问题似乎没有重叠。
chap2_para493,2,,这会是一个可容许的启发式函数吗？
chap2_para493,3,,答案是否定的，因为对于一个给定的状态，1-2-3-4子问题和5-6-7-8子问题的解一定会有一些重复操作——1-2-3-4不可能在不接触5-6-7-8的情况下移动到位，反之亦然。
chap2_para493,4,,但是，如果我们不计入这些操作，换句话说，如果我们让其他滑块直接消失呢？
chap2_para493,5,,也就是说，我们不记录求解1-2-3-4子问题的总代价，而只记录与1-2-3-4有关的操作数。
chap2_para493,6,,那么这两个代价的和仍然是求解完整问题代价的一个下界。
chap2_para493,7,,这就是不相交模式数据库（disjoint pattern database）的思想。
chap2_para493,8,,有了这样的数据库，可以在几毫秒内求解随机的15数码问题——与使用曼哈顿距离相比，生成的节点数不到原来的万分之一。
chap2_para493,9,,对于24数码问题，则可以获得大约一百万倍的加速。
chap2_para493,10,,不相交模式数据库适用于滑块数码问题，因为每次移动只涉及一个滑块，因而原问题可以被划分成若干个子问题使得每次移动只影响一个子问题。
chap2_para494,1,,3.6.4　使用地标生成启发式函数
chap2_para495,1,,一些在线服务可以托管含有数千万个顶点的地图，并在毫秒内找到代价最优的驾驶路线。
chap2_para495,2,,即使是我们之前提到的最优的搜索算法，做到这一点也要比这些在线服务多耗费100万倍的时间。
chap2_para495,3,,那在线服务是怎么做到这一点的呢？
chap2_para495,4,,这里有很多技巧，但最重要的是对一些最优路径代价的预计算（precomputation）。
chap2_para495,5,,虽然预计算可能相当耗时，但只需完成一次预计算，就可以摊销数十亿用户的搜索请求。
chap2_para496,1,,我们可以通过预计算并存储每对顶点之间的最优路径代价来生成完美的启发式函数。
chap2_para496,2,,这需要空间和时间——对于含有1万个顶点的图很实用，但对于1000万个顶点，这样的复杂性不可接受。
chap2_para497,1,,更好的方法是从顶点中选择一些（也许10个或20个）地标点（landmark point）[16]。
chap2_para497,2,,"然后，对于图中每个地标L和每个其他顶点v，我们计算并存储C*(v, L)，即从v到L的最优路径的准确代价。"
chap2_para497,3,,"（我们同样需要C*(L, v)；在无向图上，C*(L, v)与C*(v, L)相同；在有向图上，如单行道，我们则需要单独计算C*(L, v)。"
chap2_para497,4,,）给定存储的C*表，我们可以很容易地创建出一个高效的（尽管是不可容许的）启发式函数：在所有地标中，从当前节点到地标然后到目标节点代价的最小值为
chap2_para499,1,,[16]　地标点有时被称为“枢轴”或“锚点”。
chap2_para5,1,2.,任何通过传感器（sensor）感知环境（environment）并通过执行器（actuator）作用于该环境的事物都可以被视为智能体（agent）。
chap2_para5,2,1Agents and Environments,这个简单的想法如图2-1所示。
chap2_para5,3,,一个人类智能体以眼睛、耳朵和其他器官作为传感器，以手、腿、声道等作为执行器。
chap2_para5,4,,机器人智能体可能以摄像头和红外测距仪作为传感器，还有各种电动机作为执行器。
chap2_para5,5,,软件智能体接收文件内容、网络数据包和人工输入（键盘/鼠标/触摸屏/语音）作为传感输入，并通过写入文件、发送网络数据包、显示信息或生成声音对环境进行操作。
chap2_para5,6,,环境可以是一切，甚至是整个宇宙！
chap2_para5,7,,实际上，我们在设计智能体时关心的只是宇宙中某一部分的状态，即影响智能体感知以及受智能体动作影响的部分。
chap2_para50,1,"As a practical matter, one seldom requires complete autonomy from the start: when the agent has had little or no experience, it would have to act randomly unless the designer gave some assistance.",稍微聪明一点的是掘土黄蜂。
chap2_para50,2,"Just as evolution provides animals with enough built-in reflexes to survive long enough to learn for themselves, it would be reasonable to provide an artificial intelligent agent with some initial knowledge as well as an ability to learn.",雌性掘土黄蜂会挖一个洞，出去刺一只毛毛虫并把它拖到洞口，再次进入洞里检查一切是否正常，然后把毛毛虫拖进洞里再去产卵。
chap2_para50,3,"After sufficient experience of its environment, the behavior of a rational agent can become effectively independent of its prior knowledge.",当蜂卵孵化时，毛毛虫会充当食物来源。
chap2_para50,4,"Hence, the incorporation of learning allows one to design a single rational agent that will succeed in a vast variety of environments.",到目前为止还不错，但如果昆虫学家在掘土黄蜂检查洞穴时将毛毛虫移动几厘米远，它将回到其规划中的“把毛毛虫拖到洞口”步骤，即使经过数十次移动毛毛虫的干预，它仍然继续执行该规划而不进行修改，不断地重新检查洞穴。
chap2_para50,5,,掘土黄蜂无法知道其固有规划正在失败，因此不会改变规划。
chap2_para500,1,,如果最优路径刚好经过一个地标，这个启发式函数将是准确的；否则，这个启发式函数就是不可容许的——它高估了到目标的代价。
chap2_para500,2,,在A*搜索中，如果启发式函数是准确的，那么一旦到达一个位于最优路径上的节点，此后所扩展的每个节点都将位于最优路径上。
chap2_para500,3,,把等值线想象为沿着这条最优路径前进。
chap2_para500,4,,搜索将沿着最优路径进行，在每次迭代中加入一个代价为c的动作，然后到达一个h值减少c的结果状态，这意味着在整条路径上总的f = g + h得分将保持在常量C*。
chap2_para501,1,,一些寻径算法通过在图中添加捷径（shortcut）——人工定义的对应于一条最优多行动路径的边——来节省更多的时间。
chap2_para501,2,,例如，如果我们在美国最大的100个城市之间预先定义了捷径，并且尝试从位于加利福尼亚州的加利福尼亚大学伯克利分校校区导航到纽约的纽约大学，那么我们可以走萨克拉门托（Sacramento）到曼哈顿（Manhattan）之间的捷径，一次动作就能覆盖90%的路径。
chap2_para502,1,,hL(n)是高效的，但不是可容许的。
chap2_para502,2,,只要稍加注意，我们就可以提出一种既高效又可容许的启发式函数：
chap2_para503,1,,这被称为差分启发式（differential heuristic）函数（因为包含减法）。
chap2_para503,2,,可以把它理解为在比目标还要远的某个位置设置一个地标点。
chap2_para503,3,,如果目标恰好在从n到该地标点的最优路径上，那么“考虑从n到L的完整路径，然后减去这条路径的最后一部分，即从goal到L，即可得到从n到goal的这段路径的准确代价”。
chap2_para503,4,,如果目标稍微偏离到地标的最优路径，启发式函数将是不准确的，但仍然是可容许的。
chap2_para503,5,,比目标近的地标是没有用的；例如，一个恰好位于n和goal正中间的地标将导致hDH = 0，这是没有用的。
chap2_para504,1,,下面我们介绍几种选择地标点的方法。
chap2_para504,2,,随机选择速度较快，但如果我们多花些功夫将地标分散开来，使得它们彼此之间不太接近，我们将得到更好的结果。
chap2_para504,3,,贪心方法是随机选择第一个地标，然后找到离它最远的点，将其添加到地标集合中，接着在每次迭代中添加离最近地标最远的点。
chap2_para504,4,,如果你有用户过去的搜索请求日志，那么你可以选择搜索中经常请求的地点作为地标。
chap2_para504,5,,对于差分启发式函数，地标分布在图的周界上更好。
chap2_para504,6,,因此，一个比较好的技术是找到图的质心，围绕质心划分出k个楔形（就像饼状图一样），并在每个楔形中选择离中心最远的顶点。
chap2_para505,1,,地标在寻径问题上尤其有效，这是由世界上道路的布局方式导致的：许多交通运输实际上都是在地标之间穿行，所以土木工程师在这些路线上修建最宽、最快的道路；地标式搜索可以更轻松地复原这些路线。
chap2_para506,1,,3.6.5　学习以更好地搜索
chap2_para507,1,,我们介绍了几种固定的搜索策略（广度优先、A*等），这些都是计算机科学家精心设计和编程实现的。
chap2_para507,2,,那么智能体能自己学习如何更好地搜索吗？
chap2_para507,3,,答案是肯定的，这种方法基于一个重要的概念，元级状态空间（metalevel state space）。
chap2_para507,4,,元级状态空间中的每个状态将捕捉在普通状态空间（例如罗马尼亚地图）进行搜索的程序的内部（计算）状态。
chap2_para507,5,,［为了区分这两个概念，我们将罗马尼亚地图称为对象级状态空间（object-level state space）。
chap2_para507,6,,］例如，A*算法的内部状态由当前搜索树组成。
chap2_para507,7,,元级状态空间中的每个动作都是一个改变内部状态的计算步；例如，A*中的每一个计算步扩展一个叶节点，并将其后续节点添加到树中。
chap2_para507,8,,因此，图3-18展示了一个逐渐增大的搜索树序列，它描述了元级状态空间中的一条路径，路径上的每个状态都是一棵对象级搜索树。
chap2_para508,1,,现在，图3-18中的路径共有5步，包括一个扩展Fagaras的步骤，这一步不是非常有用。
chap2_para508,2,,对于更困难的问题，将存在很多这样的错误步骤，元级学习（metalevel learning）算法可以从这些经验中学习，以避免探索毫无希望的子树。
chap2_para508,3,,这种学习算法将在第22章中介绍。
chap2_para508,4,,学习的目标是对计算开销和路径代价进行权衡，以最小化求解问题的总代价。
chap2_para509,1,,3.6.6　从经验中学习启发式函数
chap2_para51,1,2.,如果在某种程度上，智能体依赖于其设计者的先验知识，而不是其自身的感知和学习过程，我们就说该智能体缺乏自主性（autonomy）。
chap2_para51,2,3The Nature of Environments,一个理性的智能体应该是自主的，它应该学习如何弥补部分或不正确的先验知识。
chap2_para51,3,,例如，能学习预测何时何地会出现额外灰尘的真空吸尘器比不能学习预测的要好。
chap2_para510,1,,我们已经看到，生成启发式函数的一种方法是设计一个容易找到最优解的松弛问题，另一种选择是从经验中学习。
chap2_para510,2,,这里的“经验”意味着，例如，求解大量8数码问题。
chap2_para510,3,,"一个8数码问题的每个最优解都提供了一个“(目标,路径)”对作为示例。"
chap2_para510,4,,可以利用学习算法通过这些示例构造一个函数h，（幸运的话）它可以近似搜索过程中出现的其他状态的真实路径代价。
chap2_para510,5,,这些方法中的大多数学习到的都是启发式函数的一个不完美的近似，因此存在启发式函数不可容许的风险。
chap2_para510,6,,这必然导致算法需要在学习时间、搜索运行时间和解的代价之间进行权衡。
chap2_para510,7,,机器学习技术将在第19章中介绍。
chap2_para510,8,,第22章中介绍的强化学习方法也适用于搜索问题。
chap2_para511,1,,如果除了原始状态描述外，还提供与预测启发式函数值相关的状态特征（feature），那么一些机器学习技术将表现得更好。
chap2_para511,2,,例如，“错位滑块数”这一特征可能有助于预测8数码问题中状态与目标的实际距离。
chap2_para511,3,,我们将这一特征记作x1(n)。
chap2_para511,4,,我们可以使用100个随机生成的8数码配置，并收集其真实解代价的统计数据。
chap2_para511,5,,我们可能会发现，当x1(n) = 5时，平均的解代价大约是14，等等。
chap2_para511,6,,当然，可以使用多种特征。
chap2_para511,7,,例如，第二个特征x2(n)可能是“在当前状态相邻而在目标状态中不相邻的滑块对的数量”。
chap2_para511,8,,如何对x1(n)和x2(n)进行组合来预测h(n)？
chap2_para511,9,,一种常见的方法是线性组合：
chap2_para512,1,,可以调整常数c1和c2以适应随机生成的配置中实际数据的值。
chap2_para512,2,,我们希望c1和c2都是正值，因为错位滑块和不正确的相邻对都会使得问题更难求解。
chap2_para512,3,,注意，这个启发式函数满足目标状态h(n) = 0的条件，但它不一定是可容许的或一致的。
chap2_para514,1,,本章对搜索算法进行了介绍，智能体可以用这些算法在各种环境中选择动作序列——只要环境是回合式的、单智能体的、完全可观测的、确定性的、静态的、离散的和已知的。
chap2_para514,2,,算法需要在搜索所需时间、可用内存和解的质量之间进行权衡。
chap2_para514,3,,如果我们对于启发式函数的形式拥有额外的领域相关知识来估计给定状态离目标有多远，或者我们预计算涉及模式或地标的部分解，算法会更高效。
chap2_para515,1,,● 在智能体开始搜索之前，必须形式化一个良定义的问题。
chap2_para516,1,,● 问题由5部分组成：初始状态、动作集合、描述这些动作结果的转移模型、目标状态集合和动作代价函数。
chap2_para517,1,,● 问题的环境用状态空间图表示。
chap2_para517,2,,通过状态空间（一系列动作）从初始状态到达一个目标状态的路径是一个解。
chap2_para518,1,,● 搜索算法通常将状态和动作看作原子的，即没有任何内部结构（尽管我们在学习时引入了状态特征）。
chap2_para519,1,,● 根据完备性、代价最优性、时间复杂性和空间复杂性来评估搜索算法。
chap2_para52,1,"Now that we have a definition of rationality, we are almost ready to think about building rational agents. First, however, we must think about task environments, which are essentially the “problems” to which rational agents are the “solutions.” We begin by showing how to specify a task environment, illustrating the process with a number of examples. We then show that task environments come in a variety of flavors. The nature of the task environment directly affects the appropriate design for the agent program.",实际上，我们很少从一开始就要求智能体完全自主：除非设计者提供一些帮助，否则当智能体几乎没有经验或完全没有经验时，它将不得不随机行动。
chap2_para52,2,,正如进化为动物提供了足够的内建反射，使其能够生存足够长的时间来学习一样，为人工智能体提供一些初始知识和学习能力也是合理的。
chap2_para52,3,,在充分体验相应环境后，理性智能体的行为可以有效地独立于其先验知识。
chap2_para52,4,,因此，结合学习能够让我们设计单个理性智能体，它能在各种各样的环境中取得成功。
chap2_para520,1,,● 无信息搜索方法只能访问问题定义。
chap2_para520,2,,算法构建一棵搜索树，试图找到一个解。
chap2_para520,3,,算法会根据其首先扩展的节点而有所不同。
chap2_para521,1,,❏ 最佳优先搜索根据评价函数选择节点进行扩展。
chap2_para522,1,,❏ 广度优先搜索首先扩展深度最浅的节点；它是完备的，对于单位动作代价是最优的，但具有指数级空间复杂性。
chap2_para523,1,,❏ 一致代价搜索扩展路径代价g(n)最小的节点，对于一般的动作代价是最优的。
chap2_para524,1,,❏ 深度优先搜索首先扩展最深的未扩展节点。
chap2_para524,2,,它既不是完备的也不是最优的，但具有线性级空间复杂性。
chap2_para524,3,,深度受限搜索增加了一个深度限制。
chap2_para525,1,,❏ 迭代加深搜索在不断增加的深度限制上调用深度优先搜索，直到找到一个目标。
chap2_para525,2,,当完成全部循环检查时，它是完备的，同时对于单位动作代价是最优的，且具有与广度优先搜索相当的时间复杂性和线性级空间复杂性。
chap2_para526,1,,❏ 双向搜索扩展两个边界，一个围绕初始状态，另一个围绕目标，当两个边界相遇时搜索停止。
chap2_para527,1,,● 有信息搜索方法可以访问启发式函数h(n)来估计从n到目标的解代价。
chap2_para527,2,,它们可以访问一些附加信息，例如，存有解代价的模式数据库。
chap2_para528,1,,❏ 贪心最佳优先搜索扩展h(n)值最小的节点。
chap2_para528,2,,它不是最优的，但通常效率很高。
chap2_para529,1,,❏ A*搜索扩展f(n) = g(n) + h(n)值最小的节点。
chap2_para529,2,,在h(n)可容许的条件下，A*是完备的、最优的。
chap2_para529,3,,对于许多问题，A*的空间复杂性仍然很高。
chap2_para53,1,2.,
chap2_para53,2,3.,
chap2_para53,3,1Specifying the task environment,
chap2_para530,1,,❏ 双向A*搜索有时比A*搜索本身更高效。
chap2_para531,1,,❏ IDA*（迭代加深A*搜索）是A*搜索的迭代加深版本，它解决了空间复杂性问题。
chap2_para532,1,,❏ RBFS（递归最佳优先搜索）和SMA*（简化的内存受限A*）搜索是健壮的最优搜索算法，它们仅使用有限的内存；如果时间充足，它们可以解决对A*来说内存不足的问题。
chap2_para533,1,,❏ 束搜索限制了边界的大小；因此它是非完备的、次优的，但束搜索通常能找到相当好的解，运行速度也比完备搜索更快。
chap2_para534,1,,❏ 加权A*搜索将搜索专注于一个目标，以扩展更少的节点，但它牺牲了最优性。
chap2_para535,1,,● 启发式搜索算法的性能取决于启发式函数的质量。
chap2_para535,2,,我们有时可以通过松弛问题定义、在模式数据库中存储预计算的子问题的解代价、定义地标点，或者从问题类的经验中学习来构建良好的启发式函数。
chap2_para538,1,,第4章　复杂环境中的搜索
chap2_para539,1,,在本章中，我们放宽了第3章的简化假设，以更接近真实世界。
chap2_para54,1,"In our discussion of the rationality of the simple vacuum-cleaner agent, we had to specify the performance measure, the environment, and the agent’s actuators and sensors. We group all these under the heading of the task environment. For the acronymically minded, we call this the PEAS (Performance, Environment, Actuators, Sensors) description. In designing an agent, the first step must always be to specify the task environment as fully as possible.",既然已经有了理性的定义，考虑构建理性智能体的准备几乎已经完成。
chap2_para54,2,,然而，还必须考虑任务环境（task environment），它本质上是“问题”，理性智能体是“解决方案”。
chap2_para54,3,,我们首先展示如何指定任务环境，并用一些示例说明该过程。
chap2_para54,4,,然后，展示任务环境的多种形式。
chap2_para54,5,,任务环境的性质直接影响智能体程序的恰当设计。
chap2_para540,1,,第3章讨论了完全可观测的、确定性的、静态的、已知的环境中的问题，问题的解是一个动作序列。
chap2_para540,2,,在本章中，我们将放宽这些限制。
chap2_para540,3,,首先，我们考虑这样一个问题，即寻找一个好的状态而不考虑到达该状态的路径，状态包括离散状态（4.1节）和连续状态（4.2节）。
chap2_para540,4,,然后，我们放宽了确定性假设（4.3节）和可观测性假设（4.4节）。
chap2_para540,5,,在一个非确定性的世界中，智能体将需要一个条件规划，并根据它所观测到的情况执行不同的动作——例如，红灯停，绿灯行。
chap2_para540,6,,对于部分可观测性环境，智能体还需要记录它的可能状态。
chap2_para540,7,,最后，4.5节将指导智能体使用在线搜索（online search）通过一个未知空间，在未知空间中一边前进一边学习。
chap2_para541,1,,4.1　局部搜索和最优化问题
chap2_para542,1,,在第3章的搜索问题中，我们希望找到一条通过搜索空间的路径，如一条从Arad到Bucharest的路径。
chap2_para542,2,,但有时我们只关心最终状态，而不是到达状态的路径。
chap2_para542,3,,例如，在8皇后问题中（图4-3），我们只关心如何找到8个皇后的有效最终配置（因为如果知道配置，重构它的创建步骤就非常简单）。
chap2_para542,4,,这也适用于许多重要应用，例如集成电路设计、工厂车间布局、作业车间调度、自动编程、电信网络优化、农作物种植规划和投资组合管理。
chap2_para543,1,,局部搜索（local search）算法的操作是从一个起始状态搜索到其相邻状态，它不记录路径，也不记录已达状态集。
chap2_para543,2,,这意味着它们不是系统性的——可能永远不会探索问题的解实际所在的那部分搜索空间。
chap2_para543,3,,但是，它们有两个主要优点：（1）使用很少的内存；（2）通常可以在系统性算法不适用的大型或无限状态空间中找到合理的解。
chap2_para544,1,,局部搜索算法也可以求解最优化问题（optimization problem），其目标是根据目标函数（objective function）找到最优状态。
chap2_para545,1,,为了理解局部搜索，我们考虑在状态空间地形图（state-space landscape）中布局的问题状态，如图4-1所示。
chap2_para545,2,,地形图中的每个点（状态）都有一个“标高”，由目标函数值定义。
chap2_para545,3,,如果标高对应于目标函数，那么目的就是找到最高峰——全局极大值（global maximum）——我们称这个过程为爬山（hill climbing）；如果标高对应于代价，那么目的就是找到最低谷——全局极小值（global minimum）——我们称之为梯度下降（gradient descent）。
chap2_para546,1,,图4-1　一维状态空间地形图，其标高对应于目标函数。
chap2_para546,2,,目的是找到全局极大值
chap2_para547,1,,4.1.1　爬山搜索
chap2_para548,1,,爬山搜索算法如图4-2所示。
chap2_para548,2,,它记录当前状态并在每次迭代中移动到值最大的相邻状态，也就是说，它朝最陡上升（steepest ascent）的方向前进。
chap2_para548,3,,当它到达一个没有邻居具有更高值的“峰值”时，算法终止。
chap2_para548,4,,爬山法不会考虑超出当前状态的直接邻居之外的状态。
chap2_para548,5,,这就像是一个健忘的人在大雾中试图找到珠穆朗玛峰的顶峰。
chap2_para548,6,,注意，使用爬山搜索的一种方法是使用启发式代价函数的负值作为目标函数；算法将局部地爬升至到目标的启发式距离最小的状态。
chap2_para549,1,,图4-2　爬山搜索算法是最基本的局部搜索技术。
chap2_para549,2,,在每一步中，当前节点被其最优邻居节点替换
chap2_para55,1,The vacuum world was a simple example; let us consider a more complex problem: an automated taxi driver. Figure 2.4 summarizes the PEAS description for the taxi’s task environment. We discuss each element in more detail in the following paragraphs.,2.3.1　指定任务环境
chap2_para550,1,,我们将使用8皇后问题（图4-3）进一步说明爬山法。
chap2_para550,2,,我们将使用一个完整状态形式化（complete-state formulation），即每个状态都包含解的所有组成部分，但它们可能并不都在正确的位置。
chap2_para550,3,,在这种情况下，每个状态都包括在棋盘上放置8个皇后，每列一个。
chap2_para550,4,,初始状态是随机选择的，状态后继是通过将一个皇后移动到同一列中的另一格所生成的所有可能状态（所以每个状态有8×7 = 56个后继）。
chap2_para550,5,,启发式代价函数h是可相互攻击的皇后对的数量；只有当该状态是一个解时，h值才是0。
chap2_para550,6,,（如果两个皇后在同一条线上，即使它们之间存在一个中间棋子，这两个皇后也会被视为形成相互攻击。
chap2_para550,7,,）图4-3b展示了一个h = 17的状态以及它所有后继的h值。
chap2_para551,1,,爬山法有时被称为贪心局部搜索（greedy local search），因为它只是选择最优的邻居状态，而不事先考虑下一步该如何走。
chap2_para551,2,,虽然贪婪被视为七宗罪之一，但事实证明，贪心算法往往相当有效。
chap2_para551,3,,爬山法可以在求解问题时取得快速进展，因为它通常可以很容易地改善一个差的状态。
chap2_para551,4,,例如，只需5步就可以从图4-3b的状态到达图4-3a的状态，该状态的h = 1，与解非常接近。
chap2_para551,5,,遗憾的是，爬山法可能会由于以下原因而陷入困境。
chap2_para552,1,,● 局部极大值（local maxima）：局部极大值是一个比它每个相邻状态都高但比全局极大值低的峰顶。
chap2_para552,2,,爬山法到达局部极大值附近就会被向上拉向峰顶，但随后将困在局部极大值处无路可走。
chap2_para552,3,,图4-1示意性地说明了这一问题。
chap2_para552,4,,更具体地说，图4-3a中的状态是一个局部极大值（即代价h的局部极小值）；不管移动哪个皇后都会让情况变得更差。
chap2_para553,1,,图4-3　（a）8皇后问题：在棋盘上放置8个皇后，使得它们不能互相攻击。
chap2_para553,2,,（皇后会攻击同一行、同一列或对角线上的任何棋子。
chap2_para553,3,,）当前状态非常接近于一个解，除了第4列和第7列的两个皇后会沿对角线互相攻击。
chap2_para553,4,,（b）一个8皇后状态，其启发式代价估计值h = 17。
chap2_para553,5,,棋盘显示了通过在同一列移动皇后而获得的每一个可能后继的h值。
chap2_para553,6,,有8个移动并列最优，其h = 12。
chap2_para553,7,,爬山法将选择它们中的一个
chap2_para554,1,,● 岭（ridge）：如图4-4 所示。
chap2_para554,2,,岭的存在将导致一系列局部极大值，对于贪心算法，这是很难处理的。
chap2_para555,1,,图4-4　岭为爬山法带来困难的示意图。
chap2_para555,2,,状态网格（蓝色圆点）叠加在从左到右上升的岭上，形成了一个彼此不直接相连的局部极大值序列。
chap2_para555,3,,从每个局部极大值出发，所有可选动作都指向下坡。
chap2_para555,4,,这样的拓扑在低维状态空间中很常见，例如二维平面中的点。
chap2_para555,5,,但是在具有成百上千个维度的状态空间中，这种直观图并不成立，而且通常至少存在几个维度使得算法有可能漏掉岭和平台区
chap2_para556,1,,● 平台区（plateau）：平台区是指状态空间地形图中的平坦区域。
chap2_para556,2,,它可能是一块平坦的局部极大值，不存在上坡的出口；也可能是一个山肩（shoulder），从山肩出发还有可能继续前进（参见图4-1）。
chap2_para556,3,,爬山搜索可能会迷失在平台区上。
chap2_para557,1,,在每种情况下，算法都会到达一个无法再取得进展的点。
chap2_para557,2,,从一个随机生成的8皇后状态开始，在86%的情况下，最陡上升爬山法会被卡住，它只能解决14%的问题实例。
chap2_para557,3,,但是，它求解速度很快，成功找到解时平均步数为4，被卡住时平均步数为3，这对一个具有万个状态的状态空间来说不算糟糕。
chap2_para558,1,,我们怎么才能求解更多问题？
chap2_para558,2,,一个答案是当我们到达一个平台区时继续前进——允许横向移动（sideways move），希望这个平台区真的是一个山肩，如图4-1所示。
chap2_para558,3,,但如果我们实际上位于一块平坦的局部极大值上，那么算法就会陷入死循环。
chap2_para558,4,,因此，我们可以限制连续横向移动的次数，如在100次连续横向移动之后停止。
chap2_para558,5,,这种方法将爬山法成功求解问题实例的百分比从14%提高到了94%。
chap2_para558,6,,成功是有代价的：平均下来，对每个成功实例算法需要运行约21步，失败实例约64步。
chap2_para559,1,,爬山法存在很多变体。
chap2_para559,2,,随机爬山法（stochastic hill climbing）在上坡行动中随机选择一个；被选中的概率随着上坡陡度的变化而变化。
chap2_para559,3,,这种方法通常比最陡上升法收敛得更慢，但在某些状态地形图中，它能找到更好的解。
chap2_para559,4,,首选爬山法（first-choice hill climbing）通过不断随机地生成后继直到生成一个比当前状态更好的后继为止来实现随机爬山。
chap2_para559,5,,当一个状态存在众多（如数千个）后继时，这是一个很好的策略。
chap2_para56,1,Description The block diagram starts with a block labeled Agent.,在讨论简单的真空吸尘器智能体的理性时，我们必须指定性能度量、环境以及智能体的执行器和传感器。
chap2_para56,2,There are six blocks inside the Agent block.,我们将所有这些都归在任务环境的范畴下，基于首字母缩写规则，我们称其为PEAS（Performance，Environment，Actuator，Sensor）描述。
chap2_para56,3,"The first block inside the agent block is labeled, What the world is like now.",在设计智能体时，第一步必须始终是尽可能完整地指定任务环境。
chap2_para56,4,"Arrows from the second, third, and fourth blocks labeled State, How the world evolves, and What my actions do, point to the first block.",
chap2_para56,5,A dashed arrow from the first block points back to the state block.,
chap2_para56,6,"A solid arrow from the first block points to the fifth block labeled, What action I should do now.",
chap2_para56,7,"An arrow from the sixth block labeled, Condition action rules, points to the fifth block.",
chap2_para56,8,An arrow from the fifth block points to the Actuators.,
chap2_para56,9,"An arrow from actuators points to the block labeled, Environment, which is outside the agent block.",
chap2_para56,10,An arrow from the environment block to the sensors in the agent block.,
chap2_para56,11,An arrow from the sensors points back to the first block.,
chap2_para560,1,,另一种变体是随机重启爬山法（random-restart hill climbing），它来自于一句格言：“如果一开始没有成功，那么尝试，再尝试。
chap2_para560,2,,”它从随机生成的初始状态开始，执行一系列爬山搜索，直到找到目标。
chap2_para560,3,,算法完备的概率为1，因为它最终会生成一个目标状态作为初始状态。
chap2_para560,4,,如果每一次爬山搜索成功的概率为p，那么需要重启的期望次数为1 / p。
chap2_para560,5,,对于不允许横向移动的8皇后实例，，所以大概需要7次迭代才能找到一个目标（6次失败，1次成功）。
chap2_para560,6,,所需步数的期望为一次成功迭代的代价加上(1−p)/p倍的失败代价，总共约为22步。
chap2_para560,7,,当允许横向移动时，平均需要次迭代，步。
chap2_para560,8,,因此，对于8皇后问题，随机重启爬山法是非常有效的。
chap2_para560,9,,即使有300万个皇后，这种方法也能在很短的时间内找到解。
chap2_para560,10,,[1]
chap2_para562,1,,"[1]　卢比等人（Luby et al., 1993）建议在搜索固定次数之后重启，并表明这比让每次搜索都无限期地继续下去要有效得多。"
chap2_para563,1,,爬山法是否能成功在很大程度上取决于状态空间地形图的形状：如果几乎不存在局部极大值和平台区，那么随机重启爬山法可以很快找到一个好的解。
chap2_para563,2,,但是，许多实际问题的地形图看起来更像是平地上散布着一群秃顶豪猪，每个豪猪的刺上还住着微型豪猪。
chap2_para563,3,,NP困难问题（参见附录 A）通常存在指数级数量的局部极大值。
chap2_para563,4,,尽管如此，在几次重启后，通常也可以找到相当好的局部极大值。
chap2_para564,1,,4.1.2　模拟退火
chap2_para565,1,,从不“下坡”，即从不向值较低（或代价较高）的状态移动的爬山算法总是很容易陷入局部极大值。
chap2_para565,2,,相比之下，纯粹的随机游走算法不考虑状态值，而是随机移动到一个后继状态，它最终能够找到全局极大值，但它的效率非常低。
chap2_para565,3,,因此，尝试将爬山法和随机游走结合起来以同时获得高效性和完备性，似乎是合理的。
chap2_para566,1,,模拟退火（simulated annealing）就是这样一种算法。
chap2_para566,2,,在冶金学中，退火（annealing）是一种通过将金属或玻璃加热到高温然后逐渐冷却的方法使材料达到低能量结晶态以进行回火或硬化的过程。
chap2_para566,3,,为了更好地解释模拟退火，我们将关注点从爬山转换为梯度下降（gradient descent）（即，最小化代价），想象这样一项任务，把一个乒乓球放入一个崎岖表面的最深的裂缝中。
chap2_para566,4,,如果只是让球滚动，它会停在一个局部极小值。
chap2_para566,5,,如果晃动平面，乒乓球会从局部极小值中弹出来——也许会弹到更深的局部极小值中，在那里它将耗费更多的时间。
chap2_para566,6,,诀窍是晃动幅度要足够大，以使球从局部极小值中弹出，但又不能太大，以至于从全局极小值中弹出。
chap2_para566,7,,模拟退火就是开始时用力晃动（即高温），然后逐渐降低晃动强度（即降低温度）。
chap2_para567,1,,模拟退火算法的总体结构（图4-5）与爬山法类似。
chap2_para567,2,,然而，它不是选择最佳移动，而是选择随机移动。
chap2_para567,3,,如果该移动使得情况改善，那么它总是会被接受。
chap2_para567,4,,否则，算法以小于1的概率接受该移动。
chap2_para567,5,,概率随着该移动的“坏的程度”——评估值变差的量——呈指数级下降。
chap2_para567,6,,概率也会随“温度”T的降低而减小：开始时T较高，“坏”的移动更有可能被接受，当T降低时，可能性也逐渐降低。
chap2_para567,7,,如果schedule所设置的T降到0的速度足够慢，那么玻尔兹曼分布的一个性质是所有概率都集中在全局极大值上，即算法将以接近1的概率找到全局极大值。
chap2_para568,1,,图4-5　模拟退火算法，一种允许某些下坡移动的随机爬山法。
chap2_para568,2,,输入的schedule是关于时间的函数，它决定了“温度”T的值
chap2_para569,1,,从20世纪80年代开始，模拟退火就被用于求解VLSI布图问题。
chap2_para569,2,,它已广泛应用于工厂调度和其他大规模优化任务。
chap2_para57,1,Figure 2.,真空吸尘器世界是一个简单的例子，让我们考虑一个更复杂的问题：自动驾驶出租车司机。
chap2_para57,2,4PEAS description of the task environment for an automated taxi driver.,图2-4总结了出租车任务环境的PEAS描述。
chap2_para57,3,,我们将在以下段落中更详细地讨论每个元素。
chap2_para570,1,,4.1.3　局部束搜索
chap2_para571,1,,对于内存限制问题，在内存中只保存一个节点似乎有些极端。
chap2_para571,2,,局部束搜索（local beam search）算法记录k个状态而不是只记录一个。
chap2_para571,3,,它从k个随机生成的状态开始。
chap2_para571,4,,在每一步中，生成全部k个状态的所有后继状态。
chap2_para571,5,,如果其中任意一个是目标状态，那么算法停止。
chap2_para571,6,,否则，它将从完整列表中选择k个最佳后继并重复上述操作。
chap2_para572,1,,从第一印象来看，具有k个状态的局部束搜索似乎只不过是并行（而非串行）地运行k次随机重启。
chap2_para572,2,,事实上，这两种算法是完全不同的。
chap2_para572,3,,在随机重启搜索中，每个搜索进程独立运行。
chap2_para572,4,,而在局部束搜索中，有用信息将在并行的搜索线程之间传递。
chap2_para572,5,,实际上，生成最佳后继的那些状态会对其他状态说：“过来，这里的草更绿！
chap2_para572,6,,”算法将很快放弃那些没有效果的搜索并把资源转移到取得最大进展的路径上。
chap2_para573,1,,如果k个状态之间缺乏多样性，局部束搜索可能会受到影响——k个状态可能聚集在状态空间的一块小区域内，导致搜索只不过是k倍慢版本的爬山法。
chap2_para573,2,,一种被称作随机束搜索（stochastic beam search）的变体可以帮助缓解这个问题，它类似于随机爬山法。
chap2_para573,3,,随机束搜索不是选择最佳的k个后继状态，而是选择概率与它对应的目标函数值成正比的后继状态，从而增加了多样性。
chap2_para574,1,,4.1.4　进化算法
chap2_para575,1,,进化算法（evolutionary algorithm）可以看作随机束搜索的变体，算法的动机明显来自生物学中自然选择的隐喻：一个由个体（状态）组成的种群，其中最适应环境（值最高）的个体可以生成后代（后继状态）来繁衍下一代，这个过程被称为重组（recombination）。
chap2_para575,2,,进化算法存在无数种形式，它们按照以下方式变化。
chap2_para577,1,,● 每个个体的表示。
chap2_para577,2,,在遗传算法（genetic algorithm）中，每个个体都是有限字母表上的一个字符串（通常是一个布尔字符串），就像DNA是字母表ACGT上的一个字符串一样。
chap2_para577,3,,在进化策略（evolution strategy）中，个体是实数序列，而在遗传编程（genetic programming）中，个体是计算机程序。
chap2_para578,1,,● 混合数，，是一起形成后代的亲本的数量。
chap2_para578,2,,最常见的情况是：双亲结合它们的“基因”（它们表示的一部分）来形成后代。
chap2_para578,3,,当时，为随机束搜索（可以看作无性繁殖）。
chap2_para578,4,,也是可能的，这在自然界中很少发生，但很容易在计算机上进行模拟。
chap2_para579,1,,● 选择（selection）过程。
chap2_para579,2,,选择将成为下一代亲本的个体：一种可能是从所有个体中选择，被选中的概率与其适应度得分成正比。
chap2_para579,3,,另一种可能是随机选择n个个体（），然后选择最适合的个个体作为亲本。
chap2_para58,1,"First, what is the performance measure to which we would like our automated driver to aspire?",图2-4　自动驾驶出租车司机任务环境的PEAS描述
chap2_para58,2,Desirable qualities include getting to the correct destination; minimizing fuel consumption and wear and tear; minimizing the trip time or cost; minimizing violations of traffic laws and disturbances to other drivers; maximizing safety and passenger comfort; maximizing profits.,
chap2_para58,3,"Obviously, some of these goals conflict, so tradeoffs will be required.",
chap2_para580,1,,● 重组过程。
chap2_para580,2,,一种常见的方法（假设）是随机选择一个杂交点（crossover point）来分割每个父字符串，并将这些部分重新组合以形成两个子串，一个是亲本1的第一部分和亲本2的第二部分的组合；另一个是亲本1的第二部分和亲本2的第一部分的组合。
chap2_para581,1,,● 突变率（mutation rate），它决定了后代在其表示上发生随机突变的频率。
chap2_para581,2,,一旦产生了一个后代，其组成中的每位都将以与突变率相等的概率被翻转。
chap2_para582,1,,● 下一代的构成。
chap2_para582,2,,可能只包括新形成的后代，也可能还包括一些上一代中得分最高的个体［这种做法被称为精英主义（elitism），它确保总体适应度永远不会随着时间的推移而下降］。
chap2_para582,3,,"而淘汰（culling），即丢弃所有分数低于给定阈值的个体，会使得进化加速（Baum et al., 1995）。"
chap2_para583,1,,图4-6a为由4个8位数字符串组成的种群，每个字符串代表8皇后问题的一个状态：第c位数字表示第c列中皇后的行号。
chap2_para583,2,,在图4-6b中，每个状态根据适应度函数进行评级。
chap2_para583,3,,适应度越高越好，所以对于8皇后问题，我们使用非攻击皇后对的数量作为适应度，解的适应度为8×7/2 = 28。
chap2_para583,4,,图4-6b中4个状态的值分别为24、23、20和11。
chap2_para583,5,,然后将适应度得分归一化为概率，结果显示在图4-6b中的适应度旁边。
chap2_para584,1,,图4-6　遗传算法，图示为表示8皇后状态的数字字符串。
chap2_para584,2,,（a）中的初始种群根据（b）中的适应度函数进行排序从而得到（c）中的配对，（d）是产生的后代，（e）是可能发生的突变
chap2_para585,1,,在图4-6c中，根据图4-6b中的概率选出两对父字符串。
chap2_para585,2,,注意，有一个个体被选择了两次，还有一个没有被选择。
chap2_para585,3,,对于每一对被选择的亲本，随机选择一个杂交点（虚线）。
chap2_para585,4,,在图4-6d中，我们在杂交点处交叉两个父串，以生成新的后代。
chap2_para585,5,,例如，第一对亲本中的第一个子串从第一个父串获得前三个数字（327），从第二个父串获得剩余数字（48552）。
chap2_para585,6,,这一重组步骤中所包含的8皇后状态如图4-7所示。
chap2_para586,1,,图4-7　对应于图4-6c中前两个亲本和图4-6d中第一个后代的8皇后状态。
chap2_para586,2,,在杂交步中，丢弃绿色列，保留红色列。
chap2_para586,3,,（图4-6中数字的解释：第1行是最下面一行，第8行是最上面一行）
chap2_para587,1,,最后，在图4-6e中，每个字符串中的每个位置都以某个很小的独立概率发生随机突变。
chap2_para587,2,,第一个、第三个和第四个后代的某个位发生了突变。
chap2_para587,3,,在8皇后问题中，这相当于随机选择一个皇后，并将其随机移动到它所在列的某个位置。
chap2_para587,4,,通常情况下，早期的种群是多样化的，所以在搜索过程的早期阶段，杂交常常在状态空间中采取较大的步调（类似于模拟退火）。
chap2_para587,5,,在经过许多代选择提高了适应度后，种群的多样性减少，步调也随之变小。
chap2_para587,6,,图4-8介绍了实现所有这些步骤的算法。
chap2_para588,1,,图4-8　遗传算法。
chap2_para588,2,,在这个函数中，population是种群中个体的有序列表，weights是每个个体所对应的适应度值的列表，而fitness是计算这些值的函数
chap2_para589,1,,遗传算法类似于随机束搜索，但增加了杂交操作。
chap2_para589,2,,如果存在可以执行有用功能的区域，杂交操作是有利的。
chap2_para589,3,,例如，将前3列皇后分别放在第2行、第4行和第6行（在这些位置上它们不会互相攻击），就组成了一个有用的区域，它可以与其他个体中出现的其他有用区域相结合，从而形成一个解。
chap2_para589,4,,数学上可以证明，如果这些区域没有任何用途——例如，如果遗传密码的位置是随机排列的——那么杂交就没有任何优势。
chap2_para59,1,"Next, what is the driving environment that the taxi will face?",首先，我们希望自动驾驶追求的性能度量（performance measure）是什么？
chap2_para59,2,"Any taxi driver must deal with a variety of roads, ranging from rural lanes and urban alleys to 12-lane freeways.",理想的标准包括到达正确的目的地，尽量减少油耗和磨损，尽量减少行程时间或成本，尽量减少违反交通法规和对其他驾驶员的干扰，最大限度地提高安全性和乘客舒适度，最大化利润。
chap2_para59,3,"The roads contain other traffic, pedestrians, stray animals, road works, police cars, puddles, and potholes.",显然，其中一些目标是相互冲突的，因此需要权衡。
chap2_para59,4,The taxi must also interact with potential and actual passengers.,
chap2_para59,5,There are also some optional choices.,
chap2_para59,6,"The taxi might need to operate in Southern California, where snow is seldom a problem, or in Alaska, where it seldom is not.",
chap2_para59,7,"It could always be driving on the right, or we might want it to be flexible enough to drive on the left when in Britain or Japan.",
chap2_para59,8,"Obviously, the more restricted the environment, the easier the design problem.",
chap2_para590,1,,遗传算法理论用模式（schema）思想来解释它是如何运作的，模式是指其中某些位未确定的子串。
chap2_para590,2,,例如，模式246*****表示前3个皇后分别位于位置2、4和6的所有8皇后状态。
chap2_para590,3,,与该模式相匹配的字符串（例如24613578）称作该模式的实例（instance）。
chap2_para590,4,,可以证明，如果某模式实例的平均适应度高于平均值，那么该模式的实例数量将随着时间推移而不断增加。
chap2_para592,1,,"进化论是由查尔斯·达尔文（Charles Darwin）（Darwin, 1859）和艾尔弗雷德·拉塞尔·华莱士（Alfred Russel Wallace）（Wallace, 1858）各自独立提出的。"
chap2_para592,2,,它的中心思想很简单：变异发生在繁殖过程中，并将在后代中以一定比例保存下来，大概与它们对生殖适应度的影响成比例。
chap2_para593,1,,达尔文在《物种起源》（On the Origin of Species by Means of Natural Selection）中的理论没有解释生物体的特征是如何遗传和改变的。
chap2_para593,2,,"控制这些过程的概率定律由修道士格雷戈尔·孟德尔（Gregor Mendel）（Mendel, 1866）首先发现，他使用豌豆进行了实验。"
chap2_para593,3,,"很久之后，沃森和克里克（Watson and Crick, 1953）确定了DNA分子的结构及其AGTC（腺嘌呤、鸟嘌呤、胸腺嘧啶、胞嘧啶）序列。"
chap2_para593,4,,在标准模型中，基因序列上某点发生突变和“杂交”（后代的DNA通过合成父母双方的DNA长片段产生）都会导致变异。
chap2_para594,1,,进化和局部搜索算法的相似性前文已经介绍过了；随机束搜索和进化的主要区别在于是否为有性生殖，有性生殖中后代是由多个而非单个个体产生的。
chap2_para594,2,,然而，进化的实际机制比大多数遗传算法要丰富得多。
chap2_para594,3,,例如，突变包括DNA的逆转、复制和大段移动；有些病毒会从一个生物体中借用DNA再将其自身插入另一个生物体；还有一些转座基因只是在基因组中把自己复制成千上万次。
chap2_para595,1,,甚至还有一些基因会破坏不携带该基因的可能配对对象的细胞，从而增加它们自身的复制机会。
chap2_para595,2,,最重要的是，基因自身对基因组复制和翻译成生物体的机制进行编码。
chap2_para595,3,,在遗传算法中，这些机制是单独的程序，不体现在被操作的字符串中。
chap2_para596,1,,达尔文进化论可能看起来效率很低，它盲目地产生了大约1043个生物体，却丝毫没有改进它的搜索启发式函数。
chap2_para596,2,,但是学习在进化中确实起着作用。
chap2_para596,3,,"尽管另一位伟大的法国博物学家让·拉马克（Jean Lamarck）（Lamarck, 1809）曾错误地提出，生物体一生中通过适应而获得的特性会遗传给后代，但詹姆斯·鲍德温（James Baldwin）（Baldwin, 1896）提出的表面上相似的理论则是正确的：学习可以有效地放宽适应度要求，从而加快进化速度。"
chap2_para596,4,,如果一个生物体具有一种不太适应环境的特性，但它也具有足够的可塑性，可以学习以一种有益的方式适应环境，那么生物体会将这种特性传递下去。
chap2_para596,5,,"计算机仿真（Hinton and Nowlan, 1987）证实了鲍德温效应（Baldwin effect）是真实存在的，其结果是，难以学习的事情最终会存在于基因组中，而容易学习的事情不必进入基因组（Morgan and Griffiths, 2015）。"
chap2_para597,1,,显然，如果相邻位之间完全不相关，效果就没那么显著，因为几乎不存在功能一致的连续区域。
chap2_para597,2,,当模式对应于解中有意义的组件时，遗传算法效果最优。
chap2_para597,3,,例如，如果字符串表示天线，那么模式则表示天线的各组成部分，如反射器和导向器。
chap2_para597,4,,一个好的组件可能在各种不同的设计中都是好的。
chap2_para597,5,,这表明，遗传算法的成功依赖于精细的表示工程。
chap2_para598,1,,"实际上，遗传算法在广泛的最优化方法中占有一席之地（Marler and Arora, 2004），尤其是复杂结构问题，如电路布图或作业车间调度，以及最近的深度神经网络架构演变（Miikkulainen et al., 2019）。"
chap2_para598,2,,目前还不清楚遗传算法的吸引力是来自于它在特定任务上的性能优势，还是来自于进化本身。
chap2_para599,1,,4.2　连续空间中的局部搜索
chap2_para6,1,"An agent is anything that can be viewed as perceiving its environment through sensors and acting upon that environment through actuators. This simple idea is illustrated in Figure 2.1. A human agent has eyes, ears, and other organs for sensors and hands, legs, vocal tract, and so on for actuators. A robotic agent might have cameras and infrared range finders for sensors and various motors for actuators. A software agent receives file contents, network packets, and human input (keyboard/mouse/touchscreen/voice) as sensory inputs and acts on the environment by writing files, sending network packets, and displaying information or generating sounds. The environment could be everything—the entire universe! In practice it is just that part of the universe whose state we care about when designing this agent—the part that affects what the agent perceives and that is affected by the agent’s actions.",图2-1　智能体通过传感器和执行器与环境交互
chap2_para60,1,The actuators for an automated taxi include those available to a human driver: control over the engine through the accelerator and control over steering and braking.,接下来，出租车将面临什么样的驾驶环境（environment）？
chap2_para60,2,"In addition, it will need output to a display screen or voice synthesizer to talk back to the passengers, and perhaps some way to communicate with other vehicles, politely or otherwise.",任何出租车司机都必须能够在各种道路上行驶，如乡村车道、城市小巷以及12车道的高速公路。
chap2_para60,3,,道路上有其他交通工具、行人、流浪动物、道路工程、警车、水坑和坑洼。
chap2_para60,4,,出租车还必须与潜在以及实际的乘客互动。
chap2_para60,5,,另外，还有一些可选项。
chap2_para60,6,,出租车可以选择在很少下雪的南加利福尼亚州或者经常下雪的阿拉斯加运营。
chap2_para60,7,,它可能总是靠右行驶，或者我们可能希望它足够灵活，在英国或日本时可以靠左行驶。
chap2_para60,8,,显然，环境越受限，设计问题就越容易解决。
chap2_para600,1,,在第2章中，我们解释了离散环境和连续环境之间的区别，并指出大多数的真实世界环境都是连续的。
chap2_para600,2,,连续动作空间的分支因子是无限的，因此我们目前介绍的大多数算法（除了首选爬山法和模拟退火）都无法处理连续空间。
chap2_para601,1,,本节将非常简要地介绍一些连续空间的局部搜索技术。
chap2_para601,2,,关于这个主题的文献有很多。
chap2_para601,3,,许多基本技术起源于牛顿和莱布尼茨发明微积分之后的17世纪。
chap2_para601,4,,[2]本书的一些章节会介绍这些技术的应用，包括学习、视觉和机器人技术相关的章节。
chap2_para603,1,,[2]　向量、矩阵和导数的知识对于学习本节内容很有帮助（见附录A）。
chap2_para604,1,,考虑一个实例。
chap2_para604,2,,假设我们希望在罗马尼亚新建3个机场，使得地图上每个城市到其最近机场的直线距离平方和最小。
chap2_para604,3,,（罗马尼亚地图见图3-1。
chap2_para604,4,,"）状态空间定义为3个机场的坐标：(x1, y1)、(x2, y2)和(x3, y3)。"
chap2_para604,5,,这是一个六维空间；我们也可以说状态由6个变量（variable）定义。
chap2_para604,6,,一般地，状态定义为n 维向量，x。
chap2_para604,7,,在这个空间中移动对应于移动地图上的一个或多个机场。
chap2_para604,8,,"对于任一特定状态，一旦计算出最近城市，目标函数f(x) = f (x1, y1, x2, y2, x3, y3)的计算就会变得相对容易。"
chap2_para604,9,,设Ci是最近机场（在状态x下）为机场 i 的城市集合。
chap2_para604,10,,那么，我们有
chap2_para606,1,,这一方程不仅对于状态x是正确的，而且对于x局部邻域中的状态也是正确的。
chap2_para606,2,,然而，对全局来说，它是不正确的；如果我们偏离x太远（通过大幅改变一个或多个机场的位置），那么该机场的最近城市集合会发生变化，我们需要重新计算Ci。
chap2_para607,1,,处理连续状态空间的一种方法是离散化（discretize）。
chap2_para607,2,,"例如，我们可以将(xi, yi)的位置限制在矩形网格上间距为的固定点，而不是允许它的位置可以为连续二维空间中的任意点。"
chap2_para607,3,,那么，空间中的每个状态将存在12个后继（对应于将6个变量分别增加），而不是之前的无限多个。
chap2_para607,4,,然后我们就可以对离散空间应用任意局部搜索算法。
chap2_para607,5,,或者，我们可以通过随机采样后继状态，即在随机方向上移动一个小量，使分支因子变为有限值。
chap2_para607,6,,通过两个相邻点之间目标函数值的变化来衡量进度的方法称为经验梯度（empirical gradient）法。
chap2_para607,7,,经验梯度搜索与离散化状态空间中的最陡上升爬山法相同。
chap2_para607,8,,随着时间逐渐减小的值可以得到更准确的解，但不一定在极限范围内收敛到全局最优值。
chap2_para608,1,,通常我们有一个以数学形式表达的目标函数，这样我们就可以用微积分来解析地而非经验地求解问题。
chap2_para608,2,,许多方法都试图利用地形图的梯度（gradient）来找到最大值。
chap2_para608,3,,目标函数的梯度是一个向量∇f，它给出了最陡斜面的长度和方向。
chap2_para608,4,,对于我们的问题，有
chap2_para609,1,,在某些情况下，我们可以通过解∇f = 0方程找到一个极大值。
chap2_para609,2,,（这是可以做到的，例如，如果我们只新建一个机场；问题的解是所有城市坐标的算术平均值。
chap2_para609,3,,）然而，在许多情况下，这个方程不存在闭式解。
chap2_para609,4,,例如，对于3个机场的情况，梯度的表达式依赖于当前状态中哪些城市离各个机场最近。
chap2_para609,5,,这意味着我们只能局部地（而非全局地）计算梯度，例如，
chap2_para61,1,"The basic sensors for the taxi will include one or more video cameras so that it can see, as well as lidar and ultrasound sensors to detect distances to other cars and obstacles. To avoid speeding tickets, the taxi should have a speedometer, and to control the vehicle properly, especially on curves, it should have an accelerometer. To determine the mechanical state of the vehicle, it will need the usual array of engine, fuel, and electrical system sensors. Like many human drivers, it might want to access GPS signals so that it doesn’t get lost. Finally, it will need touchscreen or voice input for the passenger to request a destination.",自动驾驶出租车的执行器（actuator）包括可供人类驾驶员使用的器件，例如通过加速器控制发动机以及控制转向和制动。
chap2_para61,2,,此外，它还需要输出到显示屏或语音合成器，以便与乘客进行对话，或许还需要某种方式与其他车辆进行礼貌的或其他方式的沟通。
chap2_para611,1,,给定一个局部正确的梯度表达式，我们可以根据下式来更新当前状态从而实现最陡上升爬山法：
chap2_para612,1,,其中是一个很小的常数，通常称为步长（step size）。
chap2_para612,2,,存在很多调整的方法。
chap2_para612,3,,基本问题是，如果太小，需要的迭代步太多；如果太大，搜索可能会越过最大值。
chap2_para612,4,,线搜索（line search）技术试图通过不断延伸当前梯度方向——通常通过对反复加倍——直到f再次开始减小来克服上述困境。
chap2_para612,5,,出现上述现象的点成为新的当前状态。
chap2_para612,6,,在这点上如何选择新的方向，有几种不同的方法。
chap2_para613,1,,对于许多问题，最有效的算法是古老的牛顿-拉弗森法（Newton-Raphson method）。
chap2_para613,2,,这是一种求函数根（即求解g(x) = 0形式的方程）的通用方法。
chap2_para613,3,,它的工作原理是根据牛顿公式计算根x的一个新的估计值：
chap2_para614,1,,要找到f的最大值或最小值，需要找到使得梯度为零向量（即）的x。
chap2_para614,2,,因此，牛顿公式中的g(x)为，更新方程可以写成矩阵-向量形式：
chap2_para615,1,,其中Hf(x)为二阶导数的黑塞矩阵（Hessian matrix），其元素Hij由给出。
chap2_para615,2,,对于上述机场问题实例，从式（4-2）可以看出，Hf(x)相当简单：非对角元素为零，机场i的对角线元素的值恰好为Ci中城市数目的两倍。
chap2_para615,3,,每一时刻的计算表明，每一步更新将机场i直接移动到Ci的质心处，即式（4-1）中f的局部表达式的最小值。
chap2_para615,4,,[3]然而，对于高维问题，计算黑塞矩阵的n2个元素以及对它求逆的开销可能非常昂贵，因此产生了许多牛顿-拉弗森法的近似版本。
chap2_para617,1,,[3]　一般来说，牛顿-拉弗森更新可以看作在x处用一个二次曲面拟合f，下一步则直接移动到该曲面的最小值——如果f是二次的，则也是f的最小值。
chap2_para618,1,,局部搜索方法在连续状态空间和离散状态空间中一样，同样受到局部极大值、岭和平台区的影响。
chap2_para618,2,,随机重启和模拟退火通常很有用。
chap2_para618,3,,然而，高维连续空间非常大，算法很容易陷入困境。
chap2_para619,1,,最后一个话题是约束优化（constrained optimization）。
chap2_para619,2,,如果一个优化问题的解必须满足对变量值的一些硬性约束，那么这个问题就是受约束的。
chap2_para619,3,,例如，在机场选址问题中，我们可能会将选址限制在罗马尼亚境内的陆地上（而不是某个湖中心）。
chap2_para619,4,,约束优化问题的难度取决于约束和目标函数的性质。
chap2_para619,5,,最著名的一类问题是线性规划（linear programming）问题，其约束必须是能构成凸集的线性不等式[4]，目标函数也必须是线性的。
chap2_para619,6,,线性规划的时间复杂性是关于变量数目的多项式。
chap2_para62,1,"In Figure 2.5, we have sketched the basic PEAS elements for a number of additional agent types. Further examples appear in Exercise 2.PEAS. The examples include physical as well as virtual environments. Note that virtual task environments can be just as complex as the “real” world: for example, a software agent (or software robot or softbot) that trades on auction and reselling Web sites deals with millions of other users and billions of objects, many with real images.",出租车的基本传感器（sensor）将包括一个或多个摄像头以便观察，以及激光雷达和超声波传感器以便检测其他车辆和障碍物的距离。
chap2_para62,2,,为了避免超速罚单，出租车应该有一个速度表，而为了正确控制车辆（特别是在弯道上），它应该有一个加速度表。
chap2_para62,3,,要确定车辆的机械状态，需要发动机、燃油和电气系统的传感器常规阵列。
chap2_para62,4,,像许多人类驾驶者一样，它可能需要获取GPS信号，这样就不会迷路。
chap2_para62,5,,最后，乘客需要触摸屏或语音输入才能说明目的地。
chap2_para621,1,,[4]　如果点集S中任意两点的连线也包含在S中，则称S是凸的。
chap2_para621,2,,凸函数（convex function）是指其上方空间构成凸集的函数；根据定义，凸函数没有局部（相对于全局）极小值。
chap2_para622,1,,线性规划可能是最广泛研究和最有用的优化方法。
chap2_para622,2,,它是更一般的凸优化（convex optimization）问题的一种特例，允许约束区域为任意凸区域，目标函数为约束区域内的任意凸函数。
chap2_para622,3,,在一定条件下，凸优化问题也是多项式时间内可解的，即使有上千个变量，也可能是实际可行的。
chap2_para622,4,,机器学习和控制理论中的几个重要问题可以形式化为凸优化问题（见第20章）。
chap2_para623,1,,4.3　使用非确定性动作的搜索
chap2_para624,1,,在第3章中，我们假设环境为完全可观测的、确定性的、已知的。
chap2_para624,2,,因此，智能体可以观测到初始状态，计算出可以到达目标的动作序列，然后“闭着眼睛”执行这些动作，而不需要使用自己的感知。
chap2_para625,1,,然而，当环境部分可观测时，智能体并不确定它处于什么状态；当环境是非确定性的时，智能体不知道在执行某个动作后将转移到什么状态。
chap2_para625,2,,这意味着智能体所思考的不再是“我现在位于s1状态，如果我执行a动作，我将会进入s2状态”，而是“我现在位于s1或s3状态，如果我执行a动作，我将会进入s2、s4或s5状态”。
chap2_para625,3,,我们把智能体认为其可能位于的物理状态集合称为信念状态（belief state）。
chap2_para626,1,,在部分可观测的和非确定性的环境中，问题的解不再是一个序列，而是一个条件规划（conditional plan）（有时也称为应变规划或策略），条件规划根据智能体在执行规划时接收到的感知来指定动作。
chap2_para626,2,,本节先讨论非确定性，部分可观测性留待4.4节讨论。
chap2_para627,1,,4.3.1　不稳定的真空吸尘器世界
chap2_para628,1,,如图4-9所示，第2章中的真空吸尘器世界具有8种状态。
chap2_para628,2,,有3种动作——向左Left、向右Right和吸尘Suck，目标是清理所有的灰尘（状态7和8）。
chap2_para628,3,,如果环境是完全可观测的、确定性的和完全已知的，那么使用第3章的任意算法都很容易求解这个问题，它的解是一个动作序列。
chap2_para628,4,,"例如，如果初始状态是1，那么动作序列[Suck, Right, Suck]可以到达目标状态8。"
chap2_para629,1,,图4-9　真空吸尘器世界的8种可能状态；状态7和8是目标状态
chap2_para63,1,Description The block diagram starts with a block labeled Agent.,图2-5中简要列举了一些其他智能体类型的基本PEAS元素。
chap2_para63,2,There are seven blocks inside the Agent block.,更多示例参见习题2.PEAS。
chap2_para63,3,"The first block inside the agent block is labeled, What the word is like now.",这些示例包括物理环境和虚拟环境。
chap2_para63,4,"Arrows from the second, third, and fourth blocks labeled State, How the world evolves, and What my actions do, point to the first block.",注意，虚拟任务环境可能与“真实”世界一样复杂。
chap2_para63,5,A dashed arow from the first block points back to the state block.,例如，在拍卖和转售网站上进行交易的软件智能体（software agent），或称软件机器人或软机器人（softbot），为数百万其他用户和数十亿对象提供交易，其中许多对象具有真实的图片。
chap2_para63,6,"A solid arrow from the first block points to the fifth block labeled, What it will be like if I do action ""A"".",
chap2_para63,7,"Arrows from third and fourth blocks labeled, How the world evolves and What my action do, point to fifth block.",
chap2_para63,8,"An arrow from the fifth block points to the sixth block labeled, What action I should do now.",
chap2_para63,9,An arrow from the seventh block labeled Goals points to the sixth block.,
chap2_para63,10,An arrow from the sixth block points to the Actuators.,
chap2_para63,11,"An arrow from the actuators points to the block labeled, Environment, which is outside the agent block.",
chap2_para63,12,An arrow from the environment block points to the sensors in the agent block.,
chap2_para63,13,An arrow from the sensors points back to the first block.,
chap2_para630,1,,现在假设我们以一个功能强大但不稳定的真空吸尘器的形式引入非确定性。
chap2_para630,2,,在不稳定的真空吸尘器世界中，Suck的工作原理如下。
chap2_para631,1,,● 在一个脏的方格中，Suck会清理这一方格，有时也会清理它的相邻方格。
chap2_para632,1,,● 在一个干净方格中，Suck有时反而会把灰尘弄到地面上。
chap2_para632,2,,[5]
chap2_para634,1,,[5]　我们假设大多数读者都会遇到类似的问题，并且会共情我们的智能体。
chap2_para634,2,,我们向那些拥有现代化高效清洁设备从而无法利用这一教学设计的读者道歉。
chap2_para635,1,,为了更准确地形式化这一问题，我们需要推广第3章的转移模型概念。
chap2_para635,2,,我们不使用返回单个结果状态的Result函数来定义转移模型，而是使用返回一组可能的结果状态的新的Result函数。
chap2_para635,3,,例如，在不稳定的真空吸尘器世界中，状态1中的Suck动作要么只清理当前位置，要么同时清理两个位置：
chap2_para636,1,,如果我们是从状态1开始，那么没有任何一个单独的动作序列能够求解问题，因此我们需要如下的条件规划：
chap2_para638,1,,我们看到，条件规划可以包含if–then–else步骤；这意味着解是树而不是序列。
chap2_para638,2,,这里的if语句中的条件用来测试当前状态；这是智能体在运行时能够观测到的，但规划时还不知道。
chap2_para638,3,,或者，我们也可以用公式来测试感知而不是状态。
chap2_para638,4,,真实物理世界中的许多问题都是应变问题，因为不可能对未来进行准确预测。
chap2_para638,5,,因此，许多人在走路时都会睁着眼睛。
chap2_para639,1,,4.3.2　与或搜索树
chap2_para64,1,Figure 2.,图2-5　智能体类型及其PEAS描述的示例
chap2_para64,2,5Examples of agent types and their PEAS descriptions.,
chap2_para640,1,,我们如何得到这些非确定性问题的条件解？
chap2_para640,2,,和第3章一样，我们首先从构造搜索树开始，但是这里的树有一个不同的特性。
chap2_para640,3,,在确定性环境中，分支是由智能体在每个状态下自己的选择引入的：我可以执行这个动作或那个动作。
chap2_para640,4,,我们称这些节点为或节点（OR node）。
chap2_para640,5,,例如，在真空吸尘器世界中，智能体在或节点上选择Left、Right或Suck。
chap2_para640,6,,而在非确定性环境中，环境对每个动作的结果的选择也会引入分支。
chap2_para640,7,,我们称这些节点为与节点（AND node）。
chap2_para640,8,,"例如，状态1中的Suck动作会产生信念状态{5,7}，因此智能体需要为状态5与状态7分别找到一个规划。"
chap2_para640,9,,这两种节点交替出现，形成如图4-10所示的与或树（AND–OR tree）。
chap2_para641,1,,图4-10　不稳定的真空吸尘器世界搜索树的前两层。
chap2_para641,2,,状态节点是必须选择某个动作的或节点。
chap2_para641,3,,与节点（用圆圈表示）上的每个结果都必须处理，结果分支间用弧线连接。
chap2_para641,4,,找到的解用粗线标识
chap2_para642,1,,与或搜索问题的解是完整搜索树的一棵子树：（1）每个叶子都是一个目标节点，（2）在每个或节点上选择一个动作，（3）每个与节点包括所有结果分支。
chap2_para642,2,,解在图中用粗线标识；对应于式（4-3）中的规划。
chap2_para643,1,,图4-11给出了与或图搜索的深度优先递归算法。
chap2_para643,2,,该算法的一个关键是它处理环的方法，环经常出现在非确定性问题中（例如，动作有时不起作用，或者一个意外的影响被纠正）。
chap2_para643,3,,如果当前状态与从根到它的路径上的某个状态相同，就返回失败。
chap2_para643,4,,这并不意味着从当前状态出发没有解；这仅仅意味着，如果存在一个非循环解，那么它肯定可以从当前状态的早期镜像到达，因此可以丢弃新的镜像。
chap2_para643,5,,有了这一检查，可以确保算法在任何有限状态空间中都能终止，因为每条路径都必定到达一个目标、一个死胡同或一个重复状态。
chap2_para643,6,,注意，该算法并不检查当前状态是否是从根出发的其他路径上的某个状态的重复状态，这一点对效率来说很重要。
chap2_para644,1,,图4-11　非确定性环境生成的与或图的搜索算法。
chap2_para644,2,,解是一个条件规划，它考虑每一个非确定性的结果，并为每个结果制定规划
chap2_para645,1,,与或图也可以使用广度优先或最佳优先的方式进行探索。
chap2_para645,2,,我们必须修改启发式函数的概念，即估计一个条件解而不是一个序列的代价，但可容许性的概念可以继续保留，而且存在类似的用于寻找最优解的A*算法（参见本章末尾的参考文献与历史注释）。
chap2_para646,1,,4.3.3　反复尝试
chap2_para647,1,,考虑一个光滑的真空吸尘器世界，它与普通的（稳定的）真空吸尘器世界基本相同，但移动操作有时会失效，使得智能体停在原地。
chap2_para647,2,,"例如，在状态1中执行Right将产生信念状态{1,2}。"
chap2_para647,3,,图4-12为部分搜索图；显然，从状态1出发不存在非循环解，And-Or-Search将返回失败。
chap2_para647,4,,然而，存在一个循环解（cyclic solution），即反复尝试Right动作，直到它生效。
chap2_para647,5,,我们可以用一个新的while结构来表示上述过程：
chap2_para648,1,,或者用标签（label）表示规划的某一部分，之后可以引用这个标签：
chap2_para649,1,,什么时候可以考虑将循环规划作为解？
chap2_para649,2,,最小条件是每个叶节点都是一个目标状态，并且叶节点可以从规划中的任意点到达。
chap2_para649,3,,除此之外，我们还要考虑造成非确定性的原因。
chap2_para649,4,,如果情况确实是，真空吸尘器机器人的驱动机制在某些时间工作，但在其他时间真空吸尘器会发生随机、独立地滑动，那么智能体可以保证，如果动作重复足够多次，最终总会生效，规划也会成功。
chap2_para649,5,,但是，如果这种非确定性来自机器人或环境的一些尚未观测到的原因（例如，传动带断了，那么机器人将永远不会移动），重复这个动作也没有用。
chap2_para65,1,2.,2.3.2　任务环境的属性
chap2_para65,2,3.,
chap2_para65,3,2Properties of task environments,
chap2_para650,1,,为了便于理解，我们可以认为，它是将初始问题形式（完全可观测的，非确定性的）转化为另一种形式（部分可观测的，确定性的），其中循环规划的失败正是由于传动带的某个不可观测的特性。
chap2_para650,2,,在第12章中，我们将讨论如何判断几种不确定可能性中哪个可能性更大。
chap2_para651,1,,图4-12　光滑的真空吸尘器世界的部分搜索图，（一些）循环已经明确地标出。
chap2_para651,2,,这个问题的所有解都是循环规划，因为真空吸尘器无法稳定地移动
chap2_para652,1,,4.4　部分可观测环境中的搜索
chap2_para653,1,,现在我们考虑部分可观测性问题，即智能体的感知不足以确定准确的状态。
chap2_para653,2,,这意味着，智能体的一些动作将致力于减少当前状态的不确定性。
chap2_para654,1,,4.4.1　无观测信息的搜索
chap2_para655,1,,当智能体的感知根本不提供任何信息时，问题就变成了无传感器（sensorless）问题，或称一致性（conformant）问题。
chap2_para655,2,,起初，你可能会认为，如果无传感器智能体不知道起始状态，那它就无法求解问题，但出人意料的是，无传感器解非常普遍且有用，主要是因为它们不依赖于传感器是否正常工作。
chap2_para655,3,,例如，在制造系统中，已经开发出许多巧妙的方法，通过使用一系列行动而无须任何感知，从未知初始位置正确定位零件。
chap2_para655,4,,有时，即使存在可感知的条件规划，无传感器规划也会更好。
chap2_para655,5,,例如，医生通常会开一种广谱抗生素，而不是使用条件规划：先验血，接着等待结果，然后再开一种更具体的抗生素。
chap2_para655,6,,这种无传感器规划节省了时间和金钱，并且避免了在检测结果出来之前感染恶化的风险。
chap2_para656,1,,考虑一个（确定性）真空吸尘器世界的无传感器版本。
chap2_para656,2,,假设智能体知道它所在世界的地理环境，但不知道它自己的位置和灰尘的分布。
chap2_para656,3,,"在这种情况下，它的初始信念状态为{1, 2, 3, 4, 5, 6, 7, 8}（见图4-9）。"
chap2_para656,4,,"现在，如果智能体执行Right动作，它将位于{2, 4, 6, 8}中的某个状态——智能体在没有感知的情况下获得了信息！"
chap2_para656,5,,"执行[Right, Suck]之后，智能体将总是位于{4, 8}中的某个状态。"
chap2_para656,6,,"最终，无论初始状态是什么，执行[Right, Suck, Left, Suck]之后，智能体必定会到达目标状态7。"
chap2_para656,7,,我们称，智能体可以强迫（coerce）世界到达状态7。
chap2_para657,1,,无传感器问题的解是一个动作序列，而不是条件规划（因为它没有感知）。
chap2_para657,2,,但是，我们是在信念状态空间而非物理状态空间中进行搜索。
chap2_para657,3,,[6]在信念状态空间中，问题是完全可观测的，因为智能体始终知道自己的信念状态。
chap2_para657,4,,此外，无传感器问题的解（如果有的话）始终是一个动作序列。
chap2_para657,5,,这是因为，正如第3章的原始问题一样，每个动作后接收到的感知是完全可预测的——它们总是空的！
chap2_para657,6,,所以不存在需要规划的偶发事件。
chap2_para657,7,,即使环境是非确定性的，这也是正确的。
chap2_para659,1,,[6]　在完全可观测的环境中，每个信念状态只包含一个物理状态。
chap2_para659,2,,因此，我们可以将第3章的算法看作在信念状态为单元素的信念状态空间中搜索。
chap2_para66,1,The range of task environments that might arise in AI is obviously vast.,人工智能中可能出现的任务环境范围显然非常广泛。
chap2_para66,2,"We can, however, identify a fairly small number of dimensions along which task environments can be categorized.",然而，我们可以确定相当少的维度，并根据这些维度对任务环境进行分类。
chap2_para66,3,"These dimensions determine, to a large extent, the appropriate agent design and the applicability of each of the principal families of techniques for agent implementation.",这些维度在很大程度上决定了恰当的智能体设计以及智能体实现的主要技术系列的适用性。
chap2_para66,4,"First we list the dimensions, then we analyze several task environments to illustrate the ideas.",首先我们列出维度，然后分析几个任务环境，阐明思路。
chap2_para66,5,The definitions here are informal; later chapters provide more precise statements and examples of each kind of environment.,这里的定义是非形式化的，后面的章节提供了每种环境的更精确的陈述和示例。
chap2_para660,1,,我们可以为无传感器搜索问题介绍新的算法。
chap2_para660,2,,但是，如果我们将底层物理问题转化为信念状态问题，我们就可以使用第3章中现有的算法，即，对信念状态而非物理状态进行搜索。
chap2_para660,3,,原问题P，由ActionsP、ResultP等组成，信念状态问题则包括以下部分。
chap2_para661,1,,● 状态：信念状态空间包含物理状态的每一个可能子集。
chap2_para661,2,,如果原问题P有N个状态，那么信念状态问题有2N个信念状态，尽管有很多状态都无法从初始状态到达。
chap2_para662,1,,● 初始状态：通常，初始信念状态包含P中的所有状态，尽管在某些情况下，智能体具有更多的先验知识。
chap2_para663,1,,● 动作：这部分有点棘手。
chap2_para663,2,,假设智能体位于信念状态，但是；那么智能体就无法确定哪些动作是合法的。
chap2_para663,3,,如果我们假定非法动作不会对环境产生影响，那么执行当前信念状态b下的任意物理状态的所有动作的并集都是安全的。
chap2_para664,1,,但是，如果非法动作可能导致严重后果，那么只允许执行动作的交集（对所有状态都合法的动作的集合）更安全。
chap2_para664,2,,对于真空吸尘器世界，每个状态都具有相同的合法动作，所以两种方法将给出相同的结果。
chap2_para665,1,,● 转移模型：对于确定性动作，对于每个当前可能状态，新的信念状态中都存在一个如下结果状态（尽管一些结果状态可能是相同的）。
chap2_para667,1,,对于非确定性动作，新的信念状态则包含了将该动作应用于当前信念状态中的任一状态的所有可能结果。
chap2_para668,1,,对于确定性动作，b'不会大于b，而对于非确定性动作，b'可能会大于b（见图4-13）。
chap2_para669,1,,图4-13　（a）预测在无传感器真空吸尘器世界执行确定性动作Right后的下一个信念状态；（b）在光滑的无传感器真空吸尘器世界中的同一状态下执行同一动作的预测
chap2_para67,1,"Fully observable vs. partially observable: If an agent’s sensors give it access to the complete state of the environment at each point in time, then we say that the task environment is fully observable. A task environment is effectively fully observable if the sensors detect all aspects that are relevant to the choice of action; relevance, in turn, depends on the performance measure. Fully observable environments are convenient because the agent need not maintain any internal state to keep track of the world. An environment might be partially observable because of noisy and inaccurate sensors or because parts of the state are simply missing from the sensor data—for example, a vacuum agent with only a local dirt sensor cannot tell whether there is dirt in other squares, and an automated taxi cannot see what other drivers are thinking. If the agent has no sensors at all then the environment is unobservable. One might think that in such cases the agent’s plight is hopeless, but, as we discuss in Chapter 4, the agent’s goals may still be achievable, sometimes with certainty.",完全可观测的（fully observable）与部分可观测的（partially observable）：如果智能体的传感器能让它在每个时间点都能访问环境的完整状态，那么我们说任务环境是完全可观测的。
chap2_para67,2,,如果传感器检测到与动作选择相关的所有方面，那么任务环境就是有效的完全可观测的，而所谓的相关又取决于性能度量标准。
chap2_para67,3,,完全可观测的环境很容易处理，因为智能体不需要维护任何内部状态来追踪世界。
chap2_para67,4,,由于传感器噪声大且不准确，或者由于传感器数据中缺少部分状态，环境可能部分可观测。
chap2_para67,5,,例如，只有一个局部灰尘传感器的真空吸尘器无法判断其他方格是否有灰尘，自动驾驶出租车无法感知其他司机的想法。
chap2_para67,6,,如果智能体根本没有传感器，那么环境是不可观测的（unobservable）。
chap2_para67,7,,在这种情况下，有人可能会认为智能体的困境是无解的，但是正如我们在第4章中讨论的那样，智能体的目标可能仍然可以实现，有时甚至是确定可以实现的。
chap2_para670,1,,● 目标测试：如果信念状态中的任一状态s满足底层问题的目标测试，Is-GoalP(s)，则智能体有可能到达了目标。
chap2_para670,2,,如果所有状态都满足Is-GoalP(s)，则智能体必定到达了目标。
chap2_para670,3,,我们的目标是使得智能体必定到达了目标。
chap2_para671,1,,● 路径代价：这部分也很棘手。
chap2_para671,2,,如果同一动作在不同状态下代价不同，那么在给定信念状态下执行动作的代价是几种不同值中的一种。
chap2_para671,3,,（这导致了一类新的问题，我们将在习题4.MVAL中讨论。
chap2_para671,4,,）现在我们假定同一动作在所有状态下具有相同代价，因此动作代价可以直接从底层物理问题中转换。
chap2_para672,1,,图4-14为确定性无传感器真空吸尘器世界的可达信念状态空间。
chap2_para672,2,,在28 = 256种可能信念状态中只有12种可以到达。
chap2_para673,1,,图4-14　确定性无传感器真空吸尘器世界的信念状态空间的可达部分。
chap2_para673,2,,每个矩形框对应一个信念状态。
chap2_para673,3,,在任何给定点，智能体都有一个信念状态，但它不知道自己位于哪个物理状态。
chap2_para673,4,,初始信念状态（完全未知）位于最上面的中间方框
chap2_para674,1,,上述定义确保信念状态问题的形式化能够从底层物理问题的定义自动构建。
chap2_para674,2,,一旦完成，就可以用第3章的任何普通搜索算法求解无传感器问题。
chap2_para675,1,,在一般的图搜索中，需要检测新到达的状态之前是否已经到达过。
chap2_para675,2,,"这也适用于信念状态；例如，在图4-14中，动作序列[Suck, Left, Suck]从初始状态出发，到达与序列[Right, Left, Suck]相同的信念状态，即，{5, 7}。"
chap2_para675,3,,"现在，考虑[Left]到达的信念状态，{1, 3, 5, 7}。"
chap2_para675,4,,"显然，这与{5, 7}不同，但它是{5, 7}的超集。"
chap2_para675,5,,我们可以抛弃（剪枝）任何一个这样的信念状态超集。
chap2_para675,6,,为什么？
chap2_para675,7,,"因为从{1, 3, 5, 7}出发的解一定也是任何单一状态1、3、5和7的解，因此，它也是这些单一状态任意组合的解，例如{5, 7}；因此我们没有必要试着求解{1, 3, 5, 7}，可以专注于求解更严格简单的信念状态{5, 7}。"
chap2_para676,1,,"反过来，如果已经生成{1, 3, 5, 7}，并且发现它是可解的，那么它的任何子集，如{5, 7}，可以确保也是可解的。"
chap2_para676,2,,（如果我有一个解，它在我对自己处于何种状态“非常困惑”时都是有效的，那么在我“不那么困惑”时它仍然是有效的。
chap2_para676,3,,）这种额外剪枝可能会显著提高无传感器问题的求解效率。
chap2_para677,1,,然而，即使有这样的改进，我们所介绍的无传感器问题求解方法在实践中也几乎是不可行的。
chap2_para677,2,,一个问题是信念状态空间非常庞大——我们在第3章中看到过，一个大小为N的搜索空间已经过于庞大，而现在我们搜索空间的大小为2N。
chap2_para677,3,,此外，搜索空间中的每个元素都是一个不超过N个元素的集合。
chap2_para677,4,,对于较大的N，内存空间甚至不足以表示单个的信念状态。
chap2_para678,1,,一种解决方案是用更紧凑的描述来表示信念状态。
chap2_para678,2,,例如，在英语中，我们可以用“Nothing”表示初始状态；我们可以用“Not in the rightmost column”表示执行Left动作后的信念状态，等等。
chap2_para678,3,,第7章介绍了如何在形式化表示模式中实现上述表示。
chap2_para679,1,,另一种方法是避免使用标准搜索算法，它们将信念状态看作和任何其他问题状态一样的黑盒。
chap2_para679,2,,然而，我们可以选择查看信念状态内部，并设计增量信念状态搜索（incremental belief-state search）算法，即，每次只为一个物理状态建立解。
chap2_para679,3,,"例如，在无传感器真空吸尘器世界中，初始信念状态为{1, 2, 3, 4, 5, 6, 7, 8}，我们必须找到一个在所有8种状态下都有效的动作序列。"
chap2_para679,4,,我们可以先找到状态1的解；然后检查它对于状态2是否有效；如果无效，则回溯寻找状态1的另一个解，以此类推。
chap2_para68,1,"Single-agent vs. multiagent: The distinction between single-agent and multiagent environments may seem simple enough. For example, an agent solving a crossword puzzle by itself is clearly in a single-agent environment, whereas an agent playing chess is in a two-agent environment. However, there are some subtle issues. First, we have described how an entity may be viewed as an agent, but we have not explained which entities must be viewed as agents. Does an agent A (the taxi driver for example) have to treat an object B (another vehicle) as an agent, or can it be treated merely as an object behaving according to the laws of physics, analogous to waves at the beach or leaves blowing in the wind? The key distinction is whether B’s behavior is best described as maximizing a performance measure whose value depends on agent A’s behavior.",单智能体的（single-agent）与多智能体的（multiagent）：单智能体和多智能体环境之间的区别似乎足够简单。
chap2_para68,2,,例如，独自解决纵横字谜的智能体显然处于单智能体环境中，而下国际象棋的智能体则处于二智能体环境中。
chap2_para68,3,,然而，这里也有一些微妙的问题。
chap2_para68,4,,首先，我们已经描述了如何将一个实体视为智能体，但没有解释哪些实体必须视为智能体。
chap2_para68,5,,智能体A（例如出租车司机）是否必须将对象B（另一辆车）视为智能体，还是可以仅将其视为根据物理定律运行的对象，类似于海滩上的波浪或随风飘动的树叶？
chap2_para68,6,,关键的区别在于B的行为是否被最佳地描述为一个性能度量的最大化，而这一性能度量的值取决于智能体A的行为。
chap2_para680,1,,正如与或搜索必须为与节点上的每个分支找到解一样，这一算法也必须为信念状态下的每个物理状态找到解；区别在于与或搜索可以为每个分支找到不同的解，而增量信念状态搜索必须找到一个对所有状态都有效的解。
chap2_para681,1,,增量方法的主要优点是，它通常能够快速检测出失败——当一个信念状态无解时，通常情况下，它的子集（包含最先检测的几个状态）也是无解的。
chap2_para681,2,,在某些情况下，这将导致与信念状态规模成正比的加速，信念状态本身可能就和物理状态空间一样大。
chap2_para682,1,,4.4.2　部分可观测环境中的搜索
chap2_para683,1,,对许多问题来说，没有感知就无法求解。
chap2_para683,2,,例如，求解无传感器8数码问题是不可能的。
chap2_para683,3,,但是，一点点感知可能就有很大帮助：如果我们能够看到左上角的方格，就能求解8数码问题。
chap2_para683,4,,解包括依次将每个滑片移动到可观测的方格中，并从那时起记录该滑片的位置。
chap2_para684,1,,对于部分可观测问题，问题形式化将定义一个Percept(s)函数，它返回智能体在给定状态下接收到的感知。
chap2_para684,2,,如果感知是非确定性的，那么我们可以使用Percepts函数返回可能感知的集合。
chap2_para684,3,,对于完全可观测问题，每个状态s下，Percept(s) = s，对于无传感器问题，Percept(s)= null。
chap2_para685,1,,考虑一个局部感知真空吸尘器世界，智能体拥有一个位置传感器（在左侧方格中生成感知L，右侧方格中生成感知R）和一个灰尘传感器（当前方格内有灰尘时生成感知Dirty，否则生成Clean）。
chap2_para685,2,,"因此，状态1的Percept为[L, Dirty]。"
chap2_para685,3,,"对于部分可观测的情况，通常会存在几个状态产生相同感知的情况；状态3也会产生[L, Dirty]。"
chap2_para685,4,,"因此，给定这一初始感知，初始信念状态将为{1,3}。"
chap2_para685,5,,我们可以将部分可观测问题信念状态之间的转移模型分为3个阶段，如图4-15所示。
chap2_para686,1,,"● 预测（prediction）阶段与无传感器问题相同，计算由动作所导致的信念状态，Result(b, a)。"
chap2_para686,2,,"为了强调这是一个预测，我们将其记为bˆ = Result(b, a)，其中b上方的“hat”表示“估计值”，我们还可以使用Predict(b, a)代替Result(b, a)。"
chap2_para687,1,,● 可能感知（possible percept）阶段计算在预测的信念状态下可以观测到的感知集合（用字母o表示观测到的感知）：
chap2_para688,1,,● 更新（update）阶段为每个可能感知计算其可能得到的信念状态。
chap2_para688,2,,更新后的信念状态bo是bˆ中可能产生这一感知的状态集合：
chap2_para689,1,,● 智能体需要在规划阶段处理可能的感知，因为在执行规划之前它不知道实际的感知。
chap2_para689,2,,注意，在预测阶段，物理环境中的非确定性会扩大信念状态，但每个更新后的信念状态bo不会大于预测的信念状态bˆ；观测到的感知只能帮助减少不确定性。
chap2_para689,3,,此外，对于确定性感知，不同感知的信念状态是不相交的，从而形成原始预测信念状态的一个划分。
chap2_para69,1,"For example, in chess, the opponent entity B is trying to maximize its performance measure, which, by the rules of chess, minimizes agent A’s performance measure. Thus, chess is a competitive multiagent environment. On the other hand, in the taxi-driving environment, avoiding collisions maximizes the performance measure of all agents, so it is a partially cooperative multiagent environment. It is also partially competitive because, for example, only one car can occupy a parking space.",例如，国际象棋中的对手实体B正试图最大化其性能度量，根据国际象棋规则，这将最小化智能体A的性能度量。
chap2_para69,2,,因此，国际象棋是一个竞争性（competitive）的多智能体环境。
chap2_para69,3,,但是，在出租车驾驶环境中，避免碰撞使所有智能体的性能度量最大化，因此它是一个部分合作的（cooperative）多智能体环境。
chap2_para69,4,,它还具有部分竞争性，例如，一个停车位只能停一辆车。
chap2_para690,1,,图4-15　局部感知真空吸尘器世界中的两个转移实例。
chap2_para690,2,,"（a）确定性世界中，在初始信念状态下执行Right动作，所得到的新的预测信念状态有两个可能的物理状态；对于这些状态，可能的感知是[R, Dirty]和[R, Clean]，从而得到两种信念状态，每种都只包含一个物理状态。"
chap2_para690,3,,"（b）光滑世界中，在初始信念状态下执行Right动作，所得到的新的信念状态具有4个物理状态；对于这些状态，可能的感知是[L, Dirty]、[R, Dirty]和[R, Clean]，从而得到图中所示的3种信念状态"
chap2_para691,1,,综合这3个阶段，我们可以得到由给定动作及后续的可能感知所产生的可能信念状态：
chap2_para693,1,,4.4.3　求解部分可观测问题
chap2_para694,1,,4.4.2节介绍了在给定Percept函数的情况下，如何从底层物理问题推导出非确定性信念状态问题的Results函数。
chap2_para694,2,,使用这一形式化，可以直接应用图4-11的与或搜索算法得到问题的解。
chap2_para694,3,,"图4-16为局部感知真空吸尘器世界的部分搜索树，假定初始感知为[L, Dirty]。"
chap2_para694,4,,它的解是一个条件规划：
chap2_para695,1,,注意，因为我们是在信念状态问题中应用与或搜索算法，所以它返回的条件规划所测试的是信念状态，而非实际状态。
chap2_para695,2,,这是应该的：在部分可观测环境中，智能体并不知道实际状态。
chap2_para696,1,,图4-16　局部感知真空吸尘器世界问题的第一层与或搜索树，Suck是解序列中的第一个动作
chap2_para697,1,,与标准搜索算法应用于无传感器问题的情况一样，与或搜索算法将信念状态看作和任何其他问题状态一样的黑盒。
chap2_para697,2,,可以通过检查先前生成的信念状态——它们是当前状态的子集或超集——来改进这一点，就像求解无传感器问题一样。
chap2_para697,3,,同样可以推导出与无传感器问题中描述的那些算法类似的增量搜索算法。
chap2_para697,4,,与黑盒方法相比，它们提供了显著的加速。
chap2_para698,1,,4.4.4　部分可观测环境中的智能体
chap2_para699,1,,部分可观测环境中的智能体先对问题形式化，接着调用搜索算法（例如And-Or-Search）求解，然后执行解步骤。
chap2_para699,2,,这种智能体和完全可观测确定性环境中的智能体之间有两个主要区别。
chap2_para699,3,,首先，问题的解将是一个条件规划而不是一个序列；为了执行if-then-else表达式，智能体需要测试if语句中的条件并执行正确的条件分支。
chap2_para699,4,,其次，智能体需要在执行动作和接收感知时维护其信念状态。
chap2_para699,5,,这一过程类似于式（4-5）中的预测-观测-更新过程，但更加简单，因为感知是由环境给出的，而不是由智能体自己计算的。
chap2_para699,6,,给定初始信念状态b、动作a、感知o，则新的信念状态为
chap2_para7,1,Description The block diagram starts with a block labeled Agent.,我们使用术语感知（percept）来表示智能体的传感器正在感知的内容。
chap2_para7,2,An unknown block marked with a question mark is shown inside the agent block.,智能体的感知序列（percept sequence）是智能体所感知的一切的完整历史。
chap2_para7,3,An arrow from the sensors points to the unknown block.,一般而言，一个智能体在任何给定时刻的动作选择可能取决于其内置知识和迄今为止观察到的整个感知序列，而不是它未感知到的任何事物。
chap2_para7,4,An arrow from the unknown block points to the actuators.,通过为每个可能的感知序列指定智能体的动作选择，我们或多或少地说明了关于智能体的所有内容。
chap2_para7,5,"An arrow from the actuators points to a block labeled Environment, which is outside the agent block.",从数学上讲，我们说智能体的行为由智能体函数（agent function）描述，该函数将任意给定的感知序列映射到一个动作。
chap2_para7,6,An arrow from the environment block points back to sensors in the agent block.,
chap2_para70,1,"The agent-design problems in multiagent environments are often quite different from those in single-agent environments; for example, communication often emerges as a rational behavior in multiagent environments; in some competitive environments, randomized behavior is rational because it avoids the pitfalls of predictability.",多智能体环境中的智能体设计问题通常与单智能体环境下有较大差异。
chap2_para70,2,,例如，在多智能体环境中，通信通常作为一种理性行为出现；在某些竞争环境中，随机行为是理性的，因为它避免了一些可预测性的陷阱。
chap2_para701,1,,考虑一个类幼儿园真空吸尘器世界，智能体只能感知当前方格的状态，任一方格在任一时刻都有可能变脏，除非智能体恰好在那一时刻主动清理该方格。
chap2_para701,2,,[7]图4-17为此环境中所维护的信念状态。
chap2_para703,1,,[7]　向那些不熟悉幼儿对环境影响的人表示歉意。
chap2_para704,1,,在部分可观测环境中——涵盖绝大多数真实世界环境——维护自身的信念状态是任何智能系统的核心功能。
chap2_para704,2,,这一功能有很多不同的名称，包括监视（monitoring）、过滤（filtering）和状态评估（state estimation）。
chap2_para704,3,,式（4-6）称为递归状态评估器，因为它根据前一状态计算新的信念状态，而不是检查整个感知序列。
chap2_para704,4,,如果智能体不想“落后”，计算速度必须和感知进入的速度一样快。
chap2_para704,5,,随着环境越来越复杂，智能体将只有时间计算近似信念状态，它可能重点关注感知对当前感兴趣的环境方面的影响。
chap2_para704,6,,关于这一问题的大部分工作都是用概率论的工具处理随机的连续状态的环境，详见第14章。
chap2_para705,1,,图4-17　在局部感知的类幼儿园真空吸尘器世界中，信念状态维护的两个预测-更新周期
chap2_para706,1,,在本节中，我们将展示一个离散环境中的实例，其传感器是确定性的，动作是非确定性的。
chap2_para706,2,,这个实例中涉及的机器人具有特定的状态评估任务，该任务称为定位（localization）：即在给定世界地图和一系列感知及行动的情况下，找到自己的位置。
chap2_para706,3,,机器人放置在图4-18所示的迷宫环境中。
chap2_para706,4,,它配备了4个声呐传感器，可以判断在4个罗盘方向上是否存在障碍物——外墙或者图中的深色阴影方格。
chap2_para706,5,,感知以位向量的形式出现，每一位依次代表北、东、南、西方向，所以1011表示北、南、西方向有障碍物。
chap2_para707,1,,图4-18　机器人的可能位置，⊙，（a）一次观测E1 = 1011后。
chap2_para707,2,,（b）移动一个方格并进行第二次观测E2 = 1010后。
chap2_para707,3,,如果传感器没有噪声且转移模型是准确的，那么只有一个可能位置与这两个观测序列一致
chap2_para708,1,,我们假设传感器所提供的数据完全正确，而且机器人拥有正确的环境地图。
chap2_para708,2,,但遗憾的是，机器人的导航系统发生故障，所以当它执行Right动作时，会随机移动到一个相邻方格。
chap2_para708,3,,机器人的任务是确定它的当前位置。
chap2_para709,1,,假设机器人刚刚启动，并不知道自己的位置——那么它的初始信念状态b为包含所有位置的集合。
chap2_para709,2,,接着机器人接收到感知1011，并使用公式bo = Update(1011)进行更新，得到如图4-18a所示的4个位置。
chap2_para709,3,,查看整个迷宫你会发现这是仅有的4个可以产生感知1011的位置。
chap2_para71,1,Deterministic vs.,确定性的（deterministic）与非确定性的（nondeterministic）：如果环境的下一个状态完全由当前状态和智能体执行的动作决定，那么我们说环境是确定性的，否则是非确定性的。
chap2_para71,2,nondeterministic.,原则上，在完全可观测的确定性环境中，智能体不需要担心不确定性。
chap2_para71,3,"If the next state of the environment is completely determined by the current state and the action executed by the agent(s), then we say the environment is deterministic; otherwise, it is nondeterministic.",然而，如果环境是部分可观测的，那么它可能是非确定性的。
chap2_para71,4,"In principle, an agent need not worry about uncertainty in a fully observable, deterministic environment.",
chap2_para71,5,"If the environment is partially observable, however, then it could appear to be nondeterministic.",
chap2_para710,1,,接下来，机器人执行Right动作，但结果是非确定性的。
chap2_para710,2,,"新的信念状态，ba = Predict(bo, Right)，包含了与bo中的位置相邻的所有位置。"
chap2_para710,3,,"当接收到第二个感知1010时，机器人执行Update(ba, 1010)，此时信念状态已经只剩图4-18b所示的一个位置。"
chap2_para710,4,,这是下式得到的唯一位置：
chap2_para711,1,,对于非确定性动作，Predict阶段信念状态增加，但是Update阶段信念状态又减少回去——只要感知提供了有用的识别信息。
chap2_para711,2,,有时感知对定位帮助不大：如果存在一个或多个很长的东西向走廊，那么机器人可能会接收到一个很长的1010感知序列，但它永远不会知道它在走廊的哪一位置。
chap2_para711,3,,但对于地理上存在合理差异的环境，定位往往会迅速收敛到单个点，即使动作是非确定性的。
chap2_para712,1,,如果传感器发生故障怎么办？
chap2_para712,2,,如果我们只能用布尔逻辑进行推理，那么我们就无法判断每个传感器位的正误，相当于没有任何感知信息。
chap2_para712,3,,但我们将看到，概率推理（第12章）允许我们从故障传感器中提取有用信息，只要它出错的时间不超过一半。
chap2_para713,1,,4.5　在线搜索智能体和未知环境
chap2_para714,1,,到目前为止，我们主要关注使用离线搜索（offline search）算法的智能体。
chap2_para714,2,,它们在执行第一个动作之前就已经计算出一个完整的解。
chap2_para714,3,,相比之下，在线搜索（online search）[8]智能体则交替进行计算和动作：它首先执行一个动作，然后观测环境并计算下一个动作。
chap2_para714,4,,在线搜索适用于动态或半动态环境，因为在这些环境中停止不动或计算时间太长都要付出代价。
chap2_para714,5,,在线搜索在非确定性领域也很有用，因为它允许智能体将计算精力集中在实际发生的偶然事件上，而不是那些也许会发生但很可能不会发生的事件。
chap2_para716,1,,[8]　这里的“在线”指的是必须在接收到输入时立即进行处理的算法，而不是等待整个输入数据集都可用时再进行处理。
chap2_para716,2,,“在线”的这种用法与“因特网连接”的概念无关。
chap2_para717,1,,当然，这里需要权衡：智能体提前规划得越多，发现自己陷入困境的频率越低。
chap2_para717,2,,在未知环境中，智能体不清楚存在什么状态或者动作会产生什么结果，必须使用自身的动作作为实验来了解环境。
chap2_para718,1,,在线搜索的一个典型实例是地图构建问题（mapping problem）：机器人放置在一个未知建筑中，它必须进行探索以绘制一个从A到B的地图。
chap2_para718,2,,逃离迷宫的方法——有抱负的古代英雄所需的知识——也是在线搜索算法的实例。
chap2_para718,3,,然而，空间探索并不是在线探索的唯一形式。
chap2_para718,4,,以一个新生儿为例：它可能可以做许多举动，却不知道这些动作的后果，而且它只体验过少数几个它能达到的可能状态。
chap2_para719,1,,4.5.1　在线搜索问题
chap2_para72,1,"Most real situations are so complex that it is impossible to keep track of all the unobserved aspects; for practical purposes, they must be treated as nondeterministic. Taxi driving is clearly nondeterministic in this sense, because one can never predict the behavior of traffic exactly; moreover, one’s tires may blow out unexpectedly and one’s engine may seize up without warning. The vacuum world as we described it is deterministic, but variations can include nondeterministic elements such as randomly appearing dirt and an unreliable suction mechanism (Exercise 2.VFIN).",大多数真实情况非常复杂，以至于不可能追踪所有未观测到的方面；出于实际目的，必须将其视为非确定性的。
chap2_para72,2,,从这个意义上讲，出租车驾驶显然是非确定性的，因为人们永远无法准确地预测交通行为。
chap2_para72,3,,此外，轮胎可能会意外爆胎，发动机可能会在没有警告的情况下失灵。
chap2_para72,4,,我们描述的真空吸尘器世界是确定性的，但变化可能包括非确定性因素，如随机出现的灰尘和不可靠的吸力机制（参考习题2.VFIN）。
chap2_para720,1,,求解在线搜索问题需要交替进行计算、感知和动作。
chap2_para720,2,,我们首先假设环境是确定性的和完全可观测的（第17章放宽了这些假设），并规定智能体只知道以下内容。
chap2_para721,1,,● Actions(s)，状态s下的合法动作。
chap2_para722,1,,"● c(s, a, s')，在状态s下执行动作a到达状态s'的代价。"
chap2_para722,2,,注意，前提是智能体知道s'是结果。
chap2_para723,1,,● Is-Goal(s)，目标测试。
chap2_para724,1,,"特别要注意的是，智能体不能确定Result(s, a)的值，除非它确实在s中执行了a。"
chap2_para724,2,,"例如，在图4-19所示的迷宫问题中，智能体并不知道从(1, 1)执行Up动作会到达(1, 2)；也不知道再执行Down动作会回到(1, 1)。"
chap2_para724,3,,在某些应用中可以减少这种无知——例如，机器人探测器可能知道它是如何移动的，只是不知道障碍物的位置。
chap2_para725,1,,最后，智能体可能可以访问一个可容许的启发式函数h(s)，该函数对从当前状态到目标状态的距离进行估计。
chap2_para725,2,,例如，在图4-19中，智能体可能知道目标的位置，从而可以使用曼哈顿距离启发式函数（3.6节）。
chap2_para726,1,,图4-19　一个简单的迷宫问题。
chap2_para726,2,,智能体必须从S出发到达G，但它对环境一无所知
chap2_para727,1,,通常，智能体的目标是以最小代价到达目标状态。
chap2_para727,2,,（另一个可能目标是简单地探索整个环境。
chap2_para727,3,,）代价是智能体在移动过程中产生的总的路径代价。
chap2_para727,4,,通常将它与智能体事先知道搜索空间时所产生的路径代价（即已知环境中的最优路径）进行比较。
chap2_para727,5,,在在线算法的术语中，这种比较被称为竞争比（competitive ratio），我们希望它尽可能地小。
chap2_para728,1,,在线探索器很容易陷入死胡同（dead-end）：无法到达任何目标状态的状态。
chap2_para728,2,,如果智能体不知道每个动作的后果，它可能会“跳进陷阱”，因此永远无法到达目标。
chap2_para728,3,,一般来说，没有一种算法能在所有状态空间中都避免进入死胡同。
chap2_para728,4,,以图4-20a中的两个死胡同状态空间为例。
chap2_para728,5,,对已经访问过状态S和A的在线搜索算法来说，它无法分辨自己是处于顶部的状态还是底部的状态；根据智能体观测到的感知信息，这两个状态看起来是相同的。
chap2_para728,6,,因此，它不可能知道如何在两个状态空间中选择正确的动作。
chap2_para728,7,,这是一个对手论证（adversary argument）的实例——想象对手在智能体探索状态空间时构建状态空间，并将目标和死胡同放在它所选择的任何地方，如图4-20b所示。
chap2_para729,1,,图4-20　（a）两个可能将在线搜索智能体引入死胡同的状态空间。
chap2_para729,2,,任何给定智能体都会在至少一个空间中失败。
chap2_para729,3,,（b）二维环境实例，将导致在线搜索智能体沿着一条任意低效的路线到达目标。
chap2_para729,4,,无论智能体做出何种选择，对手都会用另一堵很长很薄的墙来阻挡这条路线，这样智能体所走的路径就会比最优可能路径长得多
chap2_para73,1,"One final note: the word stochastic is used by some as a synonym for “nondeterministic,” but we make a distinction between the two terms; we say that a model of the environment is stochastic if it explicitly deals with probabilities (e.g., “there’s a 25% chance of rain tomorrow”) and “nondeterministic” if the possibilities are listed without being quantified (e.g., “there’s a chance of rain tomorrow”).",最后注意一点，随机的（stochastic）一词被一些人用作“非确定性”的同义词，但我们会区分这两个术语。
chap2_para73,2,,如果环境模型显式地处理概率（例如，“明天的降雨可能性为25%”），那么它是随机的；如果可能性没有被量化，那么它是“非确定性的”（例如，“明天有可能下雨”）。
chap2_para730,1,,死胡同是机器人探索中的一个真正的难点——楼梯、斜坡、悬崖、单行道甚至自然地形中都存在从它出发某些动作不可逆（irreversible）的状态——没有办法回到之前的状态。
chap2_para730,2,,我们提出的探索算法只保证在可安全探索（safely explorable）的状态空间中是有效的，也就是说，从每个可达状态出发都存在可以到达的目标状态。
chap2_para730,3,,所有动作都可逆的状态空间，如迷宫和8数码，显然是可安全探索的（如果它们有解的话）。
chap2_para730,4,,我们将在22.3.2节中更深入地讨论安全探索的话题。
chap2_para731,1,,即使在可安全探索的环境中，如果存在代价无界的路径，也不能保证竞争比有界。
chap2_para731,2,,在动作不可逆的环境中，很容易发现上述结论，但事实上，可逆情况下也是如此，如图4-20b所示。
chap2_para731,3,,因此，通常会根据整个状态空间的大小来描述在线搜索算法的性能，而不是仅仅根据最浅层目标的深度。
chap2_para732,1,,4.5.2　在线搜索智能体
chap2_para733,1,,可观测环境中的在线智能体在每个动作之后都会接收到一个感知，告诉它目前到达了哪一状态，通过这些信息，智能体可以更新它的环境地图。
chap2_para733,2,,更新后的地图将用于规划下一步。
chap2_para733,3,,规划和动作交替进行意味着在线搜索算法与之前介绍的离线搜索算法有很大不同：离线算法探索其状态空间模型，而在线算法探索真实世界。
chap2_para733,4,,例如，A*可以在空间的某部分扩展一个节点，然后马上在空间的另一相距很远的部分扩展另一个节点，因为节点扩展设计的是模拟动作而非真实动作。
chap2_para734,1,,另外，在线算法只能找到其实际占据的状态的后继。
chap2_para734,2,,为了避免长途跋涉到一个相距较远的状态来扩展下一个节点，按照局部顺序扩展节点似乎更好。
chap2_para734,3,,深度优先搜索恰好具有这一性质，因为（如果算法不用回溯）下一个扩展节点是前一个扩展节点的子节点。
chap2_para735,1,,图4-21为在线深度优先探索智能体（动作是确定性但未知的）。
chap2_para735,2,,"智能体将它的地图存储在一个result[s, a]表中，记录了在状态s下执行动作a所产生的状态。"
chap2_para735,3,,"（对于非确定性动作，智能体可以在results[s, a]中记录状态集合。"
chap2_para735,4,,）只要当前状态存在未探索过的动作，智能体就会尝试其中一个动作。
chap2_para735,5,,当智能体尝试完某个状态下的所有动作时，问题就来了。
chap2_para735,6,,在离线深度优先搜索中，我们只是将状态从队列中删除；而在线搜索中，智能体必须在物理世界中回溯。
chap2_para735,7,,在深度优先搜索中，这意味着回溯到智能体进入当前状态前的最近状态。
chap2_para735,8,,为了实现这一点，算法需要维护另一个表，表中列出了每个状态尚未回溯到的前驱状态。
chap2_para735,9,,如果智能体已经没有可回溯的状态，那么搜索就完成了。
chap2_para736,1,,图4-21　使用深度优先探索的在线搜索智能体。
chap2_para736,2,,智能体只有在每个动作都可以被其他动作“撤消”的状态空间中才能安全地探索
chap2_para737,1,,我们建议读者在求解图4-19中的迷宫问题时跟踪Online-DFS-Agent的进度。
chap2_para737,2,,很容易看到，最坏情况下，智能体最终恰好要遍历状态空间中的每个连接两次。
chap2_para737,3,,对探索来说，这是最优的；但是，对寻找目标来说，如果在初始状态旁边恰好有一个目标状态，智能体的竞争比将变得无限差。
chap2_para737,4,,在线迭代加深算法可以解决这一问题；对于均衡树环境，这样一个智能体的竞争比是一个很小的常数。
chap2_para738,1,,由于其回溯方法，Online-DFS-Agent只在动作可逆的状态空间中有效。
chap2_para738,2,,在一般的状态空间中，有一些更复杂的算法，但是这类算法的竞争比都不是有界的。
chap2_para739,1,,4.5.3　在线局部搜索
chap2_para74,1,"Episodic vs. sequential: In an episodic task environment, the agent’s experience is divided into atomic episodes. In each episode the agent receives a percept and then performs a single action. Crucially, the next episode does not depend on the actions taken in previous episodes. Many classification tasks are episodic. For example, an agent that has to spot defective parts on an assembly line bases each decision on the current part, regardless of previous decisions; moreover, the current decision doesn’t affect whether the next part is defective. In sequential environments, on the other hand, the current decision could affect all future decisions.4 Chess and taxi driving are sequential: in both cases, short-term actions can have long-term consequences. Episodic environments are much simpler than sequential environments because the agent does not need to think ahead.",回合式的（episodic）与序贯的（sequential）：在回合式任务环境中，智能体的经验被划分为原子式的回合。
chap2_para74,2,,在每一回合中，智能体接收一个感知，然后执行单个动作。
chap2_para74,3,,至关重要的是，下一回合并不依赖于前几回合采取的动作。
chap2_para74,4,,许多分类任务是回合式的。
chap2_para74,5,,例如，在装配流水线上检测缺陷零件的智能体需要根据当前零件做出每个决策，而无须考虑以前的决策；而且，当前的决策并不影响下一个零件是否有缺陷。
chap2_para74,6,,但是，在序贯环境中，当前决策可能会影响未来所有决策。
chap2_para74,7,,[4]国际象棋和出租车驾驶是序贯的：在这两种情况下，短期行为可能会产生长期影响。
chap2_para74,8,,因为在回合式环境下智能体不需要提前思考，所以要比序贯环境简单很多。
chap2_para740,1,,与深度优先搜索一样，爬山搜索在节点扩展上也有局部性。
chap2_para740,2,,事实上，因为爬山搜索在内存中只保存一个当前状态，它已经是在线搜索算法！
chap2_para740,3,,遗憾的是，基础算法并不适用于探索，因为智能体会陷入局部极大值而无路可走。
chap2_para740,4,,此外，不能使用随机重启，因为智能体无法将自己瞬移到一个新的初始状态。
chap2_para741,1,,相比于随机重启，我们可以考虑使用随机游走（random walk）来探索环境。
chap2_para741,2,,随机游走只是从当前状态中随机选择一个可用动作，可以优先考虑尚未尝试的动作。
chap2_para741,3,,容易证明，当空间有限且可安全探索时，随机游走最终会找到一个目标或完成探索。
chap2_para741,4,,[9]但是，这一过程可能非常慢。
chap2_para741,5,,图4-22为一个环境实例，在这个环境中，随机游走将耗费指数级的步骤来寻找目标，因为对于第一行除S之外的每个状态，后退的可能性是前进的两倍。
chap2_para741,6,,当然，这个例子是人为设计的，但是真实世界中许多状态空间的拓扑结构都会导致这类随机游走“陷阱”。
chap2_para743,1,,[9]　随机游走在无限的一维和二维网格上是完备的。
chap2_para743,2,,"在三维网格上，游走返回起点的概率只有大约0.3405（Hughes, 1995）。"
chap2_para744,1,,图4-22　环境实例，随机游走需要耗费指数级的步骤来寻找目标
chap2_para745,1,,事实证明，增加爬山法的内存而非随机性是一种更有效的方法。
chap2_para745,2,,基本思想是，存储从已访问的每个状态出发到达目标所需代价的“当前最佳估计”H(s)。
chap2_para745,3,,H(s)开始时只是启发式估计，然后根据智能体在状态空间中获得的经验不断更新。
chap2_para746,1,,图4-23为一维状态空间中的一个简单示例。
chap2_para746,2,,在图4-23a中，智能体似乎陷入了位于红色状态的局部极小值。
chap2_para746,3,,智能体不应该停留在原地，而应该根据其邻居节点的当前代价估计值选择到达目标的最优路径。
chap2_para746,4,,"经由邻居节点s'到达目标的估计代价等于到达s'的代价加上从s'到达目标的估计代价，即c(s, a, s') + H(s')。"
chap2_para746,5,,在这个示例中，有2个动作，估计代价分别为向左1 + 9，向右1 + 2，因此最好向右移动。
chap2_para747,1,,在图4-23b中，显然，将图4-23a中红色状态的代价估计为2是过于乐观的。
chap2_para747,2,,因为最佳移动的代价为1，而且其结果状态离目标状态至少还有2步，所以红色状态离目标一定至少还有3步，所以应该相应地更新红色状态的H，如图4-23b所示。
chap2_para747,3,,继续上述过程，智能体将再来回移动两次，每次都会更新H并“拉平”局部极小值，直到它逃逸到右侧。
chap2_para748,1,,能够实现上述方案的智能体称为实时学习A*（learning real-time A*，LRTA*）智能体，如图4-24所示。
chap2_para748,2,,同Online-DFS-Agent一样，它用result表构建环境地图。
chap2_para748,3,,它首先更新刚刚离开的状态的代价估计值，然后根据当前的代价估计值选择“显然最佳”移动。
chap2_para748,4,,一个重要的细节是，在状态s下尚未尝试的动作总是被假定为以最少的可能代价，即h(s)直接到达目标。
chap2_para748,5,,这种不确定性下的乐观主义（optimism under uncertainty）鼓励智能体去探索新的、可能更有希望的路径。
chap2_para749,1,,图4-23　一维状态空间上LRTA*的5次迭代。
chap2_para749,2,,每个状态都标有H(s)，即到达目标的当前代价估计值，每个连接的动作代价为1。
chap2_para749,3,,红色状态表示智能体的位置，每次迭代所更新的代价估计值以双圈标记
chap2_para75,1,"Static vs. dynamic: If the environment can change while an agent is deliberating, then we say the environment is dynamic for that agent; otherwise, it is static. Static environments are easy to deal with because the agent need not keep looking at the world while it is deciding on an action, nor need it worry about the passage of time. Dynamic environments, on the other hand, are continuously asking the agent what it wants to do; if it hasn’t decided yet, that counts as deciding to do nothing. If the environment itself does not change with the passage of time but the agent’s performance score does, then we say the environment is semidynamic. Taxi driving is clearly dynamic: the other cars and the taxi itself keep moving while the driving algorithm dithers about what to do next. Chess, when played with a clock, is semidynamic. Crossword puzzles are static.",
chap2_para750,1,,图4-24　LRTA*-Agent根据相邻状态的值选择动作，智能体在状态空间中移动时更新状态值
chap2_para751,1,,LRTA* 智能体保证在任何有限的、可安全探索的环境中都能找到目标。
chap2_para751,2,,然而，不同于A*，LRTA*在无限状态空间中是不完备的——在某些情况下，它可能被无限地引入歧途。
chap2_para751,3,,在最坏情况下，探索状态数为n的环境可能需要O(n2)步，但通常情况下会比这种情况好得多。
chap2_para751,4,,LRTA* 智能体只是一个庞大的在线智能体家族中的一员，可以通过以不同方式指定动作选择规则和更新规则来定义。
chap2_para751,5,,我们将在第22章中详细讨论这一发源于随机环境的在线智能体家族。
chap2_para752,1,,4.5.4　在线搜索中的学习
chap2_para753,1,,在线搜索智能体初始时对环境的无知为我们提供了一些学习的机会。
chap2_para753,2,,首先，智能体通过记录它们的每一次经验来学习环境“地图”——更准确地说，学习每种状态下每个动作的结果。
chap2_para753,3,,其次，当智能体以正确的方式探索状态空间时，局部搜索智能体可以利用局部更新规则获得每个状态代价更准确的估计值。
chap2_para753,4,,一旦知道代价的准确值，只需移动到代价最低的后继状态就能实现最优决策，也就是说，纯粹的爬山法就是一个最优策略。
chap2_para754,1,,如果按照我们的建议在图4-19的环境中跟踪Online-DFS-Agent的行为，你会注意到智能体不是非常聪明。
chap2_para754,2,,"例如，在它已经知道Up动作能够从(1, 1)到达(1, 2)后，它仍然不知道Down动作能回到(1, 1)，或者Up动作还能从(2, 1)到(2, 2)，从(2, 2)到(2, 3)，等等。"
chap2_para754,3,,一般来说，我们希望智能体能够学到，Up在不遇到墙的情况下使得y坐标值增加，Down则使得y坐标值降低，等等。
chap2_para755,1,,要实现这一点，我们需要做两件事。
chap2_para755,2,,首先，需要对这类一般规则有一个形式的、可显式操纵的表示；到目前为止，信息都被隐藏在名为Result函数的黑盒中。
chap2_para755,3,,第8～11章将专门讨论这个问题。
chap2_para755,4,,其次，需要能够根据智能体所得到的具体观测信息构造合适的一般规则的算法。
chap2_para755,5,,这些内容将在第19章中讨论。
chap2_para756,1,,如果我们预计将来会被要求求解多个类似问题，那么投入时间（和内存）使得这些未来搜索更容易是有意义的。
chap2_para756,2,,有几种方法可以做到这一点，它们都属于增量搜索（incremental search）的范畴。
chap2_para756,3,,我们可以将搜索树保留在内存中，并复用在新问题中未发生改变的部分。
chap2_para756,4,,我们可以保留启发式代价函数h的值，并在获得新信息时更新它们——要么是因为世界发生改变，要么是因为我们计算出了更好的估计值。
chap2_para756,5,,或者我们可以保留最优路径的g值，用它们拼凑出一个新的解，并在世界发生改变时对它们进行更新。
chap2_para758,1,,本章讨论了部分可观测的、非确定性的、未知的和连续的环境中问题的搜索算法。
chap2_para759,1,,● 局部搜索算法，如爬山法，在内存中只保留少量状态。
chap2_para759,2,,这些方法已被应用于优化问题，其思想是找到一个高分值的状态，而不考虑进入该状态的路径。
chap2_para759,3,,研究人员已经开发了一些随机局部搜索算法，包括模拟退火，当给定适当的冷却方案时它能返回最优解。
chap2_para76,1,Discrete vs.,[4]　“sequential”（串行）一词在计算机科学中也被用作“parallel”（并行）的反义词，与此处的含义在很大程度上是不相关的。
chap2_para76,2,"continuous: The discrete/continuous distinction applies to the state of the environment, to the way time is handled, and to the percepts and actions of the agent.",
chap2_para76,3,"For example, the chess environment has a finite number of distinct states (excluding the clock).",
chap2_para76,4,Chess also has a discrete set of percepts and actions.,
chap2_para76,5,Taxi driving is a continuous-state and continuous-time problem: the speed and location of the taxi and of the other vehicles sweep through a range of continuous values and do so smoothly over time.,
chap2_para76,6,"Taxi-driving actions are also continuous (steering angles, etc.",
chap2_para76,7,).,
chap2_para76,8,"Input from digital cameras is discrete, strictly speaking, but is typically treated as representing continuously varying intensities and locations.",
chap2_para760,1,,● 许多局部搜索方法同样适用于连续空间中的问题。
chap2_para760,2,,线性规划和凸优化问题服从状态空间形状和目标函数性质上的某些限制，并且允许多项式时间算法，这些算法在实践中往往非常高效。
chap2_para760,3,,对于一些数学上合式的问题，我们可以使用微积分找到梯度为零的最大值；对于其他问题，我们必须使用经验梯度，即测量两个邻近点间的适应度差值。
chap2_para761,1,,● 进化算法是一种维护状态种群的随机爬山搜索。
chap2_para761,2,,通过突变和杂交（结合状态对）产生新状态。
chap2_para762,1,,● 在非确定性环境中，智能体可以应用与或搜索算法生成应变规划，无论执行过程中出现何种结果，它都能实现目标。
chap2_para763,1,,● 如果环境是部分可观测的，信念状态表示智能体可能位于的可能状态的集合。
chap2_para764,1,,● 标准搜索算法可以直接应用于信念状态空间求解无传感器问题，而信念状态与或搜索算法可以求解一般的部分可观测问题。
chap2_para764,2,,在一个信念状态中逐状态构造解的增量算法通常效率更高。
chap2_para765,1,,● 探索问题发生在智能体对环境的状态和动作一无所知时。
chap2_para765,2,,对于可安全探索的环境，在线搜索智能体能够构建地图并找到目标（如果存在的话）。
chap2_para765,3,,根据经验来更新启发式估计值提供了一种避免局部极小值的有效方法。
chap2_para768,1,,第5章　对抗搜索和博弈
chap2_para769,1,,在本章中，我们将探索有其他智能体计划与我们对抗时的环境。
chap2_para77,1,"Known vs. unknown: Strictly speaking, this distinction refers not to the environment itself but to the agent’s (or designer’s) state of knowledge about the “laws of physics” of the environment. In a known environment, the outcomes (or outcome probabilities if the environment is nondeterministic) for all actions are given. Obviously, if the environment is unknown, the agent will have to learn how it works in order to make good decisions.",静态的（static）与动态的（dynamic）：如果环境在智能体思考时发生了变化，我们就说该智能体的环境是动态的，否则是静态的。
chap2_para77,2,,静态环境很容易处理，因为智能体在决定某个操作时不需要一直关注世界，也不需要担心时间的流逝。
chap2_para77,3,,但是，动态环境会不断地询问智能体想要采取什么行动，如果它还没有决定，那就等同于什么都不做。
chap2_para77,4,,如果环境本身不会随着时间的推移而改变，但智能体的性能分数会改变，我们就说环境是半动态的（semidynamic）。
chap2_para77,5,,驾驶出租车显然是动态的，因为驾驶算法在计划下一步该做什么时，其他车辆和出租车本身在不断移动。
chap2_para77,6,,在用时钟计时的情况下国际象棋是半动态的。
chap2_para77,7,,填字游戏是静态的。
chap2_para770,1,,在本章中，我们将讨论竞争环境（competitive environment），在这种环境中，两个或两个以上的智能体具有互相冲突的目标，这引出了对抗搜索（adversarial search）问题。
chap2_para770,2,,我们将专注于讨论博弈[1]，如国际象棋、围棋和扑克，而不是处理真实世界中的混乱冲突。
chap2_para770,3,,对人工智能研究人员来说，这些博弈的简化特性是一个优势：博弈状态很容易表示，智能体通常仅能执行少数几个动作，而且动作的效果由明确的规则定义。
chap2_para770,4,,对于体育比赛（如槌球和冰球），描述更加复杂，可能动作的范围更大，而且定义动作合法性的规则也不够明确。
chap2_para770,5,,除足球机器人外，体育比赛并没有引起人工智能社区的很大兴趣。
chap2_para772,1,,[1]　对应英文game在博弈论中译为“博弈”，但在本书中不同语境下会根据具体情况使用博弈、游戏、比赛等。
chap2_para772,2,,——译者注
chap2_para774,1,,对于多智能体环境，我们至少可以有3种观点。
chap2_para774,2,,第一种观点适用于智能体数量非常大的情况，即把它们看作一个经济（economy）整体来考虑，这让我们可以做出例如“需求增长会导致价格上涨”这样的预测，而不需要预测任何个体智能体的动作。
chap2_para775,1,,第二种观点是，我们可以认为对抗智能体只是环境的一部分——这一部分让环境变成非确定性的。
chap2_para775,2,,但如果我们以对雨建模一样的方式（例如，雨有时下，有时不下）对对手进行建模，我们就会忽略对手正在积极地尝试击败我们这一事实，而雨没有这样的意图。
chap2_para776,1,,第三种观点是用对抗博弈树搜索技术显式地对对抗智能体建模。
chap2_para776,2,,这就是本章所涵盖的内容。
chap2_para776,3,,我们从一类受限的博弈开始，定义最优移动并寻找最优移动的算法——极小化极大搜索（minimax search），它是与或搜索的一种推广（见图4-11）。
chap2_para776,4,,我们指出，剪枝（pruning）通过忽略搜索树中对最优移动没有影响的部分来提高搜索效率。
chap2_para776,5,,对于非平凡博弈，我们通常没有足够的时间以确保找到最优移动（即使使用剪枝），我们不得不在某个时刻停止搜索。
chap2_para777,1,,对于每一个我们选择在那里停止搜索的状态，我们都需要知道谁是获胜者。
chap2_para777,2,,要回答这个问题，有一个选择：可以基于状态特征应用启发式评价函数来估计谁是获胜者（5.3节），或者可以从该状态开始快速模拟至博弈结束，再取多次模拟结果的平均值（5.4节）。
chap2_para778,1,,5.5节讨论了包含机会因素（通过掷骰子或洗牌）的博弈，5.6节讨论了不完美信息（imperfect information）博弈（如扑克和桥牌，即并非所有牌对所有玩家都可见）。
chap2_para78,1,"The distinction between known and unknown environments is not the same as the one between fully and partially observable environments. It is quite possible for a known environment to be partially observable—for example, in solitaire card games, I know the rules but am still unable to see the cards that have not yet been turned over. Conversely, an unknown environment can be fully observable—in a new video game, the screen may show the entire game state but I still don’t know what the buttons do until I try them.",离散的（discrete）与连续的（continuous）：离散/连续的区别适用于环境的状态、处理时间的方式以及智能体的感知和动作。
chap2_para78,2,,例如，国际象棋环境具有有限数量的不同状态（不包括时钟）。
chap2_para78,3,,国际象棋也有一组离散的感知和动作。
chap2_para78,4,,驾驶出租车是一个连续状态和连续时间的问题，出租车和其他车辆的速度和位置是一系列连续的值，并随着时间平稳地变化。
chap2_para78,5,,出租车的驾驶动作也是连续的（转向角等）。
chap2_para78,6,,严格来说，来自数字照相机的输入是离散的，但通常被视为表示连续变化的强度和位置。
chap2_para780,1,,人工智能领域中最常研究的博弈（例如国际象棋和围棋）是博弈论学者所称的确定性、双人、轮流、完美信息（perfect information）的零和博弈（zero-sum game）。
chap2_para780,2,,“完美信息”是“完全可观测”的同义词[2]，“零和”意味着对一方有利的东西将对另一方同等程度有害：不存在“双赢”结果。
chap2_para780,3,,在博弈论中，我们通常用移动（move）作为“动作”（action）的同义词，用局面（position）作为“状态”（state）的同义词。
chap2_para782,1,,[2]　对应英文player在博弈论中为“参与者”，但在本书中不同语境下会根据具体情况使用参与者、玩家、选手等。
chap2_para782,2,,——译者注
chap2_para783,1,,我们将两个参与者[3]分别称为max和min，这么命名的原因稍后解释。
chap2_para783,2,,max先移动，然后两个参与者轮流移动，直到博弈结束。
chap2_para783,3,,博弈结束时，获胜者得分，而失败者受到惩罚。
chap2_para783,4,,可以使用以下元素对博弈进行形式化定义。
chap2_para785,1,,[3]　一些作者对此进行了区分，用“不完美信息博弈”指扑克之类的游戏，其中玩家将获得其他玩家没有的关于自己手牌的私人信息，而用“部分可观测博弈”指《星际争霸II》之类的游戏，其中每个玩家可以看到其附近的环境，但看不到远处的环境。
chap2_para786,1,,● S0：初始状态，指定博弈开始时如何设置。
chap2_para787,1,,● To-Move(s)：在状态s下，轮到其移动的参与者。
chap2_para788,1,,● Actions(s)：在状态s下，全体合法移动的集合
chap2_para789,1,,"● Result(s, a)：转移模型，定义状态s下执行动作a所产生的结果状态。"
chap2_para79,1,"As noted on page 57, the performance measure itself may be unknown, either because the designer is not sure how to write it down correctly or because the ultimate user—whose preferences matter—is not known. For example, a taxi driver usually won’t know whether a new passenger prefers a leisurely or speedy journey, a cautious or aggressive driving style. A virtual personal assistant starts out knowing nothing about the personal preferences of its new owner. In such cases, the agent may learn more about the performance measure based on further interactions with the designer or user. This, in turn, suggests that the task environment is necessarily viewed as a multiagent environment.",已知的（known）与未知的（unknown）：严格来说，这种区别不是指环境本身，而是指智能体（或设计者）对环境“物理定律”的认知状态。
chap2_para79,2,,在已知环境中，所有行动的结果（如果环境是非确定性的，则对应结果的概率）都是既定的。
chap2_para79,3,,显然，如果环境未知，智能体将不得不了解它是如何工作的，才能做出正确的决策。
chap2_para790,1,,● Is-Terminal(s)：终止测试（terminal test），博弈结束时返回真，否则返回假。
chap2_para790,2,,博弈结束时的状态称为终止状态（terminal state）。
chap2_para791,1,,"● Utility(s, p)：效用函数（也称为目标函数或收益函数），定义博弈结束时终止状态s下参与者p得到的最终的数值收益。"
chap2_para791,2,,在国际象棋中，结果为赢、输或平局，收益分别为1、0或1/2。
chap2_para791,3,,[4]一些博弈存在更大范围的可能结果，例如，西洋双陆棋的收益范围为0～192。
chap2_para793,1,,[4]　国际象棋被认为是一种“零和”游戏，尽管两个选手每局游戏的结果之和为+1，而不是0。
chap2_para793,2,,“常量和”是一个更准确的术语，但“零和”更传统，你可以将其看作每个选手被收取了1/2的入场费。
chap2_para794,1,,同第3章一样，初始状态、Actions函数和Result函数定义了状态空间图（state space graph）——在图中，顶点表示状态，边表示移动，一个状态可以通过多条路径到达。
chap2_para794,2,,如第3章所述，我们可以在图的一部分上叠加搜索树（search tree）以确定下一步移动。
chap2_para794,3,,我们将完整的博弈树（game tree）定义为搜索树，它会记录每个一直到终止状态的移动序列。
chap2_para794,4,,如果状态空间本身是无界的，或者博弈规则允许局面可以无限次重复，那么博弈树可能是无限的。
chap2_para795,1,,图5-1为井字棋（圈叉游戏tic-tac-toe）的部分博弈树。
chap2_para795,2,,从初始状态开始，max有9种可能的移动。
chap2_para795,3,,游戏交替进行，max放x，min放o，直到到达对应于终止状态的叶节点，即一个玩家占据某一行，或者所有方格都被填满。
chap2_para795,4,,每个叶节点上的数字是对max来说该终止状态的效用值，值越高对max越有利，对min越不利（这也是玩家名字的由来）。
chap2_para796,1,,对井字棋来说，博弈树相对较小——不超过9!= 362 880个终止节点（只有5478个不同状态）。
chap2_para796,2,,但是对国际象棋来说，节点数超过1040，所以博弈树被认为是一个在物理世界中无法实现的理论结构。
chap2_para797,1,,图5-1　井字棋的（部分）博弈树。
chap2_para797,2,,最上面的节点是初始状态，max先移动，在某个空位上放一个x。
chap2_para797,3,,我们展示了树的一部分，给出min(o)和max(x)的交替移动，直到最终到达终止状态，根据博弈规则为终止状态分配效用值
chap2_para798,1,,5.2　博弈中的优化决策
chap2_para799,1,,max想要找到通往胜利的动作序列，但min不希望max获胜。
chap2_para799,2,,这意味着max的策略必须是一个条件规划——一个随机应变策略，指定对min的每个可能移动的响应。
chap2_para799,3,,在具有二元结果（赢或输）的博弈中，我们可以使用与或搜索（4.3.2节）生成条件规划。
chap2_para799,4,,事实上，对于这类博弈，博弈的获胜策略的定义与非确定性规划问题的解的定义相同：在这两种情况下，无论“另一方”做什么，都必须保证己方能获得理想结果。
chap2_para799,5,,对于具有多个结果分数的博弈，我们需要一种更一般的算法，即极小化极大搜索。
chap2_para8,1,Figure 2.,可以想象将描述任何给定智能体的智能体函数制成表格。
chap2_para8,2,1Agents interact with environments through sensors and actuators.,对大多数智能体来说，这将是一个非常大的表，事实上是无限的（除非限制考虑的感知序列长度）。
chap2_para8,3,,给定一个要进行实验的智能体，原则上，我们可以通过尝试所有可能的感知序列并记录智能体响应的动作来构建此表[1]。
chap2_para8,4,,当然，该表只是该智能体的外部特征。
chap2_para8,5,,在内部，人工智能体的智能体函数将由智能体程序（agent program）实现。
chap2_para8,6,,区别这两种观点很重要，智能体函数是一种抽象的数学描述，而智能体程序是一个具体的实现，可以在某些物理系统中运行。
chap2_para80,1,"The hardest case is partially observable, multiagent, nondeterministic, sequential, dynamic, continuous, and unknown. Taxi driving is hard in all these senses, except that the driver’s environment is mostly known. Driving a rented car in a new country with unfamiliar geography, different traffic laws, and nervous passengers is a lot more exciting.",已知和未知环境之间的区别与完全可观测和部分可观测环境之间的区别不同。
chap2_para80,2,,一个已知的环境很可能是部分可观测的，例如，在纸牌游戏中，知道规则但仍然无法看到尚未翻转的牌。
chap2_para80,3,,相反，一个未知环境可以是完全可观测的，如一个全新的电子游戏，屏幕可能会显示整个游戏状态，但在尝试之前并不知道各个按钮的作用。
chap2_para800,1,,考虑图5-2中的简单博弈。
chap2_para800,2,,根节点上max的可能移动被标记为a1、a2和a3。
chap2_para800,3,,min对a1的可能响应为b1、b2、b3等。
chap2_para800,4,,这个特殊游戏在max和min各移动一次后结束。
chap2_para800,5,,（注意，在某些游戏中，“move”一词意味着双方都执行了一次移动，因此，ply一词被用来明确表示一个玩家的一次移动，即我们在博弈树中又深入了一层。
chap2_para800,6,,）博弈中终止状态的效用值范围为2～14。
chap2_para801,1,,图5-2　二层博弈树。
chap2_para801,2,,△节点为“max节点”，即轮到max移动，节点为“min节点”。
chap2_para801,3,,终止节点显示max的效用值，其他节点标记有它们的极小化极大值。
chap2_para801,4,,max在根节点的最佳移动是a1，因为它指向极小化极大值最高的状态，而min的最佳响应是b1，因为它指向极小化极大值最低的状态
chap2_para802,1,,给定博弈树，可以通过计算树中每个状态的极小化极大值（minimax value）确定最优策略，记为Minimax(s)。
chap2_para802,2,,某一状态的极小化极大值是指，假设从该状态到博弈结束两个参与者都以最优策略行动，到达的终止状态对于max的效用值。
chap2_para802,3,,终止状态的极小化极大值就是它的效用值。
chap2_para802,4,,在非终止状态下，轮到max移动时，max倾向于移动到极小化极大值最大的状态，而min倾向于移动到极小化极大值最小的状态（对max来说值最小，因此对min来说值最大）。
chap2_para802,5,,所以有：
chap2_para803,1,,让我们将上述定义应用于图5-2中的博弈树。
chap2_para803,2,,底层的终止节点从Utility函数中获取它们的效用值。
chap2_para803,3,,第一个min节点，标记为B，存在3个后继状态，值分别为3、12和8，因此它的极小化极大值为3。
chap2_para803,4,,类似地，另外两个min节点的极小化极大值都为2。
chap2_para803,5,,根节点为max节点，它的后继状态的极小化极大值分别为3、2和2，因此，它的极小化极大值为3。
chap2_para803,6,,我们还可以在根节点处确定极小化极大决策（minimax decision）：动作a1是max的最优选择，因为它指向极小化极大值最大的状态。
chap2_para804,1,,max的最优策略假设min也是按照最优策略动作。
chap2_para804,2,,如果min不按照最优策略动作呢？
chap2_para804,3,,那么max至少会表现得与它面对最优对手时一样好，甚至可能更好。
chap2_para804,4,,然而，这并不意味着，面对次优对手时选择极小化极大最优移动总是最好的。
chap2_para804,5,,考虑这样一种情况，双方均按照最优策略行动，结果为平局，但max有一种冒险的走法，在这种走法导致的状态下，min有10种可能的响应，这些响应似乎都是合理的，但其中9种都会使min输掉游戏，只有1种会使max输掉游戏。
chap2_para804,6,,如果max认为min没有足够的计算能力找到最优移动，那么max可能会尝试这种冒险的走法，因为9/10的获胜机会要比一个确定的平局好。
chap2_para805,1,,5.2.1　极小化极大搜索算法
chap2_para806,1,,现在我们来计算Minimax(s)，我们可以将其转化为一个搜索算法，即尝试所有动作然后选择其结果状态的Minimax值最大的动作作为max的最佳移动。
chap2_para806,2,,算法如图5-3所示。
chap2_para806,3,,这是一种递归算法，它一直向下进行到叶节点，然后随着递归的展开通过搜索树倒推极小化极大值。
chap2_para806,4,,例如，图5-2中的算法，首先递归到左下角的3个节点，并对它们调用Utility函数，发现它们的值分别为3、12和8。
chap2_para806,5,,然后选择其中的最小值，3，并将其返回，作为节点B的倒推值。
chap2_para806,6,,同理可得，C和D的倒推值都为2。
chap2_para806,7,,最后，我们选择3、2和2中的最大值3作为根节点的倒推值。
chap2_para807,1,,极小化极大算法对博弈树进行完整的深度优先探索。
chap2_para807,2,,如果树的最大深度为m，并且在每个点都有b种合法移动，那么极小化极大算法的时间复杂度为O(bm)。
chap2_para807,3,,对于一次生成所有动作的算法，空间复杂度为O(bm)，对于一次只生成一个动作的算法，空间复杂度为O(m)（见3.4.3节）。
chap2_para807,4,,指数级的复杂度使得Minimax无法应用于复杂博弈。
chap2_para807,5,,例如，国际象棋的分支因子约为35，平均深度约为80层，搜索个状态显然是不可行的。
chap2_para807,6,,然而，Minimax确实是对博弈进行数学分析的基础。
chap2_para807,7,,通过以各种方式近似极小化极大分析，我们可以推导出更实用的算法。
chap2_para808,1,,图5-3　使用极小化极大计算最优移动的算法。
chap2_para808,2,,最优移动是指，在假定对手移动是为了使效用值最小的前提下，使终止状态效用值最大的移动。
chap2_para808,3,,函数Max-Value和Min-Value遍历整个博弈树直到叶节点，以确定每个状态的倒推值以及如何移动以到达该状态
chap2_para809,1,,5.2.2　多人博弈中的最优决策
chap2_para81,1,Figure 2.,如2.2.1节所述，性能度量本身可能是未知的，这可能是因为设计者不确定如何正确地描述，也可能是因为最终用户（其偏好很重要）是未知的。
chap2_para81,2,6 lists the properties of a number of familiar environments.,例如，出租车司机通常不知道新乘客是喜欢悠闲还是快速的旅程，是喜欢谨慎还是激进的驾驶风格。
chap2_para81,3,Note that the properties are not always cut and dried.,虚拟个人助理一开始对新主人的个人喜好一无所知。
chap2_para81,4,"For example, we have listed the medical-diagnosis task as single-agent because the disease process in a patient is not profitably modeled as an agent; but a medical-diagnosis system might also have to deal with recalcitrant patients and skeptical staff, so the environment could have a multiagent aspect.",在这种情况下，智能体可以基于与设计者或用户的进一步交互来了解更多关于性能度量的信息。
chap2_para81,5,"Furthermore, medical diagnosis is episodic if one conceives of the task as selecting a diagnosis given a list of symptoms; the problem is sequential if the task can include proposing a series of tests, evaluating progress over the course of treatment, handling multiple patients, and so on.",继而，这表明，任务环境必须被视为一个多智能体环境。
chap2_para810,1,,许多流行游戏都允许多个玩家参与。
chap2_para810,2,,让我们来看看如何将极小化极大思想推广到多人博弈中。
chap2_para810,3,,从技术角度来看，这很自然，但是也产生了一些有趣的新的概念上的问题。
chap2_para811,1,,首先，我们需要将每个节点的单一值替换为值向量。
chap2_para811,2,,例如，在玩家A、B和C参与的3人博弈中，每个节点都与一个向量相关联。
chap2_para811,3,,对于终止状态，这一向量表示每个玩家各自在该状态得到的效用值。
chap2_para811,4,,（在双人零和博弈中，二元向量可以简化为一个值，因为两个值总是互为相反数。
chap2_para811,5,,）最简单的实现方法是让Utility函数返回效用值向量。
chap2_para812,1,,现在我们要考虑非终止状态。
chap2_para812,2,,考虑图5-4的博弈树中标为X的节点。
chap2_para812,3,,此时，轮到玩家C选择如何移动。
chap2_para812,4,,两种选择产生了效用值向量分别为和的两种终止状态，因为6大于3，所以C应该选择第一种移动。
chap2_para812,5,,这意味着，如果到达状态X，后续的博弈将产生效用值为的终止状态。
chap2_para812,6,,因此，这个向量就是X的倒推值。
chap2_para812,7,,一般地，节点n的倒推值是对在该点进行选择的玩家来说效用值最大的后继状态的效用值向量。
chap2_para813,1,,任何参与多人博弈（如Diplomacy或Settlers of Catan游戏）的参与者都会很快意识到，比起双人博弈，多人博弈要复杂得多。
chap2_para813,2,,多人博弈通常涉及参与者之间的正式或非正式联盟（alliance）。
chap2_para813,3,,联盟会随着博弈的发展建立和瓦解。
chap2_para813,4,,我们如何理解这种行为？
chap2_para813,5,,联盟是多人博弈中每个参与者都按照最优策略行动的自然结果吗？
chap2_para813,6,,事实证明的确如此。
chap2_para814,1,,例如，假设现在A和B处于弱势，而C处于强势。
chap2_para814,2,,那么，对A和B来说，最理想的做法往往是一起攻击C，而不是彼此攻击，以免C对它们逐个消灭。
chap2_para814,3,,这样的话，合作其实产生于纯粹的自私行为。
chap2_para814,4,,当然，一旦C在联合攻击下被削弱，联盟就失去了价值，A或B都有可能违反协议。
chap2_para815,1,,图5-4　三人博弈的博弈树的前三层，3个玩家为A、B、C。
chap2_para815,2,,每个节点都标有3个玩家各自的效用值。
chap2_para815,3,,最佳移动标示在根节点上
chap2_para816,1,,在某些情况下，显式联盟只是将无论如何都会发生的事情具体化。
chap2_para816,2,,而在其他情况下，破坏联盟会被记录为社会污点，所以参与者必须权衡破坏联盟所带来的即时优势和失去信任所造成的长期劣势。
chap2_para816,3,,有关这些复杂问题的更多讨论，详见18.2节。
chap2_para817,1,,如果博弈不是零和博弈，那么在只有两个参与者时，合作也可能发生。
chap2_para817,2,,例如，假设存在一个效用值为的终止状态，并且每个参与者最高的可能效用值也是1000。
chap2_para817,3,,那么最优策略是双方都尽一切可能到达该状态，也就是说，参与者会自动合作以实现共同的期望目标。
chap2_para819,1,,博弈的状态数关于树的深度是指数量级的。
chap2_para819,2,,没有一种算法可以完全消除指数项，但有时可以将它减半，即通过剪枝（见3.5.3节）消除对结果没有影响的树的大部分，从而不需要检查所有状态就能计算出正确的极小化极大决策。
chap2_para819,3,,这种技术称为剪枝（alpha-beta pruning）。
chap2_para82,1,Description The block diagram starts with a block labeled Agent.,最困难的情况是部分可观测的、多智能体的、非确定性的、序贯的、动态的、连续的且未知的。
chap2_para82,2,There are eight blocks inside the Agent block.,驾驶出租车除了驾驶员的环境大多是已知的，在所有其他方面都很难。
chap2_para82,3,"The first block inside the agent block is labeled, What the world is like now.",在一个陌生的国家驾驶租来的汽车，那里有不熟悉的地理环境、不同的交通法规以及焦虑的乘客，这令人更加紧张。
chap2_para82,4,"Arrows from the second, third, and fourth blocks labeled State, How the world evolves, and What my actions do, point to the first block.",
chap2_para82,5,A dashed arow from the first block points back to the state block.,
chap2_para82,6,"A solid arrow from the first block points to the fifth block labeled, What it will be like if I do action ""A"".",
chap2_para82,7,"Arrows from third and fourth blocks labeled, How the world evolves and What my action do, point to fifth block.",
chap2_para82,8,"An arrow from the fifth block points to the sixth block labeled, How happy I will be in such a state.",
chap2_para82,9,An arrow from the seventh block labeled Utility also points to the sixth block.,
chap2_para82,10,"An arrow from the sixth block points to the eighth block labeled, What action I should do now.",
chap2_para82,11,An arrow from the eighth block points to the Actuators.,
chap2_para82,12,"An arrow from the actuators points to the block labeled, Environment, which is outside the agent block.",
chap2_para82,13,An arrow from the environment block points to the sensors in the agent block.,
chap2_para82,14,An arrow from the sensors points back to the first block.,
chap2_para820,1,,再次考虑图5-2中的双层博弈树。
chap2_para820,2,,让我们再进行一次最优决策的计算，这一次要仔细观察在这个过程中的每个点上都获得了什么信息。
chap2_para820,3,,步骤如图5-5所示。
chap2_para820,4,,结果是，我们可以在无须评估其中两个叶节点的情况下就能确定极小化极大决策。
chap2_para821,1,,另一种考虑这一问题的方式是将Minimax公式简化。
chap2_para821,2,,假设图5-5中节点C的两个未评估的后继节点的值分别为x和y，则根节点的值为
chap2_para822,1,,也就是说，根节点的值以及极小化极大决策与叶节点x和y的值无关，因此可以将它们剪枝。
chap2_para823,1,,剪枝可以应用于任何深度的树，而且通常可以将整个子树而不只是叶节点剪枝。
chap2_para823,2,,一般原则是：考虑树中某个位置的节点n（见图5-6），玩家可以选择移动到n。
chap2_para823,3,,如果玩家在树中同一层（如图5-6中的m'）或更上层的任何位置（如图5-6中的m）有更好的选择，那么玩家永远都不愿移动到n。
chap2_para823,4,,所以，一旦我们对n有了足够的了解（通过检查它的某些后继）来得出上述结论，就可以将它剪枝。
chap2_para824,1,,图5-5　图5-2中博弈树的最优决策计算过程。
chap2_para824,2,,每一步都标有每个节点可能的值的范围。
chap2_para824,3,,（a）B下面的第一个叶节点值为3。
chap2_para824,4,,因此，作为min节点，B的值最多为3。
chap2_para824,5,,（b）B下面的第二个叶节点值为12，min将避免移动到该节点，所以B的值仍然最多为3。
chap2_para824,6,,（c）B下面的第三个叶节点值为8，此时我们已经检查完了B的所有后继状态，所以B的值就是3。
chap2_para824,7,,现在我们可以推断根节点的值至少是3，因为max在根节点处有值为3的选择。
chap2_para824,8,,（d）C下面的第一个叶节点值为2。
chap2_para824,9,,因此，作为min节点，C的值最多为2。
chap2_para824,10,,但是我们知道B的值为3，所以max永远不会选择C。
chap2_para824,11,,因此，没有必要再去检查C的其他后继状态。
chap2_para824,12,,这是剪枝的一个实例。
chap2_para824,13,,（e）D下面的第一个叶节点值为14，所以D的值最多为14。
chap2_para824,14,,这仍然高于max的最佳选择（即3），所以我们需要继续探索D的后继状态。
chap2_para824,15,,注意，此时根节点的所有后继都有界，所以根节点的值也最多为14。
chap2_para824,16,,（f）D的第二个后继值为5，所以我们又需要继续探索。
chap2_para824,17,,第三个后继值为2，所以D的值就是2。
chap2_para824,18,,最终，max在根节点处的决策是移动到值为3的节点B
chap2_para825,1,,图5-6　剪枝的一般情况。
chap2_para825,2,,如果对玩家来说m或m'要好于n，那么我们永远都不会在博弈中到达n
chap2_para826,1,,记住，极小化极大搜索是深度优先的，所以在任何时候我们只需考虑树中单个路径上的节点。
chap2_para826,2,,"剪枝得名于Max-Value(state, , )（见图5-7）中的两个额外参数，它们分别是路径上任何位置的倒推值的下界和上界。"
chap2_para827,1,,= 到目前为止，路径上发现的max的任一选择点中最佳（即最大值）选择的值。
chap2_para827,2,,也就是 说， = “至少”。
chap2_para828,1,,= 到目前为止，路径上发现的min的任一选择点中最佳（即最小值）选择的值。
chap2_para828,2,,也就是 说， = “至多”。
chap2_para829,1,,搜索不断更新和的值，并且一旦当前节点的值比此时的（对于max）或（对于min）值更差，就剪掉该节点的剩余分支（即终止递归调用）。
chap2_para829,2,,完整算法如图5-7所示。
chap2_para829,3,,图5-5跟踪了博弈树上的算法进程。
chap2_para83,1,Figure 2.,图2-6列出了许多熟悉环境的属性。
chap2_para83,2,6Examples of task environments and their characteristics.,注意，这些属性并不总是一成不变的。
chap2_para83,3,,例如，因为将患者的患病过程作为智能体建模并不适合，所以我们将医疗诊断任务列为单智能体，但是医疗诊断系统还可能必须应对顽固的病人和多疑的工作人员，因此环境还具有多智能体的方面。
chap2_para83,4,,此外，如果我们将任务设想为根据症状列表进行诊断，那么医疗诊断是回合式的；如果任务包括提出一系列测试、评估治疗过程中的进展、处理多个患者等，那么则是序贯的。
chap2_para830,1,,图5-7　搜索算法。
chap2_para830,2,,注意，这些函数与图5-3中的Minimax-Search函数相同，除了需要维护变量和，以及在值超出边界时截断搜索
chap2_para831,1,,5.2.4　移动顺序
chap2_para832,1,,剪枝的有效性很大程度上依赖于状态的检查顺序。
chap2_para832,2,,例如，在图5-5e和图5-5f中，根本不能剪掉D的任何后继，因为最差的后继（从min的角度来看）是最先生成的。
chap2_para832,3,,如果最先生成D的第三个后继，它的值为2，那么我们就可以剪掉另外两个后继。
chap2_para832,4,,这表明，应该先检查有可能是最佳选择的后继节点。
chap2_para833,1,,如果能够完美地实现这一点，搜索算法只需要检查个节点就能选出最佳移动，而极小化极大算法需要O(bm)。
chap2_para833,2,,这意味着有效分支因子从b变为了，对国际象棋来说，大约从35变为了6。
chap2_para833,3,,换句话说，在相同时间内，拥有完美移动顺序的剪枝可以求解的树的深度大约是极小化极大算法的两倍。
chap2_para833,4,,如果移动顺序随机，对于适当大小的b，需要检查的节点总数约为。
chap2_para833,5,,显然我们现在无法实现完美移动顺序，否则，在这种情况下，可以用排序函数玩一个完美的游戏！
chap2_para833,6,,但通常我们可以非常接近完美。
chap2_para833,7,,对国际象棋来说，一个非常简单的排序函数（例如，先尝试吃子，然后是威胁，再后是前进和后退）就能让检查的节点数减少到不超过最好情况的大约2倍。
chap2_para834,1,,增加动态的移动排序方案，例如先尝试之前发现的最佳移动，能让我们非常接近理论极限。
chap2_para834,2,,“之前”可能指上一次移动（通常面临同样的威胁），也可能来自之前通过迭代加深（见3.4.4节）过程对当前移动的探索。
chap2_para834,3,,首先，搜索一层并根据它们的评估结果记录这些移动的排名。
chap2_para834,4,,然后再深入搜索一层，利用之前的排名指导移动顺序，以此类推。
chap2_para834,5,,由于迭代加深过程而增加的搜索时间可以通过更好的移动顺序来弥补。
chap2_para834,6,,这些最佳移动称为绝招（killer move），首先尝试绝招称为绝招启发式评价函数。
chap2_para835,1,,在3.3.3节中，我们指出通往重复状态的冗余路径会导致搜索代价呈指数级增长，而维护一个先前到达状态的表可以解决这个问题。
chap2_para835,2,,在博弈树搜索中，重复状态的产生是由于换位（transposition）——移动序列的不同排列最终导致相同的局面，这个问题可以通过换位表（transposition table）解决，它将缓存状态的启发式值。
chap2_para836,1,,"例如，假设白方进行了移动w1，而黑方用b1应对，在棋盘的另一边有一个不相关的移动w2，黑方可以用b2应对，我们搜索移动序列[w1, b1, w2, b2]，将其结果状态记为s。"
chap2_para836,2,,在探索了s下面一棵较大的子树之后，我们找到了它的倒推值，并将其存储在换位表中。
chap2_para836,3,,"当我们之后搜索移动序列[w2, b2, w1, b1]时，我们再次到达s，这时我们可以在表中查找它的值而无须重复搜索。"
chap2_para836,4,,在国际象棋中，换位表非常有效，在相同时间内能到达的搜索深度将扩大一倍。
chap2_para837,1,,即使采用剪枝和精巧的移动顺序，极小化极大算法也不适用于国际象棋和围棋这样的游戏，因为在可用时间内仍然有太多状态需要探索。
chap2_para837,2,,"在关于计算机博弈的第一篇论文“Programming a Computer for Playing Chess”（Shannon, 1950）中，克劳德·香农意识到这一问题，并提出了两种策略。"
chap2_para837,3,,A型策略（Type A strategy）考虑搜索树中某一深度的所有可能的移动，然后使用启发式评价函数估计该深度下状态的效用值。
chap2_para837,4,,它探索了树的宽但浅的部分。
chap2_para837,5,,B型策略（Type B strategy）舍弃了那些看起来就很差的移动，“尽可能”走那些更有可能的路线。
chap2_para837,6,,它探索了树的深但窄的部分。
chap2_para838,1,,历史上，大多数国际象棋程序都是A型策略（我们将在5.3节讨论），而围棋程序通常是B型策略（将在5.4节讨论），因为围棋的分支因子要高得多。
chap2_para838,2,,"最近，B型程序在各种游戏中都达到了世界冠军级水平，包括国际象棋（Silver et al., 2018）。"
chap2_para839,1,,5.3　启发式树搜索
chap2_para84,1,"We have not included a “known/unknown” column because, as explained earlier, this is not strictly a property of the environment. For some environments, such as chess and poker, it is quite easy to supply the agent with full knowledge of the rules, but it is nonetheless interesting to consider how an agent might learn to play these games without such knowledge.",图2-6　任务环境的例子及其特征
chap2_para840,1,,为了充分利用有限的计算时间，我们可以提前截断搜索，并对状态应用启发式评价函数，从而有效地将非终止节点转变为终止节点。
chap2_para840,2,,换句话说，我们用Eval函数代替Utility函数，Eval对状态效用值进行估计。
chap2_para840,3,,用截断测试（cutoff test）代替终止测试，对于终止状态，截断测试必定返回真，但是它可以根据搜索深度和当前状态的任意属性自由决定何时终止搜索。
chap2_para840,4,,"这样我们得到了搜索深度d处状态s的启发式极小化极大值的计算公式H-Minimax(s, d)："
chap2_para841,1,,5.3.1　评价函数
chap2_para842,1,,"就像第3章的启发式函数返回到目标距离的估计值一样，启发式评价函数Eval(s, p)向参与者p返回状态s的期望效用的估计值。"
chap2_para842,2,,"对于终止状态，一定是Eval(s, p) = Utility(s, p)，而对于非终止状态，估计值必须介于输和赢之间：。"
chap2_para843,1,,除了满足这些需求之外，一个好的评价函数是由什么组成的？
chap2_para843,2,,首先，计算时间不能太长！
chap2_para843,3,,（重点是加快搜索速度。
chap2_para843,4,,）其次，评价函数应与实际的获胜机会密切相关。
chap2_para843,5,,你可能会对“获胜机会”一词感到疑惑。
chap2_para843,6,,毕竟，国际象棋并不是一种碰运气的游戏：我们确定地知道当前的状态，博弈没有任何随机性；如果双方都没有犯错，结果是预先确定的。
chap2_para843,7,,但是，如果搜索必须在非终止状态截断，那么算法对这些状态的最终结果必然是不确定的（即使这种不确定性可以通过提供无限的计算资源来解决）。
chap2_para844,1,,让我们把这一思想进一步具体化。
chap2_para844,2,,大多数评价函数需要计算状态的各种特征（feature），例如，在国际象棋中，我们将拥有白兵数目、黑兵数目、白后数目、黑后数目等特征。
chap2_para844,3,,这些特征合在一起，定义了状态的各种类别或等价类：同一类别中的状态，对所有特征都具有相同值。
chap2_para844,4,,例如，某一类别包含所有的“两兵对一兵”残局。
chap2_para844,5,,任何给定类别都可能包含一些通往（以完美玩法）胜利的状态，一些通往平局的状态和一些通往失败的状态。
chap2_para845,1,,评价函数不知道到底是处于哪种状态，但它可以返回一个值来估计每个结果的状态比例。
chap2_para845,2,,例如，假设我们的经验表明，在“两兵对一兵”类中，82%的状态通向胜利（效用值+1），2%导致失败（效用值0），16%为平局（效用值1/2）。
chap2_para845,3,,那么，该类别中状态的合理评估为期望值（expected value）：(0.82×+1) + (0.02×0) + (0.16×1/2) = 0.90。
chap2_para845,4,,原则上，可以为每一个状态类确定一个期望值，这样我们就得到了适用于任何状态的评价函数。
chap2_para846,1,,在实践中，这种方法需要分析太多类别，因此需要非常多的经验去估计所有的可能性。
chap2_para846,2,,与上述方法不同，大多数评价函数会分别计算每个特征的数值贡献，将它们结合起来得到总数值。
chap2_para846,3,,几个世纪以来，国际象棋棋手们已经提出了一些使用这一思想评估局面价值的方法。
chap2_para846,4,,例如，国际象棋入门书籍给出了各个棋子的子力价值（material value）估计：兵值1分，马或象值3分，车值5分，后值9分。
chap2_para846,5,,其他特征，如“好的兵阵”和“王的安全”可能值半个兵。
chap2_para846,6,,这些特征值简单地相加即可得到局面的评估值。
chap2_para847,1,,数学上，这种评价函数称为加权线性函数（weighted linear function），因为它可以表示为如下形式：
chap2_para848,1,,其中fi是局面的某一特征（例如“白象数目”），wi是其权重（表明该特征的重要性）。
chap2_para848,2,,权重需要归一化，使总和始终保持在输（0）到赢（+1）的范围内。
chap2_para848,3,,如图5-8a所示，一个兵的确定优势提供了很大的获胜可能性，而3个兵的确定优势则几乎必胜。
chap2_para848,4,,之前提到，评价函数应与实际的获胜机会密切相关，但并不需要线性相关：如果状态s获胜的可能性是状态s'的两倍，并不意味着Eval(s)必须是Eval(s')的两倍，只需要Eval(s) Eval(s')。
chap2_para849,1,,将特征的值相加似乎是合理的，但实际上它涉及一个很强的假设：每个特征的贡献独立于其他特征的值。
chap2_para849,2,,因此，目前的国际象棋和其他游戏程序也会使用特征的非线性组合。
chap2_para849,3,,例如，一对象的价值可能比单个象价值的两倍还要大，并且在残局时，象比之前价值更大，即当移动数这一特征很大或剩余棋子数这一特征很小时。
chap2_para85,1,"The code repository associated with this book (aima.cs.berkeley.edu) includes multiple environment implementations, together with a general-purpose environment simulator for evaluating an agent’s performance. Experiments are often carried out not for a single environment but for many environments drawn from an environment class. For example, to evaluate a taxi driver in simulated traffic, we would want to run many simulations with different traffic, lighting, and weather conditions. We are then interested in the agent’s average performance over the environment class.",因为如前所述，“已知的/未知的”不是严格意义上的环境属性，所以图2-6中没有包含此列。
chap2_para85,2,,对于某些环境，例如国际象棋和扑克，很容易为智能体提供完整的规则知识，但考虑智能体如何在没有这些知识的情况下学会玩这些游戏仍然是有趣的。
chap2_para850,1,,如何得到特征和权重？
chap2_para850,2,,它们不属于国际象棋规则，而是来自人类下棋的经验。
chap2_para850,3,,在没有这种经验的游戏中，评价函数的权重可以通过第22章的机器学习技术来估计。
chap2_para850,4,,将这些技术应用到国际象棋中，结果表明一个象确实相当于大约3个兵，而且似乎几个世纪的人类经验都可以在短短几小时的机器学习中被复制。
chap2_para851,1,,图5-8　两个国际象棋局面，只有右下角车的位置不同。
chap2_para851,2,,在（a）中，黑方有一个马两个兵的优势，这足以取胜。
chap2_para851,3,,在（b）中，白方将吃掉对方的皇后，这几乎是必胜的优势
chap2_para852,1,,5.3.2　截断搜索
chap2_para853,1,,下一步是修改Alpha-Beta-Search，让它在合适的时候调用启发式Eval函数截断搜索。
chap2_para853,2,,我们把图5-7中提到Is-Terminal的两行代码替换为下面这行代码：
chap2_para854,1,,我们还必须记录一些信息，这样在每一次递归调用时可以逐渐增加当前的depth。
chap2_para854,2,,"控制搜索量最直接的方法是设置一个固定的深度限制，这样的话，对所有大于固定深度d的depth（以及所有终止状态），Is-Cutoff(state, depth)都返回true。"
chap2_para854,3,,深度d的选择取决于分配时间内所选择的移动。
chap2_para854,4,,更稳健的方法是使用迭代加深（见第3章）。
chap2_para854,5,,当时间耗尽时，程序将返回最深的已完成搜索所选择的移动。
chap2_para854,6,,如果在每一轮迭代加深中，我们都维护换位表中的条目，那么作为奖励，后续轮次的速度将加快，我们可以使用评估值改进移动顺序。
chap2_para855,1,,由于评价函数只是一种近似，这些简单方法可能导致误差。
chap2_para855,2,,重新考虑象棋中基于子力优势的简单评价函数。
chap2_para855,3,,假设程序搜索到达了深度限制，例如到达图5-8b中的局面，即黑方多了一个马、两个兵。
chap2_para855,4,,程序会将其报告为该状态的启发式值，从而认为该状态很可能导致黑方获胜。
chap2_para855,5,,但其实白方下一步就可以不留退路地吃掉黑方的皇后。
chap2_para855,6,,因此，这个局面实际上对白方有利，但这只有通过向前看才能知道。
chap2_para856,1,,评价函数只能应用于静态（quiescent）局面，也就是说，在这些局面中不存在会使评估值大幅度摇摆变化的待定移动（例如吃掉皇后）。
chap2_para856,2,,对于非静态局面，Is-Cutoff将返回false，并继续搜索直到到达静态局面。
chap2_para856,3,,这种额外的静态搜索（quiescence search）有时会被进一步限制为只考虑特定类型的移动（例如吃子），它能快速消除当前局面的不确定性。
chap2_para857,1,,视野效应（horizon effect）则更难消除。
chap2_para857,2,,它是指程序面临一个将给我方造成严重损失而且基本无法避免的对方移动，但可以使用拖延战术暂时避开。
chap2_para857,3,,考虑图5-9中的国际象棋局面。
chap2_para857,4,,很明显，黑象已经无路可逃。
chap2_para857,5,,例如，白车可以通过依次移动到h1、a1、a2吃掉黑象，在第6步完成吃子。
chap2_para858,1,,但黑方确实可以采取一系列移动，将象被吃掉这一结果推向“视野”以外。
chap2_para858,2,,假设黑方搜索深度为8层。
chap2_para858,3,,黑方的大多数出招都会导致象最终被吃掉，因此被标记为“坏招”。
chap2_para858,4,,但黑棋也会考虑这样的移动序列，即先用兵来阻挡王，引诱王去吃兵。
chap2_para858,5,,然后黑方可以同样地处理第二个兵。
chap2_para858,6,,上述过程占用了太多步，在剩余的搜索步数内，象不会被吃掉。
chap2_para858,7,,黑方自认为这一策略用两个兵保住了象，但实际上它所做的只是白白浪费了兵，象被吃掉是不可避免的，只是被推到了黑方能搜索到的视野之外。
chap2_para859,1,,缓解视野效应的一种策略是允许单步延伸（singular extension），该策略是说，即使搜索本应在此状态截断，但是，如果在给定局面中有比其他所有移动都“明显更好”的一种移动，我们就允许算法继续沿着这个移动延伸搜索。
chap2_para859,2,,在我们的例子中，搜索将发现白车的3次移动——h2到h1，h1到a1，从a1吃掉a2处的象——依次都是明显更好的移动，因此，即使兵的某个移动序列将搜索推到视野之外，这些明显更好的移动将有机会被延伸搜索。
chap2_para859,3,,这会使树变得更深，但由于单步延伸通常很少，这一策略并不会增加很多节点，在实践中，它已被证明是有效的。
chap2_para86,1,2.,与本书相关的代码库包括多个环境实现以及用于评估智能体性能的通用环境模拟器。
chap2_para86,2,4The Structure of Agents,实验通常不是针对单个环境进行的，而是针对从环境类（environment class）中抽象的许多环境进行的。
chap2_para86,3,,例如，要在模拟交通中评估出租车司机，我们需要运行具有不同的交通状况、照明和天气条件的多次模拟。
chap2_para86,4,,我们关注智能体在环境类上的平均性能。
chap2_para860,1,,图5-9　视野效应。
chap2_para860,2,,黑方移动后，黑象注定难逃厄运。
chap2_para860,3,,但是黑方可以用兵来阻挡白方的王，引诱王去吃掉兵。
chap2_para860,4,,这会将不可避免的象的损失推到视野之外，因此，搜索算法将牺牲兵的这一步看作“好招”
chap2_para861,1,,5.3.3　前向剪枝
chap2_para862,1,,剪枝将剪掉对最终评估没有影响的树的分支，但前向剪枝（forward pruning）将剪掉那些看上去很糟糕但也可能实际很好的移动。
chap2_para862,2,,因此，这一策略以出错风险增大的代价节省了计算时间。
chap2_para862,3,,用香农的话说，这是B型策略。
chap2_para862,4,,显然，大多数人类棋手都会这么做，仅考虑每个局面的几步移动（至少是潜意识地）。
chap2_para863,1,,前向剪枝的一种方法是束搜索（见4.1.3节）：在每一层，只考虑一“束”n个最佳移动（根据评价函数），而不是所有可能的移动。
chap2_para863,2,,遗憾的是，这种方法相当危险，因为无法保证最佳移动不被剪枝。
chap2_para864,1,,"ProbCut（概率截断，probabilistic cut）算法（Buro, 1995）是搜索的前向剪枝版本，它使用从先前经验中获得的统计数据来减少最佳移动被剪除的概率。"
chap2_para864,2,,搜索将剪除所有可证明位于当前窗口之外的节点。
chap2_para864,3,,ProbCut算法则剪除有可能位于窗口之外的节点。
chap2_para864,4,,它通过执行浅层搜索计算某个节点的倒推值v，然后利用过去的经验估计树中深度为d的节点的值v位于范围之外的可能性。
chap2_para864,5,,布罗（Buro）将这种技术应用到了他的黑白棋程序Logistello，发现即使常规版本的黑白棋程序拥有两倍的可用时间，ProbCut版本依然以64%的获胜率击败了常规版本。
chap2_para865,1,,另一种技术，即后期移动缩减（late move reduction）技术，假设移动顺序已经调整好，因此在可能的移动的列表中后期才出现的移动不太可能是好的移动。
chap2_para865,2,,这一技术没有将后期的移动完全删除，只是减少了搜索这些移动的深度，从而节省了时间。
chap2_para865,3,,如果缩减后的搜索返回的值高于当前值，我们可以重新运行全深度搜索。
chap2_para866,1,,结合本章介绍的所有技术，可以得到一个国际象棋（或其他游戏）程序。
chap2_para866,2,,我们假设，已经实现了一个国际象棋评价函数——一个使用静态搜索的合理截断测试。
chap2_para866,3,,我们还假设，经过几个月的努力，可以在最新的个人计算机上每秒生成并评估大约100万个节点。
chap2_para866,4,,国际象棋的分支因子平均约为35，而355约等于5000万，因此，如果我们使用极小化极大搜索，在大约1分钟的计算时间内只能向前搜索5层。
chap2_para866,5,,按照比赛规则，我们没有足够的时间去搜索第6层。
chap2_para866,6,,平均水平的人类棋手就可以击败这样的程序，因为他们偶尔会向前规划6～8步。
chap2_para867,1,,通过搜索和大型换位表，我们可以向前搜索大约14层，已经到达了专家级水平。
chap2_para867,2,,我们可以将个人计算机换成一台拥有8个GPU的工作站，每秒可以计算超过10亿个节点，但如果要达到大师级水平，还需要一个经过精心调整的评价函数和一个存储残局招式的大型数据库。
chap2_para867,3,,像Stockfish这样的顶级国际象棋程序拥有所有这些功能，它在搜索树中通常能达到超过30的深度，远远超过任何一个人类棋手的能力。
chap2_para868,1,,5.3.4　搜索和查表
chap2_para869,1,,对一个国际象棋程序来说，开局就考虑一个包含10亿个博弈状态的树似乎有些过犹不及：漫长的搜索得出的结论仅仅是将兵放到e4（最常见的第一步）。
chap2_para869,2,,"一个世纪以来，许多国际象棋书籍都介绍了如何下好开局和残局（Tattersall, 1911）。"
chap2_para869,3,,因此，许多游戏程序使用查表而非搜索来处理开局和残局也就不足为奇了
chap2_para87,1,So far we have talked about agents by describing behavior—the action that is performed after any given sequence of percepts. Now we must bite the bullet and talk about how the insides work. The job of AI is to design an agent program that implements the agent function—the mapping from percepts to actions. We assume this program will run on some sort of computing device with physical sensors and actuators—we call this the agent architecture:,2.4　智能体的结构
chap2_para870,1,,对于开局，计算机主要依靠人类的专业知识。
chap2_para870,2,,可以从书中复制人类专家关于如何打好每个开局的最佳建议并将其输入表中供计算机使用。
chap2_para870,3,,此外，计算机还可以从以前玩过的游戏的数据库中收集统计数据，以判断哪种开局最容易取胜。
chap2_para870,4,,最开始的几步可能的局面很少，大多数局面都能存储在表中。
chap2_para870,5,,通常，移动10～15步后，我们会到达一个很少见到的局面，程序必须从查表切换到搜索。
chap2_para871,1,,在游戏接近结束时，可能的局面又变少，因此更容易查表。
chap2_para871,2,,这是计算机的专长：计算机对残局的分析能力远远超过了人类。
chap2_para871,3,,新手玩家按照一些简单的规则就能在王、车对王（KRK）残局中获胜。
chap2_para871,4,,而其他残局，例如王、象、马对王（KBNK），则很难掌握，也不存在简明的策略。
chap2_para872,1,,另外，计算机可以通过生成一种策略完全解决残局问题，这一策略是从每种可能状态到该状态下最佳移动的映射。
chap2_para872,2,,这样计算机就可以在这个表中查到正确移动从而完美完成棋局。
chap2_para872,3,,这个表由逆向（retrograde）极小化极大搜索构建：首先考虑在棋盘上放置KBNK的所有方法。
chap2_para872,4,,有些局面是白方获胜，将它们标为“赢”。
chap2_para872,5,,然后反转国际象棋规则，做逆向移动。
chap2_para872,6,,无论黑方的应对是什么，白方的任何一步最终位于“赢”局面的移动，都标为“赢”。
chap2_para872,7,,继续上述搜索，直到所有可能局面都被解析为赢、输或平局，这样就得到了一个包含所有KBNK残局的准确无误的查询表。
chap2_para872,8,,这种做法不仅适用于KBNK残局，也适用于所有棋子数不超过7的残局，这样的表格包含400万亿个状态。
chap2_para872,9,,棋子数为8的表则包含40 000万亿个状态。
chap2_para873,1,,5.4　蒙特卡罗树搜索
chap2_para874,1,,对围棋来说，启发式树搜索有两个主要缺点：首先，围棋的分支因子开始时为361，这意味着搜索被限制在4～5层。
chap2_para874,2,,其次，很难为围棋定义一个好的评价函数，因为子力价值并不是一个强有力的指标，而且大多数状态直到最后阶段都在不断变化。
chap2_para874,3,,为了应对这两个挑战，现代围棋程序已经放弃了搜索，而是使用一种称为蒙特卡罗树搜索（Monte Carlo tree search，MCTS）的策略。
chap2_para874,4,,[5]
chap2_para876,1,,[5]　“蒙特卡罗”算法是以摩纳哥蒙特卡罗赌场命名的随机算法。
chap2_para877,1,,基本的MCTS策略不使用启发式评价函数。
chap2_para877,2,,相反，状态值是根据从该状态开始的多次完整博奕模拟（simulation）的平均效用值估算的。
chap2_para877,3,,一次模拟（也被称为一个playout或rollout）先为一个参与者选择移动，接着为另一个参与者选择，重复上述操作直到到达某个终止局面。
chap2_para877,4,,这时，博弈规则（而非不可靠的启发式）决定输赢以及比分。
chap2_para877,5,,对于那些只有输赢两种结果的博弈，“平均效用值”为“获胜百分比”。
chap2_para878,1,,在模拟中我们如何选择要采取的移动？
chap2_para878,2,,如果只是随机选择，那么多次模拟之后，我们仅能得到“如果两个参与者都随机选择，那么最佳移动是什么？
chap2_para878,3,,”这一问题的答案。
chap2_para878,4,,对于一些简单游戏，这恰好与“如果两名参与者都玩得很好，那么最佳移动是什么？
chap2_para878,5,,”的答案相同，但对大多数游戏却并非如此。
chap2_para878,6,,为了从模拟中获得有用信息，我们需要一个模拟策略（playout policy），使其偏向于好的行动。
chap2_para878,7,,对围棋和其他游戏来说，人们已经使用神经网络成功地从自我对弈中学习到了模拟策略。
chap2_para878,8,,有时还会根据游戏的不同，使用不同的启发式方法，如国际象棋中的“考虑吃子”，或黑白棋中的“占据角落”。
chap2_para879,1,,给定了模拟策略，我们接下来需要决定两件事：从什么局面开始模拟，以及分配给每个局面多少次模拟？
chap2_para879,2,,最简单的答案是纯蒙特卡罗搜索（pure Monte Carlo search），即从博弈当前状态开始做N次模拟，并记录从当前局面开始哪一种可能移动胜率最高。
chap2_para88,1,agent = architecture + program.,到目前为止，我们通过描述行为（即在任意给定的感知序列之后执行的动作）讨论了智能体。
chap2_para88,2,,现在我们必须迎难而上来讨论智能体内部是如何工作的。
chap2_para88,3,,人工智能的工作是设计一个智能体程序（agent program）实现智能体函数，即从感知到动作的映射。
chap2_para88,4,,假设该程序将运行在某种具有物理传感器和执行器的计算设备上，我们称之为智能体架构（agent architecture）：
chap2_para880,1,,对于一些随机游戏，随着N的增加，这一策略会收敛到最优策略，但对大多数博弈来说，这还不够——我们需要一个选择策略（selection policy），有选择地将计算资源集中在博弈树的重要部分上。
chap2_para880,2,,选择策略需要平衡两个因素以做出更准确的估计：对那些模拟次数很少的状态的探索（exploration），以及对那些在过去的模拟中表现良好的状态的利用（exploitation）。
chap2_para880,3,,（有关探索/利用权衡的更多信息，请参阅17.3节。
chap2_para880,4,,）蒙特卡罗树搜索维护一个搜索树，它在每次迭代（包含以下4个步骤）中不断增长，如图5-10所示。
chap2_para881,1,,图5-10　使用蒙特卡罗树搜索（MCTS）选择移动的算法的一次迭代，该算法使用“应用于树搜索的置信上界”法（UCT）作为选择度量，此时已完成了100次迭代。
chap2_para881,2,,（a）选择移动，沿着树一直向下，到标记为27/35（35次模拟中黑方赢了27次）的叶节点结束。
chap2_para881,3,,（b）扩展所选节点并进行模拟，最终黑方获胜。
chap2_para881,4,,（c）将模拟结果沿树反向传播
chap2_para882,1,,● 选择：从搜索树的根节点开始，选择一个移动（在选择策略的指导下），到达一个后继节点，然后重复该过程，沿着树向下移动到叶节点。
chap2_para882,2,,图5-10a为一棵搜索树，根表示白方刚刚移动的状态，到目前为止，白方已经在100次模拟中赢了37次。
chap2_para882,3,,粗箭头表示黑方选择的移动，在它指向的节点上黑方赢了60/79次。
chap2_para882,4,,这是3种移动中最高的胜率，所以选择它是一次利用。
chap2_para882,5,,但为了探索，选择2/11节点也是合理的——只有11次模拟，该节点的估值仍有很高的不确定性，如果我们获得更多相关信息，它最终可能是最好的。
chap2_para882,6,,继续选择直到到达标有27/35的叶节点。
chap2_para883,1,,● 扩展：我们通过为所选节点生成一个新的子节点的方式增长搜索树，图5-10b中展示了标记为0/0的新节点。
chap2_para883,2,,（一些版本在这一步中会生成多个子节点。
chap2_para883,3,,）
chap2_para884,1,,● 模拟：我们从新生成的子节点开始执行一次模拟，根据模拟策略为两个参与者选择移动。
chap2_para884,2,,这些移动不会记录在搜索树中。
chap2_para884,3,,在图中，模拟结果为黑方获胜。
chap2_para885,1,,● 反向传播：我们现在使用模拟结果自底向上地更新所有搜索树节点。
chap2_para885,2,,因为这次模拟的结果是黑方获胜，所以黑方节点的获胜次数和模拟次数都会增加，27/35变为28/36，60/79变为61/80。
chap2_para885,3,,因为白方失败，其节点只增加模拟次数，所以16/53变为16/54，根节点的37/100变为37/101。
chap2_para886,1,,我们在固定次数的迭代中重复这4个步骤，或者迭代到所分配的时间耗尽，然后返回模拟次数最多的移动。
chap2_para887,1,,一种非常有效的选择策略称为“应用于树搜索的置信上界”，即UCT。
chap2_para887,2,,它根据称为UCB1的置信上界公式对每个可能的移动排序。
chap2_para887,3,,（详见17.3.3节。
chap2_para887,4,,）对节点n来说，公式为
chap2_para888,1,,其中U(n)为经过节点n的所有模拟的总效用值，N(n)是经过节点n的模拟次数，Parent(n)是树中n的父节点。
chap2_para888,2,,因此为利用项，即节点n的平均效用值。
chap2_para888,3,,带有平方根的项是探索项：分母为N(n)，这意味着对只探索过几次的节点来说，这一项的值比较高；分子记录了我们对n的父节点的探索次数，这意味着，如果我们选择n的概率不是0，那么随着计数的增加，探索项会趋于零，最终模拟次数将被分配给平均效用值最高的节点。
chap2_para889,1,,C是一个平衡利用和探索的常数。
chap2_para889,2,,有一种理论认为C应该是，但在实践中，程序员会尝试多个C值，从中选择一个表现最好的。
chap2_para889,3,,（有些程序则使用一些稍微不同的公式。
chap2_para889,4,,例如，AlphaZero增加了一个行动概率项，由根据之前的自我对弈训练得到的神经网络计算。
chap2_para889,5,,）当C = 1.4时，图5-10中60/79节点的UCB1值最高，而当C = 1.5时，2/11节点分值最高。
chap2_para89,1,"Obviously, the program we choose has to be one that is appropriate for the architecture. If the program is going to recommend actions like Walk, the architecture had better have legs. The architecture might be just an ordinary PC, or it might be a robotic car with several onboard computers, cameras, and other sensors. In general, the architecture makes the percepts from the sensors available to the program, runs the program, and feeds the program’s action choices to the actuators as they are generated. Most of this book is about designing agent programs, although Chapters 26 and 27 deal directly with the sensors and actuators.",
chap2_para890,1,,图5-11给出了完整的UCT MCTS算法。
chap2_para890,2,,当迭代终止时，算法返回模拟次数最多的移动。
chap2_para890,3,,你可能认为应该返回平均效用值最高的节点，但算法的思想是获胜65/100次的节点优于获胜2/3次的节点，因为后者有很多不确定性。
chap2_para890,4,,在任何情况下，UCB1公式确保模拟次数最多的节点几乎总是拥有最高的获胜概率，因为随着模拟次数的增加，选择过程将越来越偏向获胜概率。
chap2_para891,1,,图5-11　蒙特卡罗树搜索算法。
chap2_para891,2,,首先，初始化博弈树tree，然后重复Select/Expand/Simulate/Back-Propagate的循环，直到时间耗尽，最后返回指向模拟次数最多的节点的移动
chap2_para892,1,,计算一次模拟结果的时间对博弈树的深度来说是线性的，而不是指数级的，因为在每个选择点上只采用一个移动。
chap2_para892,2,,这样我们就有足够的时间进行多次模拟。
chap2_para892,3,,例如，假设有一个分支因子为32的博弈，博弈平均持续100步。
chap2_para892,4,,如果我们有足够的计算能力可以在执行移动前考虑10亿个博弈状态，那么极小化极大算法可以搜索6层深度，具有完美行动顺序的算法可以搜索12层深度，蒙特卡罗搜索算法可以搜索1000万次模拟。
chap2_para892,5,,哪种方法更好呢？
chap2_para892,6,,这取决于所用的启发式函数与选择策略、模拟策略的准确性的高下。
chap2_para893,1,,传统观点认为，对于围棋这种分支因子非常高（因此搜索不够深）或者很难定义一个好的评价函数的游戏，蒙特卡罗搜索要优于搜索。
chap2_para893,2,,考虑到对手的目标是最小化得分，搜索将选择指向可实现评价函数得分最高的节点的路径。
chap2_para893,3,,因此，如果评价函数不准确，搜索也会不准确。
chap2_para893,4,,对单个节点的错误计算可能导致搜索错误地选择（或避开）指向该节点的路径。
chap2_para893,5,,而蒙特卡罗搜索依赖于多次模拟的聚合，因此不容易受到单次错误的影响。
chap2_para893,6,,我们也可以将MCTS和评价函数结合起来：对一定数量的移动进行模拟，然后截断模拟，并在截断的节点上应用评价函数。
chap2_para894,1,,也可以将搜索和蒙特卡罗搜索结合。
chap2_para894,2,,例如，在可以持续很多步的博弈中，我们可能希望提前终止模拟（early playout termination），即终止持续太多步的模拟，并使用启发式评价函数对其进行评估，或者干脆宣布平局。
chap2_para895,1,,蒙特卡罗搜索可以应用于没有任何经验可以用来定义评价函数的全新博弈。
chap2_para895,2,,只要我们知道博弈规则，蒙特卡罗搜索不需要任何附加信息。
chap2_para895,3,,选择和模拟策略可以充分利用人工制定的专家知识，也可以通过仅仅使用自我对弈训练得到的神经网络来学习好的策略。
chap2_para896,1,,当单步移动可以改变游戏进程时，蒙特卡罗搜索存在缺陷，因为蒙特卡罗搜索的随机性意味着它可能不会考虑这一移动。
chap2_para896,2,,换句话说，蒙特卡罗搜索中的B型剪枝意味着它可能根本没有探索关键路线。
chap2_para896,3,,当博弈状态“明显”是一方或另一方获胜时（根据人类的知识和评价函数），蒙特卡罗搜索也存在缺陷，它仍然需要模拟很多步来验证获胜者。
chap2_para896,4,,长期以来，人们一直认为，在国际象棋等具有较低分支因子和较好评价函数的游戏中，搜索更好。
chap2_para896,5,,但最近，蒙特卡罗方法在国际象棋及其他游戏中也取得了成功。
chap2_para897,1,,模拟未来的行动，观测结果，并根据结果来确定哪些行动是好的，这样的一般思想其实就是一种强化学习思想，我们将在第22章中介绍。
chap2_para899,1,,包含随机因素（例如掷骰子）的随机博弈（stochastic game）使我们更接近现实生活的不可预测性。
chap2_para899,2,,西洋双陆棋是一种典型的运气和技巧相结合的随机游戏。
chap2_para899,3,,在图5-12的西洋双陆棋局面中，黑方掷出“6-5”，有4种可能走法［每种走法将一个棋子向前（顺时针）移动5步，另一个棋子向前移动6步］。
chap2_para9,1,"We use the term percept to refer to the content an agent’s sensors are perceiving. An agent’s percept sequence is the complete history of everything the agent has ever perceived. In general, an agent’s choice of action at any given instant can depend on its built-in knowledge and on the entire percept sequence observed to date, but not on anything it hasn’t perceived. By specifying the agent’s choice of action for every possible percept sequence, we have said more or less everything there is to say about the agent. Mathematically speaking, we say that an agent’s behavior is described by the agent function that maps any given percept sequence to an action.",
chap2_para90,1,2.,显然，我们选择的程序必须是适合相应架构的程序。
chap2_para90,2,4.,如果程序打算推荐步行这样的动作，那么对应的架构最好有腿。
chap2_para90,3,1Agent programs,架构可能只是一台普通PC，也可能是一辆带有多台车载计算机、摄像头和其他传感器的机器人汽车。
chap2_para90,4,,通常，架构使程序可以使用来自传感器的感知，然后运行程序，并将程序生成的动作选择反馈给执行器。
chap2_para90,5,,尽管本书第25章和第26章涉及传感器和执行器，但其余大部分内容都是关于设计智能体程序的。
chap2_para900,1,,图5-12　一个典型的西洋双陆棋局面。
chap2_para900,2,,游戏的目标是把自己的所有棋子移出棋盘。
chap2_para900,3,,黑方向25顺时针移动，白方向0逆时针移动。
chap2_para900,4,,一个棋子可以移动到任何位置，除非那里有多个对方棋子；如果只有一个对方棋子，对方棋子就会被吃掉，然后必须从起点重新开始。
chap2_para900,5,,"图中所示的局面，黑棋已经掷出了6-5，必须从(5−11, 5−10)、(5−11, 19−24)、(5−10, 10−16)和(5−11, 11−16)这4种合法移动中选择，其中符号(5−11, 11−16)表示将一个棋子从位置5移动到位置11，另一个棋子从位置11移动到位置16"
chap2_para901,1,,此时，黑方知道可以走什么棋，但不知道白方会掷出什么，因此也不知道白方的合法移动会是什么。
chap2_para901,2,,这意味着黑方无法构建我们在国际象棋和井字棋中看到的那种标准博弈树。
chap2_para901,3,,西洋双陆棋的博弈树除了max和min节点外，还必须包括机会节点（chance node）。
chap2_para901,4,,机会节点如图5-13中的圆圈所示。
chap2_para901,5,,从每个机会节点引出的分支表示可能掷出的骰子点数，每个分支都标有掷出的点数及其概率。
chap2_para901,6,,两个骰子有36种组合，每一种都是等可能的，但是，因为6-5和5-6是一样的，所以只有21种不同的点数组合。
chap2_para901,7,,6个点数相同的组合（1-1到6-6）的概率都是1/36，即P(1−1) = 1/36。
chap2_para901,8,,其他15种不同组合的概率都是1/18。
chap2_para902,1,,图5-13　西洋双陆棋局面的博弈树图解
chap2_para903,1,,下一步是了解如何做出正确决策。
chap2_para903,2,,显然，我们仍然想选择能够到达最佳局面的那一步棋。
chap2_para903,3,,然而，局面没有明确的极小化极大值。
chap2_para903,4,,我们只能计算局面的期望值（expected value）：机会节点所有可能结果的平均值。
chap2_para904,1,,可以将确定性博弈的极小化极大值推广为包含机会节点的博弈的期望极小化极大值（expectiminimax value）。
chap2_para904,2,,终止节点、max节点和min节点的工作方式与之前完全相同（注意，max和min的合法移动取决于前一个机会节点的掷骰子结果）。
chap2_para904,3,,对于机会节点，我们则计算期望值，即用每个机会动作的概率加权的所有结果的值之和：
chap2_para905,1,,"其中，r表示可能的掷骰子结果（或其他概率事件），而Result(s, r)仍表示状态s，附加了掷骰子结果r。"
chap2_para907,1,,和极小化极大算法一样，可以通过在某点截断搜索并对每个叶节点应用评价函数来近似估计期望极小化极大值。
chap2_para907,2,,有人可能会认为，西洋双陆棋等游戏的评价函数应该与国际象棋的评价函数类似——更好的局面得分更高。
chap2_para907,3,,但事实上，机会节点的存在意味着我们必须更加仔细地定义这些值。
chap2_para908,1,,"图5-14表明：如果评价函数给叶节点分配的值为[1, 2, 3, 4]，那么移动a1是最佳的；如果值为[1, 20, 30, 400]，移动a2是最佳的。"
chap2_para908,2,,因此，如果我们更改一些评估值，即使优先顺序保持不变，程序的选择也会完全不同。
chap2_para909,1,,图5-14　在保持叶节点值排序不变的情况下，不同的叶节点赋值改变了最佳移动
chap2_para91,1,"The agent programs that we design in this book all have the same skeleton: they take the current percept as input from the sensors and return an action to the actuators.5 Notice the difference between the agent program, which takes the current percept as input, and the agent function, which may depend on the entire percept history. The agent program has no choice but to take just the current percept as input because nothing more is available from the environment; if the agent’s actions need to depend on the entire percept sequence, the agent will have to remember the percepts.",2.4.1　智能体程序
chap2_para910,1,,为了避免这一问题，评价函数应该返回获胜概率（对于结果非输或赢的博弈返回的是期望效用值）的正线性变换值。
chap2_para910,2,,这是在不确定性下非常重要和普遍的性质，将在第16章进一步讨论。
chap2_para911,1,,如果程序事先知道游戏接下来的所有掷骰子结果，那么求解有骰子的游戏和求解没有骰子的游戏是一样的，即极小化极大算法的时间复杂度为O(bm)，其中b为分支因子，m为博弈树的最大深度。
chap2_para911,2,,因为期望极小化极大值还要考虑所有可能的掷骰子序列，它的时间复杂度为O(bmnm)，其中n是掷骰子的不同结果的数目。
chap2_para912,1,,即使将搜索深度限制在某个很小的值d内，与极小化极大算法相比，额外代价的存在也使得在大多数机会博弈中向前看很远是不现实的。
chap2_para912,2,,在西洋双陆棋中，n是21，b通常是20左右，但在某些情况下，骰子数翻倍，b可能高达4000。
chap2_para912,3,,我们大概只能搜索3层。
chap2_para913,1,,换一种方式考虑这一问题：搜索的优势在于，在采取最佳玩法的情况下它忽略了那些未来不可能发生的情况。
chap2_para913,2,,因此，它将精力集中于可能发生的情况。
chap2_para913,3,,但在一个每次移动前都要掷两个骰子的游戏中，没有可能的移动序列，即使是最有可能的移动也只在2/36的情况下出现，因为执行移动的前提是，骰子点数是正确的组合从而使该移动合法。
chap2_para913,4,,这是不确定性下的一个普遍问题：可能性急剧增多，制定详细的动作规划变得毫无意义，因为世界可能不会朝你规划的方向发展。
chap2_para914,1,,你可能会想到像剪枝这样的方法也可以应用于包含机会节点的博弈树。
chap2_para914,2,,事实证明的确可以。
chap2_para914,3,,对min和max节点的分析不变，但可以用一点聪明才智对机会节点剪枝。
chap2_para914,4,,考虑图5-13中的机会节点C，以及在计算其子节点时它的值发生了什么变化。
chap2_para914,5,,在我们检查完C的所有子节点之前是否有可能找到C的上界？
chap2_para914,6,,（回想一下，这是剪枝剪除某个节点及其子树时需要的。
chap2_para914,7,,）
chap2_para915,1,,乍一看，这似乎是不可能的，因为C的值是它子节点值的平均，为了计算一组数字的平均值，我们必须查看所有的数字。
chap2_para915,2,,但如果限制效用函数的可能值的范围，那么就可以得到平均值的范围而不需要查看每一个数字。
chap2_para915,3,,例如，假设所有效用值都在−2和+2之间，那么叶节点的值是有界的，反过来，我们就可以在不检查所有子节点的情况下为机会节点的值设置上界。
chap2_para916,1,,在机会节点分支因子较高的博弈中——考虑Yahtzee这样的游戏，即每回合掷5个骰子——你可能要考虑前向剪枝，即采样少数几个可能的机会分支。
chap2_para916,2,,或者，你可能想要完全避免使用评价函数，而选择蒙特卡罗树搜索，其中每次模拟都包含随机掷骰子。
chap2_para917,1,,5.6　部分可观测博弈
chap2_para918,1,,博比·费希尔（Bobby Fischer）认为“国际象棋就是战争”，但国际象棋缺少真实战争的一个主要特征——部分可观测性。
chap2_para918,2,,在《战争之雾》（Fog of War）游戏中，敌人的行踪往往是未知的，除非与他直接接触。
chap2_para918,3,,因此，战争中常常使用侦察兵和间谍来收集信息，用隐匿处和虚张声势来迷惑敌人。
chap2_para919,1,,部分可观测游戏也具有这些特征，因此与前文提到的游戏有本质不同。
chap2_para919,2,,像《星际争霸》这样的电子游戏尤其具有挑战性，因为它是部分可观测、多智能体、非确定性、动态且未知的。
chap2_para92,1,"We describe the agent programs in the simple pseudocode language that is defined in Appendix B. (The online code repository contains implementations in real programming languages.) For example, Figure 2.7 shows a rather trivial agent program that keeps track of the percept sequence and then uses it to index into a table of actions to decide what to do. The table—an example of which is given for the vacuum world in Figure 2.3—represents explicitly the agent function that the agent program embodies. To build a rational agent in this way, we as designers must construct a table that contains the appropriate action for every possible percept sequence.",我们在本书中设计的智能体程序都有相同的框架：它们将当前感知作为传感器的输入，并将动作返回给执行器。
chap2_para92,2,,[5]注意智能体程序（将当前感知作为输入）和智能体函数（可能依赖整个感知历史）之间的差异。
chap2_para92,3,,因为环境中没有其他可用信息，所以智能体程序别无选择，只能将当前感知作为输入。
chap2_para92,4,,如果智能体的动作需要依赖于整个感知序列，那么智能体必须记住历史感知。
chap2_para920,1,,在确定性部分可观测博弈中，关于棋盘状态的不确定性完全来自无法获知对手做出的选择。
chap2_para920,2,,这类博弈包括Battleship（每个玩家战舰的放置位置都对敌人隐藏）和Stratego（棋子的位置已知，但种类隐藏）这样的儿童游戏。
chap2_para920,3,,我们考虑四国军棋（Kriegspiel）游戏，它是国际象棋的部分可观测变体，即完全看不到对方的棋子。
chap2_para920,4,,其他游戏也有部分可观测版本：幻影围棋、幻影井字棋和Screen Shogi。
chap2_para921,1,,5.6.1　四国军棋：部分可观测的国际象棋
chap2_para922,1,,四国军棋的规则如下：白方和黑方各自只能看到自己一方的棋子。
chap2_para922,2,,裁判可以看到所有棋子，他对比赛进行判定并定期向双方宣布。
chap2_para922,3,,首先，白方向裁判提出合法移动（只要位置上没有黑方）。
chap2_para922,4,,如果该位置有黑方占位，裁判会宣布移动“非法”，白方不断向裁判提出下一步的走法，直到找到一个合法移动——在这个过程中也了解到了黑方的位置。
chap2_para923,1,,一旦提出了一个合法移动，裁判会宣布以下一项或多项内容：如果在X处有吃子则宣布“在X上吃子”，如果黑王被将军，则宣布“被D将军”，其中D是将军的方向，可以是“马”“行”“列”“长对角线”或“短对角线”。
chap2_para923,2,,如果黑方被将死或陷入僵局，裁判也会宣布；否则，轮到黑方行棋。
chap2_para924,1,,四国军棋看起来非常难处理，但人类可以很好地掌握它，计算机程序也开始迎头赶上。
chap2_para924,2,,回顾4.4节和图4-14中介绍的信念状态的概念——在给定目前为止所有历史感知的情况下，所有逻辑可能的棋盘状态的集合。
chap2_para924,3,,初始时，白方的信念状态只有一个元素，因为黑方还没有移动。
chap2_para924,4,,白方下了一步且黑方做出应对后，白方的信念状态就包含了20种局面，因为黑方对白方的任意一种开局都存在20种回应。
chap2_para925,1,,在游戏过程中跟踪信念状态正是状态评估问题，4.4.4节中的式（4-6）给出了更新步骤。
chap2_para925,2,,如果我们把对手看作不确定性的来源，那么可以把四国军棋的状态评估直接映射到4.4节的部分可观测的、非确定性的框架中；也就是说，白方所选移动的Results由白方自身移动带来的（可预测）结果和黑方回应给出的不可预测结果组成。
chap2_para925,3,,[6]
chap2_para927,1,,[6]　有时，信念状态会变得非常大以至于无法仅用棋盘状态列表表示，但我们将暂时忽略这个问题，第7章和第8章将介绍大型信念状态的紧凑表示方法。
chap2_para928,1,,给定当前的信念状态，白方可能会问：“我能赢吗？
chap2_para928,2,,”对于部分可观测游戏，策略的概念会发生改变，我们不需要规定如何回应对手的每个可能移动，而是需要规定如何回应玩家可能接收到的每种可能感知序列。
chap2_para929,1,,对四国军棋来说，必胜策略或确保将死（guaranteed checkmate）是指，对于每种可能感知序列和当前信念状态中的每种可能棋盘状态，不管对手如何移动，该策略都会取胜。
chap2_para929,2,,在这种定义下，对手的信念状态无关紧要——即使对手能看到所有棋子，这一策略也必须奏效。
chap2_para929,3,,这大大简化了计算。
chap2_para929,4,,图5-15为KRK（王车对王）残局必胜策略的一部分。
chap2_para929,5,,在这种情况下，黑方只有一个棋子（王），所以可以通过在单个棋盘上标记黑王的所有可能位置来表示白方的信念状态。
chap2_para93,1,Description The block diagram starts with a block labeled Agent.,
chap2_para93,2,There are four blocks inside the Agent block.,
chap2_para93,3,"An arrow labeled, Performance standard, points to a block labeled, Critic.",
chap2_para93,4,"An arrow labeled, feedback, from the Critic block points to a block labeled, Learning element.",
chap2_para93,5,"An arrow labeled, learning goals, from the Learning element block, points to a block labeled, Problem generator.",
chap2_para93,6,"An arrow from the problem generator block points to a block labeled, Performance element.",
chap2_para93,7,"An arrow labeled, changes, from the learning element block points to the performance element block.",
chap2_para93,8,"An arrow labeled, knowledge from the performance element block points back to the Learning element block.",
chap2_para93,9,Another arrow from the performance element block points to the Actuators.,
chap2_para93,10,"An arrow from the actuators points to the block labeled, Environment, which is outside the agent block.",
chap2_para93,11,An arrow from the environment block points to the sensors in the agent block.,
chap2_para93,12,An arrow each from the sensors points to the Performance element and Critic block.,
chap2_para930,1,,如4.4节中所述，可以将一般的与或搜索算法应用于信念状态空间来寻找必胜策略。
chap2_para930,2,,4.4.2节提到的增量信念状态算法通常能在中盘找到深度高达9的必胜策略——这远远超过了大多数人类棋手的能力。
chap2_para931,1,,除确保将死之外，四国军棋还存在一个在完全可观测游戏中毫无意义的全新概念：概率将死（probabilistic checkmate）。
chap2_para931,2,,在信念状态中的每一种棋盘状态下，这种将死都要奏效，而概率一词则来源于获胜玩家移动的随机性。
chap2_para931,3,,要了解它的基本思想，可以考虑只用白王来捉住黑王的问题。
chap2_para931,4,,通过简单地随机移动，白王最终一定会吃掉黑王，这是因为，即使黑王总是设法逃跑，它也不可能永远都猜对正确的逃跑方向。
chap2_para931,5,,在概率论的术语中，这一事件以概率1发生。
chap2_para932,1,,在这种意义上，KBNK残局——王、象、马对王——一定会赢，白方为黑方提供一个无限的随机选择序列，黑方总是会猜错其中一个，因此暴露自己的位置，然后被将死。
chap2_para932,2,,另外，KBBK残局的获胜概率是。
chap2_para932,3,,白方要想获胜，只能移动象（此时这个象不受保护）。
chap2_para932,4,,如果黑方碰巧在正确的位置上并吃掉了象（如果象是受保护的，那么这步棋就是非法的），游戏就会变成平局。
chap2_para932,5,,白方可以在一段很长的序列中随机选择一点来走这步险棋，这样会使减小到一个任意小的常数，但无法将减小到零。
chap2_para933,1,,有时将死策略只对当前信念状态中的某些棋盘状态有效，而对其他状态无效。
chap2_para933,2,,尝试这种策略可能会成功，导致意外将死（accidental checkmate）。
chap2_para933,3,,这里的意外是指，如果黑方刚好在特定的位置，白方不会知道自己将会将死对方。
chap2_para933,4,,（在人类博弈中，大多数将死都是偶然的。
chap2_para933,5,,）这个想法自然引出了一个问题，给定策略有多大可能获胜，这又引出了一个问题，当前信念状态中的每种棋盘状态有多大可能是真正的棋盘状态。
chap2_para934,1,,图5-15　KRK残局必胜策略的一部分，图中为缩减后的棋盘。
chap2_para934,2,,在初始信念状态中，黑王位于3种可能位置之一。
chap2_para934,3,,通过一系列探索移动，该策略将黑王的范围缩小到其中一种。
chap2_para934,4,,将死策略的剩余部分留作习题
chap2_para935,1,,人们的第一倾向可能认为当前信念状态中的所有棋盘状态都是等可能的——但这是错误的。
chap2_para935,2,,例如，考虑黑方走第一步棋后白方的信念状态。
chap2_para935,3,,根据定义（假设黑方遵循最优策略），黑方一定采取了最优移动，所以由次优移动产生的所有棋盘状态的概率应该为零。
chap2_para936,1,,这一论点也不完全正确，因为每个玩家的目标不仅仅是将棋子移动到正确的方格中，还需要最小化对手能掌握的关于自己位置的信息。
chap2_para936,2,,遵循任何可预测的“最优”策略都能为对手提供信息。
chap2_para936,3,,因此，在部分可观测博弈中，最佳玩法需要一定随机性。
chap2_para936,4,,（这也是餐厅卫生检查员进行随机检查的原因。
chap2_para936,5,,）这意味着他们偶尔要选择一些“本质上”较差的移动——但他们能从不可预测性上获益，因为对手不大可能为防御这些移动做好准备。
chap2_para937,1,,从这些考虑来看，似乎只有在给定最优随机策略的情况下，才能计算出当前信念状态中各种棋盘状态的概率；反过来，计算这一策略似乎需要知道棋盘可能处于的各种状态的概率。
chap2_para937,2,,这个难题可以利用博弈论中均衡解的概念解决，我们将在第17章中进一步探讨。
chap2_para937,3,,均衡为每个玩家指定了一个最优随机策略。
chap2_para937,4,,对四国军棋来说，计算均衡的代价太昂贵了。
chap2_para937,5,,目前，一般四国军棋游戏的有效算法设计是一个开放的研究课题。
chap2_para937,6,,大多数系统在自己的信念状态空间中执行有限深度的前瞻搜索，而不考虑对手的信念状态。
chap2_para937,7,,评价函数与完全可观测博弈的评价函数类似，但包含一个新的组成部分，信念状态大小——越小越好！
chap2_para937,8,,我们将在18.2节的博弈论主题下重新讨论部分可观测博弈。
chap2_para938,1,,5.6.2　纸牌游戏
chap2_para939,1,,桥牌、惠斯特牌、红心大战和扑克等纸牌游戏都具有随机的部分可观测性，即无法观测的信息是由随机发牌产生的。
chap2_para94,1,Figure 2.,[5]　智能体程序框架还有其他选择。
chap2_para94,2,7The TABLE-DRIVEN-AGENT program is invoked for each new percept and returns an action each time.,例如，我们可以让智能体程序作为与环境异步运行的协程。
chap2_para94,3,It retains the complete percept sequence in memory.,每个这样的协程都有一个输入和输出端口，并由一个循环组成，该循环读取输入端口的感知，并将动作写到输出端口。
chap2_para940,1,,乍一看，这些纸牌游戏似乎很像掷骰子：纸牌是随机分配的，并且决定了每个玩家的可能移动，但所有的“掷骰子”都发生在游戏的开始！
chap2_para940,2,,尽管将纸牌游戏类比为掷骰子是错误的，但它提出了一种算法：将游戏的开始视为一个机会节点，每一种可能的发牌视为一个结果，然后使用Expectiminimax公式选择最佳移动。
chap2_para940,3,,注意，在这种方法中，唯一的机会节点是根节点；在那之后，游戏则是完全可观测的。
chap2_para940,4,,这种方法有时被称为观测力平均，因为它假设，一旦发牌实际发生，游戏对双方都是完全可观测的。
chap2_para940,5,,尽管这种策略在直观上具有吸引力，但有可能让人误入歧途。
chap2_para940,6,,考虑下面这个故事。
chap2_para941,1,,第一天：道路A通向一桶金子，道路B通向一个岔路口。
chap2_para941,2,,你可以看到，岔路口左转是两桶金子，右转则会撞上一辆公共汽车。
chap2_para942,1,,第二天：道路A通向一桶金子，道路B通向一个岔路口。
chap2_para942,2,,你可以看到，岔路口右转是两桶金子，左转则会撞上一辆公共汽车。
chap2_para943,1,,第三天：道路A通向一桶金子，道路B通向一个岔路口。
chap2_para943,2,,你知道岔路口的一个分支通向两桶金子，另一个分支会撞上一辆公共汽车。
chap2_para943,3,,遗憾地是，你不知道哪个分支通向金子。
chap2_para944,1,,观测力平均会得出以下推论：第一天，B是正确选择；第二天，B也是正确选择；第三天，情况和第一天或第二天一样，所以B仍然是正确选择。
chap2_para945,1,,现在我们可以看出观测力平均为什么会失败：它没有考虑智能体执行行动后所处的信念状态。
chap2_para945,2,,完全忽略信念状态是不可取的，特别是当其中一种可能性是必死时。
chap2_para945,3,,因为它假设每种未来状态都自动成为一个完美知识，观测力方法从不选择那些收集信息的行动（例如图5-15中的第一个移动），也不会选择那些向对手隐藏信息或向同伴提供信息的行动，因为它假定对方已经知道这些信息。
chap2_para945,4,,在扑克游戏中，它永远不会虚张声势（bluff）[7]，因为它假设对手知道自己的牌。
chap2_para945,5,,在第17章中，我们将介绍如何构造算法解决真正的部分可观测决策问题，得到最优均衡策略（见18.2节）。
chap2_para947,1,,[7]　虚张声势——即使自己的手牌很差，也要装作很好——是扑克策略的核心部分。
chap2_para948,1,,尽管存在上述缺陷，观测力平均仍是一个有效策略，通过一些技巧可以使其更好地发挥作用。
chap2_para948,2,,在大多数纸牌游戏中，可能的发牌结果数量都相当大。
chap2_para948,3,,例如，在桥牌中，每个玩家只能看到四手牌中的两手，剩余两手各包含13张牌，所以可能的发牌结果有= 10 400 600种。
chap2_para948,4,,即使求解一种发牌结果也是相当困难的，所以求解1000万种更是不可能的。
chap2_para948,5,,处理这样巨大数目的一种方法是抽象（abstraction）：将相似的手牌视为相同手牌。
chap2_para948,6,,例如，手牌中的A和K非常重要，但是4或5就不那么重要了，可以将其抽象。
chap2_para949,1,,另一种处理方法是前向剪枝：只考虑一个小随机样本（样本数为N），再次计算Expectiminimax得分。
chap2_para949,2,,即使是相当小的N （例如100～1000），这种方法也能提供很好的近似值。
chap2_para949,3,,它也可以应用于确定性博弈，例如四国军棋（在四国军棋中，我们对游戏的可能的状态进行采样，而不是可能的发牌），只要我们有方法估计每个状态的可能性。
chap2_para949,4,,除了搜索整个博弈树，使用深度截断进行启发式搜索也很有帮助。
chap2_para95,1,"It is instructive to consider why the table-driven approach to agent construction is doomed to failure. Let Ƥ be the set of possible percepts and let T be the lifetime of the agent (the total number of percepts it will receive). The lookup table will contain | Ƥ |t entries. Consider the automated taxi: the visual input from a single camera (eight cameras is typical) comes in at the rate of roughly 70 megabytes per second (30 frames per second, 1080 × 720 pixels with 24 bits of color information). This gives a lookup table with over 10600,000,000,000 entries for an hour’s driving. Even the lookup table for chess—a tiny, well-behaved fragment of the real world—has (it turns out) at least 10150 entries. In comparison, the number of atoms in the observable universe is less than 1080. The daunting size of these tables means that (a) no physical agent in this universe will have the space to store the table; (b) the designer would not have time to create the table; and (c) no agent could ever learn all the right table entries from its experience.",我们用附录B中定义的简单伪代码语言描述智能体程序。
chap2_para95,2,,（在线代码库包含真实编程语言的实现。
chap2_para95,3,,）图2-7显示了一个相当简单的智能体程序，它记录感知序列，然后使用它来索引动作表，以决定要执行的动作。
chap2_para95,4,,动作表（如图2-3中给出的真空吸尘器世界示例）明确表示了智能体程序所体现的智能体函数。
chap2_para95,5,,作为设计者，为了以这种方式构建理性智能体，我们必须构造一个表，该表包含每个可能的感知序列所对应的适当动作。
chap2_para950,1,,到目前为止，我们假设每种发牌结果的可能性相等。
chap2_para950,2,,对于惠斯特牌和红心大战，这样的假设是有意义的。
chap2_para950,3,,但是对于桥牌，比赛之前为叫牌阶段，在这个阶段中，每支队伍都会表明它要赢多少。
chap2_para950,4,,由于玩家是根据自己持有的牌出价，因此其他玩家可以了解到每种发牌结果的概率P(s)。
chap2_para950,5,,在决定如何玩这手牌时考虑这一点是很难的，原因就像我们在四国军棋的描述中所提到的：玩家在出价时，可能会尽量最小化传达给对手的信息。
chap2_para951,1,,计算机在扑克牌上的表现已经超出了人类水平。
chap2_para951,2,,在为期20天的无限注德州扑克比赛中，扑克程序Libratus与4位世界顶尖的扑克玩家展开较量，并果断地将他们全部击败。
chap2_para951,3,,因为在扑克中存在很多可能状态，Libratus使用抽象法减少状态空间：它可能会认为手牌AAA72和AAA64是等价的（它们都是“3个A和一些小牌”），并且可能认为赌200美元与赌201美元是一样的。
chap2_para951,4,,但是Libratus也会监视其他玩家，如果它发现他们正在使用抽象法，它会立即做一些额外的计算填补这个漏洞。
chap2_para951,5,,总的来说，它在超级计算机上耗费了2500万CPU小时才取得胜利。
chap2_para952,1,,Libratus的计算开销（以及AlphaZero和其他系统的开销）表明，预算有限的研究人员可能无法达到世界冠军水平。
chap2_para952,2,,从某种程度上来说，这是正确的：就像你不能指望在你的车库里用零部件组装出一辆F1冠军赛车一样，拥有超级计算机或专业硬件（如TPU）是有优势的。
chap2_para952,3,,训练一个系统时尤其如此，但训练也可以通过众包完成。
chap2_para952,4,,例如，开源LeelaZero系统是AlphaZero的复现，它通过志愿参与者计算机上的自我对弈进行训练。
chap2_para952,5,,一旦训练完成，实际比赛中的计算需求是适中的。
chap2_para952,6,,AlphaStar在使用单个GPU的商用台式计算机上赢得了《星际争霸II》比赛，而AlphaZero也可以在这种模式下运行。
chap2_para953,1,,5.7　博弈搜索算法的局限性
chap2_para954,1,,计算复杂博弈中的最优决策是非常困难的，因此所有算法都必须做出一些假设和近似。
chap2_para954,2,,搜索使用启发式评价函数作为近似，而蒙特卡罗搜索计算随机选择的模拟的近似平均值。
chap2_para954,3,,选择哪种算法在一定程度上取决于每种博弈的特征：当分支因子较高或评价函数难以定义时，首选蒙特卡罗搜索。
chap2_para954,4,,但这两种算法都存在其基本的局限性。
chap2_para955,1,,搜索的一个局限性是它容易受到启发式函数的近似误差的影响。
chap2_para955,2,,图5-16为一个二层博弈树，极小化极大搜索会选择右边的分支，因为100 99。
chap2_para955,3,,如果所有的评估值都是精确的，那么这就是正确的选择。
chap2_para955,4,,但假设每个节点的评估值都有一个独立于其他节点的随机分布的误差，其标准差为s。
chap2_para955,5,,当s = 5时，实际上71%的情况下是左侧分支更好，当s = 2时，58%的情况下左侧分支更好（因为在这些情况下，右侧分支的4个叶节点之一可能小于99）。
chap2_para955,6,,如果评价函数中的误差不是独立的，那么发生错误的可能性更大。
chap2_para955,7,,这是很难避免的，因为我们没有一个很好的兄弟节点值之间依赖关系的模型。
chap2_para956,1,,图5-16　启发式极小化极大算法可能出错的二层博弈树
chap2_para957,1,,搜索和蒙特卡罗搜索的第二个局限性是，它们都是设计用于计算合法移动的（边界）值的。
chap2_para957,2,,但有时其中一种移动显然是最佳的（例如，合法移动只有一种），在这种情况下，浪费时间计算它的值是没有意义的——最好是直接选择该移动。
chap2_para957,3,,更好的搜索算法应该使用节点扩展的效用值的思想，选择效用值高的节点扩展，所谓高效用值的节点是指，有可能导致算法发现一个明显更好的移动。
chap2_para957,4,,如果没有一个节点扩展的效用值高于它的代价（从时间上考虑），那么算法应该停止搜索并执行一个移动。
chap2_para957,5,,这不仅适用于存在明显更好移动的情况，也适用于对称情况，在这种情况下，再多的搜索也无法证明一种移动比另一种更好。
chap2_para958,1,,这种关于计算该做什么的推理叫作元推理（metareasoning）（关于推理的推理）。
chap2_para958,2,,它不仅适用于博弈，也适用于任意一种推理。
chap2_para958,3,,所有计算都是为了做出更好的决策，所有计算都有代价，并且都有可能导致决策质量的一定程度上的改进。
chap2_para958,4,,蒙特卡罗搜索的确尝试进行元推理，将资源分配给树中最重要的部分，但不是以最优方式。
chap2_para959,1,,第三个局限性是搜索和蒙特卡罗搜索都是在单步移动的层级上进行所有推理的。
chap2_para959,2,,显然，这与人类玩游戏的方式不同：人类可以在更抽象的层级上进行推理，会考虑更高层级的目标（例如，诱捕对方的后），并使用该目标有选择地生成看似合理的规划。
chap2_para959,3,,在第11章中，我们将学习这种类型的规划，在11.4节中，我们将介绍如何用从抽象表示到具体表示的层次结构进行规划。
chap2_para96,1,"Despite all this, TABLE-DRIVEN-AGENT does do what we want, assuming the table is filled in correctly: it implements the desired agent function.",图2-7　每个新感知都会调用Table-Driven-Agent程序，并且每次返回一个动作。
chap2_para96,2,,它在内存中保留了完整的感知序列
chap2_para960,1,,第四个问题是能否将机器学习融入博弈搜索过程。
chap2_para960,2,,早期的游戏程序依靠人类的专业知识人为制定评价函数、开局库、搜索策略和高效技巧。
chap2_para960,3,,"我们才刚刚开始看到像AlphaZero这样的程序（Silver et al., 2018），它依赖于自我对弈的机器学习，而非人类在特定游戏上的专业知识。"
chap2_para960,4,,我们将从第19章开始深入探讨机器学习。
chap2_para962,1,,我们探讨了各种各样的博弈，以理解什么是最佳玩法以及如何在实际中玩好游戏，还了解了智能体在任意类型的对抗性环境中应该如何行动。
chap2_para962,2,,最重要的思想如下。
chap2_para963,1,,● 博弈可以由初始状态（棋盘如何设置）、每个状态下的合法动作、每个动作的结果、终止测试（说明什么时候博弈结束）以及应用于终止状态表明输赢和最终比分的效用函数定义。
chap2_para964,1,,● 在具有完美信息的离散、确定性、轮流的双人零和博弈中，极小化极大算法可以通过对博弈树的深度优先枚举选出最优移动。
chap2_para965,1,,● 搜索算法可以计算出与极小化极大算法相同的最优移动，通过消除可证明与结果无关的子树来提高效率。
chap2_para966,1,,● 通常，考虑整个博弈树是不可行的（即使是搜索），所以我们需要在某个点截断搜索，然后应用启发式评价函数估计状态的效用值。
chap2_para967,1,,● 蒙特卡罗树搜索（MCTS）则是另一种方法，它不是通过应用启发式函数来评估状态，而是通过将游戏模拟到结束使用游戏规则来判断输赢。
chap2_para967,2,,因为在模拟过程中选择的移动可能不是最优移动，所以这个过程需要重复多次，对结果求平均值作为评估值。
chap2_para968,1,,● 许多游戏程序会预先计算开局和残局的最佳移动表，这样它们就可以直接查表而不用搜索。
chap2_para969,1,,● 机会博弈可以通过期望极小化极大算法（极小化极大算法的扩展）来处理，该算法通过计算所有子节点的平均效用值并按每个子节点的概率加权来估计机会节点的平均效用值。
chap2_para97,1,"The key challenge for AI is to find out how to write programs that, to the extent possible, produce rational behavior from a smallish program rather than from a vast table.",表驱动的智能体构建方法注定失败，深入思考这一问题会很有启发性。
chap2_para97,2,,设为可能的感知集，T为智能体的生存期（对应它将接收的感知总数），查找表将包含条记录。
chap2_para97,3,,考虑自动驾驶出租车：来自单个摄像头（通常是8个摄像头）的视觉输入速度约为70 MB/s（每秒30帧，每帧1080 像素× 720像素，每个像素包含24位颜色信息），驾驶1小时后，将会生成一张超过10600 000 000 000条记录的表。
chap2_para97,4,,即使是作为真实世界中微小的、表现良好的片段的国际象棋，其查找表也至少有10150条记录。
chap2_para97,5,,相比之下，可观测宇宙中的原子数量少于1080个。
chap2_para97,6,,这些表的巨大规模意味着：（a）这个宇宙中没有任何物理智能体有空间存储表；（b）设计者没有时间创建表；（c）任何智能体都无法从其经验中学习所有正确的记录。
chap2_para970,1,,● 在不完美信息博弈中，例如四国军棋和扑克，最佳玩法需要对每个玩家当前和将来的信念状态进行推理。
chap2_para970,2,,可以通过对缺失信息的每种可能配置上的动作值取平均得到一个简单的近似。
chap2_para971,1,,● 在国际象棋、跳棋、黑白棋、围棋、扑克及许多其他游戏中，程序已经彻底击败了人类冠军选手。
chap2_para971,2,,在一些不完美信息博弈中人类仍然保持优势，如桥牌和四国军棋。
chap2_para971,3,,在像《星际争霸》和《刀塔2》这样的电子游戏中，程序可以与人类专家媲美，但它们的成功可能一部分要归功于它们可以快速执行许多动作的能力。
chap2_para974,1,,第6章　约束满足问题
chap2_para975,1,,在本章中，我们不把状态仅仅当作小黑盒，从而导出新的搜索方法和对问题结构的更深入理解。
chap2_para976,1,,第3章和第4章讨论了通过搜索状态空间进行问题求解的思想：状态空间是一个由节点表示状态，边表示动作的图。
chap2_para976,2,,我们看到，领域特定的启发式算法可以估计从给定状态到达目标的代价，但从搜索算法的角度来看，每个状态都是原子的，即不可分割的——一个没有内部结构的黑盒。
chap2_para976,3,,对于每个问题，我们需要领域特定的代码来描述状态之间的转移。
chap2_para977,1,,在本章中，我们通过对每个状态使用因子化表示（factored representation）来打破黑盒：因子化表示为一组变量，每个变量都有自己的值。
chap2_para977,2,,当每个变量的值都满足对该变量的所有约束时，问题就解决了。
chap2_para977,3,,以上述方式描述的问题称为约束满足问题（constraint satisfaction problem，CSP）。
chap2_para978,1,,CSP搜索算法利用了状态结构的优势，并且使用通用的而不是领域特定的启发式算法来求解复杂问题。
chap2_para978,2,,其主要思想是，通过识别违反约束的变量/值组合来一次性消除大部分搜索空间。
chap2_para978,3,,CSP的另一个优势是可以从问题描述中推导出行动和转移模型。
chap2_para979,1,,6.1　定义约束满足问题
chap2_para98,1,"We have many examples showing that this can be done successfully in other areas: for example, the huge tables of square roots used by engineers and schoolchildren prior to the 1970s have now been replaced by a five-line program for Newton’s method running on electronic calculators. The question is, can AI do for general intelligent behavior what Newton did for square roots? We believe the answer is yes.",尽管如此，假设表填充正确，Table-Driven-Agent确实做了我们想要做的事情：它实现了所需的智能体函数。
chap2_para980,1,,约束满足问题由3个部分组成，即X、D和C。
chap2_para982,1,,● D是域集合，，每个变量有一个域。
chap2_para983,1,,● C是约束集合，用来规定允许的值的组合。
chap2_para984,1,,域Di，由变量Xi的一组允许的值组成。
chap2_para984,2,,例如，布尔变量的域为。
chap2_para984,3,,不同变量可以有不同大小的域。
chap2_para984,4,,每个约束Cj由对组成，其中scope是该约束中的变量元组，而rel定义了这些值应该满足的关系（relation）。
chap2_para984,5,,关系可以表示为满足约束的所有元组值的显式集合，或者表示为判断一个元组是否为关系成员的函数。
chap2_para984,6,,"例如，如果X1和X2的域都是{1, 2, 3}，那么约束“X1必须大于X2”可以表示为或。"
chap2_para985,1,,CSP要处理变量赋值（assignment）问题，即。
chap2_para985,2,,不违反任何约束的赋值称为一致（consistent）或合法赋值。
chap2_para985,3,,完整赋值（complete assignment）是指每个变量都已被赋值；CSP的解（solution）是一致完整赋值。
chap2_para985,4,,部分赋值（partial assignment）是指某些变量还未赋值，而部分解（partial solution）是一致部分赋值。
chap2_para985,5,,一般来说，CSP求解是NP完全问题，尽管CSP的一些重要子类已经可以非常高效地求解。
chap2_para986,1,,6.1.1　问题示例：地图着色
chap2_para987,1,,也许你已经逛够了罗马尼亚，现在来看看澳大利亚地图（如图6-1a所示）[1]，地图显示了澳大利亚的州和地区，分别是：西澳大利亚州（Western Australia）、北部地区（North Territory）、昆士兰州（Queensland）、新南威尔士州（New South Wales）、维多利亚州（Victoria）、南澳大利亚州（South Australia）、塔斯马尼亚州（Tasmania）、澳大利亚首都直辖区（Australia Capital Territory）。
chap2_para987,2,,我们的任务是给每个区域涂上红色、绿色或蓝色，要求相邻的两个区域颜色不能相同。
chap2_para987,3,,[2]为了将其形式化为CSP，我们将图中的区域定义为变量，变量名为各区域的英文名缩写：
chap2_para989,1,,[1]　本图系原书原图。
chap2_para99,1,"In the remainder of this section, we outline four basic kinds of agent programs that embody the principles underlying almost all intelligent systems:",人工智能面临的关键挑战是找出编写程序的方法，尽可能从一个小程序而不是从一个大表中产生理性行为。
chap2_para990,1,,[2]　本书未将澳大利亚首都直辖区作为一个待着色区域，这使该地图着色问题更简洁明晰。
chap2_para990,2,,——编者注
chap2_para991,1,,每个变量的域为集合。
chap2_para991,2,,约束要求相邻区域颜色不同。
chap2_para991,3,,由于相邻区域的边界线有9段，所以有9个约束：
chap2_para992,1,,这里我们使用缩写。
chap2_para992,2,,是的缩写，其中可以依次完整枚举为：
chap2_para993,1,,这个问题有很多可能的解，例如：
chap2_para994,1,,将CSP可视化为约束图（constraint graph）非常有用，如图6-1b所示。
chap2_para994,2,,图的节点对应于问题的变量，图的边连接同一约束中的任意两个变量。
chap2_para995,1,,为什么要将问题形式化为CSP呢？
chap2_para995,2,,第一个原因是CSP可以自然地表示各种问题，将一个问题形式化为CSP通常很容易；第二个原因是多年的研究工作使得CSP求解器快速而高效；第三个原因是相比于原子的状态空间搜索器，CSP求解器可以快速消除大面积搜索空间。
chap2_para995,3,,例如，一旦我们在澳大利亚问题中选择了，就可以得出结论，它的5个相邻变量都不能取值为blue。
chap2_para995,4,,不使用约束的搜索过程必须考虑这5个相邻变量的35 = 243种赋值；有了约束，我们只需考虑25 = 32种赋值，计算量减少了87%。
chap2_para996,1,,图6-1　（a）澳大利亚的州和地区。
chap2_para996,2,,对该地图着色可以看作约束满足问题（CSP）。
chap2_para996,3,,目标是为每个区域分配颜色，使得相邻区域颜色不同。
chap2_para996,4,,（b）用约束图表示地图着色问题
chap2_para997,1,,在原子的状态空间搜索中，我们只能问：这个特定状态是目标状态吗？
chap2_para997,2,,不是？
chap2_para997,3,,那么这一个呢？
chap2_para997,4,,使用CSP，一旦发现某个部分赋值违反了约束，我们可以马上放弃对该部分赋值的进一步改进。
chap2_para997,5,,此外，我们可以看出为什么某个赋值不是解——可以看出哪些变量违反了约束——从而把注意力集中在关键变量上。
chap2_para997,6,,因此，许多原子状态空间搜索难以求解的问题形式化为CSP后都可以快速求解。
chap2_para998,1,,6.1.2　问题示例：车间作业调度
chap2_para999,1,,工厂有很多日常工作调度问题，要满足各种约束。
chap2_para999,2,,在实践中，使用CSP技术可以求解很多这样的问题。
chap2_para999,3,,考虑汽车装配调度问题。
chap2_para999,4,,整个作业由不同任务组成，我们可以将每个任务建模成一个变量，其中每个变量的值为任务开始时间，由整数分钟数表示。
chap2_para999,5,,约束为“一个任务必须在另一个任务之前完成”（例如，安装车轮必须在安装轮毂盖之前完成）和“一次只能同时执行一定数量的任务”等断言。
chap2_para999,6,,约束还可以指定任务完成所需的时间。
chap3_para1,1,SOLVING PROBLEMS BY SEARCHING,在本章中，我们讨论一个智能体是如何向前搜索，找到一个动作序列来实现它的最终目标。
chap3_para10,1,Description The road map shows the distance in miles between cities.,如果智能体没有额外信息，也就是说，如果环境是未知的（unknown），那么智能体只能随机执行一个动作。
chap3_para10,2,"Neamt to Iasi, 87.",这种情况将在第4章讨论。
chap3_para10,3,"Iasi to Valsui, 92.",在本章中，我们假设智能体总是能够访问与世界相关的信息，例如图3-1中的地图。
chap3_para10,4,"Vaslui to Urziceni, 142.",有了这些信息，智能体可以执行以下4个阶段的问题求解过程。
chap3_para10,5,"Urziceni to Hirsova, 98.",
chap3_para10,6,"Hirsova to Eforie, 86.",
chap3_para10,7,"Urziceni to Bucharest, 85.",
chap3_para10,8,"Bucharest to Giurgiu, 90.",
chap3_para10,9,"Bucharest to Pitesti, 101.",
chap3_para10,10,"Bucharest to Fagaras, 211.",
chap3_para10,11,"Fagaras to Sibiu, 99.",
chap3_para10,12,"Pitesti to Craiova, 138.",
chap3_para10,13,"Pitesti to Rimnicu Vilcea, 97.",
chap3_para10,14,"Rimnicu Vilcea to Sibiu, 80.",
chap3_para10,15,"Sibiu to Oradea, 151.",
chap3_para10,16,"Sibiu to Arad, 140.",
chap3_para10,17,"Arad to Zerind, 75.",
chap3_para10,18,"Zerind to Oradea, 71.",
chap3_para10,19,"Arad to Timisoara, 118.",
chap3_para10,20,"Timisoara to Lugoj, 111.",
chap3_para10,21,"Lugoj to Mehadia, 70.",
chap3_para10,22,"Mehadia to Drobeta, 75.",
chap3_para10,23,"Drobeta to Craiova, 120.",
chap3_para100,1,"•node.PATH-COST: the total cost of the path from the initial state to this node. In mathematical formulas, we use g(node) as a synonym for PATH-COST.",● node.Action：父节点生成该节点时采取的动作。
chap3_para1000,1,,每次调用智能体程序时，程序会做3件事。
chap3_para1000,2,,首先，它告知知识库它所感知到的东西。
chap3_para1000,3,,然后，它询问知识库它应当采取什么动作。
chap3_para1000,4,,在回答这一查询时，可能会对关于世界的当前状态、可能的动作序列的执行结果等进行大量推理。
chap3_para1000,5,,最后，智能体程序告知知识库它选择的动作，并返回这一动作以便执行。
chap3_para1001,1,,表示语言的细节隐藏在3个函数中，这3个函数一方面实现了传感器与执行器之间的接口，另一方面又实现了核心表示与推理系统的接口。
chap3_para1001,2,,Make-Percept-Sentence构建了一个语句，断言智能体在给定时间接收到给定的感知。
chap3_para1001,3,,Make-Action-Query构建了一个语句，询问当前时刻应当采取何种动作。
chap3_para1001,4,,最后，Make-Action-Sentence构建了一个语句，断言选定的动作已经执行。
chap3_para1001,5,,推断机制的细节隐藏在Tell与Ask中。
chap3_para1001,6,,后续章节将阐明这些细节。
chap3_para1002,1,,图7-1所示的基于知识的智能体看起来与第2章所述的具有内部状态的智能体非常相似。
chap3_para1002,2,,而由于Tell和Ask的定义，基于知识的智能体并不仅是普通的用来计算动作的程序。
chap3_para1002,3,,它受到位于知识层面（knowledge level）的描述的操控，我们只需要在知识层面明确智能体所具有的知识和它的目标，就可以决定它的行为。
chap3_para1003,1,,例如，一辆自动驾驶出租车的任务是将一名乘客从旧金山送往马林县，它或许知道金门大桥是两地间的唯一通路。
chap3_para1003,2,,因此，我们可以猜测出租车将驶过金门大桥，因为它知道这样能达成目标。
chap3_para1003,3,,注意，这一分析与出租车在实现层面（implementation level）的工作原理毫无关系。
chap3_para1003,4,,不论它是用链表或点阵图来实现地理知识，还是通过操纵寄存器中的符号串或在神经元网络中传递有噪声的信号来进行推理，都与我们的分析无关。
chap3_para1004,1,,我们可以仅通过告知智能体必需的知识来构建基于知识的智能体。
chap3_para1004,2,,智能体设计者可以从空知识库开始，逐条告知智能体语句，直到它明白如何在它的环境中运作。
chap3_para1004,3,,我们称之为陈述性（declarative）系统构建方法。
chap3_para1004,4,,相对地，过程性（procedural）方法将所需的行为直接编码为程序代码。
chap3_para1004,5,,在20世纪70年代和80年代，两种方法的提倡者进行了激烈的辩论。
chap3_para1004,6,,我们现在明白，成功的智能体在设计中常常需要将陈述性和过程性这两种方法的元素结合起来，而陈述性的知识也往往能够被编译成更有效的过程性代码。
chap3_para1005,1,,我们还可以给基于知识的智能体赋予自主学习的机制，我们将在第19章讲解的这些机制。
chap3_para1005,2,,智能体能够利用这些机制从一系列感知中创建关于环境的一般知识。
chap3_para1005,3,,进行学习的智能体可以是完全自主的。
chap3_para1006,1,,7.2　wumpus世界
chap3_para1007,1,,本节我们将描述一个能够体现基于知识的智能体的价值的环境。
chap3_para1007,2,,wumpus世界（wumpus world）是一个洞穴，其中有许多房间，房间之间有走廊连接。
chap3_para1007,3,,在洞穴的某处潜伏着可怕的wumpus，这是一只会吃掉任何进入其房间的人的怪兽。
chap3_para1007,4,,智能体可以射杀wumpus，但智能体只有一支箭。
chap3_para1007,5,,一些房间有无底洞，能困住任何漫游到这些房间中的人（wumpus除外，它体型大得无法落入无底洞）。
chap3_para1007,6,,这个阴森环境的唯一回报是可能找到的金块。
chap3_para1007,7,,尽管以现代电子游戏的眼光来看，wumpus世界相当乏味，但它却能展示出智能的一些重要属性。
chap3_para1008,1,,图7-2展示了一个简单的wumpus世界示例。
chap3_para1008,2,,任务环境的精确定义用2.3节所述的PEAS描述法给出。
chap3_para1009,1,,图7-2　一个典型的wumpus世界。
chap3_para1009,2,,智能体位于左下角，面朝东（向右）
chap3_para101,1,Following the PARENT pointers back from a node allows us to recover the states and actions along the path to that node.,● node.Path-Cost：从初始状态到此节点的路径总代价。
chap3_para101,2,Doing this from a goal node gives us the solution.,在数学公式中，一般使用g(node)表示Path-Cost。
chap3_para1010,1,,● 性能度量：带着金块从洞穴爬出+1000，跌入无底洞或被wumpus吞食−1000，每采取一个动作−1，用尽箭支−10。
chap3_para1010,2,,如果智能体死亡或爬出洞穴，游戏结束。
chap3_para1011,1,,● 环境：一个4×4的房间网格，网格四周环绕着围墙。
chap3_para1011,2,,"智能体始终从标为[1, 1]的方格开始，面向东方。"
chap3_para1011,3,,金块和wumpus的位置是根据均匀分布从除了起始方格的所有方格中随机选定的。
chap3_para1011,4,,另外，除起始方格外的每个方格都可能是无底洞，出现的概率为0.2。
chap3_para1012,1,,● 执行器：智能体可以向前（Forward）、左转（TurnLeft）90°和右转（TurnRight）90°。
chap3_para1012,2,,如果智能体进入有活着的wumpus或者有无底洞的方格，它将悲惨地死去。
chap3_para1012,3,,（但进入有死掉的wumpus的方格是安全的，尽管气味会很臭。
chap3_para1012,4,,）如果智能体试图前进并撞到墙，则智能体会原地不动。
chap3_para1012,5,,如果智能体与金块在同一个方格，抓取（Grab）动作可以用于捡起金块。
chap3_para1012,6,,射击（Shoot）动作可以用于向智能体面对的方向笔直地发射一支箭，这支箭会一直飞行，直到它命中wumpus（此时wumpus将被杀死）或击中墙壁。
chap3_para1012,7,,智能体只有一支箭，因此只有第一次射击动作有效。
chap3_para1012,8,,"最后，攀爬（Climb）动作可以用于爬出洞穴，但智能体仅能从方格[1, 1]爬出。"
chap3_para1013,1,,● 传感器：该智能体有5个传感器，每个传感器给出一个单一信息。
chap3_para1014,1,,❏ 在与wumpus直接（非对角）相邻的方格中，智能体会感知到臭味（Stench）。
chap3_para1014,2,,[1]
chap3_para1016,1,,[1]　wumpus所在的方格恐怕也有臭味，但任何进入该方格的智能体在能够进行感知前就会被吞食。
chap3_para1017,1,,❏ 在与无底洞直接相邻的方格中，智能体会感知到微风（Breeze）。
chap3_para1018,1,,❏ 在金块所在的方格中，智能体会感知到闪光（Glitter）。
chap3_para1019,1,,❏ 智能体走向墙壁会感知到碰撞（Bump）。
chap3_para102,1,We need a data structure to store the frontier.,通过从一个节点返回的Parent指针，我们可以复原到达该节点的路径上的状态和动作。
chap3_para102,2,"The appropriate choice is a queue of some kind, because the operations on a frontier are:",从一个目标节点开始复原，我们就可以得到问题的解。
chap3_para1020,1,,❏ 如果wumpus被杀死，它将发出惨叫（Scream），智能体可以在洞穴的任意位置感知到。
chap3_para1021,1,,感知将以由5个符号组成的列表的形式传给智能体程序。
chap3_para1021,2,,"例如，如果有臭味和微风，但没有闪光、碰撞和惨叫，智能体程序将收到[Stench, Breeze, None, None, None]。"
chap3_para1022,1,,我们可以在第2章所述的多个维度上描述wumpus环境。
chap3_para1022,2,,显然，它是确定性的、离散的、静态的且单智能体的。
chap3_para1022,3,,（好在wumpus不移动。
chap3_para1022,4,,）它是序贯的，因为只有采取很多动作后才可能得到奖励。
chap3_para1022,5,,它是部分可观测的，因为状态的一些方面是无法直接感知到的，如智能体的位置、wumpus的健康状况以及是否还有箭支可用。
chap3_para1022,6,,对于无底洞和wumpus的位置，我们可以将其看作状态中没有观测到的部分，在这种情况下，环境的转移模型是完全已知的，找出无底洞和wumpus的位置就能补全智能体对状态的知识；抑或，我们也可以说转移模型本身是未知的，因为智能体不知道哪些向前动作是致命的，在这种情况下，找出无底洞和wumpus的位置能够补全智能体对于转移模型的知识。
chap3_para1023,1,,对于环境中的智能体，主要的挑战是它起初并不知道环境的配置。
chap3_para1023,2,,克服这种无知似乎需要逻辑推理。
chap3_para1023,3,,在wumpus世界的大多数情况中，智能体是有可能安全地拾取金块的。
chap3_para1023,4,,但智能体偶尔也需要在空手而归和冒死寻宝之间做出选择。
chap3_para1023,5,,大约21%的环境是极不公平的，因为这时金块位于无底洞中，或被无底洞包围。
chap3_para1024,1,,我们来看一个基于知识的智能体是如何探索图7-2所示的wumpus世界的环境的。
chap3_para1024,2,,此处使用一种非形式化的知识表示语言，在网格中写下符号来表示（如图7-3和图7-4所示）。
chap3_para1025,1,,图7-3　智能体在wumpus世界迈出的第一步。
chap3_para1025,2,,"（a）在感知到[None, None, None, None, None]后的初始状态。"
chap3_para1025,3,,"（b）在移动到[2, 1]后感知到[None, Breeze, None, None, None]"
chap3_para1026,1,,智能体的初始知识库包括前述的环境规则。
chap3_para1026,2,,"具体来说，智能体知道自己位于[1, 1]且[1, 1]是安全的方格。"
chap3_para1026,3,,"我们在方格[1, 1]中用“A”和“OK”分别进行表示。"
chap3_para1027,1,,"第一个感知是[None, None, None, None, None]，据此智能体可以认定它的相邻方格[1, 2]和[2, 1]是安全的——它们是“OK”的。"
chap3_para1027,2,,图7-3a展示了此时智能体的知识状态。
chap3_para1028,1,,图7-4　智能体运作时的两个后续状态。
chap3_para1028,2,,"（a）回到[1, 1]再移动到[1, 2]后，感知到[Stench, None, None, None, None]。"
chap3_para1028,3,,"（b）来到[2, 2]再移动到[2, 3]，感知到[Stench, Breeze, Glitter, None, None]"
chap3_para1029,1,,一个谨慎的智能体只会移动到它所知的OK方格。
chap3_para1029,2,,"我们假设智能体决定前进到[2, 1]。"
chap3_para1029,3,,"这个智能体在[2, 1]感受到微风（用“B”表示），因此在相邻方格中必然存在无底洞。"
chap3_para1029,4,,"根据游戏规则，无底洞不可能在[1, 1]，因此[2, 2]和[3, 1]其中之一必然有无底洞或二者都有。"
chap3_para1029,5,,图7-3b中的记号“P?”表示这些方格中可能存在无底洞。
chap3_para1029,6,,此时，仅有一个已知的且未访问过的“OK”方格。
chap3_para1029,7,,"因此这个心思缜密的智能体将扭头，回到[1, 1]，然后移步[1, 2]。"
chap3_para103,1,•IS-EMPTY(frontier) returns true only if there are no nodes in the frontier.,我们需要一个数据结构来存储边界。
chap3_para103,2,,一个恰当的选择是某种队列（queue），因为边界上的操作有以下几个。
chap3_para1030,1,,"智能体在[1, 2]感知到臭味，导致知识状态变为图7-4a所示的状况。"
chap3_para1030,2,,"[1, 2]有臭味表明附近肯定有wumpus。"
chap3_para1030,3,,"但根据游戏规则wumpus不可能在[1, 1]，也不在[2, 2]（否则智能体先前在[2, 1]时会探测到臭味）。"
chap3_para1030,4,,"因此，智能体可以推断出wumpus在[1, 3]。"
chap3_para1030,5,,记号“W!”表示这一推断。
chap3_para1030,6,,"而[1, 2]没有微风表明[2, 2]没有无底洞。"
chap3_para1030,7,,"考虑到智能体先前已经推断出[2, 2]或[3, 1]中必然有无底洞，因此无底洞必然位于[3, 1]。"
chap3_para1030,8,,这是一次相当复杂的推断，因为它结合了在不同时间、不同地点获取的信息，并在缺乏感知的情况下迈出了关键的一步。
chap3_para1031,1,,"现在智能体已经证明了[2, 2]中既没有无底洞也没有wumpus，因此可以移动到那里。"
chap3_para1031,2,,"我们没有展示智能体在[2, 2]的知识状态，姑且假设智能体转向并移动到[2,3]，形成了图7-4b所示的情况。"
chap3_para1031,3,,"在[2, 3]中，智能体探测到闪光，因此它应该抓取金块然后回家。"
chap3_para1032,1,,注意，在智能体从可用信息中得出结论的每个情形下，如果可用信息是正确的，则可以保证结论都是正确的。
chap3_para1032,2,,这是逻辑推理的一个重要性质。
chap3_para1032,3,,本章剩余部分将描述如何构建能够表示信息并得出类似前述的结论的逻辑智能体。
chap3_para1034,1,,本节综述逻辑表示和推理的基本概念。
chap3_para1034,2,,这些漂亮的想法独立于逻辑的具体形式。
chap3_para1034,3,,因此，我们将形式的技术细节推后到7.4节介绍，本节代之以熟悉的普通算术问题作为示例。
chap3_para1035,1,,在7.1节，我们说过知识库由语句组成。
chap3_para1035,2,,这些语句是根据表示语言的语法（syntax）表达的，语法规定了所有的合规语句。
chap3_para1035,3,,用简单的算术就能清晰地说明语法这个概念：“x + y = 4”是合规的语句，而“x4y+=”不是。
chap3_para1036,1,,一种逻辑还必须定义语句的语义，或者说语句的含义。
chap3_para1036,2,,语义定义每条语句在每个可能世界中的真值。
chap3_para1036,3,,例如，算术的语义指明“x + y = 4”在一个x为2且y为2的世界为真，但在一个x为1且y为1的世界中为假。
chap3_para1036,4,,在标准的逻辑学中，每个可能世界中的每条语句要么为真，要么为假——没有中间地带。
chap3_para1036,5,,[2]
chap3_para1038,1,,[2]　第13章讨论的模糊逻辑（fuzzy logic）允许存在不同程度的真值。
chap3_para1039,1,,当需要精确描述时，我们用模型来代替“可能世界”。
chap3_para1039,2,,可能世界可以被认为是（潜在的）真实环境，智能体可能在也可能不在其中，而模型是数学抽象，对于每个相关的语句，每个模型都有固定的真值（真或假）。
chap3_para1039,3,,非正式地举个例子：我们可以认为一个可能世界是让x个男士和y个女士坐在一张桌子边上玩桥牌，如果总共有4个人，则语句x+y=4为真。
chap3_para1039,4,,正式地说，可能的模型是对变量x和y进行非负整数赋值的所有可能。
chap3_para1039,5,,每个这样的赋值都确定了任何一个变量为x和y的算术语句的真值。
chap3_para1039,6,,如果语句在模型m中为真，我们说m满足，有时也可以说m是的一个模型。
chap3_para1039,7,,我们使用记号来代表的所有模型的集合。
chap3_para104,1,•POP(frontier) removes the top node from the frontier and returns it.,● Is-Empty( frontier)：返回true当且仅当边界中没有节点。
chap3_para1040,1,,有了真值的概念，我们就可以讨论逻辑推理了。
chap3_para1040,2,,这涉及语句之间的逻辑蕴含（entailment），即一个语句逻辑上引发另一语句。
chap3_para1040,3,,数学上，我们用
chap3_para1041,1,,来表示语句蕴含语句。
chap3_para1041,2,,蕴含的形式化定义是：当且仅当在为真的每个模型中也为真。
chap3_para1041,3,,用刚才介绍的记法，我们可以将其写作
chap3_para1043,1,,（注意此处⊆的方向：若，则是比更强的断言，它排除了更多的可能世界。
chap3_para1043,2,,）蕴含关系用算术来说明会更为亲切一些：我们很容易理解语句x=0蕴含语句xy=0。
chap3_para1043,3,,显然，在任一x为0的模型中，xy也必然为0（而无论y的值是多少）。
chap3_para1044,1,,我们可以将同样的分析应用于7.2节所述的wumpus世界推理的例子。
chap3_para1044,2,,"考虑图7-3b所示的情形：智能体在[1, 1]中什么都没有探测到，在[2, 1]中探测到微风。"
chap3_para1044,3,,这些感知与智能体所具有的wumpus世界规则的知识一同构成了知识库。
chap3_para1044,4,,"智能体所感兴趣的是相邻的方格[1, 2]、[2, 2]和[3, 1]是否有无底洞。"
chap3_para1044,5,,这3个方格中的每一个都可能有或没有无底洞，因此（暂且忽略这个世界的其他方面），总共有23=8个可能的模型。
chap3_para1044,6,,图7-5展示了这8个模型。
chap3_para1044,7,,[3]
chap3_para1046,1,,"[3]　尽管该图用部分wumpus世界来表示模型，但模型实际上只是对类似“[1, 2]中有无底洞”这样的语句进行真或假的赋值。"
chap3_para1046,2,,从数学的角度来看，模型中并不需要有可怕的长毛wumpus。
chap3_para1047,1,,"图7-5　方格[1, 2]、[2, 2]和[3, 1]中无底洞存在性的可能的模型。"
chap3_para1047,2,,"在[1, 1]中没有观测到任何东西且在[2, 1]中观测到微风的知识库用实线表示。"
chap3_para1047,3,,"（a）虚线表示的模型（[1, 2]中没有无底洞）。"
chap3_para1047,4,,"（b）虚线表示的模型（[2, 2]中没有无底洞）"
chap3_para1048,1,,KB可以理解为一个语句的集合，或断言了所有单个语句的单个语句。
chap3_para1048,2,,在与智能体已知相矛盾的模型中，KB为假。
chap3_para1048,3,,"例如，在所有[1, 2]含有无底洞的模型中，KB都为假，因为[1, 1]中没有微风。"
chap3_para1048,4,,实际上，使KB为真的模型只有3个，这些模型在图7-5中用实线包围。
chap3_para1048,5,,我们现在考虑两个可能的结论：
chap3_para1049,1,,"=“[1, 2]中没有无底洞”　=“[2, 2]中没有无底洞”"
chap3_para105,1,•TOP(frontier) returns (but does not remove) the top node of the frontier.,● Pop( frontier)：返回边界中的第一个节点并将它从边界中删除。
chap3_para1050,1,,在图7-5a和图7-5b中分别用虚线包围了和的模型。
chap3_para1050,2,,仔细观察后，我们可以得出
chap3_para1051,1,,在所有KB为真的模型中，也为真
chap3_para1052,1,,"因此，，即[1,2]中没有无底洞。"
chap3_para1052,2,,我们还可以得出
chap3_para1053,1,,在一些KB为真的模型中，为假
chap3_para1054,1,,"因此，KB不蕴含，即智能体无法断定[2,2]中没有无底洞。"
chap3_para1054,2,,"（也无法断定[2,2]中有无底洞。"
chap3_para1054,3,,）[4]
chap3_para1056,1,,"[4]　智能体可以计算[2,2]中有无底洞的概率，第12章将介绍如何计算。"
chap3_para1057,1,,前述的例子不仅阐明了什么是蕴含，还展示了如何用蕴含的定义来推导出结论，即进行逻辑推断。
chap3_para1057,2,,图7-5所示的推断算法被称为模型检验，因为这个示例枚举了所有可能的模型来检验在所有KB为真的模型中都为真，即。
chap3_para1058,1,,将KB的所有推论的集合比作干草堆而将比做一根针或许有助于理解蕴含和推断。
chap3_para1058,2,,蕴含正如草堆中的针一样，而推断就像找到这根针的过程。
chap3_para1058,3,,一些形式化记法体现了这种区别：如果一个推断算法i可以从KB中推导出，则记为
chap3_para1059,1,,读作“是由i从KB中推得的”或“i从KB推得”。
chap3_para106,1,"•ADD(node, frontier) inserts node into its proper place in the queue.",● Top( frontier)：返回（但不删除）边界中的第一个节点。
chap3_para1060,1,,一个仅推导蕴含语句的推断算法被称为是可靠的或保真的。
chap3_para1060,2,,可靠性是极为重要的属性。
chap3_para1060,3,,一个不可靠的推断过程在运作时本质上会编造事实——它会声称发现了并不存在的针。
chap3_para1060,4,,我们很容易看出，模型检验在适用时[5]是一个可靠的程序。
chap3_para1062,1,,[5]　如果模型空间是有限的，则模型检验是有效的，例如，在固定大小的wumpus世界中。
chap3_para1062,2,,而对算术来说，模型空间是无限的：即使我们局限于整数范围，语句x+y=4中x和y的值也是有无限多对的。
chap3_para1063,1,,完备性也是很重要的属性：如果一个推断算法能够推导出所有蕴含的语句，则它是完备的。
chap3_para1063,2,,真正的草堆大小是有限的，对其进行全面仔细的检查就一定能确定针在不在草堆里，这似乎是很显然的道理。
chap3_para1063,3,,然而，对许多知识库来说，推论的草堆是无限的，因而完备性就成了一个重大问题。
chap3_para1063,4,,[6]幸运的是，逻辑学中有完备的推断过程，其表达能力足以处理许多知识库。
chap3_para1065,1,,[6]　比如说，在第3章的无限搜索空间的情形中，深度优先搜索就是不完备的。
chap3_para1066,1,,我们已经描述了一个推理过程，在前提为真的任何世界中都保证结论为真。
chap3_para1066,2,,具体来说，如果KB在真实世界中为真，则用可靠的推断过程从KB中推出的所有语句在真实世界中也为真。
chap3_para1066,3,,因此，当推断过程在“语法”（例如，寄存器中的位或大脑中的电信号模式这样的内部物理结构）上进行操作时，这个过程对应于一个真实世界的关系，即真实世界的某个部分为真是因为真实世界的其他一些部分为真。
chap3_para1066,4,,[7]这种世界与表示的对应如图7-6所示。
chap3_para1068,1,,"[7]　正如路德维希•维特根斯坦（Ludwig Wittgenstein）在其著名的《逻辑哲学论》（Tractatus）（Wittgenstein, 1922）中所述：“世界就是所有为真的一切。"
chap3_para1068,2,,”
chap3_para1069,1,,最后要考虑的问题是落地，也就是逻辑推理过程与智能体所存在的真实环境的联系。
chap3_para1069,2,,尤其是，我们如何知道KB在真实世界中为真？
chap3_para1069,3,,（毕竟KB只是存在于智能体头脑中的“语法”。
chap3_para1069,4,,）这是一个哲学问题，众多的书籍都对此进行了讨论（见第27章）。
chap3_para1069,5,,一个简单的回答是，智能体的传感器创建了这个联系。
chap3_para1069,6,,例如，我们的wumpus世界智能体有嗅觉传感器。
chap3_para1069,7,,一旦有气味，智能体程序就会创建一条合适的语句。
chap3_para1069,8,,因此，一旦这条语句被包含在知识库中，就意味着它在真实世界中也为真。
chap3_para1069,9,,这样，感知语句的含义和真值就是由产生这些语句的感知过程和语句构建过程定义的。
chap3_para1069,10,,那么智能体知识的其他部分呢？
chap3_para1069,11,,例如，它对于“wumpus相邻的方格有臭味”这件事的信念呢？
chap3_para1069,12,,这不是单个感知的直接表示，而是一项一般规则，它可能是从感知的经验推导出的，却与经验陈述并不完全相同。
chap3_para1069,13,,这种一般规则是通过被称为学习的语句构建过程产生的，这是第五部分的主题。
chap3_para1069,14,,学习是难免会出错的。
chap3_para1069,15,,一种可能的情况是，wumpus有臭味但闰年2月29日这一天除外，因为这一天它要洗澡。
chap3_para1069,16,,因此，KB在真实世界中可能并不为真，但因为有很好的学习过程，我们对此就有理由乐观。
chap3_para107,1,Three kinds of queues are used in search algorithms:,"● Add(node, frontier)：将节点插入队列中的适当位置。"
chap3_para1070,1,,图7-6　语句是智能体的物理结构，而推理是从旧结构构建新结构的过程。
chap3_para1070,2,,逻辑推理应当确保新结构所表示的部分世界确实能够从旧结构所表示的部分世界推得
chap3_para1071,1,,7.4　命题逻辑：一种非常简单的逻辑
chap3_para1072,1,,本节讲解命题逻辑（propositional logic）。
chap3_para1072,2,,我们将阐述其语法（即语句的结构）和语义（确定语句真值的方法）。
chap3_para1072,3,,由此，我们将推导出一个简单的、语法的逻辑推断算法，它能够实现蕴含的语义概念。
chap3_para1072,4,,当然，这一切都仍将发生在wumpus世界中。
chap3_para1074,1,,命题逻辑的语法定义合法的语句。
chap3_para1074,2,,原子语句（atomic sentence）由单个命题符号（proposition symbol）构成。
chap3_para1074,3,,每个这样的符号代表一个为真或假的命题。
chap3_para1074,4,,"我们使用以大写字母开头的、可能包含其他字母或下标的符号来表示，例如P、Q、R、W1,3以及FacingEast等。"
chap3_para1074,5,,"我们可以任意地进行命名，但通常选择一些有助记功能的名字，例如，使用W1,3代表“wumpus位于[1, 3]”。"
chap3_para1074,6,,"请记住，像W1,3这样的符号是原子的，也就是说分开的W、1、3并非符号的有意义的部分。"
chap3_para1074,7,,）有两个命题符号有固定的含义：True是永真命题，False是永假命题。
chap3_para1074,8,,使用括号和被称作逻辑联结词（logical connective）的运算符可以将简单语句构造成复合语句（complex sentence）。
chap3_para1074,9,,常用的联结词有5个。
chap3_para1075,1,,● （非）。
chap3_para1075,2,,"类似这样的语句称为W1,3的否定。"
chap3_para1075,3,,一个文字要么是原子语句，即正文字，要么是原子语句的否定，即负文字。
chap3_para1076,1,,● ∧（与）。
chap3_para1076,2,,主要联结词是∧的语句称为合取式，例如，其各部分称为合取子句。
chap3_para1076,3,,（∧看起来像是“And”中的“A”。
chap3_para1076,4,,）
chap3_para1077,1,,● ∨（或）。
chap3_para1077,2,,"主要联结词是∨的语句称为析取式，例如，其各部分为析取子句，本例中分别为和W2,2。"
chap3_para1078,1,,● （蕴涵）。
chap3_para1078,2,,如这样的语句称为蕴涵式（implication）或条件式，其前提（premise）或前件（antecedent）是，其结论（conclusion）或后件（consequent）是。
chap3_para1078,3,,蕴涵式也被称为规则（rule）或if-then声明。
chap3_para1078,4,,有时，蕴涵符号在一些书籍中写作或。
chap3_para1079,1,,● （当且仅当）。
chap3_para1079,2,,语句是双向蕴涵式（biconditional）。
chap3_para108,1,"•A priority queue first pops the node with the minimum cost according to some evaluation function, f. It is used in best-first search.",搜索算法使用了3种不同类型的队列。
chap3_para1080,1,,图7-7给出了命题逻辑的形式文法。
chap3_para1080,2,,［附录B将会介绍巴克斯-诺尔范式（Backus-Naur form，BNF）的概念。
chap3_para1080,3,,］我们在BNF文法上附加了运算符优先级，以避免在使用多个运算符时出现歧义。
chap3_para1080,4,,“非”运算符的优先级最高，这意味着在语句中，的结合力更强，因此它等价于而不是。
chap3_para1080,5,,（这与普通算术一样：−2+4等于2而不是−6。
chap3_para1080,6,,）我们也会适时地使用圆括号和方括号来明确语句结构，以改善可读性。
chap3_para1081,1,,图7-7　命题逻辑中语句的BNF文法以及从高到低排列的运算符优先级
chap3_para1083,1,,了解了命题逻辑的语法后，我们来说明其语义。
chap3_para1083,2,,语义定义了用于判定特定模型中语句真值的规则。
chap3_para1083,3,,命题逻辑中，模型就是对每个命题符号设定真值，即真（true）或假（false）。
chap3_para1083,4,,"例如，如果知识库中的语句使用了命题符号P1,2、P2,2和P3,1，则一个可能模型为"
chap3_para1084,1,,由于含有3个命题符号，因此有23=8种可能的模型，与图7-5所示的完全相同。
chap3_para1084,2,,但要注意，这些模型是纯粹的数学对象，不必与wumpus世界有关。
chap3_para1084,3,,"P1,2只是符号，它可能代表“[1, 2]中有无底洞”，也可能代表“我今天和明天都在巴黎”。"
chap3_para1085,1,,命题逻辑的语义必须指定在给定模型下如何计算任一语句的真值。
chap3_para1085,2,,这是以递归的方式实现的。
chap3_para1085,3,,所有语句都是由原子语句和5个联结词构建的。
chap3_para1085,4,,因此，我们需要指定如何计算原子语句的真值和用5个联结词构建的语句的真值。
chap3_para1085,5,,对原子语句来说这很简单。
chap3_para1086,1,,● true在每个模型里都为真，false在每个模型里都为假。
chap3_para1087,1,,● 其余命题符号的真值必须在模型中直接指定。
chap3_para1087,2,,"例如，在先前给出的模型m1中，P1,2为假。"
chap3_para1088,1,,对于复合语句，有5条规则，它们对任一模型m中的任一子句P和Q（原子语句或复合语句）都成立。
chap3_para1089,1,,● 为真，当且仅当在m中P为假。
chap3_para109,1,•A FIFO queue or first-in-first-out queue first pops the node that was added to the queue first; we shall see it is used in breadth-first search.,● 优先队列（priority queue）首先弹出根据评价函数f计算得到的代价最小的节点。
chap3_para109,2,,它被用于最佳优先搜索。
chap3_para1090,1,,● 为真，当且仅当在m中P和Q都为真。
chap3_para1091,1,,● 为真，当且仅当在m中P或Q中至少一个为真。
chap3_para1092,1,,● 为真，除非在m中P为真而Q为假。
chap3_para1093,1,,● 为真，当且仅当在m中P和Q都为真或都为假。
chap3_para1094,1,,这些规则也可以用真值表表示。
chap3_para1094,2,,真值表指明在对复合语句的组成部分进行每种可能的真值赋值后，该复合语句的真值。
chap3_para1094,3,,图7-8给出了5个联结词的真值表。
chap3_para1094,4,,任一语句s关于任一模型m的真值都可以用简单的递归求值来计算。
chap3_para1094,5,,例如，在模型m1中求语句的值，得到。
chap3_para1094,6,,"习题7.TRUV要求写出算法PL-True?(s, m)，用于计算命题逻辑语句s在模型m中的真值。"
chap3_para1095,1,,图7-8　5个逻辑联结词的真值表。
chap3_para1095,2,,若要使用真值表计算在P为真、Q为假时的值，首先在左边找到P为true而Q为false的行（第3行），然后找到该行位于列处的值，得到结果true
chap3_para1096,1,,“与”“或”“非”的真值表与我们对这些词的直观认识非常接近。
chap3_para1096,2,,可能会混淆的关键点是当P为真或Q为真，或者二者同时为真时，为真。
chap3_para1096,3,,而另一个联结词“排他或”（简称“异或”）则会在两个子句都为真时为假。
chap3_para1096,4,,[8]排他或没有公认的符号，有些人选择使用、或者⊕。
chap3_para1098,1,,[8]　在拉丁语中，“或”用两个词表示：“vel”是相容或，“aut”是排他或。
chap3_para1099,1,,⇒的真值表可能不太符合人们对“P蕴涵Q”或“若P则Q”的直观理解。
chap3_para1099,2,,一种解释是，命题逻辑并不要求P和Q之间有任何因果关系或相关性。
chap3_para1099,3,,（在一般的理解下）语句“5是奇数蕴涵东京是日本的首都”是命题逻辑中的真语句，尽管这句话相当奇怪。
chap3_para1099,4,,另一个容易混淆之处在于前件为假的所有蕴涵式都为真。
chap3_para1099,5,,例如，“5是偶数蕴涵Sam很聪明”为真，而不论Sam是否聪明。
chap3_para1099,6,,这似乎很怪异，但如果你将“”当作“如果P为真，则我可以断言Q为真，否则我无法断言”的话，就可以理解了。
chap3_para1099,7,,这条语句为假的唯一情形是当P为真而Q为假时。
chap3_para11,1,Figure 3.,● 目标形式化（goal formulation）：智能体的目标为到达Bucharest。
chap3_para11,2,"1A simplified road map of part of Romania, with road distances in miles.",目标通过限制智能体的目的和需要考虑的动作来组织其行为。
chap3_para110,1,•A LIFO queue or last-in-first-out queue (also known as a stack) pops first the most recently added node; we shall see it is used in depth-first search.,● FIFO队列（FIFO queue），即先进先出队列（first-in-first-out queue），首先弹出最先添加到队列中的节点；它被用于广度优先搜索。
chap3_para1100,1,,当与均为真时，双向蕴涵式为真，英语中常写作“P if and only if Q”（P当且仅当Q）。
chap3_para1100,2,,wumpus世界的大部分规则都可以用很好地表示。
chap3_para1100,3,,例如，当一个方格的相邻方格中有无底洞，该方格有微风，而且，仅当一个方格的某个相邻方格中有无底洞，该方格有微风。
chap3_para1100,4,,因此，我们需要使用双向蕴涵式
chap3_para1101,1,,"其中B1, 1代表[1, 1]有微风。"
chap3_para1102,1,,7.4.3　一个简单的知识库
chap3_para1103,1,,我们已经定义了命题逻辑的语义，现在可以为wumpus世界构建一个知识库了。
chap3_para1103,2,,首先关注wumpus世界的不变部分，后面章节再处理其可变部分。
chap3_para1103,3,,"对于每个位置[x, y]，需要用到下列符号："
chap3_para1104,1,,"当[x, y]有无底洞，Px, y为真。"
chap3_para1105,1,,"当wumpus在[x, y]，不论其死活Wx, y都为真。"
chap3_para1106,1,,"当[x, y]有微风，Bx, y为真。"
chap3_para1107,1,,"当[x, y]处有臭味，Sx, y为真。"
chap3_para1108,1,,"当智能体位于位置[x, y]，Lx, y为真。"
chap3_para1109,1,,"我们写下的语句将足以推得（[1, 2]中没有无底洞），正如7.3节用非形式化的方法所做的那样。"
chap3_para1109,2,,我们用Ri代表每个语句，以便推导。
chap3_para111,1,The reached states can be stored as a lookup table (e.,● LIFO队列（LIFO queue），即后进先出队列（last-in-first-out queue），也称为栈（stack），首先弹出最近添加的节点；它被用于深度优先搜索。
chap3_para111,2,g.,
chap3_para111,3,a hash table) where each key is a state and each value is the node for that state.,
chap3_para1110,1,,"● [1, 1]中没有无底洞："
chap3_para1111,1,,● 一个方格有微风，当且仅当其相邻方格中有无底洞。
chap3_para1111,2,,必须对每个方格都进行这样的表示，在此我们只写出相关方格的表示：
chap3_para1112,1,,● 上述语句在所有wumpus世界中都为真。
chap3_para1112,2,,我们现在为智能体在这个特定世界中已访问过的前两个方格引入微风感知，以形成图7-3b所示的情形：
chap3_para1113,1,,7.4.4　一个简单的推断过程
chap3_para1114,1,,我们现在的目标是确定对于一些语句，是否成立。
chap3_para1114,2,,例如，我们的KB是否蕴含？
chap3_para1114,3,,我们的第一个推理算法是模型检验方法，它直接实现了蕴含的定义：枚举所有模型，检验在KB为真的每个模型中是否为真。
chap3_para1114,4,,模型是对每个命题符号进行真或假的赋值。
chap3_para1114,5,,"回到例子中的wumpus世界，它涉及的命题符号是B1, 1、B2, 1、P1, 1、P1, 2、P2, 1、P2, 2和P3, 1。"
chap3_para1114,6,,在有7个符号的情况下，总共有27=128个可能的模型，KB在其中3个模型中为真（如图7-9所示）。
chap3_para1114,7,,"在这3个模型中，为真，因此[1, 2]中没有无底洞。"
chap3_para1114,8,,"但是，在3个模型中，P2, 2在其中两个模型中为真，在另一个模型中为假，因此我们还无法确定[2, 2]中是否有无底洞。"
chap3_para1115,1,,图7-9以更准确的形式再现了图7-5所示的推理。
chap3_para1115,2,,图7-10描述了一个确定命题逻辑中蕴含关系的通用算法。
chap3_para1115,3,,与6.3节所示的Backtracking-Search算法类似，TT-Entails?在符号赋值的有限空间中进行递归枚举。
chap3_para1115,4,,这个算法是可靠的，因为它直接实现了蕴含的定义；这个算法也是完备的，因为它对所有KB和都适用，并且算法最后都会终止——因为需要检验的模型数量是有限的。
chap3_para1116,1,,图7-9　根据文中所述的知识库构建的真值表。
chap3_para1116,2,,如果从R1到R5都为true，则KB为true。
chap3_para1116,3,,这种情况在全部128行中只出现了3次（在最右侧的列中用下划线标出）。
chap3_para1116,4,,"在这3行中，P1, 2均为false，因此[1, 2]中没有无底洞。"
chap3_para1116,5,,"但是，[2, 2]中可能有（也可能没有）无底洞"
chap3_para1117,1,,图7-10　用于确定命题蕴含的真值表枚举算法（TT代表真值表）。
chap3_para1117,2,,当语句在一个模型中成立，PL-True?返回true。
chap3_para1117,3,,变量model代表部分模型——对于部分符号的赋值。
chap3_para1117,4,,此处的关键字and不是命题逻辑中的运算符，而是伪代码编程语言中的中缀；如果其两个参数中的任意一个为true，则返回true
chap3_para1118,1,,当然，“有限数量”并不总是等同于“少量”。
chap3_para1118,2,,如果KB和总共含有n个符号，那么就会有2n个模型。
chap3_para1118,3,,这样，算法的时间复杂性就会达到O(2n)。
chap3_para1118,4,,（空间复杂性仅为O(n)，因为枚举是深度优先的。
chap3_para1118,5,,）在本章稍后部分，我们将展示一个在大多数情况下更高效的算法。
chap3_para1118,6,,遗憾的是，命题蕴含是余NP完全的（即很可能不比NP完全简单，见附录A），因此命题逻辑所有已知推断算法的最坏情况复杂性都是输入规模的指数量级。
chap3_para1119,1,,7.5　命题定理证明
chap3_para112,1,3.,已达状态可以存储为一个查找表（例如，哈希表），其中每个键是一个状态，对应的值是该状态的节点。
chap3_para112,2,3.,
chap3_para112,3,3Redundant paths,
chap3_para1120,1,,至此，我们已经展示了如何用模型检验判定蕴含关系：枚举模型，并验证语句在所有模型中必须成立。
chap3_para1120,2,,本节将展示如何通过定理证明找出蕴含关系。
chap3_para1120,3,,定理证明对知识库中的语句直接应用推断规则，它能够在不检验模型的情况下，构建对所需语句的证明。
chap3_para1120,4,,如果模型的数量很多，但其证明很短，则定理证明会比模型检验更为高效。
chap3_para1121,1,,在深入定理证明算法的细节之前，我们还需要了解一些与蕴含相关的概念。
chap3_para1121,2,,第一个概念是逻辑等价（logical equivalence）：如果两个语句和在相同的模型集合中都为真，则这两个语句逻辑等价，可以写作。
chap3_para1121,3,,（注意，用于对语句进行声明，而则用作语句的一部分。
chap3_para1121,4,,）例如，我们可以很容易地（用真值表）证明与是逻辑等价的。
chap3_para1121,5,,其他逻辑等价见图7-11。
chap3_para1121,6,,这些等价关系在逻辑中扮演的角色与算术恒等式在普通数学中的角色非常相似。
chap3_para1121,7,,等价的另一种定义为“任意两条语句和是等价的，当且仅当它们互相蕴含”：
chap3_para1123,1,,第二个概念是有效性（validity）。
chap3_para1123,2,,如果一条语句在所有模型中都为真，则这条语句是有效的。
chap3_para1123,3,,例如，语句是有效的。
chap3_para1123,4,,有效的语句也被称为重言式（tautology）——它们必然为真。
chap3_para1123,5,,由于语句True在所有模型中都为真，所有有效的语句都逻辑等价于True。
chap3_para1123,6,,有效语句有什么用？
chap3_para1123,7,,从蕴含的定义可以推导出古希腊人早已懂得的演绎定理（deduction theorem）：
chap3_para1124,1,,对于任意语句和，当且仅当语句是有效的。
chap3_para1125,1,,（习题7.DEDU要求对其进行证明。
chap3_para1125,2,,）因此，可以像图7-10所示的推断算法那样，通过检验是否在每个模型中为真来确定是否成立，或者通过证明等价于True来确定是否成立。
chap3_para1125,3,,反过来，演绎定理表明每条有效的蕴涵语句都描述一个合法的推断。
chap3_para1126,1,,图7-11　标准的逻辑等价。
chap3_para1126,2,,符号、、代表任意命题逻辑语句
chap3_para1127,1,,最后一个概念是可满足性（satisfiability）。
chap3_para1127,2,,如果一条语句在某些模型中为真或能够被满足，则这条语句是可满足的。
chap3_para1127,3,,例如，前述的知识库中，是可满足的，因为如图7-9所示，它在3个模型中为真。
chap3_para1127,4,,可以通过枚举可能的模型，直到找出满足语句的模型来验证可满足性。
chap3_para1127,5,,在命题逻辑中确定语句的可满足性的问题——SAT问题——是第一个被证明为NP完全的问题。
chap3_para1127,6,,计算机科学中的许多问题实际上都是可满足性问题。
chap3_para1127,7,,例如，第6章的所有约束满足问题询问约束是否可以通过某种赋值来满足。
chap3_para1128,1,,有效性和可满足性当然是有联系的：是有效的，当且仅当是不可满足的；换言之，是可满足的，当且仅当不是有效的。
chap3_para1128,2,,我们还能得出下述非常有用的结论：
chap3_para1129,1,,当且仅当语句是不可满足的
chap3_para113,1,The search tree shown in Figure 3.,3.3.3　冗余路径
chap3_para113,2,4 (bottom) includes a path from Arad to Sibiu and back to Arad again.,
chap3_para113,3,"We say that Arad is a repeated state in the search tree, generated in this case by a cycle (also known as a loopy path).",
chap3_para113,4,"So even though the state space has only 20 states, the complete search tree is infinite because there is no limit to how often one can traverse a loop.",
chap3_para1130,1,,通过检验的不可满足性，可以从证明，这正是数学证明方法中标准的归谬法（reductio ad absurdum，意为“归结为荒谬之物”）。
chap3_para1130,2,,它也被称为反证法或矛盾法。
chap3_para1130,3,,假设为假，并证明这会导致与已知公理矛盾，这个矛盾的含义与声明语句是不可满足的完全相同。
chap3_para1131,1,,7.5.1　推断与证明
chap3_para1132,1,,本节介绍可以用于推导证明的推断规则。
chap3_para1132,2,,证明是一系列可以引向所需目标的结论。
chap3_para1132,3,,最著名的规则是肯定前件（Modus Ponens，mode that affirms的拉丁语），写作
chap3_para1133,1,,它的意思是，当给出和具有形式的语句时，可以推导出语句。
chap3_para1133,2,,例如，如果给出，并且已知，可以推导出Shoot。
chap3_para1134,1,,另一个有用的推断规则是合取消去（and-elimination），即可以从一个合取式推导出任一合取子句：
chap3_para1135,1,,例如，由，可推导出WumpusAlive。
chap3_para1136,1,,通过考虑和的可能真值，可以证明肯定前件和合取消去是可靠的。
chap3_para1136,2,,这些规则可用于任意适用的实例，不必枚举所有模型就可以生成可靠的推断。
chap3_para1137,1,,图7-11所示的所有逻辑等价都可以用作推断规则。
chap3_para1137,2,,例如，等价消去可以产生两条推断规则：
chap3_para1138,1,,并非所有推断规则都能像上面这样双向适用。
chap3_para1138,2,,例如，不能反向运用肯定前件规则，从得出和。
chap3_para1139,1,,让我们来看看这些推断规则和等价关系是如何应用于wumpus世界的。
chap3_para1139,2,,"我们从含有R1到R5的知识库开始，演示如何证明，即证明[1, 2]中没有无底洞。"
chap3_para114,1,"A cycle is a special case of a redundant path. For example, we can get to Sibiu via the path Arad–Sibiu (140 miles long) or the path Arad–Zerind–Oradea–Sibiu (297 miles long). This second path is redundant—it’s just a worse way to get to the same state—and need not be considered in our quest for optimal paths.",图3-4（最下面一排）所示的搜索树包含了一条从Arad到Sibiu再回到Arad的路径。
chap3_para114,2,,这时我们称Arad为搜索树中的一个重复状态（repeated state），在本例中该重复状态是由循环（cycle）［也称为环路（loopy path）］生成的。
chap3_para114,3,,因此，即使状态空间只有20种状态，完整的搜索树也是无限的，因为遍历循环的频率没有限制。
chap3_para1140,1,,（1）对R2使用等价消去，得到
chap3_para1141,1,,（2）对R6使用合取消去，得到
chap3_para1142,1,,（3）假言易位逻辑等价关系得到
chap3_para1143,1,,（4）对R8和感知R4（即）使用肯定前件，得到
chap3_para1144,1,,（5）使用德摩根律，得到结论
chap3_para1145,1,,"也就是，[1, 2]和[2, 1]都没有无底洞。"
chap3_para1146,1,,应用第3章的任意搜索算法都可以找到构成这种证明的一系列步骤。
chap3_para1146,2,,只需要定义如下的证明问题。
chap3_para1147,1,,● 初始状态（Initial State）：最初的知识库。
chap3_para1148,1,,● 动作（Actions）：动作的集合，它包含所有推断规则应用于所有符合上半部分推断规则的语句。
chap3_para1149,1,,● 结果（Result）：一个动作的结果是将推断规则下半部分的语句实例加入知识库。
chap3_para115,1,"Consider an agent in a 10 × 10 grid world, with the ability to move to any of 8 adjacent squares. If there are no obstacles, the agent can reach any of the 100 squares in 9 moves or fewer. But the number of paths of length 9 is almost 89 (a bit less because of the edges of the grid), or more than 100 million. In other words, the average cell can be reached by over a million redundant paths of length 9, and if we eliminate redundant paths, we can complete a search roughly a million times faster. As the saying goes, algorithms that cannot remember the past are doomed to repeat it. There are three approaches to this issue.",循环是冗余路径（redundant path）的一种特殊情况。
chap3_para115,2,,例如，我们可以通过路径Arad—Sibiu（总长140英里）或路径Arad—Zerind—Oradea—Sibiu（总长297英里）到达Sibiu。
chap3_para115,3,,第二条路径是冗余的——是到达相同状态的一种比较差的方式——在我们寻找最优路径时不需要考虑它。
chap3_para1150,1,,● 目标（Goal）：目标是含有我们试图证明的语句的状态。
chap3_para1151,1,,这样，搜索证明就可以替代枚举模型。
chap3_para1151,2,,在许多实际案例中，找出某种证明的效率更高，因为证明可以忽略许多无关的命题，不论这种命题有多少。
chap3_para1151,3,,"例如，刚才给出的，得出的证明并没有提及命题B2,1、P1,1、P2,2或P3,1。"
chap3_para1151,4,,"由于目标命题P2,1只出现于语句R2，因此可以忽略它们；而R2中的其他命题只出现在R4和R2中，因此R1、R3和R5与证明无关。"
chap3_para1151,5,,即使在知识库中再添加一百万条语句，这一结果依然成立。
chap3_para1151,6,,而简单的真值表算法将无法承受这种模型的指数级爆炸式增长。
chap3_para1152,1,,逻辑系统的最后一个属性是单调性，它表明蕴含的语句集只能随着信息被加入知识库而增长。
chap3_para1152,2,,[9]对于任意语句和，
chap3_para1154,1,,[9]　违反单调性的非单调逻辑刻画了人类推理的常见性质：改变想法。
chap3_para1154,2,,我们将在10.6节对其进行讨论。
chap3_para1156,1,,例如，假设知识库含有额外的断言，它表明世界中恰好有8个无底洞。
chap3_para1156,2,,"这条知识可能有助于智能体得出额外的结论，但它不能使任何已经得出的结论失效，例如[1,2]中没有无底洞这样的结论。"
chap3_para1156,3,,单调性意味着只要在知识库中找到合适的前提，就可以使用推断规则——规则的结论必然是合理的，不论知识库中还有什么东西。
chap3_para1157,1,,7.5.2　通过归结证明
chap3_para1158,1,,我们已经论证了目前所说的推断规则是可靠的，但还没讨论过使用这些规则的推断算法的完备性问题。
chap3_para1158,2,,像迭代加深搜索（3.4.4节）这样的搜索算法能够找到任意的可达目标，从这种意义上说它是完备的；但如果可用的推断规则不充分，则目标是不可达的——仅使用这些推断规则的证明是不存在的。
chap3_para1158,3,,例如，如果去掉等价消去规则，7.5.1节所述的证明就行不通了。
chap3_para1158,4,,本节我们只介绍一个推断规则——归结（resolution），当它与任意完备的搜索算法结合后，可以产生一个完备的推断算法。
chap3_para1159,1,,我们从在wumpus世界使用简单的归结规则入手。
chap3_para1159,2,,"考虑导致图7-4a所示状态的步骤开始：智能体从[2, 1]返回到[1, 1]，然后走到[1, 2]，它在此处感知到臭味，但没有微风。"
chap3_para1159,3,,我们将如下事实添加到知识库中：
chap3_para116,1,"First, we can remember all previously reached states (as best-first search does), allowing us to detect all redundant paths, and keep only the best path to each state.",考虑一个10×10网格世界中的智能体，它能够移动到8个相邻方格中的任何一个。
chap3_para116,2,"This is appropriate for state spaces where there are many redundant paths, and is the preferred choice when the table of reached states will fit in memory.",如果没有障碍，智能体可以在9步或更少的移动内到达100个方格中的任何一个。
chap3_para116,3,,但是长度为9的路径的数量几乎是89（由于网格边缘的存在，路径数稍微少了一点），超过了1亿条。
chap3_para116,4,,也就是说，平均意义下，有超过100万条长度为9的冗余路径到达同一个单元格，如果我们消除了冗余路径，搜索完成的速度可以快大约100万倍。
chap3_para116,5,,俗话说，不记得历史的算法注定要重复历史。
chap3_para116,6,,有3种方法可以解决这一问题。
chap3_para1160,1,,"用先前推得R10时使用的相同步骤，可以推出[2, 2]和[1, 3]中没有无底洞（别忘了已知[1, 1]中没有无底洞）："
chap3_para1161,1,,"还可以对R3使用等价消去，然后对R5使用肯定前件，以得到[1, 1]、[2, 2]或[3, 1]中有无底洞的事实："
chap3_para1162,1,,"现在我们首次运用归结规则：R13中的文字与R15中的文字P2,2归结，得到归结句（resolvent）"
chap3_para1163,1,,"用自然语言描述：如果[1, 1]、[2, 2]或[3, 1]中必有无底洞，而[2, 2]中没有无底洞，则无底洞在[1, 1]或[3, 1]中。"
chap3_para1163,2,,"类似地，R1中的文字与R16中的文字P1,1归结，得到"
chap3_para1164,1,,"用自然语言描述：如果[1, 1]或[3, 1]中有无底洞，无底洞又不在[1, 1]中，则它在[3, 1]中。"
chap3_para1164,2,,最后两步推断采用了单元归结（unit resolution）规则
chap3_para1165,1,,其中每个都是文字，而和m是互补文字（即各自是对方的否定）。
chap3_para1165,2,,这样，单元归结推断规则使用一个子句（文字的析取式）以及一个文字，生成一个新的子句。
chap3_para1165,3,,注意，单个文字可看作是一个文字的析取式，也被称为单元子句。
chap3_para1166,1,,单元归结规则可以推广为全归结规则
chap3_para1167,1,,其中，li和mj是互补文字。
chap3_para1167,2,,这表明归结使用两个子句并产生一个新的子句，该新子句包含除一对互补文字以外的原始子句的所有文字，例如，我们有
chap3_para1168,1,,可以一次只归结一对互补文字。
chap3_para1168,2,,例如，可以归结P和推得
chap3_para1169,1,,但不能同时归结P和Q来推得R。
chap3_para1169,2,,归结规则还有一个技术细节：结果子句只能含有每个文字的一个副本。
chap3_para1169,3,,[10]去除文字的多个副本被称为因子提取。
chap3_para1169,4,,例如，如果我们用归结，得到，通过因子提取简化为A。
chap3_para117,1,"Second, we can not worry about repeating the past. There are some problem formulations where it is rare or impossible for two paths to reach the same state. An example would be an assembly problem where each action adds a part to an evolving assemblage, and there is an ordering of parts so that it is possible to add A and then B, but not B and then A. For those problems, we could save memory space if we don’t track reached states and we don’t check for redundant paths. We call a search algorithm a graph search if it checks for redundant paths and a tree-like search6 if it does not check. The BEST-FIRST-SEARCH algorithm in Figure 3.7 is a graph search algorithm; if we remove all references to reached we get a treelike search that uses less memory but will examine redundant paths to the same state, and thus will run slower.",第一，我们可以记住之前到达的所有状态（就像最佳优先搜索一样），这样能够检测到所有冗余路径，并只保留每个状态的最优路径。
chap3_para117,2,,这适用于存在大量冗余路径的状态空间，当内存可以容纳下已达状态表时，它是首选方法。
chap3_para1171,1,,[10]　如果一个子句被视作文字的集合，则这条限制自然地适用。
chap3_para1171,2,,对子句使用集合的概念可以使归结规则更简洁，但代价是引入了额外的记号。
chap3_para1172,1,,通过对文字和另一个子句中的互补文字mj的讨论，我们可以很容易理解归结规则的可靠性。
chap3_para1172,2,,如果为真，则mj为假，因此必然为真，因为已知。
chap3_para1172,3,,如果为假，则必为真，因为已知。
chap3_para1172,4,,现无论为真还是为假，结论必然成立，这与归结法则所述的完全相同。
chap3_para1173,1,,归结法则更为惊人的部分在于，它形成了一类完备推断过程的基础。
chap3_para1173,2,,基于归结的定理证明器可以对命题逻辑中的任意语句和确定是否成立。
chap3_para1173,3,,接下来的“合取范式”和“归结算法”两小节将解释归结是如何完成这项任务的。
chap3_para1175,1,,归结规则仅适用于子句（也就是文字的析取式），因此它似乎只能用于含有子句的知识库和查询。
chap3_para1175,2,,那么对于所有命题逻辑，它如何实现完备的推断过程？
chap3_para1175,3,,答案是，命题逻辑的所有语句逻辑上都等价于子句合取式。
chap3_para1176,1,,形式为子句合取式的语句被称为合取范式（conjunctive normal form）或CNF（见图7-12）。
chap3_para1176,2,,下面介绍把语句转换为CNF的过程。
chap3_para1176,3,,我们通过将语句 转换为CNF来阐明这一过程。
chap3_para1176,4,,转换的步骤如下。
chap3_para1177,1,,（1）消去，将替换为：
chap3_para1178,1,,（2）消去，将替换为
chap3_para1179,1,,（3）CNF要求只能在文字前出现，因此我们反复应用图7-11的如下等价关系“将内移”：
chap3_para118,1,"Third, we can compromise and check for cycles, but not for redundant paths in general.",第二，我们不必担心对过去的重复。
chap3_para118,2,"Since each node has a chain of parent pointers, we can check for cycles with no need for additional memory by following up the chain of parents to see if the state at the end of the path has appeared earlier in the path.",在一些问题形式化中，很少或不可能出现两条路径到达相同状态。
chap3_para118,3,"Some implementations follow this chain all the way up, and thus eliminate all cycles; other implementations follow only a few links (e.",以装配问题为例，每个动作都会将一个零件添加到一个不断发展的装配中，零件是有序的，因此可以先添加A，然后再添加B，但不能先添加B，然后再添加A。
chap3_para118,4,g.,"对于这些问题, 如果我们不记录已达状态也不检查冗余路径，则可以节省内存空间。"
chap3_para118,5,", to the parent, grandparent, and great-grandparent), and thus take only a constant amount of time, while eliminating all short cycles (and relying on other mechanisms to deal with long cycles).",如果搜索算法会检查冗余路径，我们称之为图搜索（graph search）；否则，称之为树状搜索（tree-like search）[6]。
chap3_para118,6,,图3-7中的Best-First-Search算法是一种图搜索算法；如果删除所有对reached的引用，即为树状搜索，它使用更少的内存，但会出现到达相同状态的冗余路径，因此运行速度会更慢。
chap3_para1183,1,,本例中，我们只需运用最后一条规则一次：
chap3_para1184,1,,（4）现在我们得到了一个∧和∨嵌套、运算符直接作用于文字的语句。
chap3_para1184,2,,运用图7-11的分配律，尽可能地对∧分配∨：
chap3_para1185,1,,原始语句现在已经成为CNF，是3个子句的合取式。
chap3_para1185,2,,它读起来难了很多，但它可以作为归结过程的输入。
chap3_para1186,1,,图7-12　合取范式、霍恩子句、确定子句、目标子句的文法。
chap3_para1186,2,,形式如这样的CNF子句可以写成确定子句
chap3_para1188,1,,基于归结的推断过程使用7.5.1节介绍的反证法来进行证明。
chap3_para1188,2,,也就是说，为了证明，我们要证明是不可满足的。
chap3_para1188,3,,我们通过证明矛盾来做到这一点。
chap3_para1189,1,,图7-13展示了一个归结算法。
chap3_para1189,2,,首先，被转换为CNF。
chap3_para1189,3,,然后，归结规则被应用在得到的子句上。
chap3_para1189,4,,每一对互补文字都被归结生成新的子句，如果新子句没有出现过，就将其加入子句集合。
chap3_para1189,5,,这一过程不断持续，直到发生下述的两件事情之一。
chap3_para119,1,3.,
chap3_para119,2,3.,
chap3_para119,3,4Measuring problem-solving performance,
chap3_para1190,1,,● 没有可供添加的新子句，此时KB不蕴含；
chap3_para1191,1,,● 两个子句归结为空子句，此时KB蕴含。
chap3_para1192,1,,图7-13　简单的命题逻辑归结算法。
chap3_para1192,2,,PL-Resolve返回对其两个输入进行归结得到的所有可能子句集合
chap3_para1193,1,,空子句是一个没有析取子句的析取式，它等价于False，因为仅当至少一个析取子句为真时析取式为真。
chap3_para1193,2,,另外，空子句仅在归结两个矛盾的单元子句（如P和）时出现。
chap3_para1194,1,,我们可以将归结过程用在wumpus世界中一个很简单的推断中。
chap3_para1194,2,,"当智能体位于[1,1]时，该处没有微风，因此相邻的方格没有无底洞。"
chap3_para1194,3,,相关的知识库是
chap3_para1195,1,,我们要证明，即。
chap3_para1195,2,,如果将转换为CNF，我们就能得到在图7-14顶部所示的子句。
chap3_para1195,3,,该图的第二行列出了归结第一行后的子句。
chap3_para1195,4,,"随后，当P1,2与归结后，我们得到了空子句，用小方块表示。"
chap3_para1195,5,,观察图7-14，可以发现许多归结是毫无意义的。
chap3_para1195,6,,例如，子句等价于，进而等价于True。
chap3_para1195,7,,推出True为真并没有什么用处。
chap3_para1195,8,,因此，我们可以忽略所有含有两个互补文字的子句。
chap3_para1196,1,,图7-14　对wumpus世界的一个简单推断部分运用PL-Resolution来证明查询。
chap3_para1196,2,,顶行最左侧的4个子句的每一个与其他3个都互相成对，运用归结规则产生底行的子句。
chap3_para1196,3,,"顶行的第3个和第4个子句结合生成，它继而与P1,2归结，生成空子句，表明查询被证明"
chap3_para1198,1,,作为对归结的讨论的总结，现在来了解为何PL-Resolution是完备的。
chap3_para1198,2,,为此，我们引入子句集合S的归结闭包（resolution closure）RC(S)，即对S中子句及其生成子句反复使用归结规则可推得的所有子句的集合。
chap3_para1198,3,,归结闭包就是RL-Resolution计算所得的变量clauses的最终值。
chap3_para1198,4,,"易知RC(S)必然是有限的：得益于因子提取，由S中出现的符号P1, …, Pk得出的子句数量是有限的。"
chap3_para1198,5,,因此，PL-Resolution总是能够终止。
chap3_para1199,1,,命题逻辑中归结的完备性定理被称为基本归结定理（ground resolution theorem）：
chap3_para12,1,•Goal formulation: The agent adopts the goal of reaching Bucharest. Goals organize behavior by limiting the objectives and hence the actions to be considered.,图3-1　罗马尼亚部分地区的简化道路图，道路距离单位为英里（1英里 = 1.61千米）
chap3_para120,1,"Before we get into the design of various search algorithms, we will consider the criteria used to choose among them. We can evaluate an algorithm’s performance in four ways:",[6]　我们称之为“树状搜索”，是因为无论如何搜索，状态空间仍然是相同的图；我们只是把它当作一棵树，从每个节点返回根只有一条路径。
chap3_para1200,1,,如果一个子句集是不可满足的，则这些子句的归结闭包含有空子句。
chap3_para1201,1,,定理的证明是通过其假言易位进行的：如果闭包RC(S)不含有空子句，则S可满足。
chap3_para1201,2,,"实际上，可以为S构建一个在P1, …, Pk上有适当真值的模型。"
chap3_para1201,3,,构建过程如下：
chap3_para1203,1,,"● 如果RC(S)中的子句含有文字且所有其他文字在对P1, …, Pi−1选定的赋值下为假，则对Pi赋值为false；"
chap3_para1204,1,,● 否则，对Pi赋值为true。
chap3_para1205,1,,"对P1, …, Pk的赋值是S的一个模型。"
chap3_para1205,2,,要搞清楚这一点，我们假设其反面——在序列中的某处i，对符号Pi赋值使得某个子句C为假。
chap3_para1205,3,,"此时，情况必然是C中所有其他文字都已经被对P1, …, Pi−1的赋值定为假。"
chap3_para1205,4,,因此，C的形式必然类似或。
chap3_para1205,5,,如果只有其中一个在RC(S)中，则算法将对Pi赋适当的值以使C为真，因此仅在这两个子句都在RC(S)中时，C才会为假。
chap3_para1206,1,,"现在，由于RC(S)在归结时是闭的，它会含有这两个子句的归结句，且这个归结句的所有文字已经被对P1, …, Pi−1的赋值定为假。"
chap3_para1206,2,,这与我们的假设，即第一个为假的子句出现在i处矛盾。
chap3_para1206,3,,因此，我们证明了这种构建永远无法使RC(S)中的子句为假，也就是说它创建了一个RC(S)的模型。
chap3_para1206,4,,最后，由于S包含在RC(S)中，因此任意RC(S)的模型也是S本身的模型。
chap3_para1207,1,,7.5.3　霍恩子句与确定子句
chap3_para1208,1,,归结的完备性使其成为一种非常重要的推断方法。
chap3_para1208,2,,而许多实际情形并不需要用到归结的全部能力。
chap3_para1208,3,,一些真实世界的知识库中的语句满足某些限制，这使得它们可以使用更为受限而更高效的推断算法。
chap3_para1209,1,,其中一种受限形式是确定子句（definite clause），它是文字的析取式，其中只有一个为正文字。
chap3_para1209,2,,例如，子句是确定子句而不是，因为它含有两个正文字。
chap3_para121,1,"•Completeness: Is the algorithm guaranteed to find a solution when there is one, and to correctly report failure when there is not?",第三，我们可以选择折中方法，检查循环，但通常不检查冗余路径。
chap3_para121,2,,由于每个节点都有一个父指针链，因此可以通过跟踪父指针链来查看路径末端的状态之前是否在路径中出现过，从而不需要额外内存即可检查是否存在循环。
chap3_para121,3,,某些算法实现一直沿着这个链向上移动，从而消除了所有循环。
chap3_para121,4,,另一些算法实现仅跟踪少数几个链接（例如，到父节点、祖父节点和曾祖父节点），因此仅需花费固定的时间就可以消除所有短循环（并依靠其他机制来处理长循环）。
chap3_para1210,1,,更一般性的是霍恩子句（Horn clause），它是文字的析取式，其中最多只有一个为正文字。
chap3_para1210,2,,因此所有的确定子句都是霍恩子句，没有正文字的子句也是霍恩子句——也被称为目标子句（goal clause）。
chap3_para1210,3,,霍恩子句在归结时是闭的：如果归结两个霍恩子句，仍然会得到霍恩子句。
chap3_para1210,4,,还有一种类型是k-CNF语句，它是每个子句最多含有k个文字的CNF语句。
chap3_para1211,1,,仅含有确定子句的知识库很有意义，原因有3个。
chap3_para1212,1,,（1）每个确定子句都可以写成一个蕴涵式，前提是正文字的合取式，结论是一个正文字。
chap3_para1212,2,,（见习题7.DISJ。
chap3_para1212,3,,）例如，确定子句可以写成蕴涵式。
chap3_para1212,4,,"蕴涵形式的语句更容易理解：它说明如果智能体位于[1, 1]，且感知到微风，则[1, 1]有微风。"
chap3_para1212,5,,在霍恩形式中，前提被称为体（body）而结论被称为头（head）。
chap3_para1212,6,,"由单个正文字构成的语句，例如L1,1，被称为事实（fact）。"
chap3_para1212,7,,"它也可以写成形式的蕴涵式，但只写成L1,1更为简洁。"
chap3_para1213,1,,（2）用霍恩子句进行推断可以通过前向链接（forward-chaining）算法和反向链接（backward-chaining）算法完成，我们稍后会介绍。
chap3_para1213,2,,这些算法都很自然，因为它们的推断步骤很直观，便于人类理解。
chap3_para1213,3,,这类推断是逻辑编程（logic programming）的基础，我们将在第9章进行讨论。
chap3_para1214,1,,（3）用霍恩子句确定蕴含关系所需的时间与知识库大小呈线性关系，这格外令人满意。
chap3_para1215,1,,7.5.4　前向链接与反向链接
chap3_para1216,1,,"前向链接算法PL-FC-Entails?(KB,q)确定单个命题符号q（即查询）是否被确定子句的知识库所蕴含。"
chap3_para1216,2,,它从知识库中的已知事实（正文字）开始。
chap3_para1216,3,,如果一个蕴涵式的所有前提都已知，则将其结论添加到已知事实的集合中。
chap3_para1216,4,,"例如，如果L1,1和Breeze已知，且在知识库中，则在知识库中添加B1,1。"
chap3_para1216,5,,这一过程持续进行，直到查询q被添加，或直到无法进一步进行推断。
chap3_para1216,6,,这一算法在图7-15中展示，我们要记住的要点是它的运行时间是线性的。
chap3_para1217,1,,用图和示例来理解算法是最好的办法。
chap3_para1217,2,,图7-16a展示了一个简单的霍恩子句知识库，其中有A和B两个已知事实。
chap3_para1217,3,,图7-16b展示了绘制为与或图（见第4章）的同一个知识库。
chap3_para1217,4,,在与或图中，用曲线连接的多个边表示一个合取式，每个边都要证明；而没有曲线连接的多个边表示一个析取式，证明任一边即可。
chap3_para1217,5,,图上很容易看懂前向链接是如何运作的。
chap3_para1217,6,,已知的叶节点（此处为A和B）具有真值之后，推断就会沿着图尽可能远地向上传递。
chap3_para1217,7,,当出现合取式时，传递过程开始等待，直到所有合取子句都已知。
chap3_para1217,8,,我们鼓励读者细致地研究这个示例。
chap3_para1218,1,,图7-15　命题逻辑的前向链接算法。
chap3_para1218,2,,queue记录了已知为真但还没“处理过”的符号。
chap3_para1218,3,,表count记录每个蕴涵式尚未证明的前提数量。
chap3_para1218,4,,一旦queue中的新符号p被处理，count就会为每个前提中出现p的蕴涵式减1（使用合适的索引方法，很容易在常数时间内完成）。
chap3_para1218,5,,如果count为0，则蕴涵式的所有前提都已知，因此其结论可以添加到queue。
chap3_para1218,6,,最后，我们还需要记录哪个符号已经被处理过，如此在已推断符号集inferred中的符号就无需被再次加入queue。
chap3_para1218,7,,这避免了重复的工作，也避免了由类似P⇒Q和Q⇒P这样的蕴涵式引起的循环
chap3_para1219,1,,图7-16　（a）一个霍恩子句集。
chap3_para1219,2,,（b）相应的与或图
chap3_para122,1,•Cost optimality: Does it find a solution with the lowest path cost of all solutions?7,3.3.4　问题求解性能评估
chap3_para1220,1,,显然，前向链接是可靠的：每个推断实际上都是对肯定前件的运用。
chap3_para1220,2,,前向链接也是完备的：所有蕴含的原子语句都将被推得。
chap3_para1220,3,,要理解这一点，最简单的方法是考虑（在算法到达不动点，无法产生新推断的时候）inferred表格的最终状态。
chap3_para1220,4,,该表中每个推得的符号都为真，所有其他符号都为假。
chap3_para1220,5,,我们可以将这个表看作一个逻辑模型，且原始KB的每条确定子句在这个模型中都为真。
chap3_para1221,1,,为理解这一点，可以假设其反面，即存在子句在模型中为假。
chap3_para1221,2,,则在模型中必然为真，且b在模型中必然为假。
chap3_para1221,3,,这与我们假设的算法已经到达不动点相矛盾，因为我们此时可以将b加入知识库。
chap3_para1221,4,,因此我们可以断定，不动点处推得的原子语句集定义了一个原始知识库的模型。
chap3_para1221,5,,更进一步地，知识库蕴含的任意原子语句q必然在其所有模型中都为真，在这个特定模型中也一样。
chap3_para1221,6,,因此，所有蕴含的原子语句q必然会被算法推得。
chap3_para1222,1,,前向链接是数据驱动（data-driven）推理这一更广泛概念的例子，也就是其注意力开始集中在已知数据的推理。
chap3_para1222,2,,它可以用于智能体，以便从收到的感知推导出结论，且常常是在没有特定查询的情况下。
chap3_para1222,3,,例如，wumpus世界的智能体可以用递增前向链接算法（即新的事实可以被加入队列来启动新的推断）将它的感知告知知识库。
chap3_para1222,4,,对人类来说，当获取新信息后会出现一定数量的数据驱动推理。
chap3_para1222,5,,例如，如果我在屋子里听到外面开始下雨，则我可能会想到取消野餐；但是，我大概不会想到邻居花园里最大的一朵玫瑰的第17片花瓣会淋湿——人类会对前向链接进行精心地控制，以免被无关的结果淹没。
chap3_para1223,1,,反向链接算法如其名称所示，从查询开始反向运作。
chap3_para1223,2,,如果查询q已知为真，则不需要做任何操作。
chap3_para1223,3,,否则，算法将在知识库中找寻结论为q的蕴涵式。
chap3_para1223,4,,如果这些蕴涵式的所有前提都可以（用反向链接）证明为真，则q为真。
chap3_para1223,5,,将反向链接算法用于图7-16的查询Q时，它反向地向图的下方运行，直到到达构成证明基础的已知事实集，即A和B。
chap3_para1223,6,,算法实质上与图4-11的And-Or-Graph-Search算法完全相同。
chap3_para1223,7,,与前向链接一样，它的高效实现的时间复杂性是线性的。
chap3_para1224,1,,反向链接是一种目标导向推理（goal-directed reasoning）。
chap3_para1224,2,,它对于回答类似“我现在该做什么？
chap3_para1224,3,,”和“我的钥匙在哪里？
chap3_para1224,4,,”这样的特定问题非常有用。
chap3_para1224,5,,通常，反向链接的代价远小于知识库规模的线性变化，因为这个过程仅涉及相关的事实。
chap3_para1225,1,,7.6　高效命题模型检验
chap3_para1226,1,,本节，我们介绍两种高效的、基于模型检验的一般命题推断的算法，其中一种是基于回溯搜索的，另一种则基于局部爬山搜索。
chap3_para1226,2,,这些算法是命题逻辑的“技术”部分。
chap3_para1226,3,,首次阅读本章时可以略过本节内容。
chap3_para1227,1,,我们描述的算法是用于可满足性检验的，即SAT问题。
chap3_para1227,2,,（如7.5节所述，可以通过检验的不可满足性来检验蕴含。
chap3_para1227,3,,）我们在7.5节中提到过找到满足逻辑语句的模型与找到约束满足问题的解的关系，因此这两种命题可满足性算法与6.3节的回溯算法和6.4节的局部搜索算法非常相似并不令人意外。
chap3_para1227,4,,尽管如此，这些算法本身还是极为重要的，因为许多计算机科学中的组合问题都可以被归为检验命题语句的可满足性。
chap3_para1227,5,,对可满足性算法的任何改进对于我们处理复杂性的能力都有巨大的作用。
chap3_para1228,1,,7.6.1　完备的回溯算法
chap3_para1229,1,,"我们要探讨的第一个算法常称为戴维斯-普特南算法（Davis-Putnam algorithm），得名于马丁·戴维斯（Martin Davis）和希拉里·普特南（Hilary Putnam）的重要论文（Davis and Putnam, 1960）。"
chap3_para1229,2,,"这个算法实际上采用的是戴维斯、洛吉曼和洛夫兰所描述的版本（Davis, Logemann, and Loveland, 1962），因此我们用所有4位作者姓氏的首字母DPLL命名这个算法。"
chap3_para1229,3,,DPLL使用一个合取范式形式（即一个子句集）的语句作为输入。
chap3_para1229,4,,类似于Backtracking-Search和TT-Entails?，它本质上是递归地、深度优先地枚举可能的模型。
chap3_para1229,5,,它在TT-Entails?的基础上进行了3项改进。
chap3_para123,1,"•Time complexity: How long does it take to find a solution? This can be measured in seconds, or more abstractly by the number of states and actions considered.",在开始设计各种搜索算法之前，需要考虑在这些算法中进行选择时所使用的标准。
chap3_para123,2,,我们可以从以下4个方面评价算法的性能。
chap3_para1230,1,,● 提前终止：算法可以用部分完成的模型来检测语句是否必然为真或为假。
chap3_para1230,2,,如果任一文字为真则子句为真，即使其他文字还没有真值；这样，整条语句在模型完成之前就可以断定其真值。
chap3_para1230,3,,例如，若A为真则语句为真，无论B和C的值是什么。
chap3_para1230,4,,类似地，若任一子句为假，即其所有文字为假，则语句为假。
chap3_para1230,5,,同样，这种情形可能会在模型完成前很久就发生。
chap3_para1230,6,,提前终止避免了在搜索空间中检查全部子树。
chap3_para1231,1,,● 纯符号启发式方法：纯符号是指在所有子句中“符号位”都相同的符号。
chap3_para1231,2,,例如，在3个子句、和中，A是纯符号，因为它只以正文字的形式出现；B也是纯符号，因为它总以负文字的形式出现。
chap3_para1231,3,,而C是不纯的。
chap3_para1231,4,,易知如果一条语句有模型，则存在一个模型对纯符号的赋值使其文字为真，因为这样做不会使子句为假。
chap3_para1231,5,,注意，在确定符号是否为纯时，算法可以忽略当前已构建的模型中已知为真的子句。
chap3_para1231,6,,例如，如果上述模型含有B=false，则子句已经为真，且在剩余子句中C仅作为正文字出现，因此C变为纯符号。
chap3_para1232,1,,● 单元子句启发式方法：之前对单元子句的定义是只有一个文字的子句。
chap3_para1232,2,,在DPLL中，它也指那些除了一个文字外，其余文字都被模型赋值为false的子句。
chap3_para1232,3,,例如，如果模型含有B = true，则简化为，这是一个单元子句。
chap3_para1232,4,,显然，要使这个子句为真，C必须赋值为false。
chap3_para1232,5,,单元子句启发式方法在余下的部分出现分支前对所有这样的符号赋值。
chap3_para1232,6,,这种启发式的一个重要结果是，所有对知识库中的已有文字进行的证明（通过反证法）将立刻得证（见习题7. KNOW）。
chap3_para1232,7,,还要注意的是，对一个单元子句赋值可能会创建另一个单元子句，例如，当C被置为假，也变成了单元子句，使得A被赋值为真。
chap3_para1232,8,,这种强制赋值的“级联”被称为单元传播（unit propagation）。
chap3_para1232,9,,这类似于确定子句的前向链接。
chap3_para1232,10,,实际上，如果CNF表达式仅含有确定子句，则DPLL本质上复制了前向链接。
chap3_para1232,11,,（见习题7. DPLL。
chap3_para1232,12,,）
chap3_para1233,1,,DPLL算法如图7-17所示，它给出了搜索程序的主要结构，但并未实现其细节。
chap3_para1234,1,,图7-17　用于检验命题逻辑语句可满足性的DPLL算法。
chap3_para1234,2,,Find-Pure-Symbol和Find-Unit-Clause背后的思路在正文中进行了介绍。
chap3_para1234,3,,这两个函数都返回一个符号（或返回空）以及要赋给这个符号的真值。
chap3_para1234,4,,和TT-Entails?一样，DPLL在部分模型上运行
chap3_para1235,1,,图7-17没有展示使SAT求解器能够用于大规模问题的技巧。
chap3_para1235,2,,有趣的是，这些技巧实际上都很寻常，我们之前已经见过它们的其他形式。
chap3_para1236,1,,（1）分量分析（如CSP中的塔斯马尼亚岛问题所见）：当DPLL为变量赋真值时，子句集可能会被分割成不相交的子集，我们称之为分量，它们没有共同的未赋值变量。
chap3_para1236,2,,给定一个高效探测这一状况的方法，求解器就可以通过对每个分量独立求解来加快速度。
chap3_para1237,1,,（2）变量排序与值排序（如在6.3.1节的CSP中所见）：我们对DPLL的简单实现使用任意的变量顺序，并在赋值时总是先尝试赋真再尝试赋假。
chap3_para1237,2,,度启发式算法（6.3.1节）建议在所有剩余子句中优先选择最常出现的变量。
chap3_para1238,1,,（3）智能回溯（如在6.3.3节的CSP中所见）：许多用按时序回溯几小时都求解不了的问题，如果改用智能回溯直接回溯到导致冲突的相关点上，那么问题可以在几秒内求解。
chap3_para1238,2,,所有运用智能回溯的SAT求解器都使用冲突子句学习的某种形式来记录冲突，以避免在后续的搜索中重复出现。
chap3_para1238,3,,通常只保留有限大小的冲突集，丢弃极少使用的冲突。
chap3_para1239,1,,（4）随机重启（在4.1.1节用于爬山法）：有时单次运行似乎无法取得进展。
chap3_para1239,2,,此时，我们可以从搜索树的顶端重新开始，而非尝试继续搜索。
chap3_para1239,3,,重启后（对变量和值选取）进行不同的随机选择。
chap3_para1239,4,,第一次运行中学习到的子句在重启后依然被保留，这有助于对搜索空间进行剪枝。
chap3_para1239,5,,重启并不保证能更快地找到解，但它能够减小求解时间的方差。
chap3_para124,1,•Space complexity: How much memory is needed to perform the search?,● 完备性（completeness）：当存在解时，算法是否能保证找到解，当不存在解时，是否能保证报告失败？
chap3_para1240,1,,（5）聪明索引（在许多算法中可以见到）：DPLL和其他现代求解器用到的加速方法需要快速索引“Xi作为正文字出现的子句集合”。
chap3_para1240,2,,这一任务相当复杂，因为算法所感兴趣的只是先前的变量赋值尚未满足的子句，因此索引结构必须在计算过程中动态更新。
chap3_para1241,1,,有了这些改进，现代求解器可以处理有数千万个变量的问题。
chap3_para1241,2,,它们为诸如硬件验证和安全协议验证这样的领域带来革命性的变化。
chap3_para1241,3,,在此之前，这些领域需要十分费力的、手动证明。
chap3_para1242,1,,7.6.2　局部搜索算法
chap3_para1243,1,,我们已经在本书中见过了一些局部搜索算法，包括Hill-Climbing（4.1.1节）和Simulated-Annealing（4.1.2节）。
chap3_para1243,2,,只要我们选择了正确的评价函数，这些算法可就以被直接用于可满足性问题。
chap3_para1243,3,,由于目标是找出满足所有子句的赋值，一个对未满足的子句进行计数的评价函数就可以胜任这项工作。
chap3_para1243,4,,实际上，这正是用于CSP的Min-Conflict算法所使用的量度（见6.4节）。
chap3_para1243,5,,这些算法都在完全赋值的空间采取动作，每次只翻转一个符号的真值。
chap3_para1243,6,,这个空间通常含有许多局部极小值，要跳出这些极小值，需要各种形式的随机方法。
chap3_para1243,7,,近年来，人们进行了大量实验，试图在贪婪性与随机性之间找到一个良好的平衡。
chap3_para1244,1,,这些算法中最为简单和有效的算法之一是WalkSAT（如图7-18所示）。
chap3_para1244,2,,算法每次循环都选择一个未满足的子句，并在该子句中选择一个符号来翻转。
chap3_para1244,3,,选择要翻转的符号的方法有两种：（1）最小化新状态中未满足子句的数量的“最小冲突”方法；（2）随机挑选一个符号的“随机游走”方法。
chap3_para1244,4,,算法随机选取一种。
chap3_para1245,1,,图7-18　通过随机翻转变量的值来检验可满足性的WalkSAT算法。
chap3_para1245,2,,这个算法有很多版本
chap3_para1246,1,,当WalkSAT返回一个模型时，输入语句就是可满足的。
chap3_para1246,2,,但当它返回failure时，则有两种可能的原因：语句不可满足，或我们需要多给算法一些时间。
chap3_para1246,3,,如果我们设定且p 0，WalkSAT最终将返回一个模型（如果存在的话），因为随机游走步骤终将遇到一个解。
chap3_para1246,4,,如果max_flips为无穷大，而语句不可满足，则算法永远不会终止！
chap3_para1247,1,,因此，当我们预计问题有解的时候，WalkSAT最为有用。
chap3_para1247,2,,例如，第3章和第6章讨论过的问题通常有解。
chap3_para1247,3,,但是，WalkSAT并不总是能检测到不可满足性，而对判定蕴含来说这是必备的。
chap3_para1247,4,,例如，wumpus世界中，一个智能体不能使用WalkSAT来可靠地证明一个方格是安全的。
chap3_para1247,5,,不过，它可以说：“我思考了一小时，都想不出存在一种这个方格不安全的可能世界。
chap3_para1247,6,,”这也许是个不错的经验性指示，表明方格是安全的，但它绝对不是一种证明。
chap3_para1248,1,,7.6.3　随机SAT问题概览
chap3_para1249,1,,某些SAT问题比其他要难。
chap3_para1249,2,,简单的问题可以用任意老算法求解，但由于我们知道SAT是NP完全的，至少有一些问题必须需要指数级的运行时间。
chap3_para1249,3,,在第6章中，我们见过一些针对某种问题的惊人发现。
chap3_para1249,4,,例如，对于回溯搜索算法，n皇后问题被认为是相当困难的，而对于局部搜索方法，如最小冲突法，求解这一问题却非常容易。
chap3_para1249,5,,这是由于在赋值空间中，解的分布非常密集，任意初始赋值都能保证在其附近存在解。
chap3_para1249,6,,因此，n皇后问题很简单，因为它是欠约束的（underconstrained）。
chap3_para125,1,"To understand completeness, consider a search problem with a single goal.",● 代价最优性（cost optimality）：它是否找到了所有解中路径代价最小的解？
chap3_para125,2,That goal could be anywhere in the state space; therefore a complete algorithm must be capable of systematically exploring every state that is reachable from the initial state.,[7]
chap3_para125,3,In finite state spaces that is straightforward to achieve: as long as we keep track of paths and cut off ones that are cycles (e.,
chap3_para125,4,g.,
chap3_para125,5,"Arad to Sibiu to Arad), eventually we will reach every reachable state.",
chap3_para1250,1,,当我们考虑合取范式的可满足性问题时，一个欠约束的问题是约束变量的子句非常少的情形。
chap3_para1250,2,,例如，下面是一条随机生成的3-CNF语句，它有5个符号和5个子句：
chap3_para1251,1,,在32个可能的赋值中，有16个是这条语句的模型。
chap3_para1251,2,,因此，平均而言，只需进行两次随机猜测就可以找到一个模型。
chap3_para1251,3,,与大部分这样的欠约束问题一样，这是一个简单的可满足性问题。
chap3_para1251,4,,但是，一个过约束的问题很可能没有解，因为相对于其变量数量，其子句数量过多。
chap3_para1251,5,,过约束问题通常很容易求解，因为这些约束将很快导致算法找出一个解，或进入无法逃离的死胡同。
chap3_para1252,1,,要超越这些基本的直观理解，我们必须明确定义如何生成随机语句。
chap3_para1252,2,,"记法CNFk(m, n)表示一个有m个子句、n个符号的k-CNF语句，其中子句是均匀地、独立地、无放回地从所有有k个文字的子句中选取的，文字的正负也是随机的。"
chap3_para1252,3,,（一个符号在子句中不能多次出现，一个子句也不能在语句中多次出现。
chap3_para1252,4,,）
chap3_para1253,1,,给定一个随机语句源，我们就可以测量可满足性的概率。
chap3_para1253,2,,"图7-19a绘制了CNF3(m, 50)的概率，也就是有50个变量、每条子句有3个文字的语句，这一概率被绘制为子句/符号，即m/n的函数。"
chap3_para1253,3,,如我们预期，对于较小的m/n，可满足性的概率接近0，而在较大的m/n处这一概率接近0。
chap3_para1253,4,,概率在m/n = 4.3左右急剧下降。
chap3_para1253,5,,经验上，我们发现这一“峭壁”出现在大致相同的位置（对于k = 3），并随着n的增长越来越陡峭。
chap3_para1254,1,,"理论上，可满足性阈值猜想（satisfiability threshold conjecture）表明对所有，存在一个阈值比rk，使得当n接近无穷时CNFk(rn, n)可满足的概率对于所有低于阈值的r接近于1，对于所有高于阈值的r接近于0。"
chap3_para1254,2,,即便对于如k = 3这样的特例，这一猜想仍未被证明。
chap3_para1254,3,,不论这是不是一个定理，这样的阈值效应在可满足性问题和其他类型的NP困难问题中都是相当寻常的。
chap3_para1255,1,,现在我们对可满足和不可满足问题分别会出现在什么地方有了很好的了解，接下来的问题是，困难的问题会出现在什么地方？
chap3_para1255,2,,其实它们也经常位于阈值处。
chap3_para1255,3,,图7-19b显示，阈值4.3处的50个符号的问题比阈值3.3处的相同问题大约难20倍。
chap3_para1255,4,,欠约束问题很好求解（因为很容易就能猜到一个解），而过约束问题不如欠约束问题简单，却仍然比恰好在阈值处的问题简单得多。
chap3_para1256,1,,图7-19　（a）有n个符号的随机3-CNF语句的可满足概率图，概率是子句/符号比m/n的函数。
chap3_para1256,2,,（b）DPLL和WalkSAT在随机3-CNF语句上的（多次运行后测量的）运行时间中位数图。
chap3_para1256,3,,最为困难的问题的子句/符号比约为4.3
chap3_para1257,1,,7.7　基于命题逻辑的智能体
chap3_para1258,1,,本节我们将目前所学的内容结合起来构建使用命题逻辑的wumpus世界智能体。
chap3_para1258,2,,首先我们要使智能体能够根据其历史感知对世界的状态尽可能地进行推导。
chap3_para1258,3,,这需要写出动作效果的完整逻辑模型。
chap3_para1258,4,,随后我们介绍智能体在wumpus世界中如何使用逻辑推断。
chap3_para1258,5,,我们还会介绍智能体如何在不查看每次推断的历史感知的情况下有效地跟踪世界的变化。
chap3_para1258,6,,最后，我们介绍在已知其知识库在实际世界中为真的情况下，智能体如何使用逻辑推断来构建能确保达到目标的规划。
chap3_para1259,1,,7.7.1　世界的当前状态
chap3_para126,1,"In infinite state spaces, more care is necessary. For example, an algorithm that repeatedly applied the “factorial” operator in Knuth’s “4” problem would follow an infinite path from 4 to 4! to (4!)!, and so on. Similarly, on an infinite grid with no obstacles, repeatedly moving forward in a straight line also follows an infinite path of new states. In both cases the algorithm never returns to a state it has reached before, but is incomplete because wide expanses of the state space are never reached.",
chap3_para1260,1,,如本章开头所述，逻辑智能体通过用关于世界的语句知识库推导接下来的动作来运作。
chap3_para1260,2,,知识库由公理（也就是关于世界如何运行的一般知识）和从智能体在某个特定世界获得的感知语句构成。
chap3_para1260,3,,本节，我们聚焦于推导wumpus世界的当前状态这一问题，如我在哪里、方格是否安全等。
chap3_para1261,1,,我们从7.4.3节开始收集公理。
chap3_para1261,2,,智能体知道起始方格没有无底洞（）也没有wumpus（）。
chap3_para1261,3,,此外，对于每个方格，它知道当且仅当一个方格的相邻方格有无底洞，该方格有微风；当且仅当一个方格的相邻方格有wumpus，该方格有臭味。
chap3_para1261,4,,由此，我们引入了具有如下形式的大量语句：
chap3_para1262,1,,智能体还知道恰恰只有一个wumpus。
chap3_para1262,2,,我们用两部分表示。
chap3_para1262,3,,首先，我们说至少有一个wumpus：
chap3_para1263,1,,然后我们必须说最多只有一个wumpus。
chap3_para1263,2,,我们对每对方格添加一个语句，来表明其中至少一个方格没有wumpus：
chap3_para1264,1,,到目前为止都还不错。
chap3_para1264,2,,现在让我们考虑智能体的感知。
chap3_para1264,3,,"我们使用了S1,1来表示[1, 1]有臭味，那么我们可以只用一个命题Stench来表示智能体感知到臭味吗？"
chap3_para1264,4,,遗憾的是，不行。
chap3_para1264,5,,如果在之前的时间步中没有臭味，就已经被断言，那么新的断言将与之矛盾。
chap3_para1264,6,,我们发现，如果感知只对当前时间的事情进行断言，这个问题就很容易求解。
chap3_para1264,7,,如此，假如时间步（与输入图7-1中Make-Percept-Sentence的一样）是4，则我们在知识库中添加Stench4而非Stench，这样就能轻松地避免与矛盾。
chap3_para1264,8,,对微风、碰撞、闪光和惨叫等感知也同样处理。
chap3_para1265,1,,这个将命题与时间步相关联的思路可以拓展到这个世界中所有随时间变化的部分。
chap3_para1265,2,,"例如，最初知识库中有——智能体在时刻0位于[1, 1]，以及FacingEast 0、HaveArrow 0和WumpusAlive0。"
chap3_para1266,1,,我们使用流（fluent，源于拉丁语fluens，意为流动）来表示世界随时间变化的部分。
chap3_para1266,2,,“流”与2.4.7节所述的对因子化表示的讨论中的“状态变量”同义。
chap3_para1266,3,,与世界的不变部分相关的符号不需要时间上标，它们有时被称为非时序变量（atemporal variable）。
chap3_para1267,1,,我们可以将微风和臭味直接与体验到这些感知的方格的属性连接。
chap3_para1267,2,,"[11]对任意时间步t和任意方格[x, y]，我们断言"
chap3_para1269,1,,[11]　7.4.3节出于简便考虑，隐藏了这项要求。
chap3_para127,1,"To be complete, a search algorithm must be systematic in the way it explores an infinite state space, making sure it can eventually reach any state that is connected to the initial state. For example, on the infinite grid, one kind of systematic search is a spiral path that covers all the cells that are s steps from the origin before moving out to cells that are s + 1 steps away. Unfortunately, in an infinite state space with no solution, a sound algorithm needs to keep searching forever; it can’t terminate because it can’t know if the next state will be a goal.",[7]　一些作者使用“可容许性”这一术语表示寻找最小代价解的性质，还有一些作者仅使用“最优性”，但这可能与其他类型的最优性相混淆。
chap3_para1270,1,,当然，现在我们需要能够使智能体跟进像这样的流的公理。
chap3_para1270,2,,智能体采取动作会改变这些流，因此，用第3章的术语来说，我们需要将wumpus世界的转移模型写成逻辑语句的集合。
chap3_para1271,1,,首先我们需要表示发生动作的命题符号。
chap3_para1271,2,,与感知一样，这些符号用时间索引。
chap3_para1271,3,,因此Forward 0表示智能体在时刻0执行前进动作。
chap3_para1271,4,,习惯上，给定时间步的感知先发生，然后是这个时间步上的动作，然后是到下一个时间步的转移。
chap3_para1272,1,,为描述世界如何变化，我们可以试着写出指明动作在下一个时间步产生的结果的效应公理（effect axiom）。
chap3_para1272,2,,"例如，如果智能体位于[1, 1]，在时刻0时面朝东并向前走，结果是智能体位于方格[2, 1]且不再在[1, 1]："
chap3_para1274,1,,对每个可能的时间步、16个方格中的每一个方格、4个方向中的每一个方向我们都需要类似这样的语句。
chap3_para1274,2,,对于其他动作，即抓取、射击、攀爬、左转、右转我们也需要类似的语句。
chap3_para1275,1,,假设智能体在时刻0决定向前移动，并在其知识库对此进行了断言。
chap3_para1275,2,,"给定式（7-1）的效应公理，结合时刻0时对状态的初始断言，智能体可以推得它位于[2, 1]。"
chap3_para1275,3,,也就是，Ask。
chap3_para1275,4,,到目前为止，一切还好。
chap3_para1275,5,,"遗憾的是，如果我们Ask(KB, HaveArrow1)，答案会是假，也就是智能体无法证明它仍然有箭，它也无法证明它没有箭！"
chap3_para1275,6,,信息丢失了，因为效应公理没有说明动作的结果未改变哪些状态。
chap3_para1275,7,,对这项功能的需求引出了框架问题。
chap3_para1275,8,,[12]框架问题的一个可能的求解办法是明确地添加断言所有不变命题的框架公理。
chap3_para1275,9,,例如，对于每个时刻t，我们有
chap3_para1277,1,,[12]　“框架问题”（frame problem）的名字来源于物理学中的参照系（frame of reference），也就是测量运动时假设的静止背景。
chap3_para1277,2,,电影的帧（frame）也借用了它的含义，其中前景变化时，大部分背景保持静止。
chap3_para1278,1,,其中明确地提到了在采取前进动作时所有从时刻t到时刻t+1维持不变状态的命题。
chap3_para1278,2,,尽管智能体现在已经知道它在前进后仍然有箭，且wumpus没有死去或复活，但激增的框架公理似乎相当低效。
chap3_para1278,3,,在有m个不同动作和n个流的世界，框架公理集的大小为O(mn)。
chap3_para1278,4,,这种框架问题被称作表示框架问题。
chap3_para1278,5,,这个问题在人工智能史上扮演过重要的角色，我们在本章最后的参考文献与历史注释中将进行进一步探索。
chap3_para1279,1,,表示框架问题很重要，因为即便保守来说，真实世界中的流也很多。
chap3_para1279,2,,幸运的是，对我们人类来说，每个动作改变的流通常不多于k个（k是某个较小的值），也就是说世界具有局部性。
chap3_para1279,3,,求解表示框架问题需要定义公理集大小为O(mk)而非O(mn)的转移模型。
chap3_para1279,4,,还有一个问题是推断框架问题：将t步动作规划的结果在O(kt)时间而非O(nt)时间内前向推进的问题。
chap3_para128,1,Time and space complexity are considered with respect to some measure of the problem difficulty.,● 时间复杂性（time complexity）：找到解需要多长时间？
chap3_para128,2,"In theoretical computer science, the typical measure is the size of the state-space graph, |V| + |E|, where |V| is the number of vertices (state nodes) of the graph and |E| is the number of edges (distinct state/action pairs).",可以用秒数来衡量，或者更抽象地用状态和动作的数量来衡量。
chap3_para128,3,"This is appropriate when the graph is an explicit data structure, such as the map of Romania.",
chap3_para128,4,"But in many AI problems, the graph is represented only implicitly by the initial state, actions, and transition model.",
chap3_para128,5,"For an implicit state space, complexity can be measured in terms of d, the depth or number of actions in an optimal solution; m, the maximum number of actions in any path; and b, the branching factor or number of successors of a node that need to be considered.",
chap3_para1280,1,,问题的解是关注于写出关于流而非动作的公理。
chap3_para1280,2,,这样的话，对于每个流F，以时刻t时的所有流（包括F本身）和时刻t时可能发生的动作来定义Ft+1的真值的公理。
chap3_para1280,3,,现在，Ft+1的真值可以用两种方法之一来确定：一种是时刻t的动作导致F在t+1为真，另一种是F在时刻t已经为真而时刻t的动作没有导致它为假。
chap3_para1280,4,,这种形式的公理叫作后继状态公理（successor-state axiom），具有如下形式：
chap3_para1281,1,,有箭（HaveArrow）的公理是最简单的后继状态公理。
chap3_para1281,2,,因为没有重新装填箭支的行动，ActionCausesFt部分可以去掉，所以我们有
chap3_para1283,1,,对智能体的位置来说，后继状态公理要更为复杂。
chap3_para1283,2,,"例如，如果（a）智能体在面向南方时从[1, 2]，或面向西方时从[2, 1]向前移动，或者（b）已经为真且动作未产生移动（因为动作不是向前或动作导致撞墙），则为真。"
chap3_para1283,3,,用命题逻辑写出，就是
chap3_para1285,1,,习题7.SSAX要求写出剩余的wumpus世界的流的公理。
chap3_para1286,1,,给定完整的后继状态公理和本节开始列出的其他公理，智能体就能够询问和回答世界当前状态的所有可解答问题。
chap3_para1286,2,,例如，在7.2节，感知和动作的初始序列是
chap3_para1287,1,,此时，有Ask，因此智能体知道它在什么位置。
chap3_para1287,2,,而且，Ask和Ask，因此智能体已经找到了wumpus和一个无底洞。
chap3_para1287,3,,对于智能体最重要的问题是一个方格是否能够进入，也就是这个方格是否没有无底洞也没有wumpus。
chap3_para1287,4,,为此添加公理很容易，形式如下：
chap3_para1288,1,,"最后，Ask，因此方格[2, 2]可以安全进入。"
chap3_para1288,2,,实际上，给定一个如DPLL的可靠且完备的推断算法，智能体可以回答关于哪个方格安全的任意可解答问题，而且对于小型到中型的wumpus世界可以在几毫秒内完成回答。
chap3_para1289,1,,求解表示框架问题和推断框架问题是一步重大的前进，但仍有一个亟待解决的问题：我们需要确认一个动作的所有必要的前提都成立才能保证结果效应。
chap3_para1289,2,,我们说过向前动作使智能体向前方移动，除非前方有墙，但也有许多其他意外会导致动作失败：智能体可能会被绊倒，会犯心脏病，会被巨型蝙蝠抓走，诸如此类。
chap3_para1289,3,,明确所有这些意外被称为资格问题（qualification problem）。
chap3_para1289,4,,它在逻辑学的范畴内没有完备的解，在决定要多么详细地明确模型以及要忽略哪些细节时，系统设计者必须做出很好的判断。
chap3_para1289,5,,我们将在第12章中看到，概率论允许以非显式的方式总结所有意外。
chap3_para129,1,3.,● 空间复杂性（space complexity）：执行搜索需要多少内存？
chap3_para129,2,4Uninformed Search Strategies,
chap3_para1290,1,,7.7.2　混合智能体
chap3_para1291,1,,推导世界状态的多个方面的能力可以直接与条件-动作规则（见2.4.2节）以及第3章和第4章的问题求解算法结合，产生一个wumpus世界的混合智能体。
chap3_para1291,2,,图7-20展示了达成这个目标的一种可能方式。
chap3_para1291,3,,智能体程序维护并更新一个知识库和一个当前规划。
chap3_para1291,4,,初始知识库含有非时变公理——不依赖于时间t的公理，例如将方格的微风与无底洞的存在联系起来的公理。
chap3_para1291,5,,在每个时间步，新的感知和所有依赖于t的公理，如后继状态公理，被加入知识库。
chap3_para1291,6,,（7.7.3节将解释为何智能体不需要未来时间步的公理。
chap3_para1291,7,,）然后，智能体通过向知识库询问来使用逻辑推断，以找出哪些方格是安全的且未被访问过。
chap3_para1292,1,,智能体程序的主体根据目标优先级降序创建一个规划。
chap3_para1292,2,,首先，如果存在闪光，则程序创建一个抓取金块、原路返回初始位置并爬出洞穴的规划。
chap3_para1292,3,,否则，如果没有当前规划，程序会规划一个前往最近的、未被访问过的安全方格的路线，并确保路线仅经过安全方格。
chap3_para1293,1,,路径规划使用A*搜索算法完成，而没有用Ask。
chap3_para1293,2,,如果没有可探索的安全方格，下一步——如果智能体还有箭的话——就是试图对一个可能有wumpus的位置射击来创造一个安全方格。
chap3_para1293,3,,这是通过询问Ask在何处为假完成的，也就是智能体还不知道的没有wumpus的地方。
chap3_para1293,4,,函数Plan-Shot（图中未展示）使用Plan-Route规划一系列动作来完成这次射击。
chap3_para1293,5,,如果失败，则程序寻找尚未证明是不安全的方格，也就是询问Ask返回假的方格。
chap3_para1293,6,,"如果不存在这样的方格，则任务不可能完成，智能体撤退到[1, 1]并爬出洞穴。"
chap3_para1294,1,,图7-20　wumpus世界的一个混合智能体。
chap3_para1294,2,,它使用命题知识库来推断世界的状态，结合问题求解搜索和论域特定代码来选择动作。
chap3_para1294,3,,每次调用Hybrid-Wumpus-Agent，它都会将感知添加到知识库，然后依据先前定义的规划或创建一个新规划，弹出这个规划的第一步作为下一个要采取的动作
chap3_para1295,1,,7.7.3　逻辑状态估计
chap3_para1296,1,,图7-20所示的智能体工作得不错，但它有一个重大弱点：随着时间流逝，涉及对Ask调用的计算开销不断增大。
chap3_para1296,2,,这主要是由于所需的推断不得不回到越来越早的时间点，并涉及越来越多的命题符号。
chap3_para1296,3,,显然，这是不可持续的——我们不能让一个智能体处理每次感知的时间随着其寿命的增长成比例地增加！
chap3_para1296,4,,我们真正需要的是常数更新时间，也就是，与t无关。
chap3_para1296,5,,一个显然的答案是保存或缓存（cache）推断的结果，以便下一个时间步的推断过程构建在先前的结果上，而非必须从零开始。
chap3_para1297,1,,如我们在4.4节所见，感知的历史和所有其后果都可以用信念状态代替，即对所有可能的当前世界状态集合的某种表示[13]。
chap3_para1297,2,,在新感知到来时更新信念的过程被称为状态估计（见4.4.4节）。
chap3_para1297,3,,而在4.4节，信念状态是状态的显式列表，此处我们可以使用含有关于当前时间步的命题符号，以及非时变符号的逻辑语句。
chap3_para1297,4,,例如，逻辑语句
chap3_para1299,1,,[13]　我们可以认为感知历史本身就是一个信念状态的表示，但它是一个随着历史变长使得推断代价逐渐增加的表示。
chap3_para13,1,"•Problem formulation: The agent devises a description of the states and actions necessary to reach the goal—an abstract model of the relevant part of the world. For our agent, one good model is to consider the actions of traveling from one city to an adjacent city, and therefore the only fact about the state of the world that will change due to an action is the current city.",● 问题形式化（problem formulation）：智能体刻画实现目标所必需的状态和动作——进而得到这个世界中与实现目标相关的部分所构成的抽象模型。
chap3_para13,2,,对智能体来说，一个好的模型应该考虑从一个城市到其相邻城市的动作，这时，状态中只有“当前所在城市”会由于动作而改变。
chap3_para130,1,An uninformed search algorithm is given no clue about how close a state is to the goal(s).,为了理解完备性，考虑一个具有单一目标的搜索问题。
chap3_para130,2,"For example, consider our agent in Arad with the goal of reaching Bucharest.",这个目标可能是状态空间的任何地方；因此，一个完备的算法必须能够系统地探索从初始状态可以到达的每一个状态。
chap3_para130,3,An uninformed agent with no knowledge of Romanian geography has no clue whether going to Zerind or Sibiu is a better first step.,在有限状态空间中，这是很容易实现的：只要我们跟踪路径并切断循环（例如，Arad到Sibiu再到Arad），最终我们将到达每一个可到达的状态。
chap3_para130,4,"In contrast, an informed agent (Section 3.",
chap3_para130,5,5) who knows the location of each city knows that Sibiu is much closer to Bucharest and thus more likely to be on the shortest path.,
chap3_para1301,1,,"代表时刻1的所有状态的集合，这时wumpus还活着，智能体位于[2, 1]，方格中有微风，[3, 1]或[2, 2]其中之一有无底洞或两个都有无底洞。"
chap3_para1302,1,,维护一个精确的、逻辑公式形式的信念状态并不简单。
chap3_para1302,2,,如果对于时刻t有n个流符号，则会有2n个可能的状态，也就是对这些符号的所有赋值。
chap3_para1302,3,,而现在，信念状态的集合是物理状态的超集（所有子集的集合）。
chap3_para1302,4,,总共有2n个物理状态，因此有个信念状态。
chap3_para1302,5,,即便我们对逻辑公式尽可能地使用紧凑的编码方式，即每个信念状态用一个二进制数表示，我们也需要位来标记当前的信念状态。
chap3_para1302,6,,也就是说，精确的状态估计需要的逻辑公式的规模可能是符号数量的指数级别的。
chap3_para1303,1,,一个用于近似状态估计的常见且自然的方法是用文字的合取式表示信念状态，即1-CNF公式。
chap3_para1303,2,,为此，智能体程序只需要在给定时刻t−1的信念状态的情况下，为每个符号X t证明X t和 （以及真值未知的非时变符号）即可。
chap3_para1303,3,,可证明文字的合取式成为了新的信念状态，先前的信念状态被丢弃。
chap3_para1304,1,,要了解的是，随着时间流逝，这个方法可能会损失一些信息。
chap3_para1304,2,,"例如，如果式（7-4）的语句是真正的信念状态，则P3,1和P2,2都无法被单独证明，也都不会出现在1-CNF信念状态中。"
chap3_para1304,3,,（习题7.HYBR探索了这一问题的一个可行的解法。
chap3_para1304,4,,）另外，由于1-CNF信念状态中的每一个文字都是由前一信念状态证得的，而且初始信念状态是一个真实的断言，可得出整个1-CNF信念状态必然为真。
chap3_para1304,5,,因此，1-CNF信念状态所表示的可能状态的集合包含了给定全部感知历史时的所有确实可能的状态。
chap3_para1304,6,,如图7-21所示，1-CNF信念状态就是准确信念状态的一个外包络，即保守近似（conservative approximation）。
chap3_para1304,7,,我们可以在人工智能的许多领域反复见到复杂集合的保守近似这一概念。
chap3_para1305,1,,图7-21　1-CNF信念状态（粗实线外轮廓）作为对准确信念状态（虚线轮廓的深色区域）的简单的、可表示的保守近似。
chap3_para1305,2,,每个可能世界都使用圆圈表示，深色圆圈与所有感知一致
chap3_para1306,1,,7.7.4　用命题推断进行规划
chap3_para1307,1,,图7-20所示的智能体使用逻辑推断来确定哪个方格是安全的，但使用了A*搜索来进行规划。
chap3_para1307,2,,本节展示如何通过逻辑推断来进行规划。
chap3_para1307,3,,它的思想非常简单。
chap3_para1308,1,,（1）构建一个语句，它含有：
chap3_para1309,1,,a. 对于初始状态的断言集Init0；
chap3_para131,1,3.,在无限状态空间中，则需要更加小心。
chap3_para131,2,4.,例如，在高德纳的“4”问题中反复应用“阶乘”操作的算法将沿着从4到4!到(4!)!……的无限路径行进。
chap3_para131,3,1Breadth-first search,同样地，在一个没有障碍的无限网格上，沿着直线不停前进也会形成由新状态组成的无限路径。
chap3_para131,4,,在这两种情况下，算法永远不会返回它之前到达的状态，但它是不完备的，因为状态空间中的大部分状态永远都不会到达。
chap3_para1310,1,,b. 到最大为时刻t为止的每一时间步的所有可能动作的后继状态公理 ；
chap3_para1311,1,,c. 目标在时刻t达成的断言。
chap3_para1312,1,,（2）将所有语句提供给SAT求解器。
chap3_para1312,2,,如果求解器找到一个可满足的模型，则目标是可达成的；如果语句不可满足，则问题无解。
chap3_para1313,1,,（3）假设找到了一个模型，从模型中提取代表动作并被赋值为true的变量。
chap3_para1313,2,,它们代表一个达成目标的规划。
chap3_para1314,1,,图7-22展示了一个命题规划程序SATPlan。
chap3_para1314,2,,它实现了上述的想法，仅做了一点改变。
chap3_para1314,3,,由于智能体并不知道它需要多少步才能达成目标，算法会尝试每个可能的t步，直到某个可行的最大规划长度Tmax。
chap3_para1314,4,,这样，如果这一规划存在的话，它能够确保找到最短的规划。
chap3_para1314,5,,由于SATPlan搜索解的特定方式，它无法在部分可观测的环境中使用；SATPlan只能将不可观测的变量设定为它所需的值来求解。
chap3_para1315,1,,图7-22　SATPlan算法。
chap3_para1315,2,,规划问题被转换为CNF语句，其中目标被断言在固定的时间步t时成立，到t为止的每个时间步都含有公理。
chap3_para1315,3,,如果可满足性算法找到了一个模型，则通过查看指向动作并在模型中被赋值为true的命题符号来提取规划。
chap3_para1315,4,,如果模型不存在，则将目标后移一步，重复这一过程
chap3_para1316,1,,使用SATPlan的关键步骤是构建知识库。
chap3_para1316,2,,大体来看，7.7.1节所述的wumpus世界公理似乎足以构成上述步骤1中的a和b。
chap3_para1316,3,,但蕴含（正如用Ask来检验的那些）和可满足性对公理的要求有重要的区别。
chap3_para1317,1,,"例如，考虑智能体的位置初始为[1, 1]，假设智能体的目标仅为在时刻1时移动到[2, 1]。"
chap3_para1317,2,,初始知识库含有，目标为。
chap3_para1317,3,,如果断言Forward0，则我们可以使用Ask证得；如果被断言的是Shoot0，则我们无法证得。
chap3_para1317,4,,现在，SATPlan会找到规划[Forward0]，目前看起来没什么问题。
chap3_para1318,1,,遗憾的是，SATPlan也会找到规划[Shoot0]。
chap3_para1318,2,,为什么会这样呢？
chap3_para1318,3,,"要找出其原因，先检查一下SATPlan构建的模型：它包括赋值，也就是智能体可以在时刻0时就位于[2, 1]并进行射击，故而在时刻1时也会在[2, 1]。"
chap3_para1318,4,,"有人会问：“我们不是刚说过智能体在时刻0时位于[1, 1]吗？"
chap3_para1318,5,,”的确如此，但我们没有告诉智能体它不能同时位于两个位置！
chap3_para1318,6,,对蕴含来说，是未知的，因此不能被用于证明；而对于可满足性，是未知的，因此可以被设定为任意有助于达成目标的值。
chap3_para1319,1,,对知识库来说，SATPlan是很好的调试工具，因为它能够暴露出知识缺失的地方。
chap3_para1319,2,,在这个例子中，我们可以使用类似于用来断言恰恰只存在一个wumpus的语句集，来断言在每个时刻智能体只能位于一个位置，以修复知识库。
chap3_para1319,3,,"或者，我们可以对除[1, 1]之外的所有位置断言；关于位置的后继状态公理用于处理之后的时刻。"
chap3_para1319,4,,相同的修复方式也可以用于确保智能体在一个时刻有且仅有一个朝向。
chap3_para132,1,"When all actions have the same cost, an appropriate strategy is breadth-first search, in which the root node is expanded first, then all the successors of the root node are expanded next, then their successors, and so on. This is a systematic search strategy that is therefore complete even on infinite state spaces. We could implement breadth-first search as a call to BEST-FIRST-SEARCH where the evaluation function f(n) is the depth of the node—that is, the number of actions it takes to reach the node.",完备的搜索算法探索无限状态空间的方式必须是系统的（systematic），以确保它最终能够到达与初始状态相关的任何状态。
chap3_para132,2,,例如，在无限网格上，一种系统搜索方法是螺旋路径，它覆盖了距离原点s步远的所有单元格，然后移动到s + 1步远的单元格。
chap3_para132,3,,遗憾的是，在一个不存在解的无限状态空间中，一个合理的算法会一直搜索，它不会终止，因为它不知道下一个状态是否是目标状态。
chap3_para1320,1,,但SATPlan还有更怪异的表现。
chap3_para1320,2,,首先是，它会找出含有不可能采取的动作的模型，例如在没有箭支的时候射击。
chap3_para1320,3,,要理解其原因，我们需要更为仔细地查看后继状态公理，如式（7-3），对于前提无法满足的动作的描述。
chap3_para1320,4,,公理的确正确地预测了执行这种动作不会产生任何结果（见习题7.SATP），但它没有表明这一动作不能被执行！
chap3_para1320,5,,要避免生成含有不合规动作的规划，我们必须加入表明动作的出现需要满足其前提的前提公理（precondition axiom）。
chap3_para1320,6,,[14]例如，我们需要说，对于每个时刻t，有
chap3_para1322,1,,[14]　注意，加入前提公理意味着我们不再需要在后继状态公理中包含动作的前提条件。
chap3_para1323,1,,这就确保了如果规划在某一时刻选择采取动作Shoot，则此时智能体必然有一支箭。
chap3_para1324,1,,SATPlan的另一个怪异的行为是它会创建具有多个同时进行的动作的规划。
chap3_para1324,2,,例如，它会生成一个Fotward0和Shoot0都为真的模型，而这是不允许的。
chap3_para1324,3,,要解决这个问题，我们引入动作排除公理（action exclusion axiom）：对于每对动作和，我们加入公理
chap3_para1325,1,,可能有人会提出同时向前走并射击并不是很困难，但如果是同时抓取并射击的话就相当不现实了。
chap3_para1325,2,,通过只对相互冲突的每对动作施以动作排除公理，可以使规划同时含有多个动作——而由于SATPlan能找出最短的合规规划，我们就可以确定它能够利用同时动作这个能力。
chap3_para1326,1,,总之，SATPlan能对含有初始状态、目标、后继状态公理、前提公理和动作排除公理的语句找出模型。
chap3_para1326,2,,由于不再存在任何错误的“解”，我们可以证明这一公理集是充分的。
chap3_para1326,3,,所有满足命题语句的模型都将是原始问题的有效解。
chap3_para1326,4,,现代SAT求解技术使得这一方法相当实用。
chap3_para1326,5,,例如，一个DPLL风格的求解器可以毫不费力地生成图7-2所示的wumpus世界的解。
chap3_para1327,1,,本节已经讲过构建智能体的一个陈述性方法：智能体通过结合在知识库中断言语句和执行逻辑推断运行。
chap3_para1327,2,,"这种方法有一些弱点，它们就隐含于类似“对于每个时刻t”和“对于每个方格[x, y]”这样的表述中。"
chap3_para1327,3,,对于所有实用的智能体，这些表述必须用从一般语句模式中自动生成实例的代码来实现，这些实例被用于插入知识库中。
chap3_para1327,4,,对于一个规模适中（相当于小型计算机游戏的大小）的wumpus世界，我们可能需要一个100×100的场地和1000个时间步，这样的话知识库中的语句就会有上亿条之多。
chap3_para1328,1,,这种情况不仅相当不现实，也揭露了一个深层次的问题：我们对wumpus世界的理解（即它的“物理学”在所有方格和所有时刻都一样）不能直接用命题逻辑的语言来表示。
chap3_para1328,2,,"要解决这个问题，我们需要更有表达能力的语言，也就是那种可以自然地写出像“对于每个时刻t”和“对于每个方格[x, y]”这种表述的语言。"
chap3_para1328,3,,第8章所述的一阶逻辑就是一种这样的语言。
chap3_para1328,4,,在一阶逻辑中，任意大小、任意时长的wumpus世界都可以用大约10条逻辑语句来描述，而非1000万条乃至1万亿条。
chap3_para133,1,"However, we can get additional efficiency with a couple of tricks. A first-in-first-out queue will be faster than a priority queue, and will give us the correct order of nodes: new nodes (which are always deeper than their parents) go to the back of the queue, and old nodes, which are shallower than the new nodes, get expanded first. In addition, reached can be a set of states rather than a mapping from states to nodes, because once we’ve reached a state, we can never find a better path to the state. That also means we can do an early goal test, checking whether a node is a solution as soon as it is generated, rather than the late goal test that best-first search uses, waiting until a node is popped off the queue. Figure 3.8 shows the progress of a breadth-first search on a binary tree, and Figure 3.9 shows the algorithm with the early-goal efficiency enhancements.",时间复杂性和空间复杂性与问题的困难程度相关。
chap3_para133,2,,在理论计算机科学中，一种典型的度量方式是状态空间图的大小，，其中是图中顶点（状态节点）的数量，是边（不同的状态/动作对）的数量。
chap3_para133,3,,当状态空间图是显式的数据结构（如罗马尼亚地图）时，这种度量是合适的。
chap3_para133,4,,但在许多人工智能问题中，状态空间图只是由初始状态、动作和转移模型隐式地表示。
chap3_para133,5,,对于隐式的状态空间，复杂性可以用3个量来衡量：d，最优解的深度（depth）或动作数；m，任意路径的最大动作数；b，需要考虑的节点的分支因子（branching factor）或后继节点数。
chap3_para1330,1,,我们已经介绍了基于知识的智能体，也展示了如何定义一种逻辑，以便使这种智能体能够对世界进行推理。
chap3_para1330,2,,本章重点如下。
chap3_para1331,1,,● 智能体需要关于世界的知识来获得良好的决策。
chap3_para1332,1,,● 知识包含在智能体中，其形式为存储于知识库中的、用知识表示语言表述的语句。
chap3_para1333,1,,● 一个基于知识的智能体由一个知识库和一套推断机制组成。
chap3_para1333,2,,它的运作方式是在知识库中存储关于世界的语句，使用推断机制推断新语句，并使用这些语句来决定采取何种动作。
chap3_para1334,1,,● 一种表示语言是用其语法和语义来定义的，语法规定了语句的结构，语义定义了每个可能世界或模型中每条语句的真值。
chap3_para1335,1,,● 语句之间的蕴含关系对于我们对推理的理解非常重要。
chap3_para1335,2,,在所有为真的世界中也为真，则语句蕴含语句。
chap3_para1335,3,,其等价定义包括语句的有效性和语句的不可满足性。
chap3_para1336,1,,● 推断是从旧语句推得新语句的过程。
chap3_para1336,2,,可靠的推断算法只推出蕴含的语句，完备的算法则可以推得所有蕴含的语句。
chap3_para1337,1,,● 命题逻辑是由命题符号和逻辑联结词构成的简单语言。
chap3_para1337,2,,它可以处理已知为真、为假或完全未知的命题。
chap3_para1338,1,,● 给出固定命题词汇表的前提下，可能的模型的集合是有限的，因此蕴含可以用枚举模型来检验。
chap3_para1338,2,,用于命题逻辑的高效模型检验推断算法包括回溯和局部搜索方法，它们通常能快速求解大规模问题。
chap3_para1339,1,,● 推断规则是可靠推断的模式，它可以用于证明。
chap3_para1339,2,,归结规则能产生一个用于知识库的完备推断算法，以合取范式的形式表示。
chap3_para1339,3,,前向链接和反向链接是霍恩形式知识库的非常自然的推理算法。
chap3_para134,1,"Description Sibiu to Fagaras, 99.",3.4　无信息搜索策略
chap3_para134,2,"Fagaras to Bucharest, 211.",
chap3_para134,3,"Sibiu to Rimnicu Vilcea, 80.",
chap3_para134,4,"Rimnicu Vilcea to Pitesti, 97.",
chap3_para134,5,"Pitesti to Bucharest, 101.",
chap3_para1340,1,,● 如WalkSAT这样的局部搜索方法可以用于问题求解。
chap3_para1340,2,,这种算法是可靠的，但不是完备的。
chap3_para1341,1,,● 逻辑状态估计需要使描述可能状态集的逻辑语句与历史观测保持一致。
chap3_para1341,2,,每一步更新都需要使用环境的转移模型进行推断，转移模型是根据规定流的变化方式的后继状态公理构建的。
chap3_para1342,1,,● 逻辑智能体内部的决策可以用求解SAT的方式进行：找出描述能达到目标的未来动作序列的可能的模型。
chap3_para1342,2,,这个方法仅能用于完全可观测或无传感器环境。
chap3_para1343,1,,● 命题逻辑无法扩大到大小无限制的环境中，因为它有限的表达能力不能简洁地处理时间、空间和对象间关系的通用模式。
chap3_para1347,1,,在本章中，我们将注意到世界被赋予了许多对象，其中一些对象与另一些对象相关，而我们努力对其进行推理。
chap3_para1348,1,,命题逻辑足以展示逻辑、推断和基于知识的智能体的基本概念。
chap3_para1348,2,,遗憾的是，命题逻辑的表达能力有限。
chap3_para1348,3,,本章我们介绍一阶逻辑，[1]它可以简洁地表达更多东西。
chap3_para1348,4,,我们在8.1节中总体上讨论表示语言，在8.2节中介绍一阶逻辑的语法和语义，然后在8.3节和8.4节中展示一阶逻辑在简单表示中的运用。
chap3_para135,1,Figure 3.,无信息搜索算法不提供有关某个状态与目标状态的接近程度的任何线索。
chap3_para135,2,8 Breadth-first search on a simple binary tree.,例如，考虑一个位于Arad且目标为Bucharest的智能体。
chap3_para135,3,"At each stage, the node to be expanded next is indicated by the triangular marker.",一个对罗马尼亚地理一无所知的无信息智能体无法判断第一步应该前往Zerind还是Sibiu。
chap3_para135,4,,相比之下，了解每个城市位置的有信息智能体（3.5节）则知道Sibiu距离Bucharest更近，因此Sibiu更有可能在最短路线上。
chap3_para1350,1,,[1]　一阶逻辑也称为一阶谓词演算（first-order predicate calculus），可缩写为FOL或FOPC。
chap3_para1352,1,,本节我们讨论表示语言的特性。
chap3_para1352,2,,编程语言（如C++、Java或Python）是常用的最大一类形式化语言。
chap3_para1352,3,,程序中的数据结构可以用来表示事实，例如，程序可以使用一个4×4数组表示wumpus世界的内容。
chap3_para1352,4,,"这样的话，编程语言中的语句就是断言在方格[2, 2]中有无底洞的一种很自然的方式。"
chap3_para1352,5,,将一系列这样的语句合起来，就足以对wumpus世界进行模拟。
chap3_para1353,1,,编程语言欠缺的是从其他事实推导事实的通用机制：对数据结构的每次更新都要使用领域特定的过程，而过程中的具体细节是由程序员根据其自身所具有的该领域的知识进行推导的。
chap3_para1353,2,,这种过程性的方法可与命题逻辑的陈述性（declarative）特性相对比，在命题逻辑中知识与推断是独立的，而推断完全是领域无关的。
chap3_para1353,3,,SQL数据库融合了陈述性与过程性知识。
chap3_para1354,1,,"程序（以及数据库）中数据结构的另一个缺点是缺少简便的表示方式来描述像“在方格[2, 2]或[3, 1]中有无底洞”或“如果wumpus在[1, 1]中，则它不在[2, 2]中”这样的概念。"
chap3_para1354,2,,程序可以为每个变量存储一个值，一些系统也允许这个值为“未知”，但它们缺乏直接处理部分信息的表达能力。
chap3_para1355,1,,命题逻辑是说明性语言，因为它的语义是基于语句与可能世界之间的真值关系的。
chap3_para1355,2,,使用析取和否定，命题逻辑有了足够的表达能力来处理部分信息。
chap3_para1355,3,,命题逻辑还有一个在表示语言中很有用的特性，即合成性（compositionality）。
chap3_para1355,4,,在合成语言中，一条语句的含义是其各个组成部分的含义的一个函数。
chap3_para1355,5,,"例如，“S1,4 ∧ S1,2”的含义与“S1,4”和“S1,2”的含义有关。"
chap3_para1355,6,,"如果“S1,4”表示方格[1, 4]有臭味，“S1,2”表示方格[1, 2]有臭味，而“S1,4 ∧ S1,2”却表示法国与波兰在上周的冰球资格赛1∶1打平，就显得非常奇怪。"
chap3_para1356,1,,然而，命题逻辑作为一种因子化表示，缺乏能够简洁描述具有多个对象的环境的表达能力。
chap3_para1356,2,,例如，我们不得不为每个方格分别写出关于微风和无底洞的规则，如：
chap3_para1357,1,,而在英语中，我们似乎可以简单地用一句“Squares adjacent to pits are breezy.”（与无底洞相邻的方格有微风）来一举解决问题。
chap3_para1357,2,,英语的语法和语义使它能够简洁地描述环境：英语是结构化表示，一阶逻辑也是。
chap3_para1358,1,,8.1.1　思想的语言
chap3_para1359,1,,自然语言（如英语或西班牙语）确实富有表达能力。
chap3_para1359,2,,我们设法用自然语言写作这一整本书的几乎全部内容，只偶尔地转用其他语言（主要是数学和图表）。
chap3_para1359,3,,语言学和语言哲学将自然语言视为说明性知识表示语言由来已久。
chap3_para1359,4,,如果我们能够揭示自然语言的规则，我们就能将其用于表示和推理系统，并获益于数十亿页已经用自然语言写就的文字。
chap3_para136,1,"Description The binary trees have the root node labeled “A”. Node “A” has two child nodes labeled B and C. Node B has two child nodes labeled D and E. Node C has two child nodes labeled F and G. Node D has two child nodes labeled H and I. Node E has two child nodes labeled J and K. Node F has two child nodes labeled L and M. Node G has two child nodes labeled N and O. Binary Tree 1: Node “A” is green-colored. An arrowhead points to “A”. All other nodes and paths are in faint dashed lines. Binary Tree 2: Node “A” is lavender-colored. Nodes B and C are green-colored. An arrowhead points to B. The paths from node “A” are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 3: Nodes “A” and B are lavender-colored. Nodes C, D, and E are green-colored. An arrowhead points to D. The paths from nodes “A” and B are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 4: Nodes “A”, B, and D are lavender-colored. Nodes C, E, H, and I are green-colored. An arrowhead points to H. The paths from “A”, B, and D are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 5: Nodes “A”, B, and D are lavender-colored. Nodes C, E, and I are green-colored. An arrowhead points to I. The paths from “A” and B are solid lines. The path between D and I is a solid line. The path from D to H and node H are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 6: Nodes “A” and B are lavender-colored. Nodes E and C are green-colored. An arrowhead points to E. The paths from “A” are solid lines. The path between B and E is a solid line. The path from B to D, node D, and the child nodes of D are all faded out. All other nodes and paths are in faint dashed lines. Binary Tree 7: Nodes “A”, B, and E are lavender-colored. Nodes C, J, and K are green-colored. An arrowhead points to J. The paths from “A” and E are solid lines. The path between B and E is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 8: Nodes “A”, B, and E are lavender-colored. Nodes C and K are green-colored. An arrowhead points to K. The paths from “A” are solid lines. The path between B and E is a solid line. The path between K and E is a solid line. The path from E to J and node J are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 9: Node “A” is lavender-colored and node C is green-colored. An arrowhead points to C. The path between “A” and C is a solid line. The path from “A” to B, node B, and all child nodes of B are faded. All other nodes and paths are in faint dashed lines. Binary Tree 10: Nodes “A” and C are lavender-colored. Nodes F and G are green-colored. An arrowhead points to F. The paths from C are solid lines. The path between “A” and C is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 11: Nodes “A”, C, and F are lavender-colored. Nodes G, L, and M are green-colored. An arrowhead points to L. The paths from C and F are solid lines. The path between “A” and C is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 12: Nodes “A”, C, and F are lavender-colored. Nodes G and M are green-colored. An arrowhead points to M. The paths from C are solid lines. The path between “A” and C is a solid line. The path between F and M is a solid line. The path from F to L and node L are faded out. All other nodes and paths are in faint dashed lines.",3.4.1　广度优先搜索
chap3_para1360,1,,自然语言的现代观点是将其视作交流的媒介而非单纯的表示。
chap3_para1360,2,,当说者指向一处并说“看！
chap3_para1360,3,,”听者就会明白他说的是超人终于出现在房顶了。
chap3_para1360,4,,但我们不能说是语句“看！
chap3_para1360,5,,”表示了这一事实。
chap3_para1360,6,,实际上，语句的含义既取决于语句本身，也取决于说出这一语句时的语境。
chap3_para1360,7,,显然，如果不在知识库中存储语句语境的表示而是仅存储像“看！
chap3_para1360,8,,”这样的语句，我们就无法搞清其含义——这就引发了语境本身该如何表示的问题。
chap3_para1361,1,,自然语言也受制于模糊性，这也是表示语言面临的问题。
chap3_para1361,2,,"正如平克（Pinker, 1995）所述：“当人们想到spring时，他们绝对不会困惑于他们到底是想到了一个季节还是想到了那个发出‘啵嘤’声的东西——如果一个词语可以对应于两种思想，那么思想就不能是词语。"
chap3_para1361,3,,”[2]
chap3_para1363,1,,[2]　表示“春天”和“弹簧”的英语单词都是spring。
chap3_para1363,2,,——译者注
chap3_para1364,1,,"著名的萨丕尔-沃尔夫假说（Sapir-Whorf hypothesis）（Whorf, 1956）宣称，我们对世界的理解深受我们所说的语言的影响。"
chap3_para1364,2,,不同的语言群体以不同的方式划分世界。
chap3_para1364,3,,对英语使用者来说，“chair”一词囊括法语中“chaise”和“fauteuil”两个单词的概念，但英语使用者可以轻易地认出fauteuil这个类别，并给它命名——大概是“扶手椅”（open-arm chair）。
chap3_para1364,4,,那么语言真的会对理解有影响吗？
chap3_para1364,5,,沃尔夫主要依靠直觉和猜测，他的想法也已经基本被摒弃，但多年以来我们其实有来自人类学、心理学和神经科学研究的真实数据。
chap3_para1365,1,,例如，你是否还记得下列表述中的哪一个构成了8.1节的开头？
chap3_para1366,1,,“本节我们讨论表示语言的特性……”
chap3_para1367,1,,“本节讲述表示语言的相关知识……”
chap3_para1368,1,,"维纳（Wanner, 1974）进行了类似的实验并发现，实验对象做出正确选择的概率处于随机水平——大概为50%，但对阅读内容记忆的准确率却超过90%。"
chap3_para1368,2,,这意味着，人们会解读其阅读过的文字并形成内在的非文字表示，而确切的用词并不重要。
chap3_para1369,1,,当某个概念在一种语言里根本不存在时，情况就更加有趣。
chap3_para1369,2,,澳大利亚的土著语言Guugu Yimithirr的使用者没有词语来表示如前、后、左、右这样的相对（或自我中心）方向。
chap3_para1369,3,,他们只使用绝对方向，例如“我北边的胳膊有点疼”。
chap3_para1369,4,,这种语言上的区别就导致了行为的区别：Guugu Yimithirr使用者在开阔地形上的定向能力更好，而英语使用者则更擅长于将叉子放在盘子右侧。
chap3_para137,1,Figure 3.,当所有动作的代价相同时，正确的策略是采用广度优先搜索（breadth-first search），即先扩展根节点，然后扩展根节点的所有后继节点，再扩展后继节点的后继，以此类推。
chap3_para137,2,9 Breadth-first search and uniform-cost search algorithms.,这是一种系统的搜索策略，因此即使在无限状态空间上也是完备的。
chap3_para137,3,,我们可以通过调用Best-First-Search实现广度优先搜索，其中评价函数f(n)是节点的深度，即到达该节点所需的动作数。
chap3_para1370,1,,语言似乎也会通过类似名词的性这种看起来毫无规律的文法特征来影响思维。
chap3_para1370,2,,例如，“桥”在西班牙语中是阳性词，而在德语中是阴性词。
chap3_para1370,3,,"博罗迪茨基（Boroditsky, 2003）要求实验对象选取英语形容词来描述某座桥的照片。"
chap3_para1370,4,,西班牙语使用者选择了大（big）、危险（dangerous）、坚固（strong）、耸立（towering），而德语使用者则选择了优美（beautiful）、优雅（elegant）、脆弱（fragile）、纤细（slender）。
chap3_para1371,1,,词语可以充当我们感知世界的锚点。
chap3_para1371,2,,洛夫特斯和帕尔默（Loftus and Palmer，1974）向实验对象展示了汽车事故的影片，被问及“车辆接触时的车速是多少？
chap3_para1371,3,,”的实验对象报告的平均速度为51.5 km/h，而使用“撞击”替代问题中的“接触”后，对于同一部影片的同一辆车，被提问的实验对象报告的平均速度则为66 km/h。
chap3_para1371,4,,总体来看，不同语言的使用者在认知处理上有微小却可测出的区别，但并没有令人信服的证据能够说明这会引起世界观的重大区别。
chap3_para1372,1,,在使用合取范式（CNF）的逻辑推理系统中，我们知道语言表达式“”和“”是等价的，因为我们可以看到系统的内部，并能够了解到这两条语句是以完全相同的标准CNF形式存储的。
chap3_para1372,2,,而对人类的大脑进行类似的操作正在成为可能。
chap3_para1372,3,,"米切尔等人（Mitchell et al., 2008）让实验对象进入功能性磁共振成像（fMRI）仪，然后向他们展示如“芹菜”之类的词语，并对他们的大脑进行成像。"
chap3_para1372,4,,"使用(词语, fMRI图像)数据对训练而成的机器学习程序能够在二选一任务（例如，是“芹菜”还是“飞机”）中达到77%的准确率。"
chap3_para1372,5,,这套系统甚至能够对其先前从未见过fMRI图像的词语（通过考虑相关词语的图像）和从未见过的人（证明fMRI揭示了人脑的表示方式具有某种共性）达到超过随机猜测的准确率。
chap3_para1372,6,,"尽管这类研究还相当原始，但fMRI以及其他成像技术，例如颅内电生理学（Sahin et al., 2009），有望将人类的知识表示形式探究得更为详尽。"
chap3_para1373,1,,从形式化逻辑的观点来看，用两种不同的方式表示相同的知识一点区别都没有，无论从何种表示出发都能推出相同的事实。
chap3_para1373,2,,但在实际中，从其中一种表示推出结论的步骤可能更少，这意味着资源有限的推理机只能从这一种表示得出结论，而非其他表示。
chap3_para1373,3,,对于类似从经验中学习这样的非演绎任务，其结果必然地依赖于其所使用的表示。
chap3_para1373,4,,我们在第19章阐述了当学习程序考虑两种关于世界的理论时，如果这两种理论与所有数据都是一致的，那么最为常见的破局方式就是选择最简洁的理论，而这取决于用来表示理论的语言。
chap3_para1373,5,,那么，对任何进行学习的智能体来说，语言对思想的影响就是不可避免的。
chap3_para1374,1,,8.1.2　结合形式语言和自然语言的优点
chap3_para1375,1,,我们可以采用形式逻辑的基础——一种上下文无关的、无歧义的说明性、合成式语义——来构建一种更有表达能力的逻辑，同时又从自然语言中借鉴表示方法并避免其缺点。
chap3_para1375,2,,当我们考察自然语言时，最为显眼的元素就是指代对象的名词和名词性短语（方格、无底洞、wumpus）和动词与动词性短语以及表示对象关系的形容词和副词（有微风、相邻、射击）。
chap3_para1375,3,,这些关系当中有的是函数，即对于一个给定“输入”只有一个“值”的关系。
chap3_para1375,4,,很容易就能列出一些对象、关系和函数。
chap3_para1376,1,,● 对象：人、房屋、数字、理论、麦当劳叔叔、颜色、棒球游戏、战争、世纪等。
chap3_para1377,1,,● 关系：可以是一元关系或属性，如红色的、圆的、伪造的、主要的、多层的等，或更为普适的n元关系，如是……的兄弟、大于、在……里、是……的一部分、有……颜色、发生于……之后、拥有、在……中间等。
chap3_para1378,1,,● 函数： ……的父亲、……最好的朋友、……的第三局比赛、比……多一个、……的开始等。
chap3_para1379,1,,实际上，几乎所有断言都可以看作对对象和属性的指代或关系。
chap3_para1379,2,,下面是一些例子。
chap3_para138,1,"Breadth-first search always finds a solution with a minimal number of actions, because when it is generating nodes at depth d, it has already generated all the nodes at depth d – 1, so if one of them were a solution, it would have been found. That means it is cost-optimal for problems where all actions have the same cost, but not for problems that don’t have that property. It is complete in either case. In terms of time and space, imagine searching a uniform tree where every state has b successors. The root of the search tree generates b nodes, each of which generates b more nodes, for a total of b2 at the second level. Each of these generates b more nodes, yielding b3 nodes at the third level, and so on. Now suppose that the solution is at depth d. Then the total number of nodes generated is",然而，我们可以通过一些技巧来提高算法效率。
chap3_para138,2,,先进先出队列比优先队列速度更快，并且能提供正确的节点顺序：新节点（总是比其父节点更深）进入队列的队尾，而旧节点，即比新节点浅的节点，首先被扩展。
chap3_para138,3,,此外，reached可以是一组状态，而不是状态到节点的映射，因为一旦到达某个状态，我们就再也找不到到达该状态的更好路径了。
chap3_para138,4,,这也意味着我们可以进行早期目标测试（early goal test），即在生成节点后立即检查该节点是否为一个解，而不是像最佳优先搜索使用的后期目标测试（late goal test）那样，等节点弹出队列后再检查该节点是否为一个解。
chap3_para138,5,,图3-8展示了在二叉树上进行广度优先搜索的过程，图3-9展示了使用早期目标测试来提高效率的算法。
chap3_para1380,1,,● “1加2等于3”。
chap3_para1381,1,,对象：1、2、3、1加2。
chap3_para1381,2,,关系：等于。
chap3_para1381,3,,函数：加。
chap3_para1381,4,,（“1加2”是对对象“1”和“2”应用函数“加”后得到的对象的名称。
chap3_para1381,5,,“3”是这个对象的另一个名称。
chap3_para1381,6,,）
chap3_para1382,1,,● “与wumpus相邻的方格有臭味”。
chap3_para1383,1,,对象：wumpus、方格。
chap3_para1383,2,,属性：有臭味。
chap3_para1383,3,,关系：相邻。
chap3_para1384,1,,● “邪恶的约翰国王在1200年统治英格兰”。
chap3_para1385,1,,对象：约翰、英格兰、1200年。
chap3_para1385,2,,关系：统治。
chap3_para1385,3,,属性：邪恶的、国王。
chap3_para1386,1,,一阶逻辑语言是围绕对象和关系构建的，我们于下一节定义其语法和语义。
chap3_para1386,2,,它对于数学、哲学和人工智能乃至人类生活的很多方面都非常重要，因为这些领域要处理的正是对象和对象之间的关系。
chap3_para1386,3,,一阶逻辑也可以表示关于全域中的一些和全部对象的事实。
chap3_para1386,4,,这就使我们可以表示各种法则和规则，例如陈述“与wumpus相邻的方格很臭”。
chap3_para1387,1,,命题逻辑和一阶逻辑的主要区别在于其各自的本体论约定（ontological commitment），即它对真实世界性质的假设。
chap3_para1387,2,,数学上来说，这一约定是通过语句真值确定的形式化模型的性质来表示的。
chap3_para1387,3,,例如，命题逻辑假设世界中存在要么成立要么不成立的事实。
chap3_para1387,4,,每个事实都可以为真或假这两种状态中的一个，而每个模型为每个命题符号进行true或false的赋值（见7.4.2节）。
chap3_para1387,5,,一阶逻辑则进行了更多假设，它假设世界是由具有关系的对象组成的，这些关系要么成立要么不成立（见图8-1）。
chap3_para1387,6,,因此，一阶逻辑的形式化模型也就比命题逻辑更为复杂。
chap3_para1388,1,,图8-1　形式化语言及其本体论约定和认识论约定
chap3_para1389,1,,这种本体论约定是逻辑（包括命题逻辑和一阶逻辑）的强项，因为它允许我们从真实的陈述出发来推断其他真实的陈述。
chap3_para1389,2,,这对于每条命题都有清晰边界的领域非常有效，例如数学或wumpus世界。
chap3_para1389,3,,在wumpus世界中，一个方格要么有无底洞要么没有无底洞，那种有个像无底洞一样的大坑的方格是不存在的。
chap3_para1389,4,,但在真实世界中，许多命题的边界是模糊的：维也纳是大城市吗？
chap3_para1389,5,,那家餐厅的菜好吃吗？
chap3_para1389,6,,这个人高吗？
chap3_para1389,7,,这都取决于被你提问的人，而他们的回答可能是“还行吧”。
chap3_para139,1,"All the nodes remain in memory, so both time and space complexity are O(bd).",图3-8　简单二叉树上的广度优先搜索。
chap3_para139,2,Exponential bounds like that are scary.,每个阶段接下来要扩展的节点用三角形标记表示
chap3_para139,3,"As a typical real-world example, consider a problem with branching factor b = 10, processing speed 1 million nodes/second, and memory requirements of 1 Kbyte/node.",
chap3_para139,4,"A search to depth d = 10 would take less than 3 hours, but would require 10 terabytes of memory.",
chap3_para139,5,The memory requirements are a bigger problem for breadth-first search than the execution time.,
chap3_para139,6,But time is still an important factor.,
chap3_para139,7,"At depth d = 14, even with infinite memory, the search would take 3.",
chap3_para139,8,5 years.,
chap3_para139,9,"In general, exponential-complexity search problems cannot be solved by uninformed search for any but the smallest instances.",
chap3_para1390,1,,对此，一种解决办法是细化表示：如果将城市分为“大”和“不大”的标准太粗略，使我们上述的应用中存在太多疑问，那么我们可以增加分类的个数，或使用Population这样的函数符号。
chap3_para1390,2,,另一种解决方案来源于模糊逻辑（fuzzy logic），它使用的本体论约定使得命题具有在0到1之间的真实度（degree of truth）。
chap3_para1390,3,,例如，语句“维也纳是大城市”在模糊逻辑中可能真实度是0.8，而“巴黎是一个大城市”则可能真实度是0.9。
chap3_para1390,4,,这更符合我们对真实世界的直观理解，但也更难进行推断：不同于确定A∧B真值的唯一规则，模糊逻辑在不同领域需要不同的规则。
chap3_para1390,5,,还有一个解决办法（将在24.1节阐述）是在多维空间中为每个概念分配一个点，并测量概念“大城市”与概念“巴黎”或“维也纳”的距离。
chap3_para1391,1,,不少特定用途的逻辑还进一步地进行了本体论约定，例如时态逻辑（temporal logic）假设事实在特定的时间成立，而这些时间（可能是时间点或时间区间）是有序的。
chap3_para1391,2,,这样，特定用途的逻辑就使某种对象（以及关于它们的公理）在这种逻辑内更“高级”，而非只是在知识库中对其进行定义。
chap3_para1391,3,,高阶逻辑（higher-order logic）将一阶逻辑中的关系和函数视作其自身的对象。
chap3_para1391,4,,这使我们能对所有关系进行断言，例如，我们可能想定义具有传递性的关系意味着什么。
chap3_para1391,5,,不同于大多数特定用途的逻辑，高阶逻辑的表达能力全面高于一阶逻辑，因为高阶逻辑的一些语句无法用有限数量的一阶逻辑语句来表示。
chap3_para1392,1,,一种逻辑的特性还包括其认识论约定（epistemological commitment），即这种逻辑允许每个事实所具有的可能知识状态。
chap3_para1392,2,,在命题逻辑和一阶逻辑中，一条语句表示一个事实，智能体只能选择相信其为真、相信其为假或没有意见。
chap3_para1392,3,,因此，这两种逻辑对于任何语句都具有3种可能的知识状态。
chap3_para1393,1,,而使用概率论（probability theory）的系统则可以有信任度或主观可能性，其值可以是从0（完全不信任）到1（完全信任）的任何值。
chap3_para1393,2,,千万不要将概率论中的信任度与模糊逻辑中的真实度搞混了。
chap3_para1393,3,,实际上，一些模糊系统允许对真实度具有不确定性（信任度）。
chap3_para1393,4,,"例如，一个概率的wumpus世界智能体可能相信wumpus在[1, 3]中的概率是0.75，而在[2, 3]中的概率是0.25（尽管wumpus肯定在某一个特定的方格中）。"
chap3_para1394,1,,8.2　一阶逻辑的语法和语义
chap3_para1395,1,,本节我们先更为确切地阐述一阶逻辑的可能世界是如何反映其关于对象和关系的本体论约定的。
chap3_para1395,2,,随后我们介绍这种语言的几个组成部分，并解释其语义。
chap3_para1395,3,,本节的主旨是弄清这种语言如何进行简洁的表示，以及其语义如何形成完备的推理过程。
chap3_para1396,1,,8.2.1　一阶逻辑模型
chap3_para1397,1,,第7章讲过，逻辑语言的模型是组成目前正在考虑的可能世界的形式化结构。
chap3_para1397,2,,每个模型都将逻辑语句的词汇表连接到可能世界的元素，使得任意语句的真值可以被确定。
chap3_para1397,3,,因此，命题逻辑的模型将命题符号连接到预定义的真值表。
chap3_para1398,1,,一阶逻辑模型要有趣得多。
chap3_para1398,2,,首先，它们具有对象！
chap3_para1398,3,,模型的域（domain）是它包含的对象集或域元素的集合。
chap3_para1398,4,,域应当是非空的——每个可能世界至少要含有一个对象。
chap3_para1398,5,,（见习题8.EMTP了解关于空世界的讨论。
chap3_para1398,6,,）数学上来说，对象是什么无所谓——有意义的只是每个特定模型中有多少对象。
chap3_para1398,7,,但出于教学的考虑，我们会使用一个具体的例子。
chap3_para1398,8,,图8-2展示了一个具有5个对象的模型，这5个对象分别是英格兰1189年至1199年的国王狮心理查、1199年至1215年统治英格兰的邪恶的约翰国王（理查的弟弟）、理查的左腿、约翰的左腿和王冠。
chap3_para1399,1,,图8-2　含有5个对象、2个二元关系（兄弟和在头顶）、3个一元关系（人、国王和王冠）和1个一元函数（左腿）的模型
chap3_para14,1,"•Search: Before taking any action in the real world, the agent simulates sequences of actions in its model, searching until it finds a sequence of actions that reaches the goal. Such a sequence is called a solution. The agent might have to simulate multiple sequences that do not reach the goal, but eventually it will find a solution (such as going from Arad to Sibiu to Fagaras to Bucharest), or it will find that no solution is possible.",● 搜索（search）：在真实世界中采取任何动作之前，智能体会在其模型中模拟一系列动作，并进行搜索，直到找到一个能到达目标的动作序列。
chap3_para14,2,,这样的序列称为解（solution）。
chap3_para14,3,,智能体可能不得不模拟多个无法到达目标的序列，但最终它要么找到一个解（例如从Arad到Sibiu到Fagaras再到Bucharest），要么发现问题是无解的。
chap3_para140,1,3.4.2Dijkstra’s algorithm or uniform-cost search,图3-9　广度优先搜索和一致代价搜索算法
chap3_para1400,1,,这个模型中的对象可能有多方面的关系。
chap3_para1400,2,,图中，理查和约翰是兄弟。
chap3_para1400,3,,从形式上来看，关系就是相关对象的元组集。
chap3_para1400,4,,（一个元组是以固定顺序排列的一系列对象，使用尖括号将对象括起来表示。
chap3_para1400,5,,）这样，模型中的兄弟关系就是集合
chap3_para1402,1,,（此处我们已经命名了对象，但如果你愿意的话，你可以用图片代替对象名称。
chap3_para1402,2,,"）王冠在约翰国王的头顶，因此关系“在头顶”仅含有一个元组，〈王冠, 约翰国王〉。"
chap3_para1402,3,,“兄弟”关系和“在头顶”关系都是二元关系，也就是说，它们关联了一对对象。
chap3_para1402,4,,该模型还含有一元关系，或称为属性：“人”属性对于理查和约翰都为真；“国王”属性仅对于约翰为真（假设此时理查已经去世）；而“王冠”属性则仅对王冠为真。
chap3_para1403,1,,最好将某些类型的关系视为函数，因为这样的话给定一个对象，它必然仅关联到一个对象。
chap3_para1403,2,,例如，每个人都有一条左腿，因此模型含有一个一元“左腿”函数，即从一个单元素元组到一个对象的映射，它包括如下的映射：
chap3_para1405,1,,严格来说，一阶逻辑中的模型需要全函数（total function），也就是对于所有输入的元组都要有值。
chap3_para1405,2,,这样，王冠必须要有一条左腿，每条左腿也一样。
chap3_para1405,3,,对于这种尴尬的问题有一个技术解决方案，它需要增加一个“不可见”的对象来作为一切没有左腿的东西的左腿，包括它自己。
chap3_para1405,4,,幸运的是，只要没人对没有左腿的东西的左腿进行断言，这些技术细节就不重要。
chap3_para1406,1,,目前为止，我们已经描述了组成一阶逻辑模型所需的元素。
chap3_para1406,2,,模型的另一个重要部分是这些元素与逻辑语句的词汇表的联系，我们接下来进行介绍。
chap3_para1407,1,,8.2.2　符号与解释
chap3_para1408,1,,我们现在来了解一阶逻辑的语法。
chap3_para1408,2,,不耐烦的读者可以通过图8-3获得对形式化文法的完整描述。
chap3_para1409,1,,图8-3　包含等价关系的一阶逻辑语法，使用巴克斯-诺尔范式（如果你对此不熟悉，见附录B.1）。
chap3_para1409,2,,运算符优先级从高到低定义。
chap3_para1409,3,,量词的优先级为一个量词的优先级高于其右边的一切
chap3_para141,1,"When actions have different costs, an obvious choice is to use best-first search where the evaluation function is the cost of the path from the root to the current node. This is called Dijkstra’s algorithm by the theoretical computer science community, and uniform-cost search by the AI community. The idea is that while breadth-first search spreads out in waves of uniform depth—first depth 1, then depth 2, and so on—uniform-cost search spreads out in waves of uniform path-cost. The algorithm can be implemented as a call to BEST-FIRST-SEARCH with PATH-COST as the evaluation function, as shown in Figure 3.9.",广度优先搜索总是能找到一个动作最少的解，因为当它生成深度为d的节点时，说明它已经生成了深度为d - 1的所有节点，如果其中一个节点是解，它应该已经被找到了。
chap3_para141,2,,这意味着，对于所有动作都具有相同代价的问题，它是代价最优的，但对于不具有该特性的问题，则不一定是最优的。
chap3_para141,3,,这两种情况都是完备的。
chap3_para141,4,,在时间和空间方面，想象我们在搜索一棵均衡树，其中每个状态都有b个后继。
chap3_para141,5,,搜索树的根生成b个节点，每个节点又生成b个节点，第二层总共是b2个节点。
chap3_para141,6,,每个节点又生成b个节点，从而在第三层产生b3个节点，以此类推。
chap3_para141,7,,现在假设解的深度为d，那么生成的节点总数为
chap3_para1410,1,,一阶逻辑的基本语法元素是代表对象、关系和函数的符号。
chap3_para1410,2,,因此，符号分为3种：代表对象的常量符号（constant symbol）、代表关系的谓词符号（predicate symbol）和代表函数的函数符号（function symbol）。
chap3_para1410,3,,我们采用的习惯是用大写字母开头来书写这些符号。
chap3_para1410,4,,例如，我们可以使用常量符号Richard（理查）和John（约翰），谓词符号Brother（是兄弟）、OnHead（在头顶）、Person（是人）、King（是国王）和Crown（是王冠），函数符号LeftLeg（……的左腿）。
chap3_para1410,5,,与命题符号一样，如何命名完全取决于使用者的意愿。
chap3_para1410,6,,每个谓词和函数符号都有一个决定参数数量的元数（arity）。
chap3_para1411,1,,每个模型必须提供所需的信息来确定任意给定语句为真还是为假。
chap3_para1411,2,,因此，除了它的对象、关系和函数，每个模型还要包含一套确切指明常量、谓词和函数符号指代的是哪个对象、关系和函数的解释（interpretation）。
chap3_para1411,3,,在我们的例子中，下面是一种可能的解释，也就是逻辑学家所说的预期解释（intended interpretation）。
chap3_para1412,1,,● Richard指狮心理查，John指邪恶的约翰国王。
chap3_para1413,1,,● Brother指兄弟关系，也就是式（8-1）给出的对象元组集，Onhead是连接王冠和约翰国王的关系，Person、King和Crown是识别人、国王和王冠的一元关系。
chap3_para1414,1,,● LeftLeg指式（8-2）定义的“左腿”函数。
chap3_para1415,1,,当然，模型还有很多种可能的解释。
chap3_para1415,2,,例如，一种解释将Richard映射到王冠而将John映射到约翰国王的左腿。
chap3_para1415,3,,模型中有5个对象，因此仅对常量符号Richard和John就有25种可能的解释。
chap3_para1415,4,,注意，并非所有对象都有名称。
chap3_para1415,5,,例如，预期解释并没有为王冠和腿命名。
chap3_para1415,6,,一个对象也可以有多个名称，在一种可能的解释中Richard和John都指代王冠。
chap3_para1415,7,,[3]如果你觉得这令人困惑，记住，在命题逻辑中，一个Cloudy（阴天）和Sunny（晴天）都为真的模型是完全可以存在的；排除与我们的知识不符的模型是知识库要做的事情。
chap3_para1417,1,,[3]　在随后的8.2.8节，我们会考察一种语义，其中每个对象只能有一个名称。
chap3_para1418,1,,总之，一阶逻辑中的模型包含一个对象集和一种解释，这种解释将常量符号映射到对象、将函数符号映射到关于这些对象的函数，将谓词符号映射到关系。
chap3_para1418,2,,与命题逻辑一样，蕴含、有效性等都是用所有可能模型来定义的。
chap3_para1418,3,,要大致了解可能模型集是什么样子的，见图8-4。
chap3_para1418,4,,图中显示，模型的区别在于它们包含的对象数量不同（从一到无穷多个），以及常量符号映射到对象的方式不同。
chap3_para1419,1,,图8-4　含有两个常量符号的语言中全部模型的集合的部分成员、R和J以及一个二元关系符号。
chap3_para1419,2,,每种常量符号的解释用灰色箭头标明。
chap3_para1419,3,,每个模型中，相关的对象用箭头连接
chap3_para142,1,Consider Figure 3.,所有节点都存储在内存中，所以时间复杂性和空间复杂性都是O(bd)。
chap3_para142,2,"10, where the problem is to get from Sibiu to Bucharest.",这样的指数级上界是可怕的。
chap3_para142,3,"The successors of Sibiu are Rimnicu Vilcea and Fagaras, with costs 80 and 99, respectively.",举一个典型的真实世界中的例子，考虑一个分支因子b = 10、处理速度为每秒100万节点、内存需求为1 KB/节点的问题。
chap3_para142,4,"The least-cost node, Rimnicu Vilcea, is expanded next, adding Pitesti with cost 80 + 97 = 177.",深度d = 10的搜索将花费不到3小时的时间，但需要10 TB的内存。
chap3_para142,5,"The least-cost node is now Fagaras, so it is expanded, adding Bucharest with cost 99 + 211 = 310.",对广度优先搜索来说，内存需求是一个比执行时间更严重的问题。
chap3_para142,6,"Bucharest is the goal, but the algorithm tests for goals only when it expands a node, not when it generates a node, so it has not yet detected that this is a path to the goal.",但时间仍然是一个重要因素。
chap3_para142,7,,深度d = 14时，即使有无限内存，搜索也需要3.5年。
chap3_para142,8,,一般来说，除了最小的问题实例，指数级复杂性的搜索问题无法通过无信息搜索求解。
chap3_para1420,1,,由于一阶逻辑模型数量没有上限，我们无法通过枚举所有模型的方式（像我们对命题逻辑做的那样）来检验蕴含。
chap3_para1420,2,,即便对象的数量是有限的，其组合也会是巨量的。
chap3_para1420,3,,（见习题8.MCNT。
chap3_para1420,4,,）对图8-4中的例子来说，使用不超过6个对象就会产生137 506 194 466个模型。
chap3_para1422,1,,项（term）是指代对象的逻辑表达式。
chap3_para1422,2,,常量符号是项，但对每个对象都使用不同的符号命名往往不太方便。
chap3_para1422,3,,在语言中我们使用表达“约翰国王的左腿”而不是给他的腿起个名称来称呼。
chap3_para1422,4,,这就是函数符号存在的意义：我们使用LeftLeg(John)，而不是使用常量符号来命名这条腿。
chap3_para1422,5,,[4]
chap3_para1424,1,,[4]　表达式（-expression，lambda表达式）提供了一种很有用的记法，使得新的函数符号可以“即时”构建。
chap3_para1424,2,,例如，对参数进行平方操作的函数可以写作，并可以像其他函数符号那样直接用于参数。
chap3_para1424,3,,一个表达式也可以被定义为谓语符号并用作谓词符号。
chap3_para1424,4,,这与Lisp和Python中的lambda操作符的作用完全一致。
chap3_para1424,5,,注意，像这样使用并不能增加一阶逻辑的形式化表达能力，因为所有含有表达式的语句都能通过“插入”其参数的方式重写，生成一个等价的语句。
chap3_para1425,1,,通常情况下，复合项的组成是一个函数符号后跟随一个括号，括号中是一系列项，作为该函数符号的参数。
chap3_para1425,2,,需要注意的是，复合项只是复杂一些的名称，而非“返回一个值”的“子程序调用”。
chap3_para1425,3,,并不存在以一个人作为输入，返回一条腿的LeftLeg子程序。
chap3_para1425,4,,我们甚至可以在不定义LeftLeg的情况下就进行关于左腿的推理（例如，陈述一条一般规则“每个人都有左腿”，并进而推导出约翰必然有左腿）。
chap3_para1425,5,,这是无法在编程语言中用子程序实现的。
chap3_para1426,1,,项的形式化语义非常直白。
chap3_para1426,2,,"考虑项f(t1, …, tn)。"
chap3_para1426,3,,"函数符号f指代模型中的某个函数（不妨称为F），参数项指代域中的对象（称为d1, …, dn)），整个项就指代将函数F应用于d1, …, dn产生的对象，即函数的值。"
chap3_para1426,4,,例如，假设LeftLeg函数符号代表式（8-2）所示的函数，John代表约翰国王，则LeftLeg(John)代表约翰国王的左腿。
chap3_para1426,5,,这样，解释就确定了每个项的被指代物。
chap3_para1427,1,,8.2.4　原子语句
chap3_para1428,1,,我们现在已经有了指代对象的项以及指代关系的谓词符号，将它们结合起来可以构成陈述事实的原子语句。
chap3_para1428,2,,原子语句（或简称原子）是由谓词符号以及其后可能存在的括号中的一系列项组成的，例如：
chap3_para1429,1,,在先前给定的预期解释下，这条语句表明狮心理查是约翰国王的兄弟。
chap3_para1429,2,,[5]原子语句的参数可以是复合项，如
chap3_para143,1,Figure 3.,3.4.2　Dijkstra算法或一致代价搜索
chap3_para143,2,"10 Part of the Romania state space, selected to illustrate uniform-cost search.",
chap3_para1431,1,,"[5]　我们一般遵循P(x, y)读作“x是y的P”这样的参数排序习惯。"
chap3_para1432,1,,表明狮心理查的父亲娶了约翰国王的母亲（再次强调，在合适的解释下）。
chap3_para1432,2,,[6]
chap3_para1434,1,,[6]　这个本体论认为每个人只有一位父亲和一位母亲。
chap3_para1434,2,,更为复杂的本体论可以识别出生物学母亲、生母、养母等。
chap3_para1435,1,,如果谓词符号所指代的关系在参数所指代的对象之间成立，则在给定模型中原子句为真。
chap3_para1436,1,,8.2.5　复合语句
chap3_para1437,1,,我们可以使用逻辑联结词构建更为复杂的语句，这与命题演算的语法和语义一样。
chap3_para1437,2,,下面是4条在我们的预期解释下在图8-2的模型中为真的语句：
chap3_para1439,1,,当我们有了支持对象的逻辑后，就很自然地想要表达很多对象的整体属性而非根据名称逐个列举对象。
chap3_para1439,2,,量词能使我们达到这一目的。
chap3_para1439,3,,一阶逻辑含有两个标准量词——全称量词和存在量词。
chap3_para144,1,"The algorithm continues on, choosing Pitesti for expansion next and adding a second path to Bucharest with cost 80 + 97 + 101 = 278.",当动作具有不同的代价时，一个显而易见的选择是使用最佳优先搜索，评价函数为从根到当前节点的路径的代价。
chap3_para144,2,"It has a lower cost, so it replaces the previous path in reached and is added to the frontier.",理论计算机科学界称之为Dijkstra算法，人工智能界则称之为一致代价搜索（uniform-cost search）。
chap3_para144,3,"It turns out this node now has the lowest cost, so it is considered next, found to be a goal, and returned.",不同于广度优先搜索在深度一致的波（首先是深度1，然后是深度2，以此类推）中展开，一致代价搜索算法的思想是在路径代价一致的波中展开。
chap3_para144,4,"Note that if we had checked for a goal upon generating a node rather than when expanding the lowest-cost node, then we would have returned a higher-cost path (the one through Fagaras).",该算法可以通过调用Best-First-Search实现，评价函数为Path-Cost，如图3-9所示。
chap3_para1441,1,,回想我们在第7章用命题逻辑表示一般规则时面临的困难。
chap3_para1441,2,,像“与wumpus相邻的方格有臭味”和“所有国王都是人”这样的规则对一阶逻辑来说是最基本的。
chap3_para1441,3,,我们将在8.3节中解决第一条规则。
chap3_para1441,4,,而第二条规则“所有国王都是人”在一阶逻辑中写作
chap3_para1442,1,,全称量词∀通常读作“对所有……”。
chap3_para1442,2,,［记住，上下颠倒的A表示“all”（所有）。
chap3_para1442,3,,］因此，这条语句表示“对所有x，如果x是国王，则x是人”。
chap3_para1442,4,,符号x被称为变量。
chap3_para1442,5,,习惯上，变量用小写字母表示。
chap3_para1442,6,,一个变量本身就是一个项，因此也可以作为函数的参数，例如LeftLeg(x)。
chap3_para1442,7,,一个没有变量的项被称为基本项（ground term）。
chap3_para1443,1,,直观上来说，语句∀x P，其中P为任意逻辑语句，表明P对每个对象x都为真。
chap3_para1443,2,,更确切地说，如果P在根据一个模型的给定解释构建的所有可能扩展解释（extended interpretation）下为真，则∀x P在该模型中为真，其中每个扩展解释给出了x指代的域元素。
chap3_para1444,1,,这听起来很复杂，但它实际上只是陈述全称量词的直观含义的一种严谨的方式。
chap3_para1444,2,,考虑图8-2所示的模型及其相应的预期解释。
chap3_para1444,3,,我们可以用5种方式扩展这个解释：
chap3_para145,1,"The complexity of uniform-cost search is characterized in terms of C*, the cost of the optimal solution,8 and ϵ, a lower bound on the cost of each action, with ϵ > 0. Then the algorithm’s worst-case time and space complexity is O(b1+⌊C*/ϵ⌋), which can be much greater than bd. This is because uniform-cost search can explore large trees of actions with low costs before exploring paths involving a high-cost and perhaps useful action. When all action costs are equal, b1+⌊C*/ϵ⌋ is just bd+1, and uniform-cost search is similar to breadth-first search.",考虑图3-10，问题是从Sibiu到达Bucharest。
chap3_para145,2,,Sibiu的后继是Rimnicu Vilcea和Fagaras，代价分别为80和99。
chap3_para145,3,,然后扩展代价最小的节点Rimnicu Vilcea，加入节点Pitesti，其代价为80 + 97 = 177。
chap3_para145,4,,此时代价最小的节点是Fagaras，所以接着扩展Fagaras，加入节点Bucharest，代价为99 + 211 = 310。
chap3_para145,5,,目标节点是Bucharest，但算法只在扩展节点时测试其是否为目标节点，而不是在生成节点时测试，因此它还没有检测到这是一条通往目标的路径。
chap3_para1450,1,,全称量化语句在原模型中为真的前提是语句在这5种扩展解释下都为真。
chap3_para1450,2,,也就是说，全称量化语句等价于如下5个断言：
chap3_para1451,1,,狮心理查是一位国王⇒ 狮心理查是一个人
chap3_para1452,1,,约翰国王是一位国王 ⇒ 约翰国王是一个人
chap3_para1453,1,,理查的左腿是一位国王 ⇒ 理查的左腿是一个人
chap3_para1454,1,,约翰的左腿是一位国王 ⇒ 约翰的左腿是一个人
chap3_para1455,1,,王冠是一位国王 ⇒ 王冠是一个人
chap3_para1456,1,,让我们仔细研究这些断言。
chap3_para1456,2,,在我们的模型中，由于约翰国王是唯一的国王，因而第二条语句断言他是人，正如我们所料。
chap3_para1456,3,,那么其他4条语句呢？
chap3_para1456,4,,那些声明了腿和王冠的语句呢？
chap3_para1456,5,,这也是“所有国王都是人”含义的一部分吗？
chap3_para1456,6,,实际上，其他4条断言在模型中都为真，但并未对腿、王冠乃至理查作为人的资格进行任何声明。
chap3_para1456,7,,这是因为这些对象都不是国王。
chap3_para1456,8,,回顾⇒的真值表（图7-8），我们可以看到当前提为假时蕴涵式为真——无论其结论的真值是什么。
chap3_para1456,9,,因此，通过断言全称量化语句——它等价于断言每一条蕴涵式，我们最终仅对前提为真的对象断言规则的结论，而对前提为假的对象什么也不说。
chap3_para1456,10,,因此，⇒的真值表定义被证明非常适合用来编写含有全称量词的一般规则。
chap3_para1457,1,,即使是勤奋地将本节读了好几遍的读者也可能会犯的常见错误是使用合取式而非蕴涵式与全称量词搭配。
chap3_para1457,2,,语句
chap3_para1459,1,,狮心理查是国王∧狮心理查是人
chap3_para146,1,"Uniform-cost search is complete and is cost-optimal, because the first solution it finds will have a cost that is at least as low as the cost of any other node in the frontier. Uniform-cost search considers all paths systematically in order of increasing cost, never getting caught going down a single infinite path (assuming that all action costs are > ϵ > 0).",图3-10　罗马尼亚问题状态空间的一部分，选择这部分来说明一致代价搜索
chap3_para1460,1,,约翰国王是国王∧约翰国王是人
chap3_para1461,1,,理查的左腿是国王∧理查的左腿是人
chap3_para1463,1,,显然，这并不是我们想要表达的。
chap3_para1465,1,,全称量词对所有对象进行陈述。
chap3_para1465,2,,反之，我们也可以对某些对象进行陈述而不需指明其名称。
chap3_para1465,3,,使用存在量词就可以实现这一点。
chap3_para1465,4,,例如，要说约翰国王的头顶有王冠，我们写作
chap3_para1466,1,,∃x读作“存在x使得……”或“对于一些x……”。
chap3_para1467,1,,直观上来说，语句∃x P说的是P至少对于一个对象x为真。
chap3_para1467,2,,更准确地说，如果P在至少一个将x分配给域元素的扩展解释下为真，则∃x P在给定模型中为真。
chap3_para1467,3,,也就是，下列语句中至少有一个为真：
chap3_para1468,1,,狮心理查是王冠 ∧ 狮心理查在约翰的头顶
chap3_para1469,1,,约翰国王是王冠 ∧ 约翰国王在约翰的头顶
chap3_para147,1,3.,算法继续进行，接下来选择Pitesti进行扩展，添加到Bucharest的第二条路径，代价为80 + 97 + 101 = 278。
chap3_para147,2,4.,它的代价更低，因此用它取代reached中之前的路径，并添加到frontier中。
chap3_para147,3,3Depth-first search and the problem of memory,结果证明，这个节点目前具有最小代价，因此它被认为是下一个要扩展的节点，此时我们发现它是一个目标节点，从而返回该节点。
chap3_para147,4,,注意，如果我们在生成节点时检查目标，而不是在扩展代价最小的节点时检查，那么我们将返回一个代价更高的路径（即经过Fagaras的路径）。
chap3_para1470,1,,理查的左腿是王冠 ∧ 理查的左腿在约翰的头顶
chap3_para1471,1,,约翰的左腿是王冠 ∧ 约翰的左腿在约翰的头顶
chap3_para1472,1,,王冠是王冠 ∧ 王冠在约翰的头顶
chap3_para1473,1,,第五个断言在模型中为真，因此先前的存在量化语句在模型中为真。
chap3_para1473,2,,注意，根据我们的定义，这条语句在约翰国王戴了两顶王冠的模型中也为真。
chap3_para1473,3,,这与原始语句“约翰国王的头顶有王冠”完全不矛盾。
chap3_para1473,4,,[7]
chap3_para1475,1,,[7]　存在量词有一个变种，通常写作∃1或∃!，意思是“恰好存在一个”。
chap3_para1475,2,,相同的含义可以用等词陈述表示。
chap3_para1476,1,,正如⇒是能自然地与∀合用的联结词一样，∧是与∃自然合用的联结词。
chap3_para1476,2,,使用∧作为∀的主要联结词会导致前面示例中的过强陈述，而使用⇒搭配∃则会导致过弱的陈述。
chap3_para1476,3,,考虑如下语句：
chap3_para1477,1,,表面来看，这似乎是对我们的语句的一种合理的表示。
chap3_para1477,2,,使用语义规则，我们发现该语句表达的是如下断言中至少一条为真：
chap3_para1478,1,,狮心理查是一顶王冠 ⇒ 狮心理查在约翰的头顶
chap3_para1479,1,,约翰国王是一顶王冠 ⇒ 约翰国王在约翰的头顶
chap3_para148,1,"Depth-first search always expands the deepest node in the frontier first. It could be implemented as a call to BEST-FIRST-SEARCH where the evaluation function f is the negative of the depth. However, it is usually implemented not as a graph search but as a tree-like search that does not keep a table of reached states. The progress of the search is illustrated in Figure 3.11; search proceeds immediately to the deepest level of the search tree, where the nodes have no successors. The search then “backs up” to the next deepest node that still has unexpanded successors. Depth-first search is not cost-optimal; it returns the first solution it finds, even if it is not cheapest.",一致代价搜索的复杂性用C*和表示，C*是最优解的代价[8]，是每个动作代价的下界，。
chap3_para148,2,,那么算法在最坏情况下的时间复杂性和空间复杂性是，比bd大得多。
chap3_para148,3,,这是因为一致代价搜索在探索包含一个可能有用的高代价动作的路径之前，可能会先探索具有低代价动作的大型树。
chap3_para148,4,,当所有动作代价相同时，等于bd+1，这时一致代价搜索类似于广度优先搜索。
chap3_para1480,1,,理查的左腿是一顶王冠 ⇒ 理查的左腿在约翰的头顶
chap3_para1482,1,,蕴涵式为真的条件是其前提和结论都为真，或其前提为假。
chap3_para1482,2,,因此，如果狮心理查不是一顶王冠，则第一条断言为真，存在量化语句被满足。
chap3_para1482,3,,因此，只要任一对象不能满足前提，存在量化的蕴涵式语句就为真。
chap3_para1482,4,,因而这种语句其实基本上什么都没说。
chap3_para1484,1,,我们经常希望用多个量词表示更复杂的语句。
chap3_para1484,2,,最简单的情形是量词种类相同的情形。
chap3_para1484,3,,例如，“兄弟是同胞”可以写成
chap3_para1485,1,,连续的同类量词可以写成有多个变量的单个量词。
chap3_para1485,2,,例如，要表示同胞是对称关系，可以写成
chap3_para1486,1,,其他情况下，我们得混用量词。
chap3_para1486,2,,“每个人都喜爱一些人”意思是，对所有人都存在其喜爱的人：
chap3_para1487,1,,相反，要说“有人被所有人喜爱”，就写成
chap3_para1488,1,,因此，量词的顺序非常重要。
chap3_para1488,2,,添加括号会使语句看起来更清晰。
chap3_para1488,3,,表明每个人都有某种属性，也就是他们喜爱一些人的属性。
chap3_para1488,4,,反之，则表示世界上的一些人具有某种属性，即每个人都喜爱他们的属性。
chap3_para1489,1,,当两个量词与相同的变量名合用时会引起一些混淆。
chap3_para1489,2,,考虑语句
chap3_para149,1,Figure 3.,
chap3_para149,2,"11 A dozen steps (left to right, top to bottom) in the progress of a depth-first search on a binary tree from start state A to goal M.",
chap3_para149,3,"The frontier is in green, with a triangle marking the node to be expanded next.",
chap3_para149,4,"Previously expanded nodes are lavender, and potential future nodes have faint dashed lines.",
chap3_para149,5,Expanded nodes with no descendants in the frontier (very faint lines) can be discarded.,
chap3_para1490,1,,"此处Brother(Richard, x)中的x是被存在量化的。"
chap3_para1490,2,,规则是，变量属于提及它的最内层量词，随后便不再受任何其他量词约束。
chap3_para1490,3,,"另一种考虑方式是，∃x Brother(Richard, x)是关于理查（有一个兄弟）的语句，不是关于x的语句；因此在外层放一个∀x并无效果。"
chap3_para1490,4,,"该语句一个等价的写法是∃z Brother (Richard, z)。"
chap3_para1490,5,,因为这可能是导致混淆的源头，所以我们会始终在嵌套量词中使用不同的变量名。
chap3_para1492,1,,∀与∃两个量词实际上通过否定词紧密相关。
chap3_para1492,2,,断言每个人都讨厌欧洲萝卜与断言不存在喜欢欧洲萝卜的人是等价的，反之亦然：
chap3_para1494,1,,我们可以更进一步——“每个人都喜欢冰激凌”意思是没有人不喜欢冰激凌：
chap3_para1496,1,,由于∀实际上是对全体对象的合取而∃则是析取，因此它们遵循德摩根律就不足为奇了。
chap3_para1496,2,,量化语句和非量化语句的德摩根律如下：
chap3_para1497,1,,因此，我们实际上并不同时需要∀和∃，正如我们不同时需要∧和∨一样。
chap3_para1497,2,,不过，可读性比简洁性更重要，因此我们同时保留这两种量词。
chap3_para1499,1,,除了使用前述的谓词和项，一阶逻辑还有一种构成原子语句的方式。
chap3_para1499,2,,我们可以使用等词符号（equality symbol）来表示两个项指代相同的对象。
chap3_para1499,3,,例如：
chap3_para15,1,"•Execution: The agent can now execute the actions in the solution, one at a time.",● 执行（execution）：现在智能体可以执行解中的动作，一次执行一个动作。
chap3_para150,1,"For finite state spaces that are trees it is efficient and complete; for acyclic state spaces it may end up expanding the same state many times via different paths, but will (eventually) systematically explore the entire space.",[8]　在这里，以及整本书中，C*中的“*”表示C的最优值。
chap3_para1500,1,,Father(John) = Henry
chap3_para1501,1,,表示Father(John)指代的对象与Henry指代的对象是相同的。
chap3_para1501,2,,由于解释会固定所有项的被指代物，确定等词语句的真值就只需要观察两项的被指代物是否为相同的对象即可。
chap3_para1502,1,,等词符号可以用于陈述关于给定函数的事实，正如我们对Father符号所做的那样。
chap3_para1502,2,,它也可以与否定合用，表示两项不是相同的对象。
chap3_para1502,3,,要表示理查至少有两个兄弟，我们可以写成
chap3_para1504,1,,就不能表示我们所期望的含义。
chap3_para1504,2,,具体来说，这条语句在图8-2的模型中也为真，尽管其中理查只有一个兄弟。
chap3_para1504,3,,要弄清楚这一点，考虑x和y都被指定到约翰国王的扩展解释。
chap3_para1504,4,,附加的排除了这种模型。
chap3_para1504,5,,记法可以用作的简写。
chap3_para1505,1,,8.2.8　数据库语义
chap3_para1506,1,,继续8.2.7节中的例子，假设我们相信理查有2个兄弟——约翰和杰弗里[8]，我们可以写
chap3_para1508,1,,[8]　实际上理查有4个兄弟，另外两个是威廉和亨利。
chap3_para151,1,In cyclic state spaces it can get stuck in an infinite loop; therefore some implementations of depth-first search check each new node for cycles.,一致代价搜索是完备的，也是代价最优的，因为它找到的第一个解的代价至少与边界上的任何其他节点的代价一样小。
chap3_para151,2,"Finally, in infinite state spaces, depth-first search is not systematic: it can get stuck going down an infinite path, even if there are no cycles.",一致代价搜索会按照代价递增的顺序系统地考虑所有路径，而不会陷入一直沿单一无限路径探索的困境（假设所有动作的代价 ）。
chap3_para151,3,"Thus, depth-first search is incomplete.",
chap3_para1510,1,,但这并不能完全反映我们要表示的状态。
chap3_para1510,2,,首先，这条断言在理查只有一个兄弟的模型中也为真——我们需要加上。
chap3_para1510,3,,其次，这条语句没有剔除理查除了约翰和杰弗里还有很多其他兄弟的模型。
chap3_para1510,4,,因此，对“理查的兄弟是约翰和杰弗里”的正确翻译如下：
chap3_para1511,1,,这条逻辑语句似乎比对应的自然语言表述烦琐很多。
chap3_para1511,2,,如果不能恰当地翻译自然语言，我们的逻辑推理系统就会犯错。
chap3_para1511,3,,我们能否构思一种语义，使逻辑语句更加直白呢？
chap3_para1512,1,,一种在数据库系统中非常流行的做法的工作方式如下。
chap3_para1512,2,,首先，我们确定每个常量符号都指代一个唯一的对象——唯一名称假设（unique-names assumption）。
chap3_para1512,3,,然后，我们假设未知其为真的原子语句事实上都为假——封闭世界假设（closed world assumption）。
chap3_para1512,4,,最后，我们调用域闭包（domain closure），意味着每个模型中的域元素不多于常量符号指代的那些。
chap3_para1513,1,,在由此产生的语义中，式（8-3）的确能表明理查仅有两个兄弟，约翰和杰弗里。
chap3_para1513,2,,我们称之为数据库语义（database semantics），以区别于标准的一阶逻辑语义。
chap3_para1513,3,,数据库语义也用于逻辑编程系统中，在9.4.4节我们对此进行解释。
chap3_para1514,1,,在数据库语义里考虑图8-4所示的情形中的所有可能的模型是很有指导性的。
chap3_para1514,2,,图8-5展示了其中一些模型，从没有元组满足关系的模型到所有元组都满足关系的模型。
chap3_para1514,3,,在有两个对象的情况下，有4种可能的二元素元组，存在24 = 16种不同的元组子集满足关系。
chap3_para1514,4,,因此，总共有16种可能模型——大大少于标准一阶逻辑语法下巨量的模型数量。
chap3_para1514,5,,不过，数据库语义需要世界中包含的东西的确定知识。
chap3_para1515,1,,图8-5　在数据库语义下，含有两个常量符号R和J以及一个二元关系符号的语言中的全部模型集的一部分成员。
chap3_para1515,2,,常量符号的解释是固定的，每个常量符号有唯一的对象
chap3_para1516,1,,这个例子引发了一个重要的观点：逻辑中不存在“正确的”语义。
chap3_para1516,2,,提出的语义的有用性取决于它对我们想要记录的知识的表示是否简洁和直观，以及相应的推断规则的生成是否容易和自然。
chap3_para1516,3,,当我们明确了知识库中描述的所有对象的身份，并且掌握了所有事实的时候，数据库语义最有用，而在其他情况下，数据库语义就很棘手。
chap3_para1516,4,,本章剩余部分，我们默认使用标准语义，并会在这种语义使表达变得非常繁琐的实例中另行标注。
chap3_para1517,1,,8.3　使用一阶逻辑
chap3_para1518,1,,现在我们已经定义了一种很有表达能力的逻辑语言，接下来我们学习如何使用它。
chap3_para1518,2,,本节，我们在一些简单的论域（domain）中给出范例语句。
chap3_para1518,3,,在知识表示中，论域是指我们要表示其知识的那部分世界。
chap3_para1519,1,,我们从简要地解释一阶知识库中的Tell/Ask推断开始。
chap3_para1519,2,,随后我们考察家庭关系、数、集合、列表以及wumpus世界论域。
chap3_para1519,3,,8.4.2节展示一个更大规模的示例（电子电路），而第10章则涵盖了宇宙万物。
chap3_para152,1,"With all this bad news, why would anyone consider using depth-first search rather than breadth-first or best-first? The answer is that for problems where a tree-like search is feasible, depth-first search has much smaller needs for memory. We don’t keep a reached table at all, and the frontier is very small: think of the frontier in breadth-first search as the surface of an ever-expanding sphere, while the frontier in depth-first search is just a radius of the sphere.",3.4.3　深度优先搜索与内存问题
chap3_para1520,1,,8.3.1　一阶逻辑的断言与查询
chap3_para1521,1,,语句是通过Tell添加到知识库的，与在命题逻辑中完全一样。
chap3_para1521,2,,这种语句被称为断言（assertion）。
chap3_para1521,3,,例如，我们可以断言约翰是国王、理查是人以及所有的国王都是人：
chap3_para1522,1,,我们可以使用Ask对知识库提问。
chap3_para1522,2,,例如：
chap3_para1523,1,,返回true。
chap3_para1523,2,,使用Ask提出的问题被称为查询或目标。
chap3_para1523,3,,一般来说，知识库中逻辑蕴含的所有查询都应该得到肯定的回答。
chap3_para1523,4,,例如，给定上述3条断言，查询
chap3_para1524,1,,应该也返回true。
chap3_para1524,2,,我们可以提出量化的问题，例如：
chap3_para1525,1,,答案为true，但它可能并不是我们想要的答案。
chap3_para1525,2,,它就像用“可以”回答“你能告我现在几点了吗？
chap3_para1525,3,,”一样。
chap3_para1525,4,,如果我们想了解使语句为真的x的值，我们就需要另一个函数AskVars：
chap3_para1526,1,,将返回一系列答案。
chap3_para1526,2,,在这个例子中有两个答案：以及。
chap3_para1526,3,,这种回答叫作置换（substitution）或绑定表（binding list）。
chap3_para1526,4,,AskVars通常与仅由霍恩子句构成的知识库合用，因为在这种知识库中，每种使查询为真的方式都将变量绑定到特定的值。
chap3_para1526,5,,而一阶逻辑中并不存在这种状况：在KB仅被告知King(John)的情况下，不存在使得查询∃x King(x)为真的x的单个绑定，即使这条查询实际上为真。
chap3_para1527,1,,8.3.2　亲属关系论域
chap3_para1528,1,,我们第一个考虑的范例是家庭关系（或称亲属关系）论域。
chap3_para1528,2,,这个论域包括类似“伊丽莎白是查尔斯的母亲”和“查尔斯是威廉的父亲”这样的事实，以及类似“一个人的祖母（外祖母）是他父母的母亲”这样的规则。
chap3_para1529,1,,显然，这个论域的对象是人。
chap3_para1529,2,,一元谓词包括Male和Female等。
chap3_para1529,3,,亲属关系（父母、兄弟、婚姻等）使用二元谓词表示：Parent、Sibling、Brother、Sister、Child、Daughter、Son、Spouse、Wife、Husband、Grandparent、Grandchild、Cousin、Aunt和Uncle。
chap3_para1529,4,,我们用函数表示Mother和Father，因为从生物学角度来说，每个人只有一对父母（尽管我们可以引入更多函数来处理养母、代孕妈妈等）。
chap3_para153,1,For a finite tree-shaped state-space like the one in Figure 3.,深度优先搜索（depth-first search）总是优先扩展边界中最深的节点。
chap3_para153,2,"11, a depth-first tree-like search takes time proportional to the number of states, and has memory complexity of only O(bm), where b is the branching factor and m is the maximum depth of the tree.",它可以通过调用Best-First-Search来实现，其中评价函数f为深度的负数。
chap3_para153,3,Some problems that would require exabytes of memory with breadth-first search can be handled with only kilobytes using depth-first search.,然而，它通常不是以图搜索的形式实现而是以树状搜索（不维护已达状态表）的形式实现。
chap3_para153,4,"Because of its parsimonious use of memory, depth-first tree-like search has been adopted as the basic workhorse of many areas of AI, including constraint satisfaction (Chapter 5), propositional satisfiability (Chapter 7), and logic programming (Chapter 9).",搜索的过程如图3-11所示，搜索先直接到达搜索树的最深层，这里的节点不存在后继节点。
chap3_para153,5,,然后，搜索将“回退”到下一个仍存在未扩展后继节点的最深的节点。
chap3_para153,6,,深度优先搜索不是代价最优的，它会返回它找到的第一个解，即使这个解不是路径代价最小的。
chap3_para1530,1,,我们可以考察每个函数和谓词，并就我们知道的写下它们与其他符号的关系。
chap3_para1530,2,,例如， 一个人的母亲就是他父母中的女性成员：
chap3_para1531,1,,一个人的丈夫是她的男性配偶：
chap3_para1532,1,,父母与孩子是反关系：
chap3_para1533,1,,祖父母（外祖父母）是一个人父母的父母：
chap3_para1534,1,,兄弟姐妹是一个人父母的其他孩子：
chap3_para1535,1,,我们可以像这样写出很多页，这正是习题8.KINS的题目。
chap3_para1536,1,,所有这些语句都可以看作亲属关系论域中的公理，如7.1节所阐述。
chap3_para1536,2,,公理通常与纯数学论域相关（我们很快就能看到一些关于数字的公理），但它们在所有论域都有用。
chap3_para1536,3,,它们提供了用于推导有用结论的基本因子化信息。
chap3_para1536,4,,我们的亲属关系公理同时也是定义，它们具有形式。
chap3_para1536,5,,公理用其他谓词定义了Mother函数以及Husband、Male、Parent、Grandparent和Sibling谓词。
chap3_para1536,6,,我们的定义从基本的谓词集（Child、Female等）发展而来，并以此最终定义其他谓词。
chap3_para1537,1,,这是构建一个论域的表示的自然方式，类似于用基本的库函数定义子程序，再用子程序构建软件包。
chap3_para1537,2,,注意，基本谓词集并不一定是唯一的，我们可以使用Parent而非Child来得到同样的结果。
chap3_para1537,3,,像我们所展示的一样，在一些论域中并不存在清晰可辨的基本谓词集。
chap3_para1538,1,,并非所有关于论域的逻辑语句都是公理，其中一些是定理，也就是说，它们被公理所蕴含。
chap3_para1538,2,,例如，考虑如下关于兄弟姐妹关系对称性的断言：
chap3_para1539,1,,这条语句是公理还是定理？
chap3_para1539,2,,实际上，它是与定义兄弟姐妹的公理逻辑一致的定理。
chap3_para1539,3,,如果我们用这条语句Ask知识库，它应当返回true。
chap3_para154,1,A variant of depth-first search called backtracking search uses even less memory.,图3-11　二叉树的深度优先搜索过程中，从开始状态A到目标M，共12步（从左到右，从上到下）。
chap3_para154,2,(See Chapter 5 for more details.,边界节点为绿色，用三角形表示下一步要扩展的节点。
chap3_para154,3,") In backtracking, only one successor is generated at a time rather than all successors; each partially expanded node remembers which successor to generate next.",已扩展的节点为淡紫色，潜在的未来节点用模糊的虚线表示。
chap3_para154,4,"In addition, successors are generated by modifying the current state description directly rather than allocating memory for a brand-new state.",边界中没有后继的已扩展节点（用非常模糊的线表示）可以丢弃
chap3_para154,5,This reduces the memory requirements to just one state description and a path of O(m) actions; a significant savings over O(bm) states for depth-first search.,
chap3_para154,6,"With backtracking we also have the option of maintaining an efficient set data structure for the states on the current path, allowing us to check for a cyclic path in O(1) time rather than O(m).",
chap3_para154,7,"For backtracking to work, we must be able to undo each action when we backtrack.",
chap3_para154,8,"Backtracking is critical to the success of many problems with large state descriptions, such as robotic assembly.",
chap3_para1540,1,,从纯逻辑的观点来看，知识库应当只包含公理并且不含有定理，因为定理并不能增加从知识库导出的结论集。
chap3_para1540,2,,从实用的角度来看，定理对于降低推导新语句的计算开销是很有意义的。
chap3_para1540,3,,没有定理，推理系统就不得不每次都从基本原则出发，就像物理学家每次求解问题时都要重新推导微积分的法则一样。
chap3_para1541,1,,并非所有的公理都是定义。
chap3_para1541,2,,一些公理提供了关于某些谓词的更一般的信息，却不构成定义。
chap3_para1541,3,,实际上，一些谓词并没有完整的定义，因为我们不具有完全刻画它们的知识。
chap3_para1541,4,,例如，没有显而易见的定义方式能够完成语句
chap3_para1542,1,,幸运的是，一阶逻辑允许我们使用Person谓词而无须对其进行完整定义。
chap3_para1542,2,,不过我们可以写出每个人具有的性质和使某物成为人的性质：
chap3_para1543,1,,"公理也可以是“直白的事实”，例如Male(Jim)和Spouse(Jim, Laura)。"
chap3_para1543,2,,这些来自特定问题实例描述的事实使特定的提问能够得到解答。
chap3_para1543,3,,如果一切顺利的话，这些问题的答案会成为与公理逻辑一致的定理。
chap3_para1544,1,,"我们常常会发现期望的答案不是现成的，例如，从Spouse(Jim, Laura)出发，我们期望（根据很多国家的法律）能推得，但这并不能由先前给出的公理推导得出，即便在我们像8.2.8节所述的那样添加也不行。"
chap3_para1544,2,,这表明缺失了一条公理。
chap3_para1544,3,,习题8.HILL要求读者提供这条公理。
chap3_para1545,1,,8.3.3　数、集合与列表
chap3_para1546,1,,数可能是展示从一小部分核心公理构建庞大理论的最生动的示例。
chap3_para1546,2,,我们在此阐述自然数或称非负整数的理论。
chap3_para1546,3,,我们需要谓词NatNum对于自然数为真，我们还需要常量符号0，以及一个函数符号S（后继）。
chap3_para1546,4,,皮亚诺公理（Peano axioms）定义了自然数和加法。
chap3_para1546,5,,[9]自然数是递归定义的：
chap3_para1548,1,,[9]　皮亚诺公理还包括归纳法则，但它是二阶逻辑的语句而非一阶逻辑。
chap3_para1548,2,,这种区别的重要性将在第9章中进行解释。
chap3_para1549,1,,也就是说，0是自然数，对于每一个对象n，如果n是自然数，则S(n)是自然数。
chap3_para1549,2,,"因此自然数是0, S(0), S(S(0)), …。"
chap3_para1549,3,,我们还需要约束后继函数的公理：
chap3_para155,1,3.,对于树型的有限状态空间，算法是有效且完备的。
chap3_para155,2,4.,对于无环状态空间，算法可能会通过不同路径多次扩展同一状态，但是（最终）将系统地探索整个空间。
chap3_para155,3,4Depth-limited and iterative deepening search,
chap3_para1550,1,,现在我们就可以用后继函数定义加法：
chap3_para1551,1,,这些公理中，第一个公理表示对任何自然数m加0等于m本身。
chap3_para1551,2,,"注意，在+(m, 0)项中二元函数符号“+”的使用：在普通数学中，这一项会使用中缀（infix）记法写作m + 0。"
chap3_para1551,3,,［我们在一阶逻辑中使用的记法称为前缀（prefix）。
chap3_para1551,4,,］为使我们关于数的语句更容易阅读，我们允许使用中缀记法。
chap3_para1551,5,,我们可以将S(n)写成n + 1，因此第二个公理变为
chap3_para1552,1,,这条公理将加法简化为对后继函数的反复应用。
chap3_para1553,1,,使用中缀记法是一个语法糖（syntactic sugar）的示例。
chap3_para1553,2,,语法糖是一种对标准语法的扩展或缩略，但不改变语义。
chap3_para1553,3,,所有使用糖的语句都可以“脱糖”生成普通一阶逻辑中的等价语句。
chap3_para1553,4,,还有一个示例是使用方括号而非圆括号来使左右括号的对应关系更易读。
chap3_para1553,5,,而另一个示例是量词折叠：用代替。
chap3_para1554,1,,我们有了加法以后，将乘法定义为重复的加法、乘方定义为连续的乘法就是顺理成章的事情，同样我们可以定义整数除法和余数、质数等。
chap3_para1554,2,,这样，整个数论（包括密码学）就能从一个常量、一个函数、一个谓词和4条公理开始构建起来。
chap3_para1555,1,,集合的论域对数学和常识推理也是非常重要的。
chap3_para1555,2,,（实际上，可以用集合论来定义数论。
chap3_para1555,3,,）我们希望能够表示每个集合，包括空集。
chap3_para1555,4,,我们需要一种方法用其他集合的元素或对其他集合的操作构建集合。
chap3_para1555,5,,我们想知道一个元素是否是集合的成员，也需要区分一个对象是否是集合。
chap3_para1556,1,,我们将使用集合论中的一般词汇作为语法糖。
chap3_para1556,2,,空集是一个常量，写作{}。
chap3_para1556,3,,一元谓词Set对集合为真。
chap3_para1556,4,,二元谓词包括（x是集合s的成员）以及（集合s1是集合s2的子集，两个集合也可以相同）。
chap3_para1556,5,,"二元函数是（交集）、（并集）和Add(x, s)（将元素x添加到集合s生成的集合）。"
chap3_para1556,6,,下面是一个可能的公理集。
chap3_para1557,1,,（1）集合只能是空集和向集合中添加元素产生的集合：
chap3_para1558,1,,（2）空集没有被加入的元素。
chap3_para1558,2,,换言之，无法将空集分解为更小的集合和元素：
chap3_para1559,1,,（3）对集合添加已有元素没有作用：
chap3_para156,1,"To keep depth-first search from wandering down an infinite path, we can use depth-limited search, a version of depth-first search in which we supply a depth limit, l, and treat all nodes at depth l as if they had no successors (see Figure 3.",在有环状态空间中，深度优先搜索算法可能陷入无限循环；因此，一些深度优先搜索算法的实现会检查每个新节点是否存在循环。
chap3_para156,2,12).,在无限状态空间中，深度优先搜索不是系统性的：即使没有循环，它也可能陷入无限路径。
chap3_para156,3,The time complexity is O(bl) and the space complexity is O(bl).,因此，深度优先搜索是不完备的。
chap3_para156,4,"Unfortunately, if we make a poor choice for l the algorithm will fail to reach the solution, making it incomplete again.",
chap3_para1560,1,,（4）集合中的成员只能是被添加到集合中的元素。
chap3_para1560,2,,我们用递归的形式表示它：声明x是s中的元素，当且仅当s等于某个将元素y添加到集合s2后的集合，其中y与x相同，或x是s2的成员：
chap3_para1561,1,,（5）一个集合是另一个集合的子集当且仅当第一个集合的所有成员都是第二个集合的成员：
chap3_para1562,1,,（6）两个集合相等当且仅当它们互为对方的子集：
chap3_para1563,1,,（7）一个对象在两个集合的交集中，当且仅当它同时是这两个集合的成员：
chap3_para1564,1,,（8）一个对象在两个集合的并集中，当且仅当它同时是某个集合的成员：
chap3_para1565,1,,列表与集合类似。
chap3_para1565,2,,它们的区别是，列表是有序的，相同的元素在列表中可以出现多次。
chap3_para1565,3,,我们可以用Lisp语言的词汇表示列表：Nil是没有元素的常量列表；Cons、Append、First和Rest是函数；Find在列表中的作用与Member在集合中的作用相同。
chap3_para1565,4,,List是仅对列表为真的谓词。
chap3_para1565,5,,与集合一样，涉及列表的逻辑语句也常用到语法糖。
chap3_para1565,6,,空列表是[]。
chap3_para1565,7,,"Cons(x, Nil)项（即仅含有元素x，尾部没有其他元素的列表）写作[x]。"
chap3_para1565,8,,"含有若干元素的列表，如[A, B, C]，对应于嵌套项。"
chap3_para1565,9,,习题8.LIST要求你写出列表的公理。
chap3_para1566,1,,8.3.4　wumpus世界
chap3_para1567,1,,第7章给出了wumpus世界的一些命题逻辑公理。
chap3_para1567,2,,本节介绍的一阶公理简洁得多，自然、精确地刻画了我们的意图。
chap3_para1568,1,,如前所述，wumpus世界智能体接收一个含有5个元素的感知向量。
chap3_para1568,2,,知识库中存储的对应一阶语句必须包含感知和感知出现的时间，否则，智能体会搞不清何时接收到什么感知。
chap3_para1568,3,,我们使用整数表示时间步。
chap3_para1568,4,,一个典型的感知语句是
chap3_para1569,1,,此处，Percept是二元谓词，Stench等是列表中的常量。
chap3_para1569,2,,wumpus世界中的动作可以用逻辑项表示：
chap3_para157,1,"Since depth-first search is a tree-like search, we can’t keep it from wasting time on redundant paths in general, but we can eliminate cycles at the cost of some computation time. If we look only a few links up in the parent chain we can catch most cycles; longer cycles are handled by the depth limit.",那么，为什么还会有人选择使用深度优先搜索而不是广度优先搜索或最佳优先搜索呢？
chap3_para157,2,,答案是，对于使用树状搜索可以处理的问题，深度优先搜索对内存的需求要小得多。
chap3_para157,3,,深度优先搜索根本不保留reached表，并且边界集很小：如果将广度优先搜索中的边界集视为不断扩展的球体的表面，那么深度优先搜索中的边界集只是球体的半径。
chap3_para1570,1,,要确定哪个动作最优，智能体程序执行查询
chap3_para1572,1,,将返回一个类似的绑定表。
chap3_para1572,2,,智能体程序将Grab作为要采取的动作。
chap3_para1572,3,,原始感知数据蕴涵了关于当前状态的某些事实。
chap3_para1572,4,,例如：
chap3_para1573,1,,这些规则展现了一个被称为感知的推理形式的细节，我们将在第25章进行深入研究。
chap3_para1573,2,,注意对时间t的量化。
chap3_para1573,3,,在命题逻辑中，我们需要每个时间步的每条语句的副本。
chap3_para1574,1,,简单的“反射”行为也可以用量化蕴涵式语句来实现。
chap3_para1574,2,,例如，我们有
chap3_para1575,1,,"给定感知和先前几段给出的规则，就能得出所需的结论BestAction(Grab, 5)，也就是说，Grab是要做的正确的事。"
chap3_para1576,1,,我们已经表示了智能体的输入和输出，现在可以表示环境本身了。
chap3_para1576,2,,我们从对象开始。
chap3_para1576,3,,显然，候选的对象有方格、无底洞和wumpus。
chap3_para1576,4,,"我们可以命名方格，如Square1,2等，但接下来Square1,2与Square1,3相邻的事实就必须是“额外”的事实，我们要为每一对方格列出一条这样的事实。"
chap3_para1576,5,,"使用行和列为整数的复合项是更好的做法，例如，我们可以简单地使用列表项[1, 2]。"
chap3_para1576,6,,任意相邻的方格可以定义为
chap3_para1577,1,,我们也可以为每个无底洞命名，但不宜这么做另有原因：没有必要去区分每个无底洞。
chap3_para1577,2,,[10]使用一元谓词Pit并使其在含有无底洞的方格中为真是更简单的做法。
chap3_para1577,3,,最后，由于只存在一个wumpus，用常量Wumpus与使用一元谓词并没什么区别（从wumpus的视角看，使用常量可能更威严）。
chap3_para1579,1,,[10]　同样，大多数人也不会为冬天迁徙到温暖地区的每一只鸟命名。
chap3_para1579,2,,但想研究迁徙模式、生存率等的鸟类学家要追踪每一只鸟，因此会为每只鸟命名，方法是为鸟安装腿环。
chap3_para158,1,Sometimes a good depth limit can be chosen based on knowledge of the problem.,对于图3-11所示的有限树状状态空间，深度优先的树状搜索所花费的时间与状态数成正比，其空间复杂性仅为O(bm)，其中b是分支因子，m是树的最大深度。
chap3_para158,2,"For example, on the map of Romania there are 20 cities.",有些问题在广度优先搜索时需要EB量级的内存，而在深度优先搜索时仅需要KB量级。
chap3_para158,3,"Therefore, l = 19 is a valid limit.",由于其对内存的节约使用，深度优先树状搜索已经成为许多人工智能领域的基本工具，例如，约束满足（第6章）、命题可满足性（第7章）和逻辑编程（第9章）。
chap3_para158,4,"But if we studied the map carefully, we would discover that any city can be reached from any other city in at most 9 actions.",
chap3_para158,5,"This number, known as the diameter of the state-space graph, gives us a better depth limit, which leads to a more efficient depth-limited search.",
chap3_para158,6,"However, for most problems we will not know a good depth limit until we have solved the problem.",
chap3_para1580,1,,"智能体的位置随时间变化，因此我们用At(Agent, s, t)来表示智能体在时间t位于方格s。"
chap3_para1580,2,,我们可以用将wumpus永远固定在一个位置。
chap3_para1580,3,,然后我们就可以说对象在一个时刻只能在一个位置：
chap3_para1581,1,,给定智能体的当前位置，它就可以用当前的感知来推断方格的属性。
chap3_para1581,2,,例如，如果智能体在一个方格中并感知到微风，则这个方格是有微风的：
chap3_para1582,1,,知道一个方格有微风很有用，因为我们知道无底洞是不能移动的。
chap3_para1582,2,,注意，Breezy没有时间参数。
chap3_para1583,1,,发现了哪些位置有微风（或有臭味）以及同样重要的哪些位置没有微风（或没有臭味），智能体就可以推导出无底洞的位置（以及wumpus的位置）。
chap3_para1583,2,,在命题逻辑中每个方格都需要一条公理（见7.4.3节的R2和R3），并且对每种世界的地形布局都需要一套不同的公理。
chap3_para1583,3,,而在一阶逻辑中我们只需要一条公理：
chap3_para1585,1,,类似地，一阶逻辑中我们可以量化所有时间，因此，对于每个谓词我们只需要一个后继状态公理，而非对每个时间步都保留副本。
chap3_para1585,2,,例如，箭的公理［式（7-2）］变为
chap3_para1586,1,,从这两个例子的语句可以看出，一阶逻辑的表达方式并不比第7章给出的自然语言描述更复杂。
chap3_para1586,2,,我们鼓励读者对智能体的位置和朝向构建类似的公理——在这些情况下，公理需要量化时间和空间。
chap3_para1586,3,,如命题状态估计一样，智能体可以对这样的公理使用逻辑推断来了解不能直接观测的那部分世界。
chap3_para1586,4,,第11章会更深入地研究一阶逻辑的后继状态公理以及它在构建规划中的用处。
chap3_para1587,1,,8.4　一阶逻辑中的知识工程
chap3_para1588,1,,8.3节展示了如何用一阶逻辑在3个简单的论域中表示知识。
chap3_para1588,2,,本节描述知识库构建的一般过程，这一过程称作知识工程（knowledge engineering）。
chap3_para1588,3,,知识工程师是研究一个特定论域，了解这个论域中哪些概念是重要的，并创建该论域中对象和关系的形式化表示的人。
chap3_para1588,4,,我们会阐述在电子电路论域中进行知识工程的过程。
chap3_para1588,5,,我们采用的方法适于构建专用知识库，这种知识库的论域是精心划定的，其查询的范围也是已知的。
chap3_para1588,6,,通用知识库则涵盖了较大范围的人类知识，用于支持像自然语言理解这样的任务，我们在第10章对其进行讨论。
chap3_para1589,1,,8.4.1　知识工程的过程
chap3_para159,1,"Iterative deepening search solves the problem of picking a good value for l by trying all values: first 0, then 1, then 2, and so on—until either a solution is found, or the depth-limited search returns the failure value rather than the cutoff value. The algorithm is shown in Figure 3.12. Iterative deepening combines many of the benefits of depth-first and breadth-first search. Like depth-first search, its memory requirements are modest: O(bd) when there is a solution, or O(bm) on finite state spaces with no solution. Like breadth-first search, iterative deepening is optimal for problems where all actions have the same cost, and is complete on finite acyclic state spaces, or on any finite state space when we check nodes for cycles all the way up the path.",回溯搜索（backtracking search）是深度优先搜索的一种变体，它使用的内存更少。
chap3_para159,2,,（详见第6章。
chap3_para159,3,,）在回溯搜索中，一次只生成一个后继，而不是所有后继节点；每个部分扩展的节点会记住下一个要生成的后继节点。
chap3_para159,4,,此外，回溯通过直接修改当前状态描述而不是为一个全新的状态分配内存来生成后继状态。
chap3_para159,5,,这将内存需求减少到只有一个状态描述和一条具有O(m)个动作的路径；与深度优先搜索的O(bm)个状态相比，节省了大量资源。
chap3_para159,6,,通过回溯，我们还可以为当前路径上的状态维护一个有效的集合数据结构，从而使检查循环的时间从O(m)减少到O(1)。
chap3_para159,7,,为了使回溯起作用，我们必须能够在回溯时撤销每个动作。
chap3_para159,8,,回溯对许多具有大型状态描述的问题（例如机器人组装）的成功求解至关重要。
chap3_para1590,1,,知识工程项目的内容、范围和难度各不相同，但所有这样的项目都包括如下的步骤。
chap3_para1591,1,,（1）确定问题。
chap3_para1591,2,,知识工程必须描述知识库要支持的问题范围，以及对每个特定问题实例可获取的事实类型。
chap3_para1591,3,,例如，wumpus知识库是需要能够选择动作，还是只需要回答关于环境内容的问题？
chap3_para1591,4,,传感器事实是否需要包括当前位置？
chap3_para1591,5,,任务将决定为了将问题实例连接到回答必须表示哪些知识。
chap3_para1591,6,,这一步类似于第2章用于设计智能体的PEAS过程。
chap3_para1592,1,,（2）收集相关知识。
chap3_para1592,2,,知识工程师可能已经是领域专家，也可能需要与真正的专家合作来获得他们的知识——这个过程叫作知识获取（knowledge acquisition）。
chap3_para1592,3,,在这一阶段，知识并非形式化表示的，这一步的主要目的是了解任务所确定的知识库的范围，以及了解这一领域的运行方式。
chap3_para1593,1,,对由人工产生的规则集定义的wumpus世界来说，我们很容易找出相关知识。
chap3_para1593,2,,（但是要注意，相邻关系的定义并不是由wumpus世界规则明确给出。
chap3_para1593,3,,）对于真实世界的论域，相关性问题可能非常困难，例如，仿真VLSI设计的系统可能需要，也可能不需要考虑杂散电容和集肤效应问题。
chap3_para1594,1,,（3）确定谓词、函数和常量的词汇表。
chap3_para1594,2,,也就是说，将重要的论域级概念翻译为逻辑级名称。
chap3_para1594,3,,这就涉及知识工程风格的许多问题。
chap3_para1594,4,,类似于编程风格，知识工程风格可能对项目最终成功与否产生重要影响。
chap3_para1594,5,,例如，无底洞应当被表示为对象还是表示为方格的一元谓词？
chap3_para1594,6,,智能体的朝向应当是函数还是谓词？
chap3_para1594,7,,wumpus的位置是否与时间相关？
chap3_para1594,8,,一旦做出这些决定，就会形成被称为论域的本体论（ontology）的词汇表。
chap3_para1594,9,,“本体论”一词是指关于存在或实存的本质的理论。
chap3_para1594,10,,本体论决定哪些东西存在，但不能决定它们的具体性质和相互关系。
chap3_para1595,1,,（4）对论域的通用知识编码。
chap3_para1595,2,,知识工程师为词汇表中的所有项写出公理。
chap3_para1595,3,,这就（尽可能地）固定了项的含义，使专家能够检查其内容。
chap3_para1595,4,,这一步经常会发现词汇表的概念误解或理解偏差，这必须返回第3步进行修正并重复这个过程。
chap3_para1596,1,,（5）对问题实例的描述编码。
chap3_para1596,2,,如果本体论确定得很恰当，这一步就相当容易。
chap3_para1596,3,,它涉及写出本体论中的概念实例的简单原子语句。
chap3_para1596,4,,对逻辑智能体来说，问题实例是由传感器提供的，而“无形”的知识库获取语句的方式与传统程序获取输入数据的方式相同。
chap3_para1597,1,,（6）向推断过程提出查询并获得答案。
chap3_para1597,2,,这是获得回报的一步：我们可以让推断过程在公理和问题相关的事实上运行来推导我们有兴趣了解的事实。
chap3_para1597,3,,这样，我们就不需要编写应用相关的求解算法了。
chap3_para1598,1,,（7）调试并评估知识库。
chap3_para1598,2,,很遗憾，查询得到的答案一开始往往是错误的。
chap3_para1598,3,,更准确地说，答案对于现有的知识库是正确的（如果假设推断过程是可靠的），但它们不是用户期望的答案。
chap3_para1598,4,,例如，如果缺失了一条公理，一些查询就不能从知识库中得到答案。
chap3_para1598,5,,这就需要大量的调试过程。
chap3_para1598,6,,关注推理链意外停止的地方可以轻易找出缺失或过弱的公理。
chap3_para1598,7,,例如，如果知识库为找到wumpus而含有诊断规则（见习题8.WUMD）：
chap3_para1599,1,,而没有采用双向蕴涵，智能体就永远不能证明wumpus不存在。
chap3_para1599,2,,不正确的公理是关于世界的错误陈述，因此可以被找出。
chap3_para1599,3,,例如，语句
chap3_para16,1,"It is an important property that in a fully observable, deterministic, known environment, the solution to any problem is a fixed sequence of actions: drive to Sibiu, then Fagaras, then Bucharest. If the model is correct, then once the agent has found a solution, it can ignore its percepts while it is executing the actions—closing its eyes, so to speak—because the solution is guaranteed to lead to the goal. Control theorists call this an open-loop system: ignoring the percepts breaks the loop between agent and environment. If there is a chance that the model is incorrect, or the environment is nondeterministic, then the agent would be safer using a closed-loop approach that monitors the percepts (see Section 4.4).",一个重要的性质是，在一个完全可观测的、确定性的、已知的环境中，任何问题的解都是一个固定的动作序列：开车到Sibiu，然后到Fagaras，最后到达Bucharest。
chap3_para16,2,,如果模型是正确的，那么一旦智能体找到了一个解，它就可以在执行动作时忽略它的感知（“闭上眼睛”），因为解一定会到达目标。
chap3_para16,3,,控制理论家称之为开环（open-loop）系统，因为忽略感知打破了智能体和环境之间的环路。
chap3_para16,4,,如果模型有可能是不正确的，或者环境是非确定性的，那么监控感知的闭环（closed-loop）方法会更安全（见4.4节）。
chap3_para160,1,Figure 3.,3.4.4　深度受限和迭代加深搜索
chap3_para160,2,12 Iterative deepening and depth-limited tree-like search.,
chap3_para160,3,Iterative deepening repeatedly applies depth-limited search with increasing limits.,
chap3_para160,4,"It returns one of three different types of values: either a solution node; or failure, when it has exhausted all nodes and proved there is no solution at any depth; or cutoff, to mean there might be a solution at a deeper depth than l.",
chap3_para160,5,"This is a tree-like search algorithm that does not keep track of reached states, and thus uses much less memory than best-first search, but runs the risk of visiting the same state multiple times on different paths.",
chap3_para160,6,"Also, if the IS-CYCLE check does not check all cycles, then the algorithm may get caught in a loop.",
chap3_para1600,1,,对爬行动物、两栖动物和桌子都不成立。
chap3_para1600,2,,判断这条语句的错误性可以不依赖于知识库的其他部分。
chap3_para1600,3,,但是，程序中的一个典型错误则如下：
chap3_para1601,1,,在不理解上下文的情况下，不可能判断offset应当是position还是position+1。
chap3_para1602,1,,当你的知识库中没有明显的错误时，似乎就要大功告成了。
chap3_para1602,2,,但最好还是通过在查询测试套件上运行系统并测量正确答案的数量来正式地评估系统，除非你的知识库明显没有错误。
chap3_para1602,3,,没有客观度量的话，你很容易就以为任务已经完成了。
chap3_para1602,4,,为了更好地理解这7个步骤，我们现在将其应用于一个扩展的示例——电子电路论域。
chap3_para1603,1,,8.4.2　电子电路论域
chap3_para1604,1,,我们将构建一个本体论和一个知识库，使我们能够进行关于图8-6所示的数字电路的推理。
chap3_para1604,2,,我们将遵循知识工程的7个步骤。
chap3_para1605,1,,图8-6　一位全加器的数字电路C1。
chap3_para1605,2,,前两个输入是要相加的两位，第三个输入是进位位。
chap3_para1605,3,,第一个输出是和，第二个输出是通往下一个加法器的进位位。
chap3_para1605,4,,电路包含两个异或门、两个与门和一个或门
chap3_para1607,1,,涉及数字电路的推理任务很多。
chap3_para1607,2,,最高层次的任务是分析电路的功能性。
chap3_para1607,3,,例如，图8-6的电路是否能够正确地做加法？
chap3_para1607,4,,如果所有输入都为高，A2门的输出是什么？
chap3_para1607,5,,关于电路结构的问题同样有趣。
chap3_para1607,6,,例如，连接到第一个输入端子的门有哪些？
chap3_para1607,7,,电路是否含有反馈回路？
chap3_para1607,8,,这都是这一步骤中的任务。
chap3_para1607,9,,还有更详细的分析层次，包括关于延迟、电路面积、功耗以及生产成本等的分析。
chap3_para1607,10,,所有这些层次的分析都需要额外的知识。
chap3_para1609,1,,我们对数字电路了解多少？
chap3_para1609,2,,根据我们的目的，这包括导线和门。
chap3_para1609,3,,信号沿着导线传输到门的输入端，每个门则在输出端产生一个信号沿着另一条导线传输。
chap3_para1609,4,,要确定这些信号是什么，我们需要了解门如何转换其输入信号。
chap3_para1609,5,,门有4种：具有两个输入端子的与门（AND）、或门（OR）和异或门（XOR），以及只有一个输入端子的非门（NOT）。
chap3_para1609,6,,所有门都只有一个输出端子。
chap3_para1609,7,,像门一样，电路本身也有输入端子和输出端子。
chap3_para161,1,"The time complexity is O(bd) when there is a solution, or O(bm) when there is none.",为了避免深度优先搜索陷入无限路径，我们可以使用深度受限搜索（depth-limited search）。
chap3_para161,2,"Each iteration of iterative deepening search generates a new level, in the same way that breadth-first search does, but breadth-first does this by storing all nodes in memory, while iterative-deepening does it by repeating the previous levels, thereby saving memory at the cost of more time.",这是一个深度优先搜索的改进版本，在深度受限搜索中，我们设置深度界限，将深度上的所有节点视为其不存在后继节点（见图3-12）。
chap3_para161,3,Figure 3.,深度受限搜索算法的时间复杂性为O(b)，空间复杂性为O(b)。
chap3_para161,4,"13 shows four iterations of iterative-deepening search on a binary search tree, where the solution is found on the fourth iteration.",遗憾的是，如果我们对的选择不当，算法将无法得到解，成为不完备的算法。
chap3_para1610,1,,要推理电路的功能性和连接性，我们不需要涉及导线本身、导线路径或导线连接点。
chap3_para1610,2,,重要的只有端子之间的连接——我们可以说某个输出端子连接到另一个输入端子，而不需要了解其实际的连接方式。
chap3_para1610,3,,其他因素，像元件的尺寸、形状、颜色或价格与我们的分析也不相关。
chap3_para1611,1,,如果我们的目的不是在门的层级验证设计，本体论就完全不同。
chap3_para1611,2,,例如，如果我们对于故障电路修复有兴趣，那么将导线纳入本体论就很可能是个好主意，因为导线的故障会妨碍在其中传输的信号。
chap3_para1611,3,,要解决时序故障，我们需要把门延迟加进本体论。
chap3_para1611,4,,如果我们要设计可盈利的产品，电路价格及其相对于市场上其他产品的速度就会很重要。
chap3_para1613,1,,我们现在已经知道我们要涉及电路、端子、信号和门。
chap3_para1613,2,,下一步选择用于表示它们的函数、谓词和常量。
chap3_para1613,3,,我们需要先将不同的门与其他对象区分开。
chap3_para1613,4,,每个门由常量命名的对象表示，我们用Gate(X1)来断言X1是门。
chap3_para1613,5,,每个门的行为由其类型决定，即常量AND、OR、XOR和NOT中的一种。
chap3_para1613,6,,由于一个门只能有一种类型，我们可以使用函数Type(X1) = XOR。
chap3_para1613,7,,电路与门类似，使用一个谓词来表示——Circuit(C1)。
chap3_para1614,1,,接下来我们考虑端子，使用谓词Terminal(x)表示。
chap3_para1614,2,,一个电路可以有一个或多个输入端子和一个或多个输出端子。
chap3_para1614,3,,"我们使用函数In(1, X1)来表示电路X1的第1个输入端子。"
chap3_para1614,4,,"相似的函数Out(n, c)用于输出端子。"
chap3_para1614,5,,"谓词Arity(c, i, j)断言电路c有i个输入端子和j个输出端子。"
chap3_para1614,6,,门之间的连接性可以用谓词Connected表示，它需要两个端子作为参数，如。
chap3_para1615,1,,最后，我们需要知道一个信号是通还是断。
chap3_para1615,2,,一种可能是使用一元谓词On(t)，在某个端子的信号通时为真。
chap3_para1615,3,,但这会增加提出类似“电路C1输出端子的所有可能信号值有哪些？
chap3_para1615,4,,”的问题的难度。
chap3_para1615,5,,因此我们引入两个信号值1和0作为对象，分别表示“通”和“断”，而用函数Signal(t)表示端子t的信号值。
chap3_para1616,1,,4. 对论域的通用知识编码
chap3_para1617,1,,好的本体论仅需要少量通用规则，并且可以简明地声明这些规则。
chap3_para1617,2,,如下是我们需要的全部公理。
chap3_para1618,1,,（1）如果两个端子连通，则它们信号相同：
chap3_para1619,1,,（2）每个端子的信号只能是1或0：
chap3_para162,1,"Figure 3.13 Four iterations of iterative deepening search for goal M on a binary tree, with the depth limit varying from 0 to 3. Note the interior nodes form a single path. The triangle marks the node to expand next; green nodes with dark outlines are on the frontier; the very faint nodes provably can’t be part of a solution with this depth limit.",由于深度优先搜索是一种树状搜索，通常无法避免在冗余路径上浪费时间，但我们可以以一定的计算时间为代价来消除循环。
chap3_para162,2,,沿着父节点向上查看几个节点，就能检测出大多数循环；更长的循环则由深度界限处理。
chap3_para1620,1,,（3）Connected具有交换性：
chap3_para1621,1,,（4）门的类型有4种：
chap3_para1622,1,,（5）与门的输出为0，当且仅当其任意输入为0：
chap3_para1623,1,,（6）或门的输出为1，当且仅当其任意输入为1：
chap3_para1624,1,,（7）异或门的输出为1，当且仅当其输入不相同：
chap3_para1625,1,,（8）非门的输出与其输入不同：
chap3_para1626,1,,（9）除了非门之外的所有门都有两个输入和一个输出：
chap3_para1627,1,,（10）电路有端子，数量不超过其输入和输出元数，不存在超出元数的任何东西：
chap3_para1628,1,,（11）门、端子和信号是不同的：
chap3_para163,1,Iterative deepening search may seem wasteful because states near the top of the search tree are re-generated multiple times.,有时可以根据对问题的了解选择一个较好的深度界限。
chap3_para163,2,"But for many state spaces, most of the nodes are in the bottom level, so it does not matter much that the upper levels are repeated.",例如，罗马尼亚地图上有20个城市。
chap3_para163,3,"In an iterative deepening search, the nodes on the bottom level (depth d) are generated once, those on the next-to-bottom level are generated twice, and so on, up to the children of the root, which are generated d times.",因此， = 19是一个有效的界限。
chap3_para163,4,So the total number of nodes generated in the worst case is,但是如果仔细研究地图，我们会发现，从任何一个城市到达另一个城市最多需要9步。
chap3_para163,5,,这个数值称为状态空间图的直径（diameter），它为我们提供了更好的深度界限，从而可以更有效地进行深度受限搜索。
chap3_para163,6,,然而，对于大多数问题，在求解问题之前，我们无法知道什么深度界限是好的。
chap3_para1630,1,,5. 对特定问题实例编码
chap3_para1631,1,,图8-6所示的电路被编码为电路C1并有如下描述。
chap3_para1631,2,,首先我们对电路及其门元件进行分类：
chap3_para1632,1,,随后我们给出其连接情况：
chap3_para1633,1,,6. 向推断过程提出查询
chap3_para1634,1,,哪种输入组合会使C1的第一个输出（求和位）为0，第二个输出（进位位）为1？
chap3_para1635,1,,答案是变量i1、i2和i3的置换，以使得语句被知识库所蕴含。
chap3_para1635,2,,AskVars将给我们3种这样的置换：
chap3_para1636,1,,加法器电路中所有端子的可能值的集合有哪些？
chap3_para1637,1,,最后这个查询将返回设备的完整输入输出表，可以用于检验它是否能正确做加法。
chap3_para1637,2,,这是电路验证（circuit verification）的一个简单示例。
chap3_para1637,3,,我们也可以使用电路的定义来构建更大的数字系统，并使用相同的验证方式。
chap3_para1637,4,,（见习题8.ADDR）许多论域都支持这种结构化的知识库创建方式，但需要在简单概念的基础上定义更为复杂的概念。
chap3_para1639,1,,我们可以以各种方式查询知识库以了解它会出现哪些错误行为。
chap3_para1639,2,,例如，假设我们没有阅读8.2.8节，因而忘记断言10。
chap3_para1639,3,,假设我们发现系统除了输入000和110的情况，无法证明电路的任何输出，我们可以通过询问每个门的输出的方式来找到问题。
chap3_para1639,4,,我们可以询问：
chap3_para164,1,"which gives a time complexity of O(bd)—asymptotically the same as breadth-first search. For example, if b = 10 and d = 5, the numbers are",迭代加深搜索（iterative deepening search）解决了如何选择一个合适的的问题，方法是尝试所有值：首先是0，然后是1，然后是2，依次类推——直到找到一个解，或者深度受限搜索返回failure值（而不是cutoff值）。
chap3_para164,2,,算法如图3-12所示。
chap3_para164,3,,迭代加深搜索结合了深度优先和广度优先搜索的许多优点。
chap3_para164,4,,和深度优先搜索一样，它对内存的需求也不大：当问题存在解时，是O(bd)，在不存在解的有限状态空间上，是O(bm)。
chap3_para164,5,,与广度优先搜索一样，迭代加深搜索对于所有动作都具有相同代价的问题是最优的，并且在有限无环状态空间上是完备的，或者说在任何有限状态空间上，当我们检查路径节点上所有的循环时，它都是完备的。
chap3_para1640,1,,结果显示在X1处对于输入10和01没有输出。
chap3_para1640,2,,因此，我们查看应用于X1的异或门的公理：
chap3_para1641,1,,如果输入已知为1和0，则上式简化为
chap3_para1642,1,,现在，问题就很明显了：系统不能推断出，因此，我们需要告诉它10。
chap3_para1644,1,,本章介绍了一阶逻辑，一种命题逻辑更具表达能力的表示语言。
chap3_para1644,2,,本章要点如下。
chap3_para1645,1,,● 知识表示语言应当是说明性的、合成式的、有表达能力的、上下文无关的且无歧义的。
chap3_para1646,1,,● 逻辑之间的区别在于其本体论约定和认识论约定，命题逻辑仅约定事实的存在，一阶逻辑则约定对象和关系的存在，因而增加了表达能力，适用于像wumpus世界和电子电路这样的论域。
chap3_para1647,1,,● 命题逻辑和一阶逻辑在表示模糊命题上都有困难。
chap3_para1647,2,,这一困难限制了它们在需要个人判断的论域的应用性，如政治或烹饪。
chap3_para1648,1,,● 一阶逻辑的语法构建于命题逻辑之上。
chap3_para1648,2,,它增加了项来表示对象，并且有全称量词和存在量词来构建关于被量化的变量的全部或部分可能值的断言。
chap3_para1649,1,,● 一阶逻辑的一个可能世界或模型包括一个对象集和一种将常量符号映射到对象、将谓词符号映射到对象的关系、将函数符号映射到对象上的函数的解释。
chap3_para165,1,"If you are really concerned about the repetition, you can use a hybrid approach that runs breadth-first search until almost all the available memory is consumed, and then runs iterative deepening from all the nodes in the frontier.",图3-12　迭代加深和深度受限树状搜索。
chap3_para165,2,"In general, iterative deepening is the preferred uninformed search method when the search state space is larger than can fit in memory and the depth of the solution is not known.",迭代加深搜索反复调用界限递增的深度受限搜索。
chap3_para165,3,,它返回以下3种类型的值中的一种：一个解节点；当它搜索了所有节点，证明在任何深度都不存在解时，返回failure；当在比更深的层上可能存在解时，返回cutoff。
chap3_para165,4,,这是一种树状搜索算法，它不记录reached状态，因此比最佳优先搜索使用的内存要少得多，但存在通过不同路径多次访问相同状态的风险。
chap3_para165,5,,另外，如果Is-Cycle检验函数不检查所有环，那么算法可能会陷入一个无限循环
chap3_para1650,1,,● 一条原子语句为真，仅当谓词命名的关系在项命名的对象之间成立。
chap3_para1650,2,,扩展解释将量词变量映射到模型中的对象，定义了量化语句的真值。
chap3_para1651,1,,● 在一阶逻辑中构建知识库需要严谨的过程来分析论域、选择词汇表、编码能支持所需推断的公理。
chap3_para1654,1,,第9章　一阶逻辑中的推断
chap3_para1655,1,,在本章中，我们定义有效的过程来回答用一阶逻辑提出的问题。
chap3_para1656,1,,在本章中，我们阐述能够回答所有可解的一阶逻辑问题的算法。
chap3_para1656,2,,9.1节介绍量词的推断规则，并展示如何将一阶逻辑推断约简为命题逻辑推断，尽管这样做代价巨大。
chap3_para1656,3,,9.2节描述了如何用合一来构建直接用于一阶逻辑的推断规则。
chap3_para1656,4,,随后我们讨论一阶逻辑推断的3类主要算法：前向链接（9.3节）、反向链接（9.4节）和基于归结的定理证明（9.5节）。
chap3_para1657,1,,9.1　命题推断与一阶推断
chap3_para1658,1,,进行一阶推断的方法之一是将一阶知识库转换为命题逻辑并使用我们已知的命题推断。
chap3_para1658,2,,第一步是消去全称量词。
chap3_para1658,3,,例如，假设我们的知识库含有典型的朴素道德公理，认为所有贪婪的国王都是邪恶的：
chap3_para1659,1,,由此我们可以推断出下列任一语句：
chap3_para166,1,3.,存在解时，时间复杂性为O(bd)，不存在解时，时间复杂性为O(bm)。
chap3_para166,2,4.,与广度优先搜索相同，迭代加深搜索的每次迭代也会生成一个新层级，但是广度优先搜索将所有节点都存储在内存中，而迭代加深搜索则会重复之前的层级，从而以花费更多的时间为代价节省了内存。
chap3_para166,3,5Bidirectional search,图3-13展示了二叉搜索树上的迭代加深搜索的4次迭代，在第4次迭代时找到了解。
chap3_para1660,1,,一般来说，全称量词实例化（universal instantiation，UI）表明我们可以通过用基本项（没有变量的项）置换全称量化的变量来推断任意语句。
chap3_para1660,2,,[1]
chap3_para1662,1,,[1]　不要把此处的置换与8.2.6节用于定义量词语义的扩展解释搞混了。
chap3_para1662,2,,置换用项（term，语法片段）代替变量来产生新的语句，而解释将变量映射到论域中的实例。
chap3_para1663,1,,我们使用8.3节介绍过的置换来形式化地写出推断规则。
chap3_para1663,2,,令表示对语句应用置换后的语句。
chap3_para1663,3,,则对于任意变量v和基本项g，规则写作
chap3_para1664,1,,前述的3条语句就是分别用置换、和得到的。
chap3_para1665,1,,类似地，存在量词实例化（existential instantiation）用一个新的常量符号替换存在量化的变量。
chap3_para1665,2,,其形式化描述如下：对于任意语句、变量v和未在知识库其他地方出现的常量符号k，
chap3_para1668,1,,只要C1未在知识库的其他地方出现。
chap3_para1668,2,,简单来说，存在语句表明存在满足某个条件的对象，运用存在实例化就是给这个对象命名。
chap3_para1668,3,,当然，这个名称不能已经属于其他对象。
chap3_para1668,4,,数学中有一个很好的例子：假设我们发现有一个数字比2.718 28稍大，并满足等式中的x。
chap3_para1668,5,,我们可以将这个数字命名为e，但不能将其命名为已经存在的对象名，如。
chap3_para1668,6,,在逻辑中，新的名称被称为斯科伦常量（Skolem constant）。
chap3_para1669,1,,全称量词实例化可以多次用于同一条公理来产出许多不同结果，而存在量词实例化只需要使用一次，随后就可以丢掉存在量化的语句。
chap3_para1669,2,,"例如，一旦我们添加了语句Kill(Murderer, Victim)的话，就不再需要。"
chap3_para167,1,The algorithms we have covered so far start at an initial state and can reach any one of multiple possible goal states.,迭代加深搜索可能看起来很浪费，因为搜索树顶端附近的状态被多次重复生成。
chap3_para167,2,"An alternative approach called bidirectional search simultaneously searches forward from the initial state and backwards from the goal state(s), hoping that the two searches will meet.",但是对于许多状态空间，大多数节点位于底层，所以上层是否重复并不重要。
chap3_para167,3,The motivation is that bd/2 + bd/2 is much less than bd (e.,在迭代加深搜索中，底层（深度d）的节点被生成一次，倒数第二层的节点被生成两次，以此类推，直到根节点的子节点（生成d次）。
chap3_para167,4,g.,所以在最坏情况下生成的节点总数是
chap3_para167,5,", 50,000 times less when b = d = 10).",
chap3_para1671,1,,我们现在展示如何将任意一阶知识库转换为命题知识库。
chap3_para1671,2,,第一个想法是，正如存在量化语句能够用一个实例代替一样，全称量化语句也可以用所有可能实例的集合代替。
chap3_para1671,3,,例如，假设我们的知识库仅含有语句
chap3_para1673,1,,且对象仅有John和Richard。
chap3_para1673,2,,我们用所有可能的置换，和，对第一条语句应用全称量词实例化。
chap3_para1673,3,,我们得到
chap3_para1674,1,,接下来用命题符号（如JohnIsKing）替换基本原子语句（如King(John)）。
chap3_para1674,2,,最后，用第7章的任意完备的命题算法得到如JohnIsEvil的结论，它等价于Evil(John)。
chap3_para1675,1,,正如我们将在9.5节中讨论的，这种命题化（propositionalization）技术可以被彻底一般化。
chap3_para1675,2,,然而，如果知识库中包含函数符号，可能的基本项置换集是无穷的！
chap3_para1675,3,,例如，如果知识库提到Father函数，就可以构建像Father(Father(Father(John)))这样的无穷多的嵌套项。
chap3_para1676,1,,"幸运的是，雅克·埃尔布朗（Jacques Herbrand）针对这一现象提出了著名的定理，即如果语句被原始的一阶知识库蕴含，则存在仅涉及命题化知识库的有限子集的证明（Herbrand, 1930）。"
chap3_para1676,2,,由于任意这样的子集都有其基本项的最大嵌套深度，我们可以通过先生成含有常量符号（Richard和John）的所有实例化，然后再生成深度为1的所有项（Father(Richard)和Father(John)），然后是深度为2的所有项，以此类推，直到我们能够构建所蕴含语句的命题证明。
chap3_para1677,1,,我们已经概述了通过命题化进行一阶逻辑推断的完备方法，也就是，所有蕴含的语句都可以被证明。
chap3_para1677,2,,这是一个重大的成就，特别是在可能模型的空间无限大的情况下。
chap3_para1677,3,,但是，在证明完成前我们并不知道语句是被蕴含的！
chap3_para1677,4,,如果语句并不被蕴含怎么办？
chap3_para1677,5,,我们能证明吗？
chap3_para1677,6,,实际上，对于一阶逻辑，答案是否定的。
chap3_para1677,7,,我们的证明程序会一直运行，生成越来越深的嵌套项，但我们不知道它是陷入绝望的循环，还是就快要得出证明结果。
chap3_para1677,8,,这非常类似于图灵机的停机问题。
chap3_para1677,9,,"艾伦·图灵（Turing, 1936）和阿朗佐·丘奇（Church, 1936）分别以不同方式证明了这种情况的不可避免性。"
chap3_para1677,10,,一阶逻辑的蕴含问题是半可判定的，也就是，存在能判定所有蕴含的语句的算法，却不存在能够判定所有不蕴含的语句的算法。
chap3_para1678,1,,9.2　合一与一阶推断
chap3_para1679,1,,眼尖的读者可能已经注意到命题化方法生成了许多不必要的全称量化语句的实例。
chap3_para1679,2,,我们希望有一个方法，仅使用一条规则，以如下方式推理出解答了查询：给定贪婪的国王都是邪恶的这条规则，找出某个x使得x为国王且x是贪婪的，进而推断出这个x是邪恶的。
chap3_para1679,3,,更一般地说，如果存在某个置换使得每个蕴涵式前提的合取子句与知识库中的语句完全相同，那么我们就在应用后，断言蕴涵式的结论。
chap3_para1679,4,,这种情况下，置换能达到这一目的。
chap3_para1679,5,,假设现在我们不知道Greedy(John)，但我们知道所有人都是贪婪的：
chap3_para168,1,"For this to work, we need to keep track of two frontiers and two tables of reached states, and we need to be able to reason backwards: if state sʹ is a successor of s in the forward direction, then we need to know that s is a successor of sʹ in the backward direction. We have a solution when the two frontiers collide.9",时间复杂性为O(bd)——与广度优先搜索相近。
chap3_para168,2,,例如，当b = 10、d = 5时，生成的节点数分别为
chap3_para1681,1,,则我们仍然能够断定Evil(John)，因为我们知道约翰是国王（已给定）且约翰是贪婪的（因为每个人都是贪婪的）。
chap3_para1681,2,,为了能采取这种做法，我们需要找出一个置换，来同时取代蕴涵语句中的变量和知识库中待匹配语句中的变量。
chap3_para1681,3,,这种情况下，对蕴涵式的前提King(x)和Greedy(x)使用置换就会使它们完全相同。
chap3_para1681,4,,这样我们可以推断出蕴涵式的后件。
chap3_para1682,1,,这种推断过程可以表述为一条单独的推断规则被称为一般化肯定前件[2]（generalized Modus Ponens）。
chap3_para1682,2,,对于原子语句pi、和q，存在置换使得对所有i有，有
chap3_para1684,1,,[2]　一般化肯定前件比肯定前件（7.5.1节）更一般化，因为已知的事实和蕴涵式的前提只需要与一个置换匹配，而不需要完全一致。
chap3_para1684,2,,但肯定前件允许任意语句作为前提，而非仅是原子语句的合取。
chap3_para1685,1,,这条规则有n+1个前提：n个原子语句和一个蕴涵式。
chap3_para1685,2,,结论是对后件q运用置换的结果。
chap3_para1685,3,,对我们的例子来说：
chap3_para1686,1,,是King(John)　　　　　　　　　　 p1是King(x)
chap3_para1687,1,,是Greedy(y)　　　　　　　　　　　p2是Greedy(x)
chap3_para1688,1,,是　　　　　　　　q是Evil(x)
chap3_para1689,1,,是Evil(John)
chap3_para169,1,"There are many different versions of bidirectional search, just as there are many different unidirectional search algorithms.",如果你确实很在意重复的问题，可以使用一种混合方法，即先运行广度优先搜索，直到几乎消耗掉所有可用内存，然后对边界集中的所有节点应用迭代加深搜索。
chap3_para169,2,"In this section, we describe bidirectional best-first search.",通常，当搜索状态空间大于内存容量而且解的深度未知时，迭代加深搜索是首选的无信息搜索方法。
chap3_para169,3,"Although there are two separate frontiers, the node to be expanded next is always one with a minimum value of the evaluation function, across either frontier.",
chap3_para169,4,"When the evaluation function is the path cost, we get bidirectional uniform-cost search, and if the cost of the optimal path is C*, then no node with cost will be expanded.",
chap3_para169,5,This can result in a considerable speedup.,
chap3_para1690,1,,很容易证明一般化肯定前件是可靠的推断规则。
chap3_para1690,2,,首先，我们观察到，对于任意语句p（假设其变量是全称量化的）和任意置换，
chap3_para1691,1,,根据全称量词实例化为真。
chap3_para1691,2,,特别地，它对于满足一般化肯定前件规则条件的为真。
chap3_para1691,3,,因此，我们可以从推断
chap3_para1692,1,,并且，从蕴涵式我们可以推断
chap3_para1693,1,,现在，一般化肯定前件规则中的已被定义为对所有i使得，因此这两条语句中，第一条语句正好匹配第二条语句的前提。
chap3_para1693,2,,根据肯定前件规则可得。
chap3_para1694,1,,一般化肯定前件是肯定前件的提升版——它将肯定前件从基本（无变量的）命题逻辑提升到一阶逻辑。
chap3_para1694,2,,我们将在本章其余部分看到第7章中的前向链接、反向链接和归结算法的提升版。
chap3_para1694,3,,提升版推断规则相比于命题化的重要优势在于，提升版推断规则只需必要的置换就可以进行特定的推断。
chap3_para1696,1,,提升版推断规则需要找出使不同的逻辑表达式看起来相同的置换。
chap3_para1696,2,,这一过程被称作合并（unification），是所有一阶逻辑推断算法的重要组成部分。
chap3_para1696,3,,合一算法Unify接收两条语句作为输入，如果存在置换，则为它们返回一个合一子（unifier）（即这个置换）：
chap3_para1697,1,,我们用一个例子来展示Unify的工作方式。
chap3_para1697,2,,"假设有查询AskVar(Knows(John, x))：约翰认识谁？"
chap3_para1697,3,,"这条查询的答案可以通过找出知识库中所有与Knows(John, x)合一的语句来找到。"
chap3_para1697,4,,此处有与4条不同语句合并而来的结果，它们可能在知识库中：
chap3_para1698,1,,最后一条合一失败了，因为x不能同时取值为John和Elizabeth。
chap3_para1698,2,,"但我们知道Knows(x, Elizabeth)的意思是“所有人都认识伊丽莎白”，因此我们应该可以推断出约翰认识伊丽莎白。"
chap3_para1698,3,,之所以出现问题是因为两条语句恰好使用了相同的变量名x。
chap3_para1698,4,,对要合一的两条语句中的一条进行标准化分离（standardizing apart），也就是对其变量进行重命名来避免名称冲突，就可以解决这一问题。
chap3_para1698,5,,"例如，我们可以将Knows(x, Elizabeth)中的x重命名为（新变量名）x17而不会改变其含义。"
chap3_para1698,6,,现在就可以进行合一了：
chap3_para1699,1,,习题9.STAN深入探讨了标准化分离的必要性。
chap3_para17,1,"In partially observable or nondeterministic environments, a solution would be a branching strategy that recommends different future actions depending on what percepts arrive. For example, the agent might plan to drive from Arad to Sibiu but might need a contingency plan in case it arrives in Zerind by accident or finds a sign saying “Drum Închis” (Road Closed).",在部分可观测或非确定性环境中，问题的解将是一个根据感知推荐不同的未来动作的分支策略。
chap3_para17,2,,例如，智能体可能规划从Arad开车到Sibiu，但还需要一个应变规划，以防它不小心到了Zerind或者发现了“Drum Închis”（道路封闭）的标志。
chap3_para170,1,The general best-first bidirectional search algorithm is shown in Figure 3.,图3-13　二叉搜索树上的迭代加深搜索的4次迭代（目标为M），深度界限从0到3。
chap3_para170,2,14.,注意，内部节点形成了一条路径。
chap3_para170,3,"We pass in two versions of the problem and the evaluation function, one in the forward direction (subscript F) and one in the backward direction (subscript B).",三角形标记下一步要扩展的节点，边界为加粗轮廓的绿色节点，非常模糊的节点可被证明不可能是这种深度界限下的解的一部分
chap3_para170,4,"When the evaluation function is the path cost, we know that the first solution found will be an optimal solution, but with different evaluation functions that is not necessarily true.",
chap3_para170,5,"Therefore, we keep track of the best solution found so far, and might have to update that several times before the TERMINATED test proves that there is no possible better solution remaining.",
chap3_para1700,1,,还有一个麻烦：我们说过Unify应当返回使两个参数看起来相同的置换。
chap3_para1700,2,,但这样的合一子可能不止一种。
chap3_para1700,3,,例如，可能返回或者。
chap3_para1700,4,,第一个合一子的结果是，而第二个合一子的结果是。
chap3_para1700,5,,第二个结果可以在第一个结果的基础上置换得出，因此我们说第一个合一子比第二个更一般化，因为它对变量的值的限制更少。
chap3_para1701,1,,每一对可合一的表达式都有一个最一般合一子（most general unifier，MGU），在不考虑变量的重命名和置换的情况下，它是唯一的。
chap3_para1701,2,,例如，和被看作是等价的，和也是等价的。
chap3_para1702,1,,图9-1展示了一个用于计算最一般合一子的算法。
chap3_para1702,2,,这一过程很简单：同时递归地交替探索两个表达式，并在这个过程中创建合一子，如果结构中的两个对应点不匹配则返回失败。
chap3_para1702,3,,这个过程中存在一个高代价的步骤：当匹配某变量和一个复合项时，必须检查这个变量是否出现在这一复合项中；如果是，则匹配失败，因为无法构建一致的合一子。
chap3_para1702,4,,例如，S(x)无法与S(S(x))合一。
chap3_para1702,5,,这种出现检验（occur check）使得整个算法的复杂性是待合一的表达式规模的二次方。
chap3_para1702,6,,包括许多逻辑编程系统在内的一些系统干脆取消了出现检验，将避免不可靠推断的责任推给用户。
chap3_para1702,7,,其他系统则使用具有线性复杂性的更为复杂的合一算法。
chap3_para1703,1,,图9-1　合一算法。
chap3_para1703,2,,参数x和y可以是任意表达式：一个常量或者一个变量，或复合表达式（如复合的语句或项），或一系列表达式。
chap3_para1703,3,,参数是一个置换，初始值为空置换，但会随着我们在输入、逐个比较表达式元素的递归中加入。
chap3_para1703,4,,"在如F(A, B)的复合表达式中，Op(x)函数提取函数符号F而Args(x)函数提取参数表(A,B)"
chap3_para1704,1,,9.2.2　存储与检索
chap3_para1705,1,,用于告知和询问知识库的Tell、Ask和AskVar函数的底层是更基本的Store和Fetch函数。
chap3_para1705,2,,Store(s)将语句s存入知识库，而Fetch(q)返回所有使查询q与知识库中某个语句合一的合一子。
chap3_para1705,3,,"之前我们用于解释合一的例题（找出能与Knows(John, x)合一的所有事实）就是Fetch的一个实例。"
chap3_para1706,1,,实现Store和Fetch最简单的方式就是在一个长列表中列出所有事实，并将每个查询与列表中的每个元素合一。
chap3_para1706,2,,这种过程很低效，却可以正常工作。
chap3_para1706,3,,本节余下部分将概述使检索更为高效的方法。
chap3_para1707,1,,我们可以通过确保仅对有一定合一可能的语句进行合一来使Fetch更高效。
chap3_para1707,2,,"例如，合一Knows(John, x)和Brother(Richard, John)就没什么意义。"
chap3_para1707,3,,我们可以通过索引知识库中的事实来避免这种合一。
chap3_para1707,4,,一种叫作谓词索引的简单方法将所有Knows开头的事实放入一个存储桶内，而将所有Brother开头的事实放入另一个存储桶内。
chap3_para1707,5,,而这些存储桶可以用哈希表存储，以提高效率。
chap3_para1708,1,,谓词索引对于谓词符号很多而每个符号只有少量子句的情形非常有用。
chap3_para1708,2,,但有时，一个谓词有许多子句。
chap3_para1708,3,,"例如，假设税务部门想用谓词Employs(x, y)掌握雇佣关系情况。"
chap3_para1708,4,,这就会形成一个非常大的存储桶，其中很可能有几百万雇主和几千万雇员。
chap3_para1708,5,,"用谓词索引方法回答如Employs(x, Richard)这样的查询就需要搜索整个存储桶。"
chap3_para1709,1,,对于这类特殊的查询，如果除谓词外再使用第二个参数一起索引事实的话，就可能改善效率。
chap3_para1709,2,,这种方法也许要用到组合的哈希表键值。
chap3_para1709,3,,这样我们只要用查询构造键值，就能精确地检索到能与查询合一的事实。
chap3_para1709,4,,"对于其他查询，如Employs(IBM, y)，我们可能需要结合谓词和第一个参数来索引事实。"
chap3_para1709,5,,因此，事实可以存储在多个索引键值之下，以便各种可能与之合一的查询迅速地找到它们。
chap3_para171,1,Figure 3.,3.4.5　双向搜索
chap3_para171,2,14 Bidirectional best-first search keeps two frontiers and two tables of reached states.,
chap3_para171,3,"When a path in one frontier reaches a state that was also reached in the other half of the search, the two paths are joined (by the function JOIN-NODES) to form a solution.",
chap3_para171,4,The first solution we get is not guaranteed to be the best; the function TERMINATED determines when to stop looking for new solutions.,
chap3_para1710,1,,给定要存储的语句，可以对所有可能与之合一的查询构建索引。
chap3_para1710,2,,"对于Employs(IBM, Richard)这样的事实，查询为"
chap3_para1711,1,,"Employs(IBM, Richard)（IBM是否雇佣了理查？"
chap3_para1711,2,,）
chap3_para1712,1,,"Employs(x, Richard)（谁雇佣了理查？"
chap3_para1712,2,,）
chap3_para1713,1,,"Employs(IBM, y)（IBM雇佣了谁？"
chap3_para1713,2,,）
chap3_para1714,1,,"Employs(x, y)（谁雇佣了谁？"
chap3_para1714,2,,）
chap3_para1715,1,,这些查询构成了一个包容格（subsumption lattice），如图9-2a所示。
chap3_para1715,2,,包容格具有一些有趣的性质。
chap3_para1715,3,,格中任意节点的子节点都是对父节点进行一次置换而来，而任意两个节点的 “最高” 共同后代则是应用最一般合一子的结果。
chap3_para1715,4,,具有重复常量的语句的格略有不同，如图9-2b所示。
chap3_para1715,5,,尽管函数符号并未在图中体现，但它们也可以被纳入这种格结构中。
chap3_para1716,1,,"图9-2　（a）最低节点为Employs(IBM, Richard)的包容格。"
chap3_para1716,2,,"（b）语句Employs(John, John)的包容格"
chap3_para1717,1,,对于只有少量参数的谓词符号，为包容格中每一个点创建一个索引是一种很好的权衡。
chap3_para1717,2,,这增加了一点点存储时间，但节省了检索时间。
chap3_para1717,3,,然而，对于有n个参数的谓词，其包容格含有O(2n)个节点。
chap3_para1717,4,,如果允许函数符号的话，节点的数量同样是要存储的语句中项的数量的指数级。
chap3_para1717,5,,这就会导致大量的索引。
chap3_para1718,1,,我们不得不采用一些方法将索引的范围限制为可能被查询频繁使用的节点，否则我们花在创建索引上的时间可能比使用索引而节省的时间还多。
chap3_para1718,2,,我们可以采取固定的策略，譬如只维护键值由一个谓词和单个参数构成的索引。
chap3_para1718,3,,我们还可以习得一种自适应的策略，它能够创建索引来满足各类查询的要求。
chap3_para1718,4,,对于事实数量以十亿计的商用数据库，一直有对这一课题的大量的研究、技术开发和持续改进。
chap3_para172,1,3.,到目前为止，我们介绍的算法都是从一个初始状态开始，最终到达多个可能目标状态中的任意一个。
chap3_para172,2,4.,另一种称为双向搜索（bidirectional search）的方法则同时从初始状态正向搜索和从目标状态反向搜索，直到这两个搜索相遇。
chap3_para172,3,6Comparing uninformed search algorithms,算法的动机是，要比bd小得多（例如，当b = d = 10时，复杂性不到之前算法的五万分之一）。
chap3_para1720,1,,在7.5节中我们展示了用于命题确定子句知识库的前向链接算法。
chap3_para1720,2,,本节我们拓展这个概念以涵盖一阶确定子句。
chap3_para1721,1,,当然，有一些逻辑语句无法被表述为确定子句，因此也无法用这种方法处理。
chap3_para1721,2,,但形如Antecedent ⇒ Consequent的规则足以涵盖许多有趣的真实世界系统。
chap3_para1722,1,,9.3.1　一阶确定子句
chap3_para1723,1,,一阶确定子句是文字的析取式，其中必须有且仅有一个正文字。
chap3_para1723,2,,这意味着确定子句要么是原子的，要么是前件为正文字的合取、后件为单个正文字的蕴涵式。
chap3_para1723,3,,存在量词在此处不能使用，而全称量词则被隐式地表示：如果你在确定子句中看到x，就意味着有隐含的∀x量词。
chap3_para1723,4,,典型的一阶逻辑确定子句如下：
chap3_para1724,1,,但文字King(x)和Greedy(y)也可以看作确定子句。
chap3_para1724,2,,一阶文字可以含有变量，因此Greedy(y)被解释为“每个人都是贪婪的”（全称量词是隐含的）。
chap3_para1725,1,,我们用确定子句表示如下问题：
chap3_para1726,1,,法律规定，美国人将武器出售给敌对国家是犯罪行为。
chap3_para1726,2,,诺诺（Nono）国是美国的敌人，它拥有一些导弹，所有导弹都是韦斯特（West）上校出售给它的，而韦斯特上校是美国人。
chap3_para1727,1,,首先，我们用一阶确定子句表示这些事实。
chap3_para1728,1,,“……美国人将武器出售给敌对国家是犯罪行为”：
chap3_para173,1,"Figure 3.15 compares uninformed search algorithms in terms of the four evaluation criteria set forth in Section 3.3.4. This comparison is for tree-like search versions which don’t check for repeated states. For graph searches which do check, the main differences are that depth-first search is complete for finite state spaces, and the space and time complexities are bounded by the size of the state space (the number of vertices and edges, |V | + |E|).",为此，我们需要维护两个边界集和两个已达状态表，并且要能反向推理：如果状态s'是s的正向后继，那么我们需要知道s是s'的反向后继。
chap3_para173,2,,当两个边界触碰到一起时，我们就找到了一个解。
chap3_para173,3,,[9]
chap3_para1730,1,,表示“诺诺国……拥有一些导弹”的语句被转换为两个存在量化的确定子句，其中引入了新的常量M1：
chap3_para1733,1,,“所有导弹都是韦斯特上校出售给它的”：
chap3_para1735,1,,我们还需要知道导弹是武器：
chap3_para1737,1,,且我们必须知道美国的敌人是“敌对的”：
chap3_para1739,1,,“而韦斯特上校是美国人……”：
chap3_para174,1,"Figure 3.15Evaluation of search algorithms. b is the branching factor; m is the maximum depth of the search tree; d is the depth of the shallowest solution, or is m when there is no solution; l is the depth limit. Superscript caveats are as follows: 1 complete if b is finite, and the state space either has a solution or is finite. 2 complete if all action costs are ≥ ϵ > 0; 3 cost-optimal if action costs are all identical; 4 if both directions are breadth-first or uniform-cost.",
chap3_para1741,1,,“诺诺国是美国的敌人……”：
chap3_para1743,1,,这个知识库恰好是一个数据日志（datalog）知识库：数据日志是由不含函数符号的一阶确定子句组成的语言。
chap3_para1743,2,,它能够表示由关系数据库生成的陈述类型，故得名。
chap3_para1743,3,,没有了函数符号使推断更容易。
chap3_para1744,1,,9.3.2　简单的前向链接算法
chap3_para1745,1,,图9-3展示了简单的前向链接推断算法。
chap3_para1745,2,,它从已知事实开始，触发所有前提被满足的规则，将结论添加到已知事实中。
chap3_para1745,3,,这一过程不断重复，直到查询得到回答（假设只需要一个回答）或没有新的事实被添加。
chap3_para1745,4,,注意，如果一个事实只是某个已知事实的重命名，也就是只有变量名字不同的语句，那它就不是一个“新”事实。
chap3_para1745,5,,"例如，Likes(x, IceCream)与Likes(y, IceCream)互为重命名。"
chap3_para1745,6,,它们都意味着相同的事情：“每个人都喜欢冰激凌”。
chap3_para1746,1,,图9-3　一个概念上很直观，但低效的前向链接算法。
chap3_para1746,2,,每次迭代，它都将那些用一步就可以从已经在KB中的蕴涵语句和原子语句推断出的原子语句添加到KB中。
chap3_para1746,3,,函数Standardize-Variables用先前未使用过的变量替换其所有的参数
chap3_para1747,1,,下面我们使用前面的犯罪问题来解释FOL-FC-Ask。
chap3_para1747,2,,可用于链接的蕴涵语句为式（9-3）、式（9-6）、式（9-7）和式（9-8）。
chap3_para1747,3,,这里需要两次迭代。
chap3_para1748,1,,● 第一次迭代中，规则式（9-3）的前提未满足。
chap3_para1749,1,,满足规则式（9-6），添加。
chap3_para175,1,3.,[9]　在我们的实现中，reached数据结构支持查询给定状态是否为其成员，而边界数据结构（一个优先队列）不支持，因此我们使用reached检查是否互相触碰；但从概念上讲，我们查询的是这两个边界是否已经相遇。
chap3_para175,2,5Informed (Heuristic) Search Strategies,通过将每个目标状态的节点加载到反向边界和反向已达表中，可以将实现扩展为处理多个目标状态。
chap3_para1750,1,,满足规则式（9-7），添加。
chap3_para1751,1,,满足规则式（9-8），添加。
chap3_para1752,1,,● 第二次迭代中，规则式（9-3）被满足，添加推断。
chap3_para1753,1,,图9-4展示了所生成的证明树。
chap3_para1753,2,,注意，此时已不可能再产生新的推断，因为每个可以用前向链接得出的语句已经显式地被纳入知识库。
chap3_para1753,3,,这种知识库被称为推断过程的不动点。
chap3_para1753,4,,对一阶确定子句使用前向链接得到的不动点与命题前向链接中的类似（7.5.4节），主要的区别在于一阶逻辑不动点可以含有全称量化的原子语句。
chap3_para1754,1,,FOL-FC-Ask很容易分析。
chap3_para1754,2,,首先，它是可靠的，因为每个推断都是对一般化肯定前件的应用，而一般化肯定前件是可靠的。
chap3_para1754,3,,其次，它对于确定子句知识库是完备的，也就是说，它能够对所有答案蕴涵在确定子句知识库中的查询做出回答。
chap3_para1755,1,,对于不含有函数符号的数据日志知识库，完备性的证明相当简单。
chap3_para1755,2,,先对可能被添加的事实进行计数，这决定着迭代的次数。
chap3_para1755,3,,令k为最大元数（参数的数量），p为谓词数量，n为常量符号的数量。
chap3_para1755,4,,显然，基本事实的数量不可能超过pnk个，因此在这么多次迭代后，算法必然已经到达了不动点。
chap3_para1755,5,,然后我们就可以得出论据，它非常类似于命题前向链接完备性的证明。
chap3_para1755,6,,（见7.5.4节。
chap3_para1755,7,,）如何从命题逻辑完备性转进到一阶逻辑完备性的细节在9.5节介绍归结算法时给出。
chap3_para1756,1,,图9-4　前向链接算法为犯罪问题生成的证明树。
chap3_para1756,2,,最早的事实出现在最下层，第一次迭代推断得到的事实在中间层，而第二次迭代推断得出的事实在最顶层
chap3_para1757,1,,对于含有函数符号的一般确定子句，FOL-FC-Ask会生成无穷多的新事实，因此我们需要非常小心。
chap3_para1757,2,,在查询语句q的答案被蕴含的情形下，我们只能凭借埃尔布朗定理（9.1.1节）来证实算法将找到证明。
chap3_para1757,3,,（见9.5节的归结情形。
chap3_para1757,4,,）如果查询没有答案，算法在某些情况下就无法终止。
chap3_para1757,5,,例如，如果知识库含有皮亚诺公理
chap3_para1758,1,,则前向链接将添加NatNum(S(0))、NatNum(S(S(0)))、NatNum(S(S(S(0))))等。
chap3_para1758,2,,一般来说，这个问题是无法避免的。
chap3_para1758,3,,如我们在常规一阶逻辑中所见，确定子句的蕴含是半可判定的。
chap3_para1759,1,,9.3.3　高效前向链接
chap3_para176,1,"This section shows how an informed search strategy—one that uses domain-specific hints about the location of goals—can find solutions more efficiently than an uninformed strategy. The hints come in the form of a heuristic function, denoted h(n):10",双向搜索有很多不同版本，就像有很多不同的单向搜索算法一样。
chap3_para176,2,,在这一节中，我们将介绍双向最佳优先搜索。
chap3_para176,3,,尽管存在两个独立的边界，但接下来要扩展的节点始终是两个边界中的评价函数值最小的节点。
chap3_para176,4,,当函数为路径代价时，我们得到双向一致代价搜索，如果最优路径的代价是C*，则不扩展代价大于的节点。
chap3_para176,5,,这将使得速度大大提高。
chap3_para1760,1,,图9-3所示的前向链接算法为了便于理解而牺牲了效率。
chap3_para1760,2,,低效的原因有3个。
chap3_para1760,3,,首先，算法的内层循环试图对知识库中的每一条规则和每一条事实进行匹配。
chap3_para1760,4,,其次，算法每次迭代都检查所有规则，尽管知识库只有少量更新。
chap3_para1760,5,,最后，算法会生成许多与目标无关的事实。
chap3_para1760,6,,我们依次解决这些问题。
chap3_para1761,1,,1. 将规则与已知事实进行匹配
chap3_para1762,1,,将规则的前提与知识库中的事实进行匹配的问题似乎很简单。
chap3_para1762,2,,例如，假设我们要应用规则
chap3_para1763,1,,则我们需要找出所有与匹配的事实；被恰当索引的知识库可以在常量时间内对每个事实完成这项操作。
chap3_para1763,2,,现在考虑规则
chap3_para1764,1,,同样，我们可以在常量时间内找出诺诺国拥有的所有对象，然后对于每个对象，我们可以检查它是否是导弹。
chap3_para1764,2,,但如果知识库含有许多诺诺国拥有的对象而其中只有极少数是导弹，先找出所有的导弹然后再检查它们是否被诺诺国所拥有就是更好的操作。
chap3_para1764,3,,这就是合取子句排序（conjunct ordering）问题：求解规则前提的合取子句的排序，使总代价最小。
chap3_para1764,4,,实际上找出最优排序是NP困难问题，不过可以使用很好的启发式算法求解。
chap3_para1764,5,,例如，在第6章用于CSP的最小剩余值（MRV）启发式算法会建议，如果导弹的数量比诺诺国拥有的对象数量少，就对合取子句进行排序先查找导弹。
chap3_para1765,1,,实际上，模式匹配与约束满足的联系十分紧密。
chap3_para1765,2,,我们可以将每个合取子句看作一条对它所包含的变量的约束，例如，是x的一元约束。
chap3_para1765,3,,拓展这种想法，就能将所有有限域CSP表示为单个确定子句和相关的基本事实。
chap3_para1765,4,,考虑图6-1中的地图着色问题，这里显示于图9-5a。
chap3_para1765,5,,图9-5b给出了其等价的单个确定子句形式。
chap3_para1765,6,,很明显，只有CSP有解，才可以推断出结论Colorable()。
chap3_para1765,7,,因为3-SAT问题是一般CSP的一个特例，我们可以断定，将确定子句与事实集进行匹配的问题是NP困难问题。
chap3_para1766,1,,图9-5　（a）用于为澳大利亚地图着色的约束图。
chap3_para1766,2,,（b）用单个确定子句表示的地图着色CSP。
chap3_para1766,3,,每个地图区域都用变量表示，变量的值可以为常量red、green、blue（使用Diff声明）
chap3_para1767,1,,前向链接的内层循环含有NP困难的匹配问题看起来相当令人沮丧。
chap3_para1767,2,,但还是有3种方法能令我们振奋起来。
chap3_para1768,1,,● 我们可以发现，真实世界知识库的大部分规则是简洁的（如同犯罪例子中所示），而不是繁复的（如图9-5所示的CSP形式化）。
chap3_para1768,2,,在数据库世界中，很常用的假设是规则的长短和谓词的元数都限于一个常数，只需关心数据复杂性的问题，也就是，形式为知识库中基本事实数量的函数的推断复杂性。
chap3_para1768,3,,很容易证明前向链接的数据复杂性是多项式级别的，而非指数量级的。
chap3_para1769,1,,● 我们可以考虑使匹配变得高效的规则的子类别。
chap3_para1769,2,,本质上，所有数据日志子句都可以视作定义一个CSP，因此，如果对应的CSP容易求解，则匹配也容易求解。
chap3_para1769,3,,第6章描述了几种易解的CSP。
chap3_para1769,4,,例如，如果约束图（节点为变量，边为约束的图）构成一棵树，那么CSP就可以在线性时间内求解。
chap3_para1769,5,,完全相同的情况对匹配也成立。
chap3_para1769,6,,例如，如果我们从图9-5的地图中去掉南澳大利亚州SA，得到的子句就是：
chap3_para177,1,h(n) = estimated cost of the cheapest path from the state at node n to a goal state.,一般的最佳优先双向搜索算法如图3-14所示。
chap3_para177,2,,我们传入问题和评价函数的两个版本，一个是正向的（下标F），另一个是反向的（下标B）。
chap3_para177,3,,当评价函数是路径代价时，找到的第一个解将是最优解，但是对于不同的评价函数，这一结论不一定是正确的。
chap3_para177,4,,因此，我们会记录迄今为止找到的最优解，并且可能不得不多次更新最优解，直到Terminated测试证明不可能再有更好的解。
chap3_para1770,1,,它对应于6.5.1节的图6-12所示的简化CSP。
chap3_para1770,2,,用于求解树状结构CSP的算法可以直接用来求解规则匹配问题。
chap3_para1771,1,,● 我们可以试着消除前向链接算法中冗余的规则匹配尝试，如下一部分内容所述。
chap3_para1773,1,,我们先前在解释前向链接算法在犯罪问题示例中的工作方式时作弊了。
chap3_para1773,2,,具体而言，我们省略了由图9-3所示的算法完成的规则匹配。
chap3_para1773,3,,例如，在第二次迭代中，规则
chap3_para1774,1,,（第二次）匹配到了Missile(M1)，当然地，结论Weapon(M1)已知，因此什么都没发生。
chap3_para1774,2,,如果我们有如下的观察：所有在第t次迭代中推断出的新事实必然是从至少一个在第t−1次迭代中推断出的新事实推得的，就可以避免这种多余的规则匹配。
chap3_para1774,3,,这是正确的，因为所有不需要来自第t−1次迭代的新事实的推断，肯定在第t−1次迭代时就已经得出了。
chap3_para1775,1,,这一观察结果自然地引出增量前向链接算法，其中在第t次迭代时，我们仅检查前提含有合取子句pi的规则，pi能够与在第t−1次迭代新产生的事实p'i合一。
chap3_para1775,2,,规则匹配步骤随后固定pi来与p'i合一，但允许规则的其他合取子句与任意先前迭代产生的事实匹配。
chap3_para1775,3,,这个算法在每次迭代中生成的事实与图9-3所示的算法完全一致，但高效得多。
chap3_para1776,1,,如果有合适的索引，就很容易找到所有能够由任意已知事实触发的规则。
chap3_para1776,2,,很多真实系统在“更新”模式下运作，也就是每次收到Tell时都以前向链接作为回应。
chap3_para1776,3,,推断在规则集上逐级运行，直到达到不动点。
chap3_para1776,4,,这一过程对下一个新事实重复执行。
chap3_para1777,1,,一般来说，知识库中只有少部分规则是由新添加的已知事实而触发的。
chap3_para1777,2,,这就意味着在反复构建某些前提不满足的部分匹配时产生了大量冗余的工作。
chap3_para1777,3,,我们的犯罪问题示例由于太简单而无法很好地展示这种情形，但注意，第一次迭代中构建了一个规则
chap3_para1778,1,,和事实American(West)的部分匹配。
chap3_para1778,2,,这一部分匹配被丢弃，并在第二次迭代中重新构建（当规则匹配成功时）。
chap3_para1778,3,,比较好的做法是，保留部分匹配，并在新事实到来时逐步补全部分匹配而非直接丢弃它们。
chap3_para1779,1,,Rete算法（Rete algorithm）[3]首先求解了这一问题。
chap3_para1779,2,,算法对知识库中的规则集进行预处理来构建一个数据流网络，其中每个节点是规则前提中的一个文字。
chap3_para1779,3,,变量绑定在网络中流动，并在无法匹配某个文字时被过滤掉。
chap3_para1779,4,,如果一条规则中的两个文字共用一个变量，例如犯罪示例中的，则每个文字的绑定会被一个相等节点过滤。
chap3_para1779,5,,当变量绑定到达一个n元文字（如）的节点时，可能需要在过程继续运行前等待其他变量绑定的建立。
chap3_para1779,6,,在任意给定时刻，Rete网络的状态都会捕获所有规则的部分匹配，避免了大量的重新计算。
chap3_para178,1,"For example, in route-finding problems, we can estimate the distance from the current state to a goal by computing the straight-line distance on the map between the two points.",图3-14　双向最佳优先搜索维护两个边界集和两个已达状态表。
chap3_para178,2,We study heuristics and where they come from in more detail in Section 3.,当一个边界中的路径到达另一半搜索已达状态时，这两条路径（通过Join-Nodes函数）被连起来构成一个解。
chap3_para178,3,6.,我们得到的第一个解不一定是最优的；函数Terminated决定了什么时候停止寻找新的解
chap3_para1781,1,,[3]　Rete是拉丁语“网”的意思。
chap3_para1781,2,,它与“条约”（treaty）的英语发音押韵。
chap3_para1782,1,,Rete网络和以它为基础的各种改进已经成为了所谓的产生式系统（production system）的关键组成部分。
chap3_para1782,2,,产生式系统是最早被大量使用的前向链接系统之一。
chap3_para1782,3,,"[4]Xcon系统（最初被称为R1；McDermott, 1982）就是用产生式系统的结构构建的。"
chap3_para1782,4,,Xcon含有用于为DEC公司的客户设计计算机部件规格的数千条规则。
chap3_para1782,5,,它是最早在专家系统这一新兴领域取得显著商业成功的系统之一。
chap3_para1782,6,,许多其他类似的系统都以相同的核心技术构建，这一技术已经在通用语言Ops-5中实现。
chap3_para1784,1,,[4]　“产生式系统”中的“产生式”表示一种条件-行动规则。
chap3_para1785,1,,产生式系统在认知架构（cognitive architecture）中也很流行。
chap3_para1785,2,,"认知架构也就是人类推理的模型，如ACT（Anderson, 1983）和Soar（Laird et al., 1987）。"
chap3_para1785,3,,在这些系统中，系统的“工作记忆”对人类的短期记忆进行建模，而产生式则是长期记忆的一部分。
chap3_para1785,4,,在每个操作周期中，产生式被匹配到事实的工作记忆。
chap3_para1785,5,,条件得到满足的产生式可以在工作记忆中添加或删除事实。
chap3_para1785,6,,相比于数据库中的典型情形，产生式系统往往有很多规则，却只有很少的事实。
chap3_para1785,7,,运用适当的优化匹配技术，系统可以在有几百万条规则的情况下实时运行。
chap3_para1787,1,,另一个低效的原因是前向链接允许所有基于已知事实的推断，即使它们与目标并不相关。
chap3_para1787,2,,在犯罪示例中，没有能够得出不相关结论的规则。
chap3_para1787,3,,但如果存在很多描述美国人饮食习惯，或导弹的部件及价格的规则，那么FOL-FC-Ask就会产生不相关结论。
chap3_para1788,1,,一种避免得到不相关结论的方法是使用反向链接，在9.4节中将进行讨论。
chap3_para1788,2,,另一种方法是将前向链接限制到特意挑选的规则子集上，如PL-FC-Entails?所示（7.5.4节）。
chap3_para1788,3,,第三种方法已经出现在演绎数据库（deductive database）中，这是一种大规模数据库，类似于关系数据库，但使用前向链接而非SQL查询作为标准推断工具。
chap3_para1788,4,,它的基本原理是使用目标信息重写规则集，以便在前向推理中只考虑相关的变量绑定，也就是那些属于所谓的魔法集（magic set）的绑定。
chap3_para1788,5,,例如，如果目标是Criminal(West)，能得出Criminal(x)的规则就会被重写，以便包含附加的、限制x的值的合取子句：
chap3_para1789,1,,事实Magic(West)也被加入知识库中。
chap3_para1789,2,,这样，即使知识库含有关于几百万美国人的事实，也只有韦斯特上校会在前向链接中被考虑到。
chap3_para1789,3,,定义魔法集、重写知识库的完整过程过于复杂，在此不详细描述，但其基本概念是从目标进行某种“通用”的反向推断，以此来找出哪些变量绑定需要被约束。
chap3_para1789,4,,因此，魔法集方法可以被认为是一种前向推断和反向预处理的混合。
chap3_para179,1,3.,3.4.6　无信息搜索算法对比
chap3_para179,2,5.,
chap3_para179,3,1Greedy best-first search,
chap3_para1791,1,,另一种主要的逻辑推断算法对确定子句使用反向链接。
chap3_para1791,2,,这些算法从目标开始反向运行，链接规则以找出支持证明的已知事实。
chap3_para1792,1,,9.4.1　反向链接算法
chap3_para1793,1,,图9-6展示了用于确定子句的反向链接算法。
chap3_para1793,2,,"如果知识库含有形如lhs ⇒ goal的规则，就能证得FOL-BC-Ask(KB, goal)，其中lhs（左手侧）是合取子句列表。"
chap3_para1793,3,,原子事实，如Americal(West)被视为lhs为空列表的子句。
chap3_para1793,4,,现在，含有变量的查询可以用多种方式证明。
chap3_para1793,5,,例如，查询Person(x)可以用置换和证明。
chap3_para1793,6,,因此，我们将FOL-BC-Ask实现为生成器，也就是能多次返回的函数，每次返回值给出一个可能的结果（见附录B）。
chap3_para1794,1,,反向链接是一种与或搜索——或的部分是由于目标查询可以用知识库中的任意规则证明，而与的部分是由于所有lhs中的合取子句都必须被证明。
chap3_para1794,2,,FOL-BC-Or的工作方式是抓取所有可能与目标合一的子句，将子句中的变量标准化为全新变量，如果子句的rhs确实能够与目标合一，就使用FOL-BC-And证明lhs中的所有合取子句。
chap3_para1794,3,,这个函数的工作方式是轮流证明合取子句，并记录运行中积累的所有置换。
chap3_para1794,4,,图9-7是从式（9-3）到式（9-10）推导Criminal(West)的证明树。
chap3_para1795,1,,如前所述，反向链接明显是深度优先搜索算法。
chap3_para1795,2,,这意味着其空间需求与证明规模呈线性关系，也意味着反向链接（不同于前向链接）受制于重复状态和不完备性。
chap3_para1795,3,,尽管有这些局限，事实表明反向链接在逻辑编程语言中仍然是非常流行且有效的。
chap3_para1796,1,,图9-6　用于一阶知识库的简单的反向链接算法
chap3_para1797,1,,图9-7　使用反向链接构建证明树来证明韦斯特是有罪的。
chap3_para1797,2,,树的阅读方式是深度优先，从左至右。
chap3_para1797,3,,要证明Criminal(West)，我们必须先证明其下方的4个合取子句。
chap3_para1797,4,,其中一些在知识库中，而另一些需要进一步反向链接。
chap3_para1797,5,,每次成功置换的绑定显示在对应的子目标旁边。
chap3_para1797,6,,注意，只要合取式中的一个子目标达成，其置换就被用于接下来的子目标。
chap3_para1797,7,,这样，当FOL-BC-Ask运行到最后一个合取子句，即最初为Hostile(z)的子句时，z就已经被绑定为Nono
chap3_para1798,1,,9.4.2　逻辑编程
chap3_para1799,1,,逻辑编程是一种接近第7章所述的陈述性理念的技术，即系统应当通过用形式语言表示的知识来构建，而问题应当通过在这些知识上运行推断过程来求解。
chap3_para1799,2,,这项理念在罗伯特·科瓦尔斯基（Robert Kowalski）的等式中得以总结：
chap3_para18,1,3.,3.1.1　搜索问题和解
chap3_para18,2,1.,
chap3_para18,3,1Search problems and solutions,
chap3_para180,1,Greedy best-first search is a form of best-first search that expands first the node with the lowest h(n) value—the node that appears to be closest to the goal—on the grounds that this is likely to lead to a solution quickly. So the evaluation function f(n)= h(n).,图3-15根据3.3.4节中列出的4个评价标准对无信息搜索算法进行了比较。
chap3_para180,2,,这种比较适用于不检查重复状态的树状搜索版本。
chap3_para180,3,,对于检查重复状态的图搜索，主要区别在于，对于有限状态空间，深度优先搜索是完备的，并且空间复杂性和时间复杂性受到状态空间大小（顶点和边的数量，）的限制。
chap3_para1801,1,,Prolog是最为广泛使用的逻辑编程语言。
chap3_para1801,2,,"它主要被用作快速原型语言，也用于像编写编译器（Van Roy, 1990）、自然语言分析（Pereira and Warren, 1980）这样的符号处理任务。"
chap3_para1801,3,,许多用于法律、医疗、财经和其他领域的专家系统都使用Prolog编写。
chap3_para1802,1,,Prolog程序是确定子句集，但记法与标准的一阶逻辑有所不同。
chap3_para1802,2,,Prolog使用大写字母表示变量，小写字母则表示常量——与逻辑中的约定相反。
chap3_para1802,3,,"确定子句中的合取子句用逗号区分，而确定子句的书写也与我们所习惯的“相反”：不同于写为，在Prolog中我们将其写作C :- A, B。"
chap3_para1802,4,,这里有一个典型的例子：
chap3_para1803,1,,"criminal(X) :- american(X), weapon(Y), sells(X,Y,Z), hostile(Z)"
chap3_para1804,1,,在Prolog中，记法[E|L]表示第一个元素为E其余部分为L的列表。
chap3_para1804,2,,"下面是append(X,Y,Z)的Prolog程序，如果列表Z是列表Y追加到X后的结果，则程序返回成功："
chap3_para1805,1,,"append([],Y,Y)"
chap3_para1806,1,,"append([A|X],Y,[A|Z]) :- append(X,Y,Z)"
chap3_para1807,1,,我们可以将这些子句用自然语言描述为：（1）将列表Y追加到空列表后得到相同的列表Y；（2）在给定Z是Y追加到X后的结果的情况下，[A|Z]是[Y]追加到[A|X]后的结果。
chap3_para1807,2,,在大多数高级语言中我们可以写出类似的递归函数来描述如何追加列表，但实际上Prolog的定义更为强大，因为它描述了3个参数间的关系，而非用两个参数算出的函数。
chap3_para1807,3,,"例如，我们可以提出查询append(X,Y,[1,2,3])：哪两个列表追加能产生[1,2,3]？"
chap3_para1807,4,,Prolog为我们返回的解是
chap3_para1808,1,,"X=[] 　Y=[1,2,3];"
chap3_para1809,1,,"X=[1] 　Y=[2,3];"
chap3_para181,1,"Let us see how this works for route-finding problems in Romania; we use the straight-line distance heuristic, which we will call hSLD.",图3-15　搜索算法比较。
chap3_para181,2,"If the goal is Bucharest, we need to know the straight-line distances to Bucharest, which are shown in Figure 3.",b是分支因子；m是搜索树的最大深度；d是最浅层解的深度，当不存在解时为m；是深度界限
chap3_para181,3,16.,
chap3_para181,4,"For example, hSLD(Arad) = 366.",
chap3_para181,5,"Notice that the values of hSLD cannot be computed from the problem description itself (that is, the ACTIONS and RESULT functions).",
chap3_para181,6,"Moreover, it takes a certain amount of world knowledge to know that hSLD is correlated with actual road distances and is, therefore, a useful heuristic.",
chap3_para1810,1,,"X=[1,2] 　Y=[3];"
chap3_para1811,1,,"X=[1,2,3]　Y=[];"
chap3_para1812,1,,Prolog程序的执行是通过深度优先的反向链接完成的，其中确定子句以其在知识库中的顺序进行尝试。
chap3_para1812,2,,Prolog的设计代表着陈述性与执行效率的妥协。
chap3_para1812,3,,Prolog的一些方面不属于标准的逻辑推断。
chap3_para1813,1,,● Prolog使用8.2.8节所述的数据库语义而非一阶语义，这可以明显地从它对等词和否定的处理看出（见9.4.4节）。
chap3_para1814,1,,● 有一系列用于算术的内置函数。
chap3_para1814,2,,使用这些函数符号的文字是通过执行代码而非进行深入推断“证得”的。
chap3_para1814,3,,例如，目标“X is 4+3”当X被绑定为7时达成。
chap3_para1814,4,,而目标“5 is X+Y”则无法达成，因为内置函数无法求解任意等式。
chap3_para1815,1,,● 存在执行时会产生副作用的内置谓词。
chap3_para1815,2,,这包括输入-输出谓词和用于修改知识库的assert/retract谓词。
chap3_para1815,3,,这类谓词在逻辑中没有对应物，会导致令人困惑的结果，例如，如果事实是在证明树的一个最终会失败的分支中断言的。
chap3_para1816,1,,● 出现检验在Prolog的合一算法中被略去。
chap3_para1816,2,,这就意味着会产生一些不可靠的推断。
chap3_para1816,3,,这在实际中几乎完全不会发生。
chap3_para1817,1,,● Prolog使用深度优先反向链接搜索，并且不检查无限递归。
chap3_para1817,2,,在恰当使用的情况下，这种做法使得编程语言可用且高效。
chap3_para1817,3,,但这也意味着某些看起来是有效逻辑的程序将无法终止。
chap3_para1818,1,,9.4.3　冗余推断和无限循环
chap3_para1819,1,,我们现在来看Prolog的致命弱点：深度优先搜索和包含了重复状态和无限路径的搜索树之间的错配。
chap3_para1819,2,,考虑如下的逻辑程序，这一程序判断有向图中的两点是否存在路径：
chap3_para182,1,"Description The binary trees have the root node labeled ""A"". Node ""A"" has two child nodes labeled B and C. Node B has two child nodes labeled D and E. Node C has two child nodes labeled F and G. Node D has two child nodes labeled H and I. Node E has two child nodes labeled J and K. Node F has two child nodes labeled L and M. Node G has two child nodes labeled N and O. Limit: 0. Two binary trees of level 1. Binary Tree 1: An arrowhead points to “A”. Node “A” is green-colored. Binary Tree 2: Node “A” is faded out. Limit: 1. Four binary trees of level 2. Binary Tree 1: Node “A” is lavender-colored. An arrowhead points to “A”. All other nodes and paths are in faint dashed lines. Binary Tree 2: Node “A” is lavender-colored. Nodes B and C are green-colored. An arrowhead points to B. The paths from node “A” are solid lines. Binary Tree 3: Node “A” is lavender-colored. Node C is green-colored. The path between nodes “A” and C is a solid line. The path from “A” to B and node B are faded out. Binary Tree 4: All nodes and paths are faded out. Limit: 2. Eight binary trees of level 2. Binary Tree 1: Node “A” is lavender-colored. An arrowhead points to “A”. All other nodes and paths are in faint dashed lines. Binary Tree 2: Node “A” is lavender-colored. Nodes B and C are green-colored. An arrowhead points to B. The paths from node “A” are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 3: Nodes “A” and B are lavender-colored. Nodes C, D, and E are green-colored. An arrowhead points to D. The paths from “A” and B are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 4: Nodes “A” and B are lavender-colored. Nodes C and E are green-colored. An arrowhead points to E. The paths from “A” are solid lines. The path between B and E is a solid line. The path from B to D and node D are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 5: Node “A” is lavender-colored. Node C is green-colored. An arrowhead points to C. The path between “A” and C is a solid line. The path from “A” to B, node B, and all child nodes of B are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 6: Nodes “A” and C are lavender-colored. Nodes F and G are green-colored. An arrowhead points to F. The path between “A” and C is a solid line. The paths from C are solid lines. Binary Tree 7: Nodes “A” and C are lavender-colored. Node G is green-colored. The path between “A” and C is a solid line. The path between C and G is a solid line. The path from C to E and node E are faded out. Binary Tree 8: All nodes and paths are faded out. Limit: 3. Twelve binary trees of level 3. Binary Tree 1: Node “A” is green-colored. An arrowhead points to “A”. All other nodes and paths are in faint dashed lines. Binary Tree 2: Node “A” is lavender-colored. Nodes B and C are green-colored. An arrowhead points to B. The paths from node “A” are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 3: Nodes “A” and B are lavender-colored. Nodes C, D, and E are green-colored. An arrowhead points to D. The paths from nodes “A” and B are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 4: Nodes “A”, B, and D are lavender-colored. Nodes C, E, H, and I are green-colored. An arrowhead points to H. The paths from “A”, B, and D are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 5: Nodes “A”, B, and D are lavender-colored. Nodes C, E, and I are green-colored. An arrowhead points to I. The paths from “A” and B are solid lines. The path between D and I is a solid line. The path from D to H and node H are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 6: Nodes “A” and B are lavender-colored. Nodes E and C are green-colored. An arrowhead points to E. The paths from “A” are solid lines. The path between B and E is a solid line. The path from B to D, node D, and the child nodes of D are all faded out. All other nodes and paths are in faint dashed lines. Binary Tree 7: Nodes “A”, B, and E are lavender-colored. Nodes C, J, and K are green-colored. An arrowhead points to J. The paths from “A” and E are solid lines. The path between B and E is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 8: Nodes “A”, B, and E are lavender-colored. Nodes C and K are green-colored. An arrowhead points to K. The paths from “A” are solid lines. The path between B and E is a solid line. The path between K and E is a solid line. The path from E to J and node J are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 9: Node “A” is lavender-colored and node C is green-colored. An arrowhead points to C. The path between “A” and C is a solid line. The path from “A” to B, node B, and all child nodes of B are faded. All other nodes and paths are in faint dashed lines. Binary Tree 10: Nodes “A” and C are lavender-colored. Nodes F and G are green-colored. An arrowhead points to F. The paths from C are solid lines. The path between “A” and C is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 11: Nodes “A”, C, and F are lavender-colored. Nodes G, L, and M are green-colored. An arrowhead points to L. The paths from C and F are solid lines. The path between “A” and C is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 12: Nodes “A”, C, and F are lavender-colored. Nodes G and M are green-colored. An arrowhead points to M. The paths from C are solid lines. The path between “A” and C is a solid line. The path between F and M is a solid line. The path from F to L and node L are faded out. All other nodes and paths are in faint dashed lines.",3.5　有信息（启发式）搜索策略
chap3_para1820,1,,"path(X,Z) :- link(X,Z)"
chap3_para1821,1,,"path(X,Z) :- path(X,Y), link(Y,Z)"
chap3_para1822,1,,"事实link(a,b)和link(b,c)描述的一个简单的三节点图如图9-8a所示。"
chap3_para1822,2,,"在这个程序中，查询path(a,c)生成了图9-9a所示的证明树。"
chap3_para1822,3,,与此同时，如果我们按顺序写出如下子句：
chap3_para1825,1,,则Prolog会进入图9-9b所示的无限路径。
chap3_para1825,2,,因此，作为一个确定子句——甚至对于本例所示的数据日志程序——的定理证明器，Prolog是不完备的，因为对于某些知识库，它无法证明其所蕴含的语句。
chap3_para1825,3,,"注意，前向链接并没有这种问题：只要path(a,b)、path(b,c)和path(a,c)被推得，前向链接就会停止。"
chap3_para1826,1,,图9-8　（a）找出从A到C的路径会导致Prolog陷入死循环；（b）每个节点连接到下一层中两个随机后继的图。
chap3_para1826,2,,找到从A1到J4的路径需要877次推断
chap3_para1827,1,,图9-9　（a）证明从A到C存在一条路径。
chap3_para1827,2,,（b）子句顺序“错误”时生成的无限证明树
chap3_para1828,1,,深度优先反向链接也有冗余计算的问题。
chap3_para1828,2,,例如，当查找图9-8b中从A1到J4的路径时，Prolog进行了877次推断，大部分推断用于找出到达无法达成目标的节点的所有可能路径。
chap3_para1828,3,,这类似于第3章所述的重复状态问题。
chap3_para1828,4,,推断的总量随着生成的基本事实的数量增加而呈指数增长。
chap3_para1828,5,,"如果我们使用前向链接而非反向链接，连接到n个节点的path(X,Y)数量至多为n2个。"
chap3_para1828,6,,对于图9-8b所示的问题则仅需要62次推断。
chap3_para1829,1,,图搜索问题中的前向链接是动态规划（dynamic programming）的一个实例，其子问题的解是由更小的子问题的解递增构建的，通过缓存更小的子问题来避免重复计算。
chap3_para1829,2,,我们可以在反向链接中达到类似的效果，只需要将大目标分解为小目标而非从小目标构建大目标。
chap3_para183,1,Figure 3.16 Values of hSLD—straight-line distances to Bucharest.,本节将展示有信息搜索（informed search）策略——使用关于目标位置的特定领域线索——如何比无信息搜索策略更有效地找到解。
chap3_para183,2,,线索以启发式函数（heuristic function）的形式出现，记为h(n)：[10]
chap3_para1830,1,,不论如何，存储中间结果以避免重复计算是问题的关键。
chap3_para1830,2,,这是表格化逻辑编程（tabled logic programming）系统所采取的方法，它使用高效的存储和检索机制。
chap3_para1830,3,,表格化逻辑编程结合了反向链接的目标导向性以及前向链接动态规划的高效性。
chap3_para1830,4,,它对于数据日志知识库是完备的，这意味着程序员不太需要为死循环而担忧。
chap3_para1830,5,,"（使用类似father(X,Y)这种指代可能有无穷多对象的语句时，它仍然可能会进入死循环。"
chap3_para1830,6,,）
chap3_para1831,1,,9.4.4　Prolog的数据库语义
chap3_para1832,1,,Prolog使用8.2.8节讨论过的数据库语义。
chap3_para1832,2,,唯一名称假设表明每个Prolog常量和每个基本项都仅指代唯一的对象，而封闭世界假设表明为真的语句只能是知识库蕴含的语句。
chap3_para1832,3,,Prolog无法断言某条语句是假的。
chap3_para1832,4,,这使得Prolog的表达能力比一阶逻辑差，但这正是使Prolog更为高效简洁的原因之一。
chap3_para1832,5,,考虑如下关于一些课程的断言：
chap3_para1834,1,,在唯一名称假设下，CS和EE是不同的（101、102和106也不同），因此这表示有4门不同的课程。
chap3_para1834,2,,在封闭世界假设下，不存在其他课程，因此只有4门课程。
chap3_para1834,3,,但如果它是一阶逻辑（FOL）的断言，而非数据库语义的话，我们只能说课程的数量介于1到无穷之间。
chap3_para1834,4,,这是由于FOL中的断言并不否认存在未提及的课程的可能性，也不表明提到的课程各自不同。
chap3_para1834,5,,如果我们想将式（9-11）翻译成FOL，我们就会得到如下语句：
chap3_para1836,1,,这就是对式（9-11）的完备化（completion）。
chap3_para1836,2,,在FOL中它表示最多有4门课程。
chap3_para1836,3,,要用FOL表示最少有4门课程的概念，我们需要写出等词的完备化：
chap3_para1837,1,,完备化对于理解数据库语义是有益的，但为了实用，如果你的问题可以用数据库语义描述，则用Prolog和其他数据库语义系统进行推理会更加高效，而不是翻译为FOL后用完备的定理证明器推理。
chap3_para1838,1,,9.4.5　约束逻辑编程
chap3_para1839,1,,在对前向链接的讨论中（9.3节），我们展示了约束满足问题（CSP）是如何被编码为确定子句的。
chap3_para1839,2,,标准的Prolog求解此类问题的方法与图6.5所示的回溯算法完全一样。
chap3_para184,1,"Figure 3.17 shows the progress of a greedy best-first search using hSLD to find a path from Arad to Bucharest. The first node to be expanded from Arad will be Sibiu because the heuristic says it is closer to Bucharest than is either Zerind or Timisoara. The next node to be expanded will be Fagaras because it is now closest according to the heuristic. Fagaras in turn generates Bucharest, which is the goal. For this particular problem, greedy best-first search using hSLD finds a solution without ever expanding a node that is not on the solution path. The solution it found does not have optimal cost, however: the path via Sibiu and Fagaras to Bucharest is 32 miles longer than the path through Rimnicu Vilcea and Pitesti. This is why the algorithm is called “greedy”—on each iteration it tries to get as close to a goal as it can, but greediness can lead to worse results than being careful.",
chap3_para1840,1,,由于回溯算法枚举变量的域，因而只能用于有限域CSP。
chap3_para1840,2,,用Prolog的方式来说，如果目标含有未绑定变量的问题，其解的数量必须是有限的。
chap3_para1840,3,,（例如，在地图着色问题中，每个变量可以取4种不同的颜色中的一种。
chap3_para1840,4,,）无限域CSP（例如含有实数变量或整数变量的CSP）需要完全不同的算法，例如边界传播或线性规划。
chap3_para1841,1,,考虑如下的例子。
chap3_para1841,2,,"我们定义triangle(X,Y,Z)为其3个参数满足三角不等式时成立的谓词："
chap3_para1842,1,,"triangle(X,Y,Z) :-"
chap3_para1843,1,,"X0, Y0, Z0, X+YZ, Y+ZX, X+ZY."
chap3_para1844,1,,"如果我们向Prolog查询triangle(3,4,5)，它会返回成功；而如果我们询问triangle(3,4,Z)，它就无法找到解，因为Prolog无法处理子目标Z0。"
chap3_para1844,2,,我们不能将未绑定的值与0比较。
chap3_para1845,1,,约束逻辑编程（constraint logic programming）允许变量是被约束的而非被绑定的。
chap3_para1845,2,,CLP的解是从知识库中可以推得的、查询变量的最为具体的约束集。
chap3_para1845,3,,"例如，triangle(3,4,Z)的解是约束7Z1。"
chap3_para1845,4,,标准的逻辑程序只是CLP中约束必须为等式约束（也就是绑定）的特殊情形。
chap3_para1846,1,,CLP系统整合了各种约束求解算法用于该语言所支持的约束。
chap3_para1846,2,,例如，支持实值变量线性不等式的系统可能包含线性规划算法来求解这些约束。
chap3_para1846,3,,CLP系统也采用更为灵活的方法来求解标准的逻辑编程查询。
chap3_para1846,4,,例如，它可能使用第6章所述的任一高效算法，而非使用深度优先、从左到右回溯。
chap3_para1846,5,,因此，CLP系统结合了约束满足算法、逻辑编程和演绎数据库的要素。
chap3_para1847,1,,已经出现了一些允许程序员对用于推断的搜索顺序有更多控制的系统。
chap3_para1847,2,,"MRS语言（Genesereth and Smith, 1981; Russell, 1985）允许程序员编制元规则（metarule）来决定首先处理哪些合取式。"
chap3_para1847,3,,用户可以编制规则，说明要首先尝试变量最少的目标，或者也可以对某个谓词编制论域特定的规则。
chap3_para1849,1,,逻辑系统家族中的最后一个成员，也是唯一能够用于所有知识库而不仅是确定子句的成员，是归结。
chap3_para1849,2,,我们在7.5.2节了解了命题归结是命题逻辑的完备推断过程。
chap3_para1849,3,,在本节中，我们将其拓展到一阶逻辑。
chap3_para185,1,"Description Arad, 366.",[10]　这看起来可能很奇怪，启发式函数真正需要的只是节点的状态，但作用对象却是节点。
chap3_para185,2,"Bucharest, 0, Craiova, 160.",一般使用h(n)而不是h(s)，是为了与评价函数f (n)和路径代价g(n)保持一致。
chap3_para185,3,"Drobeta, 242.",
chap3_para185,4,"Eforie, 161.",
chap3_para185,5,"Fagaras, 176.",
chap3_para185,6,"Giurgiu, 77.",
chap3_para185,7,"Hirsova, 151.",
chap3_para185,8,"Iasi, 226.",
chap3_para185,9,"Lugoj, 244.",
chap3_para185,10,"Mehadia, 241.",
chap3_para185,11,"Neamt, 234.",
chap3_para185,12,"Oradea, 380.",
chap3_para185,13,"Pitesti, 100.",
chap3_para185,14,"Rimnicu Vilcea, 193.",
chap3_para185,15,"Sibiu, 253.",
chap3_para185,16,"Timisoara, 329.",
chap3_para185,17,"Urziceni, 80.",
chap3_para185,18,"Vaslui, 199.",
chap3_para185,19,"Zerind, 374.",
chap3_para1850,1,,9.5.1　一阶逻辑的合取范式
chap3_para1851,1,,第一步是将语句转换为合取范式（CNF）——每个子句为文字析取的子句合取式。
chap3_para1851,2,,[5]在CNF中，文字可以包含变量，假定这些变量是全称量化的。
chap3_para1851,3,,例如，语句
chap3_para1853,1,,[5]　子句也可以用原子语句合取式为前提，原子语句析取式为结论的蕴涵式表示（习题9.DISJ）。
chap3_para1853,2,,"这被称为蕴涵范式或科瓦尔斯基范式［特别是写成从右到左的蕴涵符号时（Kowalski, 1979）］，它通常比有许多否定文字的析取式更易读。"
chap3_para1855,1,,关键在于每条一阶逻辑语句都可以转换为推断上等价的CNF语句。
chap3_para1856,1,,转换成CNF的过程与命题逻辑中类似，我们已在7.5.2节中学习过。
chap3_para1856,2,,关键的差别在于对存在量词的消除。
chap3_para1856,3,,我们通过翻译语句“Everyone who loves all animals is loved by someone”（爱所有动物的每个人被一些人爱），即
chap3_para1857,1,,来描述转换过程，步骤如下。
chap3_para1858,1,,● 蕴涵消去：使用取代。
chap3_para1858,2,,在我们的例句中，需要操作两次。
chap3_para1859,1,,● 内移：除了针对否定联结词的一般规则，我们还需要针对否定量词的规则。
chap3_para1859,2,,因此，我们有
chap3_para186,1,Figure 3.,h(n) = 从节点n的状态到目标状态的最小代价路径的代价估计值
chap3_para186,2,17 Stages in a greedy best-first tree-like search for Bucharest with the straight-line distance heuristic hSLD.,
chap3_para186,3,Nodes are labeled with their h-values.,
chap3_para1860,1,,我们的语句经过如下变换：
chap3_para1861,1,,注意，蕴涵式前提中的全称量词（∀y）已经变为存在量词。
chap3_para1861,2,,语句现在解读为“要么存在x不喜爱的动物，要么（如果事实并非如此的话）有人喜爱x”。
chap3_para1861,3,,显然，原始语句的含义被保留了下来。
chap3_para1862,1,,● 变量标准化：对于如这样两次使用相同变量名的语句，更改其中一个变量名。
chap3_para1862,2,,这可以避免在消除量词时产生歧义。
chap3_para1862,3,,因此，有
chap3_para1863,1,,● 斯科伦化：斯科伦化（Skolemization）就是通过消去移除存在量词的过程。
chap3_para1863,2,,在这个简单例子中，它就像9.1节所述的存在量词实例化，将翻译为P(A)，其中A是一个新变量。
chap3_para1863,3,,然而，我们无法对上述的语句应用存在量词实例化，因为它不符合的形式。
chap3_para1863,4,,语句中只有一部分满足这一形式。
chap3_para1863,5,,如果我们盲目地对两个符合的部分应用这一规则，得到
chap3_para1864,1,,其含义完全是错误的。
chap3_para1864,2,,它表明每个人要么无法爱上特定动物A，要么就被某个特定实体B所爱。
chap3_para1864,3,,而实际上，我们的原始语句允许每个人不爱不同的动物，或者被不同的人喜爱。
chap3_para1864,4,,我们希望斯科伦实体依赖于x：
chap3_para1865,1,,此处F和G为斯科伦函数（Skolem function）。
chap3_para1865,2,,总的规则是，斯科伦函数的参数全部是全称量化的变量，要消去的存在量词出现在这些变量的辖域内。
chap3_para1865,3,,与存在量词实例化一样，斯科伦化的语句的可满足性与原始语句完全一致。
chap3_para1866,1,,● 全称量词消除：此时，所有剩余变量必然是全称量化的。
chap3_para1866,2,,因此，我们消除全称量词不会损失任何信息：
chap3_para1868,1,,这一步可能还需要展开嵌套的合取式和析取式。
chap3_para1869,1,,语句现在成为了含有两个子句的CNF。
chap3_para1869,2,,它比原本含有蕴涵的语句难读多了。
chap3_para1869,3,,（将斯科伦函数F(x)解释为可能不被x所爱的动物，而将G(x)解释为可能爱着x的人，可能会对理解有所帮助。
chap3_para1869,4,,）幸运的是，人类很少需要考察CNF语句——翻译过程很容易自动化。
chap3_para187,1,"Greedy best-first graph search is complete in finite state spaces, but not in infinite ones.",例如，在寻径问题中，我们可以通过计算地图上两点之间的直线距离来估计从当前状态到目标的距离。
chap3_para187,2,The worst-case time and space complexity is O(|V|).,我们将在3.6节中详细研究启发式函数及其来源。
chap3_para187,3,"With a good heuristic function, however, the complexity can be reduced substantially, on certain problems reaching O(bm).",
chap3_para1870,1,,9.5.2　归结推断规则
chap3_para1871,1,,一阶子句的归结规则就是7.5.2节命题归结规则的提升版。
chap3_para1871,2,,两条进行了标准化分离、没有共同变量的子句，如果它们含有互补文字则可以被归结。
chap3_para1871,3,,如果两个命题文字相互否定，则这两个命题文字是互补的；如果两个一阶逻辑文字中的一个能够与另一个的否定合一，则这两个一阶逻辑文字是互补的。
chap3_para1871,4,,因此，我们有
chap3_para1872,1,,其中。
chap3_para1872,2,,例如，我们可以归结两个子句
chap3_para1874,1,,通过用合一子来消去互补文字和，生成归结式子句
chap3_para1875,1,,这个规则叫作二元归结（binary resolution）规则，因为它刚好归结两个文字。
chap3_para1875,2,,二元归结本身并不产生完备的推断过程。
chap3_para1875,3,,完备的归结规则能够归结每个子句的可合一文字子集。
chap3_para1875,4,,另一种方法是将因子提取（也就是对冗余文字的消除）拓展到一阶逻辑。
chap3_para1875,5,,命题逻辑因子提取将两个相同的文字约简为一个，一阶逻辑因子提取则约简两个可合一的文字。
chap3_para1875,6,,这种合一子必须应用于整个子句。
chap3_para1875,7,,二元归结和因子提取的组合是完备的。
chap3_para1876,1,,9.5.3　证明范例
chap3_para1877,1,,归结通过证明不可满足来证明，也就是说，通过推导空子句来证明。
chap3_para1877,2,,它的算法与命题逻辑情形相同，如图7-13所示，因此我们不在此重复。
chap3_para1877,3,,但我们会给出两个证明范例。
chap3_para1877,4,,第一个是9.3节的犯罪示例。
chap3_para1877,5,,CNF形式的语句为
chap3_para1878,1,,我们还包括了目标的否定。
chap3_para1878,2,,图9-10展示了归结证明。
chap3_para1878,3,,注意其结构：一条“主线”从目标子句开始，归结知识库中的子句，直到生成空子句。
chap3_para1878,4,,这是在霍恩子句知识库上进行归结的特点。
chap3_para1878,5,,实际上，沿着主线的子句严格对应于图9-6反向链接算法中目标变量的值。
chap3_para1878,6,,这是由于我们总是选择归结正文字能够与主线中“当前”子句最左边文字合一的子句；这与反向链接一模一样。
chap3_para1878,7,,因此，反向链接是归结的一个特例，它具有特定的控制策略来决定下一步要进行哪个归结。
chap3_para1879,1,,图9-10　归结证明韦斯特有罪。
chap3_para1879,2,,每个归结步骤中，合一文字用加粗字体表示，带有正文字的子句用蓝底表示
chap3_para188,1,3.,3.5.1　贪心最佳优先搜索
chap3_para188,2,5.,
chap3_para188,3,2A* search,
chap3_para1880,1,,我们的第二个范例使用斯科伦化，并涉及非确定子句。
chap3_para1880,2,,这会导致更为复杂的证明结构。
chap3_para1880,3,,其自然语言描述如下。
chap3_para1881,1,,Everyone who loves all animals is loved by someone.（每个爱所有动物的人都被一些人所爱。
chap3_para1881,2,,）
chap3_para1882,1,,Anyone who kills an animal is loved by no one.（任何害死动物的人都不被人所爱。
chap3_para1882,2,,）
chap3_para1883,1,,Jack loves all animals.（杰克爱所有动物，）
chap3_para1884,1,,"Either Jack or Curiosity killed the cat, who is named Tuna.（要么是杰克要么是好奇心害死了那只猫，猫的名字叫Tuna。"
chap3_para1884,2,,）
chap3_para1885,1,,Did Curiosity kill the cat?（是好奇心害死了那只猫吗？
chap3_para1885,2,,）
chap3_para1886,1,,首先，我们将原始语句，也就是一些背景知识，以及目标G的否定表示为一阶逻辑：
chap3_para189,1,"The most common informed search algorithm is A* search (pronounced “A-star search”), a best-first search that uses the evaluation function",贪心最佳优先搜索（greedy best-first search）是最佳优先搜索的一种形式，它首先扩展h(n)值最小的节点——看起来最接近目标的节点——因为这样可能可以更快找到解。
chap3_para189,2,,因此，评价函数f(n) = h(n)。
chap3_para1894,1,,然后，我们使用转换过程将每条语句转换为CNF：
chap3_para19,1,A search problem can be defined formally as follows:,搜索问题（problem）的形式化定义如下。
chap3_para190,1,"where g(n) is the path cost from the initial state to node n, and h(n) is the estimated cost of the shortest path from n to a goal state, so we have",让我们看看这种算法如何求解罗马尼亚寻径问题；我们使用直线距离（straight-line distance）作为启发式函数，记为hSLD。
chap3_para190,2,,如果目标是Bucharest，我们需要知道到Bucharest的直线距离，如图3-16所示。
chap3_para190,3,,例如，hSLD(Arad) = 366。
chap3_para190,4,,注意，无法从问题描述本身（即Actions和Result函数）来计算hSLD的值。
chap3_para190,5,,此外，根据经验可知，hSLD与实际道路距离相关，因此是一个有用的启发式函数。
chap3_para1903,1,,图9-11展示了“好奇心害死猫”的归结证明。
chap3_para1903,2,,在自然语言中，证明可以释义为：
chap3_para1904,1,,假设好奇心没有害死Tuna。
chap3_para1904,2,,我们知道要么是杰克要么是好奇心做了这件事，因此一定是杰克干的。
chap3_para1904,3,,现在，Tuna是一只猫，而猫是动物，因此Tuna是动物。
chap3_para1904,4,,因为任何害死动物的人都不被人所爱，我们就知道没人爱杰克。
chap3_para1904,5,,但是，杰克爱所有动物；至此有人爱他；至此我们得到了一个矛盾。
chap3_para1904,6,,因此，好奇心害死了那只猫。
chap3_para1905,1,,证明回答了问题“是好奇心害死了那只猫吗？
chap3_para1905,2,,”但我们常常希望提出更一般的问题，例如“谁害死了那只猫？
chap3_para1905,3,,”归结可以做到这一点，但需要稍微增加一些工作才能得到答案。
chap3_para1905,4,,"目标是∃w Kills(w, Tuna)，其CNF形式的否定为。"
chap3_para1905,5,,用新的否定的目标重复图9-11所示的证明，我们得到了类似的证明树，其中一步的置换为。
chap3_para1905,6,,因此，这种情况下，找出谁害死了那只猫就只是记录证明中查询变量的绑定的问题了。
chap3_para1905,7,,遗憾的是，归结有时会对存在量化目标产生非构造性证明（nonconstructive proof），我们知道一个查询为真，但却不知道这个变量的唯一绑定。
chap3_para1906,1,,图9-11　好奇心害死猫的归结证明。
chap3_para1906,2,,"注意，在推导子句Loves(G(Jack), Jack)时使用了因子分解。"
chap3_para1906,3,,"还要注意，在右上角，合一Loves(x, F(x))和Loves(Jack, x)只有在变量标准化分离后才可以进行"
chap3_para1907,1,,9.5.4　归结的完备性
chap3_para1908,1,,本节给出归结完备性证明。
chap3_para1908,2,,认为归结完备性是理所当然的读者可以略过本节。
chap3_para1909,1,,我们展示归结是反演完备的（refutation-complete），这意味着如果一个语句集是不可满足的，则归结总能推出矛盾。
chap3_para1909,2,,归结不能用于生成语句集的所有逻辑结果，但它可以用于证明给定语句是某个语句集所蕴含的。
chap3_para1909,3,,因此，它可以通过证明不可满足来找到给定问题Q(x)的所有答案。
chap3_para191,1,"In Figure 3.18, we show the progress of an A* search with the goal of reaching Bucharest. The values of g are computed from the action costs in Figure 3.1, and the values of hSLD are given in Figure 3.16. Notice that Bucharest first appears on the frontier at step (e), but it is not selected for expansion (and thus not detected as a solution) because at f = 450 it is not the lowest-cost node on the frontier—that would be Pitesti, at f = 417. Another way to say this is that there might be a solution through Pitesti whose cost is as low as 417, so the algorithm will not settle for a solution that costs 450. At step (f), a different path to Bucharest is now the lowest-cost node, at f =418, so it is selected and detected as the optimal solution.",图3-17展示了使用hSLD搜索从Arad到Bucharest的路径的贪心最佳优先搜索的过程。
chap3_para191,2,,从Arad扩展的第一个节点是Sibiu，因为启发式函数认为它比Zerind或Timisoara更接近Bucharest。
chap3_para191,3,,下一个要扩展的节点是Fagaras，因为根据启发式函数，它现在最接近Bucharest。
chap3_para191,4,,Fagaras接着生成了Bucharest，即目标节点。
chap3_para191,5,,对于这一特定问题，使用hSLD的贪心最佳优先搜索无须扩展不在解路径上的节点就找到了解。
chap3_para191,6,,但是，它找到的解并不是代价最优的：经由Sibiu和Fagaras到达Bucharest的路径比经过Rimnicu Vilcea和Pitesti的路径长32英里。
chap3_para191,7,,这就是为什么这种算法会被称为“贪心的”——在每次迭代中，它都会做出在当前看来最优的（即可以最接近目标的）选择，但这也会导致贪心法在全局意义上可能产生比谨慎的算法更糟糕的结果。
chap3_para1910,1,,我们认定了一阶逻辑的所有语句（不含等词）都可以重写为CNF中的子句集。
chap3_para1910,2,,"它以原子语句为基础，在语句的形式上进行归纳来证明（Davis and Putnam, 1960）。"
chap3_para1910,3,,因此我们的目标是证明下面的陈述：如果S是不可满足的子句集，则对S应用有限次归结会产生矛盾。
chap3_para1911,1,,"我们的证明遵循鲁宾逊（Robinson）的原始证明，同时使用了（Genesereth and Nilsson, 1987）中的一些简化。"
chap3_para1911,2,,证明的基本结构（见图9-12）如下。
chap3_para1912,1,,（1）我们观察到如果S不可满足，则存在S中子句的某个基本实例集使得该集合同样无法满足（埃尔布朗定理）。
chap3_para1913,1,,（2）我们引入第7章给出的基本归结定理，它证明命题归结对于基本语句是完备的。
chap3_para1914,1,,（3）我们使用提升引理来证明，对于使用基本语句集的任意命题归结证明，都存在相应的一阶归结证明，它使用一阶语句，从中可以得到基本语句。
chap3_para1915,1,,图9-12　归结完备性证明的结构
chap3_para1917,1,,通过稍微拓展一阶逻辑语言来允许算术中的数学归纳法，库尔特·哥德尔的不完全性定理证明存在无法证明的真值算术语句。
chap3_para1918,1,,不完全性定理的证明有点超出本书的讨论范畴，要证明它至少需要30页纸，但我们在此可以给出一些思路。
chap3_para1918,2,,我们从逻辑数论开始。
chap3_para1918,3,,在该理论中，只存在单个常量0和单个函数S（后继函数）。
chap3_para1918,4,,在预期模型中，S(0)表示1，S(S(0))表示2，以此类推。
chap3_para1918,5,,因此语言中所有自然数都有名称。
chap3_para1918,6,,它的词汇表还包含函数符号+、×和Expt（幂运算）以及普通的逻辑联结词和量词。
chap3_para1919,1,,首先要注意的是，在这种语言中我们能够写出的语句集是可以枚举的。
chap3_para1919,2,,（想象给符号定义字母序，然后按字母顺序依次排列长度分别为1、2……的语句集。
chap3_para1919,3,,）我们就可以为每条语句编号一个唯一的自然数（即哥德尔数）。
chap3_para1919,4,,这很重要：数论包含了它的每个语句的名字。
chap3_para1919,5,,同样地，我们可以为每个证明P编号为哥德尔数G(P)，因为证明都是一个有限的语句序列。
chap3_para192,1,"Description In all four parts, a node labeled Arad is shown. Part (“A”): The initial state. The Arad node is green-colored. An arrowhead points to Arad and 366 is marked next to the node. Part (b): After expanding Arad. The Arad node is lavender-colored and is connected to three green-colored nodes labeled Sibiu 253, Timisoara 329, and Zerind 374. An arrowhead points to Sibiu. Part (c): After expanding Sibiu. The Arad node is lavender-colored and is connected to three nodes labeled Sibiu, Timisoara 329, and Zerind 374. Sibiu is lavender-colored while Timisoara and Zerind are green-colored. Sibiu is connected to four green-colored nodes labeled Arad 366, Fagaras 177, Oradea 380, and Rimnicu Vilcea 193. An arrowhead points to Fagaras. Part (d): After expanding Fagaras. The Arad node is lavender-colored and is connected to three nodes labeled Sibiu, Timisoara 329, and Zerind 374. Sibiu is lavender-colored while Timisoara and Zerind are green-colored. Sibiu is connected to four nodes labeled Arad 366, Fagaras, Oradea 380, and Rimnicu Vilcea 193. Of these four, Fagaras is lavender-colored while the other three are green-colored. Fagaras is connected to two green-colored nodes labeled Sibiu 253 and Bucharest 0. An arrowhead points to Bucharest.",图3-16　hSLD（到Bucharest的直线距离）的值
chap3_para1920,1,,现在假设我们有递归可枚举的语句集A，它是对自然数的真命题。
chap3_para1920,2,,别忘了A可以由给定的整数集命名，我们可以想象用我们的语言写出如下类型的语句：
chap3_para1921,1,,不是哥德尔数为j的语句的证明的哥德尔数，其中证明只使用A中的前提。
chap3_para1922,1,,然后，令为语句，也就是表明其自身不可由A证明的语句。
chap3_para1922,2,,（也就是，这条语句恒为真，但并不明显。
chap3_para1922,3,,）
chap3_para1923,1,,现在我们提出如下的巧妙观点：假设是可由A证明的，则为假（因为说自己是不可证明的）。
chap3_para1923,2,,但这样我们就有一个可以从A证明的真值为假的语句，因此A不可能只包含真语句——这与我们的前提矛盾。
chap3_para1923,3,,因此是不可由A证明的。
chap3_para1923,4,,但这正如自己所述，因此是一个真语句。
chap3_para1924,1,,因此，我们证明了（略去了页）对于数论的所有真语句集，特别是所有基本公理集，存在由这些公理无法证明的真语句。
chap3_para1924,2,,这就明确了我们无法在任何给定公理系统内证明所有数学定理。
chap3_para1924,3,,显然，这是数学的重要发现。
chap3_para1924,4,,它对人工智能的重要性已经被广泛的争论，这种争论正始于哥德尔本人的猜想。
chap3_para1924,5,,我们在第27章探讨这些争论。
chap3_para1925,1,,要进行第一步，我们需要3个新概念。
chap3_para1926,1,,（1）埃尔布朗域（Herbrand universe）：如果S是子句集，则S的埃尔布朗域HS是可以由下面几项构建的基本项集合。
chap3_para1927,1,,a. S中的函数符号，如果存在的话。
chap3_para1928,1,,b. S中的常量符号，如果存在的话；如果不存在，则为默认常量符号S。
chap3_para1929,1,,例如，如果S仅含有子句 ，则HS为如下基本项的无限集：
chap3_para193,1,Figure 3.,图3-17　基于直线距离启发式函数hSLD的贪心最佳优先树状搜索的各个阶段（目标为Bucharest）。
chap3_para193,2,18 Stages in an A* search for Bucharest.,节点上标有h值
chap3_para193,3,Nodes are labeled with f = g + h.,
chap3_para193,4,The h values are the straight-line distances to Bucharest taken from Figure 3.,
chap3_para193,5,16.,
chap3_para1930,1,,（2）饱和（saturation）：如果S为子句集，P是基本项集，则P(S)为S对于P的饱和，它是通过对S中的变量应用所有可能P中基本项的一致置换得到的所有基本子句的集合。
chap3_para1931,1,,（3）埃尔布朗基（Herbrand base）：子句集S关于其埃尔布朗域的饱和称为S的埃尔布朗基，写作HS(S)。
chap3_para1931,2,,例如，如果S仅含有上述的子句，则HS(S)是无限子句集
chap3_para1932,1,,"这些定义使我们可以陈述埃尔布朗定理（Herbrand, 1930）的一种形式："
chap3_para1933,1,,如果子句集S不可满足，则存在HS(S)的一个不可满足的有限子集。
chap3_para1934,1,,令S'为基本语句的有限子集。
chap3_para1934,2,,现在我们可以使用接地归结定理（7.5.2节）来证明归结闭包RC(S')含有空子句。
chap3_para1934,3,,也就是说，使用命题归结对S'进行完备化会推得矛盾。
chap3_para1935,1,,现在我们已经证明了必然存在涉及S的埃尔布朗基的有限子集的归结证明，下一步是证明存在使用S本身的子句的归结证明，它们不一定是基本子句。
chap3_para1935,2,,我们从考虑单次运用归结规则的情形开始。
chap3_para1935,3,,鲁宾逊阐述了如下引理：
chap3_para1936,1,,令C1和C2为两个不含相同变量的子句，C'1和C'2分别为C1和C2的基本实例。
chap3_para1936,2,,如果C'是C'1和C'2的归结式，则存在子句C使得：（1）C是C1和C2的归结式；（2）C'是C的基本实例。
chap3_para1937,1,,这就是提升引理（lifting lemma），因为它将基本子句的证明提升到一般一阶逻辑子句。
chap3_para1937,2,,鲁宾逊为了证明其基本提升引理而不得不发明了合一且推导了最一般合一子的所有性质。
chap3_para1937,3,,我们仅阐明该引理而不在此进行证明：
chap3_para1938,1,,我们看到C'实际上是C的基本实例。
chap3_para1938,2,,一般来说，要使C'1和C'2具有归结式，就必须通过先对C1和C2使用C1和C2中的互补文字的最一般合一子来构建它们。
chap3_para1938,3,,由提升引理，易得任意多次应用归结规则时的相似结论：
chap3_para1939,1,,对于归结闭包S'内的任意子句C'，有归结闭包S内的子句C使得C'为C的基本实例且对C的推导长度与对C'的推导长度相同。
chap3_para194,1,A* search is complete.,贪心最佳优先图搜索在有限状态空间中是完备的，但在无限状态空间中是不完备的。
chap3_para194,2,11 Whether A* is cost-optimal depends on certain properties of the heuristic.,最坏情况下的时间复杂性和空间复杂性是。
chap3_para194,3,A key property is admissibility: an admissible heuristic is one that never overestimates the cost to reach a goal.,然而，使用一个好的启发式函数，复杂性可以大大降低，对于某些问题可以达到O(bm)。
chap3_para194,4,(An admissible heuristic is therefore optimistic.,
chap3_para194,5,") With an admissible heuristic, A* is cost-optimal, which we can show with a proof by contradiction.",
chap3_para194,6,"Suppose the optimal path has cost C*, but the algorithm returns a path with cost C > C*.",
chap3_para194,7,"Then there must be some node n which is on the optimal path and is unexpanded (because if all the nodes on the optimal path had been expanded, then we would have returned that optimal solution).",
chap3_para194,8,"So then, using the notation g*(n) to mean the cost of the optimal path from the start to n, and h*(n) to mean the cost of the optimal path from n to the nearest goal, we have:",
chap3_para1940,1,,由此可得，如果归结闭包S'内有空子句，则它必然也在归结闭包S中。
chap3_para1940,2,,这是由于空子句不可能是任何其他子句的基本实例。
chap3_para1940,3,,概括来说：我们已经证明了如果S不可满足，则存在使用归结规则的对空子句的有限推导。
chap3_para1941,1,,定理证明从基本子句提升到一阶子句大大增加了其能力。
chap3_para1941,2,,这种能力的增加来源于以下事实：一阶逻辑证明只需要在证明确有必要时才实例化变量，而基本子句方法则需要检查大量的任意实例化。
chap3_para1943,1,,本章到目前为止讲述过的所有推断方法都不能在不增加额外工作的情况下处理形如x = y的断言。
chap3_para1943,2,,为此可以采取3种不同的方法。
chap3_para1943,3,,第一种方法是公理化等词，也就是在知识库中写入相等关系的语句。
chap3_para1943,4,,我们需要说明相等是自反的、对称的和传递的，我们还需要说明我们可以在所有谓词或函数中用相等量置换相等量。
chap3_para1943,5,,因此我们需要3类基本公理，另外每个谓词和函数都需要一条公理：
chap3_para1944,1,,给定这些语句，标准的推断过程，如归结，就可以执行需要等词推理的任务，如求解数学方程。
chap3_para1944,2,,不过，这些公理会产生大量结论，其中大多数对证明没有帮助。
chap3_para1944,3,,因此第二种方法是添加推断规则而非公理。
chap3_para1944,4,,最简单的规则是解调，它取单元子句x = y和一个含有x项的子句，生成一个用y置换中的x得出的新子句。
chap3_para1944,5,,如果中的项能够与x合一，解调就可以使用，而不需要完全等于x。
chap3_para1944,6,,注意，解调是有方向性的，给定x = y，x总是会被y替换，而非相反。
chap3_para1944,7,,这意味着解调可以用形如z + 0 = z或z1 = z这样的解调器来简化表达式。
chap3_para1944,8,,下面的例子中，给定
chap3_para1945,1,,我们可以通过解调得出
chap3_para1946,1,,更为形式化地，我们有
chap3_para1947,1,,● 解调（demodulation）：对于任意项x、y和z，其中z出现在文字mi中的某处且 ，
chap3_para1948,1,,其中Subst是对绑定表的一般置换，而表示在m中的某处用y替换x。
chap3_para1949,1,,这个规则可以拓展到处理含有等词的非单元子句。
chap3_para195,1,"The first and last lines form a contradiction, so the supposition that the algorithm could return a suboptimal path must be wrong—it must be that A* returns only cost-optimal paths.",3.5.2　A*搜索
chap3_para1950,1,,● 超解调（paramodulation）：对于任意项x、y和z，其中z出现在文字mi中的某处且，
chap3_para1953,1,,我们有，通过超解调我们可以得到结论
chap3_para1954,1,,超解调产生含有等词的一阶逻辑的一个完备推断程序。
chap3_para1955,1,,第三种方法仅使用拓展的合一算法处理等词推理。
chap3_para1955,2,,也就是说，如果若干项在某种置换下可证明为相等，则它们是可合一的，其中“可证明”允许等词推理。
chap3_para1955,3,,例如，项1 + 2和2 + 1通常不可合一，但知道的合一算法可以用空置换合一它们。
chap3_para1955,4,,这种等词合一（equational unification）可以用针对特定公理（交换性、结合性等）设计的高效算法完成，而非通过直接用这些公理推断。
chap3_para1955,5,,使用这种技术的定理证明器与9.4节所述的CLP系统密切相关。
chap3_para1956,1,,9.5.6　归结策略
chap3_para1957,1,,我们知道只要证明存在，反复运用归结推断规则总会找到一个证明。
chap3_para1957,2,,在本节中我们考察有助于高效找出证明的策略。
chap3_para1958,1,,单元优先（unit preference）：这个策略优先处理其中一条语句为单文字（也就是单元子句）的归结。
chap3_para1958,2,,这一策略的思路是，我们试图产生空子句，因此先处理产生较短子句的推断可能是个好主意。
chap3_para1958,3,,归结单元语句（如P）与其他任意语句（如）总是生成比其他子句短的子句（本例中为）。
chap3_para1958,4,,当这种单元优先策略在1964年首次被用于命题推断时，它产生了巨大的加速作用，使得它能够证明许多先前无法处理的定理。
chap3_para1958,5,,单元归结是归结的一种受限形式，其中归结的每一步都含有单元子句。
chap3_para1958,6,,单元归结总体上是不完备的，但对霍恩子句是完备的。
chap3_para1958,7,,霍恩子句上的单元归结证明与前向链接类似。
chap3_para1959,1,,"Otter定理证明器（McCune, 1990）使用了最佳优先搜索。"
chap3_para1959,2,,其启发函数度量每个子句的“权重”，并偏好权重较轻的子句。
chap3_para1959,3,,启发式函数的选择取决于用户，但通常子句的权重应当与其规模或难度相关。
chap3_para1959,4,,它认为单元子句权重较轻，因此这种搜索可以被看作单元优先策略的一般化。
chap3_para196,1,"A slightly stronger property is called consistency. A heuristic h(n) is consistent if, for every node n and every successor nʹ of n generated by an action a, we have:",最常见的有信息搜索算法是A*搜索（A* search）（读为“A星搜索”），这是一种最佳优先搜索，评价函数为
chap3_para197,1,"This is a form of the triangle inequality, which stipulates that a side of a triangle cannot be longer than the sum of the other two sides (see Figure 3.",其中g(n)是从初始状态到节点n的路径代价，h(n)是从节点n到一个目标状态的最短路径的代价估计值，因此我们有
chap3_para197,2,19).,
chap3_para197,3,An example of a consistent heuristic is the straight-line distance hSLD that we used in getting to Bucharest.,
chap3_para198,1,"Description Part (“A”): The initial state. A green-colored node is labeled Arad 366 equals 0 plus 366. An arrowhead points to Arad. Part (b): After expanding Arad. The Arad node is now lavender-colored and is connected to three green-colored nodes labeled Sibiu 393 equals 140 plus 253, Timisoara 447 equals 118 plus 329, and Zerind 449 equals 75 plus 374. An arrowhead points to Sibiu. Part (c): After expanding Sibiu. The Sibiu node is now lavender-colored and is connected to four green-colored nodes labeled Arad 646 equals 280 plus 366, Fagaras 415 equals 239 plus 176, Oradea 671 equals 291 plus 380, and Rimnicu Vilcea 413 equals 220 plus 193. An arrowhead points to Rimnicu Vilcea. Part (d): After expanding Rimnicu Vilcea. The Rimnicu Vilcea node is now lavender-colored and is connected to three green-colored nodes labeled Craiova 526 equals 366 plus 160, Pitesti 417 equals 317 plus 100, and Sibiu 553 equals 300 plus 253. An arrowhead points to Fagaras. Part (e): After expanding Fagaras. The Fagaras node under the Sibiu node is now lavender-colored and is connected to two green-colored nodes labeled Sibiu 591 equals 338 plus 253 and Bucharest 450 equals 450 plus 0. An arrowhead points to Pitesti under Rimnicu Vilcea. Part (f): After expanding Pitesti. The node Pitesti is now lavender-colored and is connected to three green-colored nodes labeled Bucharest 418 equals 418 plus 0, Craiova 615 equals 455 plus 160, and Rimnicu Vilcea 607 equals 414 plus 193. An arrowhead points to Bucharest under the Pitesti node.",f(n) = 经过n到一个目标状态的最优路径的代价估计值
chap3_para199,1,"Figure 3.19 Triangle inequality: If the heuristic h is consistent, then the single number h(n) will be less than the sum of the cost c(n, a, aʹ) of the action from n to nʹ plus the heuristic estimate h(nʹ).",在图3-18中，我们展示了目标为Bucharest的A*搜索过程。
chap3_para199,2,,g的值由图3-1中的动作代价计算得到，hSLD的值在图3-16中给出。
chap3_para199,3,,注意，Bucharest首先出现在图3-18的步骤e的边界中，但算法并没有选择它来进行扩展（因此它没有被检测为一个解），因为此时它不是边界中代价最小的节点（f = 450）——代价最小的节点是Pitesti（f = 417）。
chap3_para199,4,,换句话说，可能存在一个经过Pitesti的解，代价低至417，所以算法不会满足于一个代价为450的解。
chap3_para199,5,,在图3-18的步骤f中，另一条到Bucharest的路径此时代价最小（f = 418），因此它被选中并被检测为最优解。
chap3_para2,1,In which we see how an agent can look ahead to find a sequence of actions that will eventually achieve its goal.,当要采取的正确动作不是很明显时，智能体可能需要提前规划：考虑一个形成通往目标状态路径的动作序列。
chap3_para2,2,,这样的智能体被称为问题求解智能体（problem-solving agent），它所进行的计算过程被称为搜索（search）。
chap3_para20,1,•A set of possible states that the environment can be in. We call this the state space.,● 可能的环境状态（state）的集合，我们称之为状态空间（state space）。
chap3_para200,1,"Every consistent heuristic is admissible (but not vice versa), so with a consistent heuristic, A* is cost-optimal. In addition, with a consistent heuristic, the first time we reach a state it will be on an optimal path, so we never have to re-add a state to the frontier, and never have to change an entry in reached. But with an inconsistent heuristic, we may end up with multiple paths reaching the same state, and if each new path has a lower path cost than the previous one, then we will end up with multiple nodes for that state in the frontier, costing us both time and space. Because of that, some implementations of A* take care to only enter a state into the frontier once, and if a better path to the state is found, all the successors of the state are updated (which requires that nodes have child pointers as well as parent pointers). These complications have led many implementers to avoid inconsistent heuristics, but Felner et al. (2011) argues that the worst effects rarely happen in practice, and one shouldn’t be afraid of inconsistent heuristics.",A*搜索是完备的。
chap3_para200,2,,[11]它是否是代价最优则取决于启发式函数的某些性质。
chap3_para200,3,,一个关键性质是可容许性（admissibility）：一个可容许的启发式（admissible heuristic）函数永远不会高估到达某个目标的代价。
chap3_para200,4,,（因此，一个可容许的启发式函数是乐观的。
chap3_para200,5,,）
chap3_para201,1,"With an inadmissible heuristic, A* may or may not be cost-optimal. Here are two cases where it is: First, if there is even one cost-optimal path on which h(n) is admissible for all nodes n on the path, then that path will be found, no matter what the heuristic says for states off the path. Second, if the optimal solution has cost C*, and the second-best has cost C2, and if h(n) overestimates some costs, but never by more than C2 – C*, then A* is guaranteed to return cost-optimal solutions.",
chap3_para202,1,3.,[11]　再强调一次，假设所有动作的代价都 ，状态空间要么有解，要么有限。
chap3_para202,2,5.,
chap3_para202,3,3Search contours,
chap3_para203,1,"A useful way to visualize a search is to draw contours in the state space, just like the contours in a topographic map. Figure 3.20 shows an example. Inside the contour labeled 400, all nodes have f(n) = g(n) + h(n) ≤ 400, and so on. Then, because A* expands the frontier node of lowest f-cost, we can see that an A* search fans out from the start node, adding nodes in concentric bands of increasing f-cost.",对于可容许的启发式函数，A*是代价最优的，我们可以通过反证法来证明这一点。
chap3_para203,2,,假设最优路径的代价为C*，但是该算法返回的路径代价为C C*，那么最优路径上一定存在某个未扩展的节点n（因为如果最优路径上的所有节点都已被扩展，那么算法返回的将是这个最优解）。
chap3_para203,3,,因此，使用符号g*(n)表示从起点到n的最优路径的代价，h*(n)表示从n到最近目标的最优路径的代价，我们将得到
chap3_para204,1,"Description Three circles are labeled n, n prime, and G subscript n prime. An arrow from n to G subscript n prime is labeled h (n). An arrow from n prime to G subscript n prime is labeled h (n prime). An arrow from n to n prime is labeled c (n, “A”, n prime).",第一行和最后一行矛盾，所以“算法可能返回次优路径”的假设一定是错误的——A*一定只返回代价最优路径。
chap3_para205,1,Figure 3.,另一个稍强的性质为一致性（consistency）。
chap3_para205,2,"20 Map of Romania showing contours at f = 380, f = 400, and f = 420, with Arad as the start state.",如果对于每个节点n以及由动作a生成的n的每个后继节点n' 有以下条件，则启发式函数h(n)是一致的：
chap3_para205,3,Nodes inside a given contour have f = g + h costs less than or equal to the contour value.,
chap3_para206,1,"With uniform-cost search, we also have contours, but of g-cost, not g + h. The contours with uniform-cost search will be “circular” around the start state, spreading out equally in all directions with no preference towards the goal. With A* search using a good heuristic, the g + h bands will stretch toward a goal state (as in Figure 3.20) and become more narrowly focused around an optimal path.",这是三角不等式（triangle inequality）的一种形式，它规定三角形的一条边不能大于其他两条边之和（见图3-19）。
chap3_para206,2,,一致的启发式函数的一个实例是上文中的直线距离hSLD。
chap3_para207,1,"It should be clear that as you extend a path, the g costs are monotonic: the path cost always increases as you go along a path, because action costs are always positive.12 Therefore you get concentric contour lines that don’t cross each other, and if you choose to draw the lines fine enough, you can put a line between any two nodes on any path.",图3-18　A*搜索的各个阶段（目标为Bucharest）。
chap3_para207,2,,节点上标有f = g + h，h值为图3-16中得到的到Bucharest的直线距离
chap3_para208,1,"But it is not obvious whether the f = g + h cost will monotonically increase. As you extend a path from n to nʹ, the cost goes from g(n) + h(n) to g(n) + c(n, a, n') + h(n'). Canceling out the g(n) term, we see that the path’s cost will be monotonically increasing if and only if h(n) ≤ c(n, a, n') + h(n'); in other words if and only if the heuristic is consistent.13 But note that a path might contribute several nodes in a row with the same g(n) + h(n) score; this will happen whenever the decrease in h is exactly equal to the action cost just taken (for example, in a grid problem, when n is in the same row as the goal and you take a step towards the goal, g is increased by 1 and h is decreased by 1). If C* is the cost of the optimal solution path, then we can say the following:","图3-19　三角不等式：如果启发式函数h是一致的，那么单个数值h(n)小于从n到n'的动作代价值c(n, a, n')加上启发式函数的估计值h(n')的和"
chap3_para209,1,•A* expands all nodes that can be reached from the initial state on a path where every node on the path has f(n) < C*. We say these are surely expanded nodes.,一致的启发式函数都是可容许的（反过来不成立），因此，使用一致的启发式函数的A*搜索都是代价最优的。
chap3_para209,2,,此外，如果使用一致的启发式函数，算法第一次到达某个状态时，它就在一条最优路径上，因此我们永远不需要将某个状态重复添加到边界中，也不必更改reached中的条目。
chap3_para209,3,,但是，如果使用不一致的启发式函数，最终可能导致多个路径到达相同状态，而且如果每条新路径的路径代价都小于前一条路径，最终在边界中该状态会有多个节点，这会耗费时间和空间。
chap3_para209,4,,因此，有些A*搜索算法的实现会注意让一个状态只进入边界一次，如果找到了到达该状态的更优路径，那么该状态的所有后继都会更新（这要求节点除了父指针外还要有子指针）。
chap3_para209,5,,"这些复杂性使得许多研究人员在实现A*搜索时避免使用不一致的启发式函数，但费尔纳等人（Felner et al., 2011）认为，最坏的结果在实践中很少发生，因此不应该害怕不一致的启发式函数。"
chap3_para21,1,•The initial state that the agent starts in. For example: Arad.,● 智能体启动时的初始状态（initial state），例如Arad。
chap3_para210,1,•A* might then expand some of the nodes right on the “goal contour” (where f(n) = C*) before selecting a goal node.,如果采用不可容许的启发式函数，那么A*搜索可能是代价最优的，也可能不是。
chap3_para210,2,,存在两种情况使得A*搜索是代价最优的：第一，如果存在一条代价最优路径，对于该路径上的所有节点n，h(n)都是可容许的，那么无论启发式函数在路径外状态上的值如何，算法都能找到这条路径。
chap3_para210,3,,第二，假设最优解的代价为C*，次优解的代价为C2，如果h(n)高估了部分代价但又没有高估太多，都不超过C2 − C*，那么也可以保证A*返回的解是代价最优的。
chap3_para211,1,•A* expands no nodes with f(n) > C*.,3.5.3　搜索等值线
chap3_para212,1,"We say that A* with a consistent heuristic is optimally efficient in the sense that any algorithm that extends search paths from the initial state, and uses the same heuristic information, must expand all nodes that are surely expanded by A* (because any one of them could have been part of an optimal solution). Among the nodes with f(n) = C*, one algorithm could get lucky and choose the optimal one first while another algorithm is unlucky; we don’t consider this difference in defining optimal efficiency.",一种对搜索进行可视化的方法是在状态空间中绘制等值线（contour），就像在地形图中绘制等高线一样。
chap3_para212,2,,如图3-20所示，在标记为400的等值线内，所有节点都有，以此类推。
chap3_para212,3,,因为A*扩展的是f代价最小的边界节点，所以它是从初始节点扇形地向外扩展，以f 值递增的同心带状方式添加节点。
chap3_para213,1,"A* is efficient because it prunes away search tree nodes that are not necessary for finding an optimal solution. In Figure 3.18(b) we see that Timisoara has f = 447 and Zerind has f = 449. Even though they are children of the root and would be among the first nodes expanded by uniform-cost or breadth-first search, they are never expanded by A* search because the solution with f = 418 is found first. The concept of pruning—eliminating possibilities from consideration without having to examine them—is important for many areas of AI.",一致代价搜索中也存在等值线，但是等值线表示g代价，而不是g + h。
chap3_para213,2,,一致代价搜索中，等值线将以初始状态为圆心呈“圆形”向各个方向均匀扩展，而不是偏向于目标状态。
chap3_para213,3,,对于具有好的启发式函数的A*搜索，g + h带将朝一个目标状态延伸（如图3-20所示），并且在最优路径周围收敛变窄。
chap3_para214,1,"That A* search is complete, cost-optimal, and optimally efficient among all such algorithms is rather satisfying.",需要清楚的是，扩展路径时，g代价是单调的（monotonic）：路径代价始终随着路径的延伸而不断增加，因为动作代价始终为正。
chap3_para214,2,"Unfortunately, it does not mean that A* is the answer to all our searching needs.",[12]因此，所得到的同心等值线彼此不会交叉，如果希望画出的等值线足够精细，则可以在任何路径上的任意两个节点之间画一条线。
chap3_para214,3,"The catch is that for many problems, the number of nodes expanded can be exponential in the length of the solution.",
chap3_para214,4,"For example, consider a version of the vacuum world with a super-powerful vacuum that can clean up any one square at a cost of 1 unit, without even having to visit the square; in that scenario, squares can be cleaned in any order.",
chap3_para214,5,"With N initially dirty squares, there are 2N states where some subset has been cleaned; all of those states are on an optimal solution path, and hence satisfy f(n) < C*, so all of them would be visited by A*.",
chap3_para215,1,3.,
chap3_para215,2,5.,
chap3_para215,3,4Satisficing search: Inadmissible heuristics and weighted A*,
chap3_para216,1,"A* search has many good qualities, but it expands a lot of nodes. We can explore fewer nodes (taking less time and space) if we are willing to accept solutions that are suboptimal, but are “good enough”—what we call satisficing solutions. If we allow A* search to use an inadmissible heuristic—one that may overestimate—then we risk missing the optimal solution, but the heuristic can potentially be more accurate, thereby reducing the number of nodes expanded. For example, road engineers know the concept of a detour index, which is a multiplier applied to the straight-line distance to account for the typical curvature of roads. A detour index of 1.3 means that if two cities are 10 miles apart in straight-line distance, a good estimate of the best path between them is 13 miles. For most localities, the detour index ranges between 1.2 and 1.6.",[12]　从技术上讲，始终保持增加的代价称为“严格单调的”；永远不会减少但可能保持不变的代价称为“单调的”。
chap3_para217,1,"We can apply this idea to any problem, not just ones involving roads, with an approach called weighted A* search where we weight the heuristic value more heavily, giving us the evaluation function f(n)= g(n) + W × h(n), for some W > 1.",但代价是否单调递增则并不显然。
chap3_para217,2,,当你将一条路径从n扩展到n'时，代价从变为。
chap3_para217,3,,消去g(n)项，我们可以看到，当且仅当时，路径代价单调递增。
chap3_para217,4,,换句话说，当且仅当启发式函数是一致的时，路径代价单调递增。
chap3_para217,5,,[13]但需要注意的是，一条路径可能会在一行中贡献若干个具有相同g(n) + h(n)得分的节点；当h的减少量恰好等于刚刚采取的动作代价时，就会发生这种情况（例如，在一个网格问题中，当n与目标在同一行然后向目标迈进一步时，g增加1，h减少1）。
chap3_para217,6,,如果C*是最优解路径的代价，那么以下说法成立。
chap3_para218,1,"Figure 3.21 shows a search problem on a grid world. In (a), an A* search finds the optimal solution, but has to explore a large portion of the state space to find it. In (b), a weighted A* search finds a solution that is slightly costlier, but the search time is much faster. We see that the weighted search focuses the contour of reached states towards a goal. That means that fewer states are explored, but if the optimal path ever strays outside of the weighted search’s contour (as it does in this case), then the optimal path will not be found. In general, if the optimal solution costs C*, a weighted A* search will find a solution that costs somewhere between C* and W × C*; but in practice we usually get results much closer to C* than W × C*.",
chap3_para219,1,"Description The cities of Romania as shown as nodes and each node is labeled with the respective city’s starting letter. The contour labeled 380 encloses node “A”. The contour labeled 400 encloses “A” and S. The contour labeled 420 encloses “A”, S, R, F, P, and B. The remaining cities are outside all contours shown.",[13]　事实上，“单调启发式函数”这一术语是“一致的启发式函数”的同义词。
chap3_para219,2,,"这两种观点是独立发展的，但是之后被证明是等价的（Pearl, 1984）。"
chap3_para22,1,"•A set of one or more goal states. Sometimes there is one goal state (e.g., Bucharest), sometimes there is a small set of alternative goal states, and sometimes the goal is defined by a property that applies to many states (potentially an infinite number). For example, in a vacuum-cleaner world, the goal might be to have no dirt in any location, regardless of any other facts about the state. We can account for all three of these possibilities by specifying an IS-GOAL method for a problem. In this chapter we will sometimes say “the goal” for simplicity, but what we say also applies to “any one of the possible goal states.”",● 一个或多个目标状态（goal state）的集合。
chap3_para22,2,,有时问题只有一个目标状态（如Bucharest），有时存在若干个可供选择的目标状态，也有时目标是由一个适用于许多状态（可能是无限多个状态）的属性所定义的。
chap3_para22,3,,例如，在一个真空吸尘器世界里，目标可能是让任何位置都没有灰尘，而无论该状态的其他情况如何。
chap3_para22,4,,我们通过给问题指定一个Is-Goal方法来将这3种可能性都考虑在内。
chap3_para22,5,,在本章中，为了简单起见，我们有时会直接用“目标”一词，它表示“任一可能的目标状态”。
chap3_para220,1,Figure 3.,● A*搜索将扩展从初始状态可以到达并且路径上的每个节点都满足的所有节点。
chap3_para220,2,21 Two searches on the same grid: (a) an A* search and (b) a weighted A* search with weight W = 2.,我们称这些节点为必然扩展节点（surely expanded node）。
chap3_para220,3,"The gray bars are obstacles, the purple line is the path from the green start to red goal, and the small dots are states that were reached by each search.",
chap3_para220,4,"On this particular problem, weighted A* explores 7 times fewer states and finds a path that is 5% more costly.",
chap3_para221,1,We have considered searches that evaluate states by combining g and h in various ways; weighted A* can be seen as a generalization of the others:,● A*搜索可能会在选出目标节点之前扩展某些恰好在“目标等值线”（即f (n) = C*）上的节点。
chap3_para222,1,"You could call weighted A* “somewhat-greedy search”: like greedy best-first search, it focuses the search towards a goal; on the other hand, it won’t ignore the path cost completely, and will suspend a path that is making little progress at great cost.",● A*搜索不扩展的节点。
chap3_para223,1,"There are a variety of suboptimal search algorithms, which can be characterized by the criteria for what counts as “good enough.” In bounded suboptimal search, we look for a solution that is guaranteed to be within a constant factor W of the optimal cost. Weighted A* provides this guarantee. In bounded-cost search, we look for a solution whose cost is less than some constant C. And in unbounded-cost search, we accept a solution of any cost, as long as we can find it quickly.",图3-20　罗马尼亚地图，其中等值线为f = 380、f = 400和f = 420，初始状态为Arad。
chap3_para223,2,,给定等值线内的节点的代价f = g + h小于或等于等值线值
chap3_para224,1,"An example of an unbounded-cost search algorithm is speedy search, which is a version of greedy best-first search that uses as a heuristic the estimated number of actions required to reach a goal, regardless of the cost of those actions.",我们认为具有一致启发式函数的A*搜索是效率最优（optimally efficient）的，因为任何从初始状态扩展搜索路径并使用相同启发式信息的算法都必须扩展A*的所有必然扩展节点（因为任何一个必然扩展节点都可能是某个最优解的一部分）。
chap3_para224,2,"Thus, for problems where all actions have the same cost it is the same as greedy best-first search, but when actions have different costs, it tends to lead the search to find a solution quickly, even if it might have a high cost.",对于f(n)=C*的节点，某个算法可能运气好，首先选择了最优节点，而另一个算法就没这么幸运。
chap3_para224,3,,我们在定义最优效率时不考虑这种差异。
chap3_para225,1,3.,A*之所以高效，是因为它会对那些对于寻找最优解没有帮助的搜索树节点进行剪枝（pruning）。
chap3_para225,2,5.,在图3-18b中，我们看到，对于Timisoara，f = 447；对于Zerind，f = 449。
chap3_para225,3,5Memory-bounded search,即使它们是根的子节点并且是采用一致代价搜索或广度优先搜索时首先扩展的节点，它们也永远不会被A*搜索扩展，因为A*会首先找到f = 418的解。
chap3_para225,4,,对许多人工智能领域来说，剪枝（不必进行检查就可以排除不正确的答案）非常重要。
chap3_para226,1,"The main issue with A* is its use of memory. In this section we’ll cover some implementation tricks that save space, and then some entirely new algorithms that take better advantage of the available space.",在所有这些算法中，A*搜索都是完备的、代价最优的和效率最优的，这是相当令人满意的结果。
chap3_para226,2,,遗憾的是，这并不意味着A*适用于所有搜索需求。
chap3_para226,3,,问题在于，对于许多问题，所扩展的节点数可能是解路径长度的指数级。
chap3_para226,4,,例如，考虑一个具有超强吸力的真空吸尘器世界，它可以以单位代价清理任一方格却不需要访问该方格。
chap3_para226,5,,在这种情况下，可以按任何顺序清理方格。
chap3_para226,6,,如果开始时有N个脏的方格，则有2N种状态，其中某个子集已被清理；所有这些状态都在最优解路径上，因此满足，所以所有这些状态都会被A*搜索访问。
chap3_para227,1,Memory is split between the frontier and the reached states.,3.5.4　满意搜索：不可容许的启发式函数与加权A*搜索
chap3_para227,2,"In our implementation of best-first search, a state that is on the frontier is stored in two places: as a node in the frontier (so we can decide what to expand next) and as an entry in the table of reached states (so we know if we have visited the state before).",
chap3_para227,3,"For many problems (such as exploring a grid), this duplication is not a concern, because the size of frontier is much smaller than reached, so duplicating the states in the frontier requires a comparatively trivial amount of memory.",
chap3_para227,4,"But some implementations keep a state in only one of the two places, saving a bit of space at the cost of complicating (and perhaps slowing down) the algorithm.",
chap3_para228,1,Another possibility is to remove states from reached when we can prove that they are no longer needed.,A*搜索有很多好的性质，但它扩展了大量节点。
chap3_para228,2,"For some problems, we can use the separation property (Figure 3.",如果我们愿意接受次优但“足够好”的解——我们称之为满意（satisficing）解，则可以探索更少的节点（花费更少的时间和空间）。
chap3_para228,3,"6 on page 90), along with the prohibition of U-turn actions, to ensure that all actions either move outwards from the frontier or onto another frontier state.",如果我们允许A*搜索使用不可容许的启发式函数（inadmissible heuristic）（它可能会高估到达某个目标的代价），那么我们就有可能错过最优解，但是该启发式函数可能更准确，从而减少了需要扩展的节点数。
chap3_para228,4,"In that case, we need only check the frontier for redundant paths, and we can eliminate the reached table.",例如，道路工程师知道弯道指数（detour index）的概念，它是应用于直线距离的乘数，用来说明道路的典型曲率。
chap3_para228,5,,弯道指数1.3意味着如果两个城市的直线距离相距10千米，那么它们之间的最优路径的一个恰当的估计值是13千米。
chap3_para228,6,,对于大多数地区，弯道指数的范围是1.2到1.6。
chap3_para229,1,"For other problems, we can keep reference counts of the number of times a state has been reached, and remove it from the reached table when there are no more ways to reach the state.",不仅仅是与道路相关的问题，我们还可以将这一思想应用于任何问题，我们采用一种称为加权A*搜索（weighted A* search）的方法，对启发式函数的值进行更重的加权，评价函数为，其中。
chap3_para229,2,"For example, on a grid world where each state can be reached only from its four neighbors, once we have reached a state four times, we can remove it from the table.",
chap3_para23,1,"•The actions available to the agent. Given a state s, ACTIONS(s) returns a finite2 set of actions that can be executed in s. We say that each of these actions is applicable in s. An example:",● 智能体可以采取的行动（action）。
chap3_para23,2,,给定一个状态s，Actions(s)将返回在s中可以执行的有限[2]动作集合。
chap3_para23,3,,我们称集合中的任一动作在s中都是适用的（applicable）。
chap3_para23,4,,例如：
chap3_para230,1,Now let’s consider new algorithms that are designed to conserve memory usage.,图3-21为一个网格世界中的搜索问题。
chap3_para230,2,,在图3-21a中，A*搜索必须探索大部分状态空间才能找到最优解。
chap3_para230,3,,在图3-21b中，加权A*搜索找到一个代价稍高的解，但搜索时间要快得多。
chap3_para230,4,,我们看到，加权搜索使得已达状态的等值线专注于趋向某个目标。
chap3_para230,5,,这意味着需要探索的状态变少，但如果最优路径偏离加权搜索的等值线（就像在这种情况下一样），则无法找到最优路径。
chap3_para230,6,,一般来说，如果最优解的代价是C*，那么加权A*搜索将找到一个代价介于C*和W×C*之间的解；但在实践中，通常结果更接近于C*而不是W×C*。
chap3_para231,1,Beam search limits the size of the frontier.,图3-21　同一网格上的两种搜索：（a）A*搜索，（b）加权A*搜索，权重W = 2。
chap3_para231,2,"The easiest approach is to keep only the k nodes with the best f-scores, discarding any other expanded nodes.",灰色线条表示障碍，紫色线是一条从绿色起始点到红色目标点的路径，较小的点是每次搜索到达的状态。
chap3_para231,3,"This of course makes the search incomplete and suboptimal, but we can choose k to make good use of available memory, and the algorithm executes fast because it expands fewer nodes.",在这个特定问题上，加权A*搜索探索的状态数不到A*搜索探索的状态数的七分之一，找到的路径的代价只比最优代价大了5%
chap3_para231,4,For many problems it can find good near-optimal solutions.,
chap3_para231,5,"You can think of uniform-cost or A* search as spreading out everywhere in concentric contours, and think of beam search as exploring only a focused portion of those contours, the portion that contains the k best candidates.",
chap3_para232,1,"An alternative version of beam search doesn’t keep a strict limit on the size of the frontier but instead keeps every node whose f-score is within δ of the best f-score. That way, when there are a few strong-scoring nodes only a few will be kept, but if there are no strong nodes then more will be kept until a strong one emerges.",我们已经考虑过以各种方式组合g和h来评价状态的搜索方法；加权A*搜索可以看作是其他方法的一般化。
chap3_para233,1,"Iterative-deepening A* search (IDA*) is to A* what iterative-deepening search is to depth-first: IDA* gives us the benefits of A* without the requirement to keep all reached states in memory, at a cost of visiting some states multiple times.",
chap3_para233,2,It is a very important and commonly used algorithm for problems that do not fit in memory.,
chap3_para234,1,"In standard iterative deepening the cutoff is the depth, which is increased by one each iteration. In IDA* the cutoff is the f-cost (g + h); at each iteration, the cutoff value is the smallest f-cost of any node that exceeded the cutoff on the previous iteration. In other words, each iteration exhaustively searches an f-contour, finds a node just beyond that contour, and uses that node’s f-cost as the next contour. For problems like the 8-puzzle where each path’s f-cost is an integer, this works very well, resulting in steady progress towards the goal each iteration. If the optimal solution has cost C*, then there can be no more than C* iterations (for example, no more than 31 iterations on the hardest 8-puzzle problems). But for a problem where every node has a different f-cost, each new contour might contain only one new node, and the number of iterations could be equal to the number of states.",
chap3_para235,1,"Recursive best-first search (RBFS) (Figure 3.22) attempts to mimic the operation of standard best-first search, but using only linear space. RBFS resembles a recursive depth-first search, but rather than continuing indefinitely down the current path, it uses the f-limit variable to keep track of the f-value of the best alternative path available from any ancestor of the current node. If the current node exceeds this limit, the recursion unwinds back to the alternative path. As the recursion unwinds, RBFS replaces the f-value of each node along the path with a backed-up value—the best f-value of its children. In this way, RBFS remembers the f-value of the best leaf in the forgotten subtree and can therefore decide whether it’s worth reexpanding the subtree at some later time. Figure 3.23 shows how RBFS reaches Bucharest.",
chap3_para236,1,"Description In both parts, equidistant small dots are shown across the entire grid. A maze of multiple gray bars is shown scattered throughout the grid. A green dot is shown toward the left end of the grid and a red dot toward the right end of the grid. A purple line starts from the green, moves through the grid, and ends at the red dot. The purple line doesn’t cross or pass through any gray bars, rather, it moves above, below, or between two gray bars. Part (“A”): The purple line takes a path that almost resembles a curve that opens upward. The purple line stays mostly below the bulk of the gray bars, without navigating much through the maze of the gray bars. Part (b): The purple line moves in an irregular path. The purple line navigates through the maze of the gray bars, through the bulk.",
chap3_para237,1,Figure 3.,你可以称加权A*搜索为“有点贪心的搜索”：就像贪心最佳优先搜索一样，它使得搜索专注于趋向一个目标；但是，它不会完全忽略路径代价，并且会暂停代价高昂但进展甚微的路径。
chap3_para237,2,22 The algorithm for recursive best-first search.,
chap3_para238,1,"RBFS is somewhat more efficient than IDA*, but still suffers from excessive node regeneration. In the example in Figure 3.23, RBFS follows the path via Rimnicu Vilcea, then “changes its mind” and tries Fagaras, and then changes its mind back again. These mind changes occur because every time the current best path is extended, its f-value is likely to increase—h is usually less optimistic for nodes closer to a goal. When this happens, the second-best path might become the best path, so the search has to backtrack to follow it. Each mind change corresponds to an iteration of IDA* and could require many reexpansions of forgotten nodes to recreate the best path and extend it one more node.",次优的搜索算法有很多，其区别在于“足够好”的标准。
chap3_para238,2,,在有界次优搜索（bounded suboptimal search）中，我们寻找一个能保证代价在最优代价的常数因子W倍内的解。
chap3_para238,3,,加权A*搜索提供了这一保证。
chap3_para238,4,,在有界代价搜索（bounded-cost search）中，我们寻找一个代价小于某个常数C的解。
chap3_para238,5,,在无界代价搜索（unbounded-cost search）中，我们接受任何代价的解，只要能快速找到它。
chap3_para239,1,"Description Part (“A”): After expanding Pitesti, Sibiu, and Rimnicu Vilcea. A node labeled Arad 366 is connected to three nodes labeled Sibiu 393, Timisoara 447, and Zerind 449. Timisoara and Zerind are green-colored. A small box above Arad reads infinity. Sibiu is connected to four nodes labeled Arad 646, Fagaras 415, Oradea 671, and Rimnicu Vilcea 413. A small box each above Sibiu and Rimnicu Vilcea read 447 and 415, respectively. Arad, Sibiu, and Rimnicu Vilcea are lavender-colored. The other three nodes under Sibiu are green-colored. Rimnicu Vilcea is connected to three green-colored nodes, Craiova 526, Pitesti 417, and Sibiu 553. Part (b): After unwinding back to Sibiu and expanding Fagaras. Rimnicu Vilcea is now green-colored, the small box above it is removed, and the node’s previous label of 413 is struck off to read the new value of 417. Fagaras is now lavender-colored and has a small box above it that reads 417. Fagaras is connected to two green-colored nodes labeled Sibiu 591 and Bucharest 450. Part (c): After switching back to Rimnicu Vilcea and expanding Pitesti. Fagaras is now back to being green-colored, the small box above it is removed, and the node’s previous label of 415 is struck off to read the new value of 450. Rimnicu Vilcea is back to being lavender-colored and has a small box above it that reads 447. Rimnicu Vilcea is connected to three nodes labeled Craiova 526, Pitesti 417, and Sibiu 553. Pitesti is lavender-colored and has a small box above it that reads 447. The other two nodes under Rimnicu Vilcea are green-colored. Pitesti is connected to three green-colored nodes Bucharest 418, Craiova 615, and Rimnicu Vilcea 607.",无界代价搜索算法的一个例子是快速搜索（speedy search），它是一种贪心最佳优先搜索，使用到达目标所需动作个数的估计值作为启发式函数，不考虑这些动作的代价。
chap3_para239,2,,因此，对于所有动作都具有相同代价的问题，它等于贪心最佳优先搜索，但当动作具有不同代价时，它往往会导致搜索快速找到一个代价可能很高的解。
chap3_para24,1,"•A transition model, which describes what each action does. RESULT(s, a) returns the state that results from doing action a in state s. For example,",
chap3_para240,1,Figure 3.,3.5.5　内存受限搜索
chap3_para240,2,23 Stages in an RBFS search for the shortest route to Bucharest.,
chap3_para240,3,"The f-limit value for each recursive call is shown on top of each current node, and every node is labeled with its f-cost.",
chap3_para240,4,(a) The path via Rimnicu Vilcea is followed until the current best leaf (Pitesti) has a value that is worse than the best alternative path (Fagaras).,
chap3_para240,5,"(b) The recursion unwinds and the best leaf value of the forgotten subtree (417) is backed up to Rimnicu Vilcea; then Fagaras is expanded, revealing a best leaf value of 450.",
chap3_para240,6,(c) The recursion unwinds and the best leaf value of the forgotten subtree (450) is backed up to Fagaras; then Rimnicu Vilcea is expanded.,
chap3_para240,7,"This time, because the best alternative path (through Timisoara) costs at least 447, the expansion continues to Bucharest.",
chap3_para241,1,RBFS is optimal if the heuristic function h(n) is admissible.,A*搜索的主要问题是它对内存的使用较多。
chap3_para241,2,"Its space complexity is linear in the depth of the deepest optimal solution, but its time complexity is rather difficult to characterize: it depends both on the accuracy of the heuristic function and on how often the best path changes as nodes are expanded.",在本节中，我们将介绍一些可以节省空间的实现技巧和一些能够更好地利用可用空间的全新算法。
chap3_para241,3,"It expands nodes in order of increasing f-score, even if f is nonmonotonic.",
chap3_para242,1,IDA* and RBFS suffer from using too little memory.,内存被分为frontier状态和reached状态。
chap3_para242,2,"Between iterations, IDA* retains only a single number: the current f-cost limit.",在我们所实现的最佳优先搜索中，边界上的状态存储在两个位置：边界中的一个节点（因此我们可以决定下一步扩展哪个节点）和已达状态表中的一个表项（因此我们知道之前是否访问过该状态）。
chap3_para242,3,"RBFS retains more information in memory, but it uses only linear space: even if more memory were available, RBFS has no way to make use of it.",对于许多问题（例如探索网格），这种重复不是关注点，因为frontier要比reached小得多，所以复制边界中的状态所需内存相对较少。
chap3_para242,4,"Because they forget most of what they have done, both algorithms may end up reexploring the same states many times over.",但是有些算法实现只保留这两个位置中的其中一个，从而节省了一点空间，其代价是算法变得更复杂（可能会减慢速度）。
chap3_para243,1,"It seems sensible, therefore, to determine how much memory we have available, and allow an algorithm to use all of it. Two algorithms that do this are MA* (memory-bounded A*) and SMA* (simplified MA*). SMA* is—well—simpler, so we will describe it. SMA* proceeds just like A*, expanding the best leaf until memory is full. At this point, it cannot add a new node to the search tree without dropping an old one. SMA* always drops the worst leaf node—the one with the highest f-value. Like RBFS, SMA* then backs up the value of the forgotten node to its parent. In this way, the ancestor of a forgotten subtree knows the quality of the best path in that subtree. With this information, SMA* regenerates the subtree only when all other paths have been shown to look worse than the path it has forgotten. Another way of saying this is that if all the descendants of a node n are forgotten, then we will not know which way to go from n, but we will still have an idea of how worthwhile it is to go anywhere from n.",另一种可能性是，当我们能够证明不再需要某些状态时，就将它们从reached中删除。
chap3_para243,2,,对于某些问题，我们可以利用分离性质（图3-6），同时禁止掉头行动，以确保所有行动要么是从边界向外移动，要么是移动到另一个边界状态。
chap3_para243,3,,在这种情况下，我们只需检查边界就能判断是否有冗余路径，并且可以删除reached状态表。
chap3_para244,1,The complete algorithm is described in the online code repository accompanying this book.,对于其他问题，我们可以维护引用计数（reference count）——到达某一状态的次数，并且在再也没有路径可以到达该状态时将其从reached表中删除。
chap3_para244,2,There is one subtlety worth mentioning.,例如，在网格世界中，每个状态只能从它的4个邻居状态到达，一旦我们已经到达了一个状态4次，就可以将它从表中删除。
chap3_para244,3,We said that SMA* expands the best leaf and deletes the worst leaf.,
chap3_para244,4,What if all the leaf nodes have the same f-value?,
chap3_para244,5,"To avoid selecting the same node for deletion and expansion, SMA* expands the newest best leaf and deletes the oldest worst leaf.",
chap3_para244,6,"These coincide when there is only one leaf, but in that case, the current search tree must be a single path from root to leaf that fills all of memory.",
chap3_para244,7,"If the leaf is not a goal node, then even if it is on an optimal solution path, that solution is not reachable with the available memory.",
chap3_para244,8,"Therefore, the node can be discarded exactly as if it had no successors.",
chap3_para245,1,"SMA* is complete if there is any reachable solution—that is, if d, the depth of the shallowest goal node, is less than the memory size (expressed in nodes). It is optimal if any optimal solution is reachable; otherwise, it returns the best reachable solution. In practical terms, SMA* is a fairly robust choice for finding optimal solutions, particularly when the state space is a graph, action costs are not uniform, and node generation is expensive compared to the overhead of maintaining the frontier and the reached set.",现在，我们考虑旨在节省内存使用的新算法。
chap3_para246,1,"On very hard problems, however, it will often be the case that SMA* is forced to switch back and forth continually among many candidate solution paths, only a small subset of which can fit in memory.",束搜索（beam search）对边界的大小进行了限制。
chap3_para246,2,(This resembles the problem of thrashing in disk paging systems.,最简单的方法是只保留具有最优f值的k个节点，放弃其他已扩展节点。
chap3_para246,3,") Then the extra time required for repeated regeneration of the same nodes means that problems that would be practically solvable by A*, given unlimited memory, become intractable for SMA*.",这当然会导致搜索变成不完备的和次优的算法，但我们可以选取合适的k以充分利用可用内存，算法执行速度也会更快，因为它只扩展了较少的节点。
chap3_para246,4,"That is to say, memory limitations can make a problem intractable from the point of view of computation time.",对于许多问题，它可以找到很好的近似最优解。
chap3_para246,5,"Although no current theory explains the tradeoff between time and memory, it seems that this is an inescapable problem.",你可以将一致代价搜索或A*搜索看作在同心等值线的各个方向扩展，而将束搜索看作只探索这些等值线的主要部分，即包含k个最佳候选的部分。
chap3_para246,6,The only way out is to drop the optimality requirement.,
chap3_para247,1,3.,另一种形式的束搜索并不严格限制边界的大小，而是保留f值在最优f值的范围内的所有节点。
chap3_para247,2,5.,这样的话，当存在几个强得分节点时，只会保留几个节点，但如果不存在强节点，则会保留更多节点，直到出现一个强节点。
chap3_para247,3,6Bidirectional heuristic search,
chap3_para248,1,"With unidirectional best-first search, we saw that using f(n) = g(n) + h(n) as the evaluation function gives us an A* search that is guaranteed to find optimal-cost solutions (assuming an admissible h) while being optimally efficient in the number of nodes expanded.",迭代加深A*搜索（iterative-deepening A* search，IDA*）之于A*搜索，就像迭代加深搜索之于深度优先搜索一样：IDA*既拥有A*的优点，又不要求在内存中保留所有已达状态，这样做的代价是需要多次访问某些状态。
chap3_para248,2,,它是一种非常重要且常用的用于解决内存不足问题的算法。
chap3_para249,1,"With bidirectional best-first search we could also try using f(n) = g(n) + h(n), but unfortunately there is no guarantee that this would lead to an optimal-cost solution, nor that it would be optimally efficient, even with an admissible heuristic.",在标准的迭代加深搜索中，截断值为深度，每次迭代深度增加1。
chap3_para249,2,"With bidirectional search, it turns out that it is not individual nodes but rather pairs of nodes (one from each frontier) that can be proved to be surely expanded, so any proof of efficiency will have to consider pairs of nodes (Eckerle et al.",而在IDA*中，截断值是f代价（g + h）；在每次迭代中，新的截断值为超过上一次迭代截断值的节点中最小的f代价。
chap3_para249,3,", 2017).",换句话说，每次迭代都会彻底地搜索一个f等值线，找到一个刚好超出该等值线的节点，并使用该节点的f代价作为下一个等值线。
chap3_para249,4,,像8数码这样的问题，每条路径的f代价都是整数，这非常有效地使得每次迭代都朝着目标稳步前进。
chap3_para249,5,,如果最优解的代价是C*，那么迭代的次数不可能超过C*（例如，最难的8数码问题的迭代次数不超过31）。
chap3_para249,6,,但对于每个节点的f代价都不相同的问题，每一个新的等值线可能只包含一个新节点，并且迭代次数可能等于状态数。
chap3_para25,1,"•An action cost function, denoted by ACTION-COST(S,a, sʹ) when we are programming or c(s, a, sʹ) when we are doing math, that gives the numeric cost of applying action a in state s to reach state sʹ. A problem-solving agent should use a cost function that reflects its own performance measure; for example, for route-finding agents, the cost of an action might be the length in miles (as seen in Figure 3.1), or it might be the time it takes to complete the action.",[2]　对于具有无限多个动作的问题，我们需要本章之外的其他技巧。
chap3_para250,1,"We’ll start with some new notation. We use fF (n) = gF (n)+ hF (n) for nodes going in the forward direction (with the initial state as root) and fB(n) = gB(n) + hB(n) for nodes in the backward direction (with a goal state as root). Although both forward and backward searches are solving the same problem, they have different evaluation functions because, for example, the heuristics are different depending on whether you are striving for the goal or for the initial state. We’ll assume admissible heuristics.",递归最佳优先搜索（recursive best-first search，RBFS）（见图3-22）试图模拟标准的最佳优先搜索的操作，但仅仅使用线性空间。
chap3_para250,2,,RBFS类似于递归深度优先搜索，但它不是沿着当前路径无限地向下搜索，而是使用f_limit变量跟踪从当前节点的任意祖先节点可得到的最优备选路径的f值。
chap3_para250,3,,如果当前节点超过了这个限制，那么递归将回到备选路径上。
chap3_para250,4,,随着递归的展开，RBFS将路径上每个节点的f值替换为一个倒推值（backed-up value）——其子节点的最优f值。
chap3_para250,5,,通过这种方式，RBFS可以记住被它遗忘的子树中最优叶节点的f值，因此，在之后的某个时刻，RBFS可以决定是否要重新扩展该子树。
chap3_para250,6,,图3-23展示了RBFS是如何到达Bucharest的。
chap3_para251,1,Consider a forward path from the initial state to a node m and a backward path from the goal to a node n.,图3-22　递归最佳优先搜索算法
chap3_para251,2,"We can define a lower bound on the cost of a solution that follows the path from the initial state to m, then somehow gets to n, then follows the path to the goal as",
chap3_para252,1,"In other words, the cost of such a path must be at least as large as the sum of the path costs of the two parts (because the remaining connection between them must have nonnegative cost), and the cost must also be at least as much as the estimated f cost of either part (because the heuristic estimates are optimistic). Given that, the theorem is that for any pair of nodes m, n with lb(m, n) less than the optimal cost C*, we must expand either m or n, because the path that goes through both of them is a potential optimal solution. The difficulty is that we don’t know for sure which node is best to expand, and therefore no bidirectional search algorithm can be guaranteed to be optimally efficient—any algorithm might expand up to twice the minimum number of nodes if it always chooses the wrong member of a pair to expand first. Some bidirectional heuristic search algorithms explicitly manage a queue of (m, n) pairs, but we will stick with bidirectional best-first search (Figure 3.14), which has two frontier priority queues, and give it an evaluation function that mimics the lb criteria:",在一定程度上，RBFS比IDA*更高效，但仍然存在重复生成大量节点的问题。
chap3_para252,2,,在图3-23的示例中，RBFS沿着经过Rimnicu Vilcea的路径，然后“改变主意”去尝试经过Fagaras，然后又“回心转意”。
chap3_para252,3,,之所以会发生这些改变，是因为每次扩展当前的最优路径时，它的f值很可能增加——对于靠近目标的节点，h值通常不那么乐观。
chap3_para252,4,,当这种情况发生时，次优路径可能会成为最优路径，因此搜索必须回溯。
chap3_para252,5,,每一次改变对应于IDA*的一次迭代，并且可能需要多次重新扩展已经遗忘的节点，以重建最优路径，并对该路径再扩展一个节点。
chap3_para253,1,"The node to expand next will be the one that minimizes this f2 value; the node can come from either frontier. This f2 function guarantees that we will never expand a node (from either frontier) with g(n) > . We say the two halves of the search “meet in the middle” in the sense that when the two frontiers touch, no node inside of either frontier has a path cost greater than the bound . Figure 3.24 works through an example bidirectional search.",图3-23　使用RBFS搜索到Bucharest的最短路线的各个阶段。
chap3_para253,2,,每次递归调用的f_limit值标注在每个当前节点的上方，每个节点上都标有它的f代价。
chap3_para253,3,,（a）沿着经过Rimnicu Vilcea的路径前进，直到当前最优叶节点（Pitesti）的值比最优备选路径（Fagaras）差。
chap3_para253,4,,（b）递归回溯，被遗忘子树的最优叶节点值（417）被备份到Rimnicu Vilcea；接着扩展Fagaras，得到最优叶节点值450。
chap3_para253,5,,（c）递归回溯，被遗忘子树的最优叶节点值（450）被备份到Fagaras；然后扩展Rimnicu Vilcea。
chap3_para253,6,,这一次，因为最优备选路径（经由Timisoara）的代价至少为447，所以继续扩展Bucharest
chap3_para254,1,"Description There are four circles in each of the two rows where the circles represent nodes. The four circles in the first row are Start, “A”, F, and Goal. The four circles in the second row are C, B, D, and E. A solid arrow from Start to “A” is labeled 4. For circle “A”, f equals 9 equals 4 plus 5 and f subscript 2 equals 10. Another solid arrow from Start to B is labeled 6. For B, f equals 8 equals 6 plus 2 and f subscript 2 equals 12. A dashed arrow from B to C is labeled 1. For C, f equals 8 equals 7 plus 1 and f subscript 2 equals 14. Another dashed arrow from B to D is labeled 1. For D, f equals 9 equals 7 plus 2 and f subscript 2 equals 14. A dashed arrow from D to E is labeled 1. For E, f equals 9 equals 8 plus 1 and f subscript 2 equals 16. An arrow from Goal to F is labeled 4. For node F, function f equals 10 equals 6 plus 4 and f subscript 2 equals 10. A dashed double-headed arrow from node F to “A” is labeled 2.",如果启发式函数h(n)是可容许的，那么RBFS是最优的。
chap3_para254,2,,它的空间复杂性在最深的最优解的深度上是线性的，但时间复杂性很难刻画：既取决于启发式函数的准确性，也取决于最优路径随节点扩展变化的频率。
chap3_para254,3,,它按照f得分递增的顺序来扩展节点，即使f是非单调的。
chap3_para255,1,Figure 3.,IDA*和RBFS使用内存太少，它们的时间复杂性会受到影响。
chap3_para255,2,"24 Bidirectional search maintains two frontiers: on the left, nodes A and B are successors of Start; on the right, node F is an inverse successor of Goal.",在两次迭代之间，IDA*只保留一个数值：当前的f代价限制。
chap3_para255,3,"Each node is labeled with f = g + h values and the f2 = max(2g, g + h) value.",RBFS在内存中保留了更多的信息，但它只使用线性空间：即使有更多的内存可用，RBFS也无法利用。
chap3_para255,4,(The g values are the sum of the action costs as shown on each arrow; the h values are arbitrary and cannot be derived from anything in the figure.,因为它们会遗忘它们所做的大部分事情，这两种算法都可能会多次重复探索相同状态。
chap3_para255,5,") The optimal solution, Start-A-F-Goal, has cost C* = 4 + 2 + 4 = 10, so that means that a meet-in-the-middle bidirectional algorithm should not expand any node with g > = 5; and indeed the next node to be expanded would be A or F (each with g=4), leading us to an optimal solution.",
chap3_para255,6,"If we expanded the node with lowest f cost first, then B and C would come next, and D and E would be tied with A, but they all have g > and thus are never expanded when f2 is the evaluation function.",
chap3_para256,1,"We have described an approach where the hF heuristic estimates the distance to the goal (or, when the problem has multiple goal states, the distance to the closest goal) and hB estimates the distance to the start. This is called a front-to-end search. An alternative, called front-to-front search, attempts to estimate the distance to the other frontier. Clearly, if a frontier has millions of nodes, it would be inefficient to apply the heuristic function to every one of them and take the minimum. But it can work to sample a few nodes from the frontier. In certain specific problem domains it is possible to summarize the frontier—for example, in a grid search problem, we can incrementally compute a bounding box of the frontier, and use as a heuristic the distance to the bounding box.",因此，确定我们有多少可用内存并允许算法使用所有内存似乎是明智的。
chap3_para256,2,,执行这样操作的两种算法是MA*（memory-bounded A*，内存受限的A*）和SMA*（simplified MA*，简化的MA*）。
chap3_para256,3,,SMA*更简单一些，所以我们介绍SMA*。
chap3_para256,4,,SMA*很像A*算法，不断扩展最优叶节点，直到内存被填满。
chap3_para256,5,,此时，它不能再为搜索树添加新节点，除非删除旧节点。
chap3_para256,6,,SMA*总是丢弃最差的叶节点，即f值最大的叶节点。
chap3_para256,7,,和RBFS一样，SMA*将被遗忘节点的值备份到其父节点。
chap3_para256,8,,这样，被遗忘子树的祖先知道该子树中最优路径的质量。
chap3_para256,9,,有了这一信息，只有在所有其他路径看起来都比它已经遗忘的路径更差时，SMA*才会重新生成该子树。
chap3_para256,10,,这意味着如果节点n的所有后代都被遗忘了，那么尽管我们不知道从n开始应该走哪条路径，但我们仍知道是否应该从n开始走。
chap3_para257,1,"Bidirectional search is sometimes more efficient than unidirectional search, sometimes not.",本书附带的在线代码库中描述了完整的SMA*算法。
chap3_para257,2,"In general, if we have a very good heuristic, then A* search produces search contours that are focused on the goal, and adding bidirectional search does not help much.",有一点值得注意，我们之前提到SMA*将扩展最优叶节点，删除最差叶节点。
chap3_para257,3,"With an average heuristic, bidirectional search that meets in the middle tends to expand fewer nodes and is preferred.",如果所有叶节点的f值都相同呢？
chap3_para257,4,"In the worst case of a poor heuristic, the search is no longer focused on the goal, and bidirectional search has the same asymptotic complexity as A*.",为了避免算法选择同一个节点进行删除和扩展操作，SMA*扩展最新的最优叶节点并删除最老的最差叶节点。
chap3_para257,5,Bidirectional search with the f2 evaluation function and an admissible heuristic h is complete and optimal.,当只有一个叶节点时，这两者是同一个节点，但在这种情况下，当前的搜索树一定是一条从根节点到叶节点的占满所有内存的单一路径。
chap3_para257,6,,如果叶节点不是目标节点，那么即使它在最优解路径上，也无法在可用内存范围内得到这个解。
chap3_para257,7,,因此，完全可以丢弃该节点，就好像它没有后继节点一样。
chap3_para258,1,3.,如果存在任意可达解，也就是说，如果最浅的目标节点的深度d小于内存大小（用节点数表示），那么SMA*就是完备的。
chap3_para258,2,6Heuristic Functions,如果存在可达的最优解，那么SMA*就是最优的；否则，就返回当前最优的可达解。
chap3_para258,3,,在实践中，SMA*是寻找最优解的一个相当稳健的选择，特别是当状态空间是一个图、行动代价不一致，并且生成节点的总开销相比维护边界集和已达集的总开销更大时。
chap3_para259,1,"In this section, we look at how the accuracy of a heuristic affects search performance, and also consider how heuristics can be invented. As our main example we’ll return to the 8-puzzle. As mentioned in Section 3.2, the object of the puzzle is to slide the tiles horizontally or vertically into the empty space until the configuration matches the goal configuration (Figure 3.25).",然而，在非常困难的问题上，常常会出现SMA*被迫在许多候选解路径之间来回不断切换的情况，只有一小部分路径可以存入内存。
chap3_para259,2,,［这类似于磁盘分页系统中的抖动（thrashing）问题。
chap3_para259,3,,］那么，重复生成相同节点就需要额外的时间，这意味着，在给定无限内存的情况下可以用A*实际求解的问题，对于SMA*将变得难以处理。
chap3_para259,4,,也就是说，从计算时间的角度，内存限制会使问题变得难以处理。
chap3_para259,5,,虽然还没有现有理论解释如何在时间和内存之间权衡，但这似乎是一个不可避免的问题。
chap3_para259,6,,唯一的出路是放弃最优性要求。
chap3_para26,1,"A sequence of actions forms a path, and a solution is a path from the initial state to a goal state.",● 转移模型（transition model）用于描述每个动作所起到的作用。
chap3_para26,2,"We assume that action costs are additive; that is, the total cost of a path is the sum of the individual action costs.","Result(s, a)将返回在状态s中执行动作a所产生的状态。"
chap3_para26,3,An optimal solution has the lowest path cost among all solutions.,例如：
chap3_para26,4,"In this chapter, we assume that all action costs will be positive, to avoid certain complications.",
chap3_para26,5,3,
chap3_para260,1,,3.5.6　双向启发式搜索
chap3_para261,1,Figure 3.,我们发现，在单向最佳优先搜索中，使用f(n) = g(n) + h(n)作为评价函数可以得到A*搜索，保证找到代价最优的解（假设h是可容许的），同时在所扩展的节点数上效率最优。
chap3_para261,2,25 A typical instance of the 8-puzzle.,
chap3_para261,3,The shortest solution is 26 actions long.,
chap3_para262,1,"There are 9!/2 = 181,400 reachable states in an 8-puzzle, so a search could easily keep them all in memory. But for the 15-puzzle, there are 16!/2 states—over 10 trillion—so to search that space we will need the help of a good admissible heuristic function. There is a long history of such heuristics for the 15-puzzle; here are two commonly used candidates:",在双向最佳优先搜索中，我们也可以尝试使用f(n) = g(n) + h(n)，但遗憾的是，即使使用可容许的启发式函数，算法也不能保证可以找到代价最优的解，更不能保证效率最优。
chap3_para262,2,,"可以证明的是，在双向搜索中一定会被扩展的并不是单个的节点，而是节点对（分别来自两个边界），因此任何效率证明都必须考虑节点对（Eckerle et al., 2017）。"
chap3_para263,1,"•h1 = the number of misplaced tiles (blank not included). For Figure 3.25, all eight tiles are out of position, so the start state has h1 = 8. h1 is an admissible heuristic because any tile that is out of place will require at least one move to get it to the right place.",我们先介绍一些新的符号。
chap3_para263,2,,对于正向搜索（以初始状态作为根节点）中的节点，我们用fF(n) = gF(n) + hF(n)作为评价函数；对于反向搜索（以某个目标状态作为根节点）中的节点，我们用fB(n) = gB(n) + hB(n)作为评价函数。
chap3_para263,3,,尽管正向搜索和反向搜索求解的是同一个问题，但它们具有不同的评价函数，这是因为，启发式函数依据其努力方向是目标状态还是初始状态而有所不同。
chap3_para263,4,,我们假设启发式函数是可容许的。
chap3_para264,1,"•h2 = the sum of the distances of the tiles from their goal positions. Because tiles cannot move along diagonals, the distance is the sum of the horizontal and vertical distances—sometimes called the city-block distance or Manhattan distance. h2 is also admissible because all any move can do is move one tile one step closer to the goal. Tiles 1 to 8 in the start state of Figure 3.25 give a Manhattan distance of",考虑从初始状态到节点m的正向路径和从目标到节点n的反向路径。
chap3_para264,2,,我们可以如下定义一个解代价的下界（这个解先沿着前向路径从初始状态到达m，然后以某种方式到达n，最后再沿着后向路径从n到达目标）。
chap3_para265,1,"As expected, neither of these overestimates the true solution cost, which is 26.",换句话说，这样一条路径的代价一定不小于两部分路径代价之和（因为它们之间的剩余连接一定具有非负代价），而且也一定不小于任一部分的f代价估计值（因为启发式的估计是乐观的）。
chap3_para265,2,,"因此，有如下的定理：对于任意一对节点m和n，若lb(m, n)小于最优代价C*，那么算法必须扩展m或n，因为经过这两个节点的路径是一个潜在的最优解。"
chap3_para265,3,,然而，一个难题是我们无法确定扩展这两者中的哪个节点才是最优的，因此，没有一个双向搜索算法可以保证效率最优——如果算法总是首先选择一对节点中错误的那个进行扩展，那么任何算法都可能需要扩展到最小节点数两倍的节点。
chap3_para265,4,,"一些双向启发式搜索算法显式地管理一个(m, n)节点对队列，但我们将坚持双向最佳优先搜索（图3-14），它有两个边界优先队列，并使用模拟lb准则的评价函数："
chap3_para266,1,3.,接下来要扩展的节点将是f2值最小的节点；它可以来自任何一个边界。
chap3_para266,2,6.,这个f2函数保证算法永远不会扩展（来自任一边界的）的节点。
chap3_para266,3,1The effect of heuristic accuracy on performance,当两个边界相交时，任一边界内的节点都不存在超过C*/2的路径代价，在这种意义上，我们可以说搜索的两部分“在中间相遇”。
chap3_para266,4,,图3-24为一个双向搜索的示例。
chap3_para267,1,One way to characterize the quality of a heuristic is the effective branching factor b*.,图3-24　双向搜索维护两个边界：左半部分，节点A和B是开始状态的后继；右半部分，节点F是目标状态的逆向后继。
chap3_para267,2,"If the total number of nodes generated by A* for a particular problem is N and the solution depth is d, then b* is the branching factor that a uniform tree of depth d would have to have in order to contain N + 1 nodes.","每个节点都标有f = g + h值和f2 = max(2g, g + h)值。"
chap3_para267,3,"Thus,",（g值是每个箭头上所显示的动作代价的总和；h值是任意的，而且不能从图中的任何内容推出。
chap3_para267,4,,）最优解“开始-A-F-目标”的代价C* = 4 + 2 + 4 = 10，这意味着一个在中间相遇的双向算法不应该扩展任何的节点；实际上，下一个要扩展的节点是A或F（g = 4），这将引导我们找到一个最优解。
chap3_para267,5,,如果我们首先扩展f代价最低的节点，那么下一个扩展的将是B和C，D和E将与A并列，但它们的，因此当f2是评价函数时它们永远不会被扩展
chap3_para268,1,"For example, if A* finds a solution at depth 5 using 52 nodes, then the effective branching factor is 1.92. The effective branching factor can vary across problem instances, but usually for a specific domain (such as 8-puzzles) it is fairly constant across all nontrivial problem instances. Therefore, experimental measurements of b* on a small set of problems can provide a good guide to the heuristic’s overall usefulness. A well-designed heuristic would have a value of b* close to 1, allowing fairly large problems to be solved at reasonable computational cost.",我们已经介绍了一种方法，即用hF估计到目标的距离（或者说，当问题有多个目标状态时，估计到最近目标的距离），用hB估计到开始状态的距离。
chap3_para268,2,,这就是所谓的front-to-end搜索。
chap3_para268,3,,另一种方法是front-to-front搜索，它试图估计到另一个边界的距离。
chap3_para268,4,,显然，如果边界内有数百万个节点，那么对每个节点应用启发式函数然后取最小值是非常低效的。
chap3_para268,5,,但它可以从边界中抽样几个节点。
chap3_para268,6,,在某些特定问题域中，可以对边界进行总结，例如，在网格搜索问题中，我们可以递增地计算边界的界限框，并使用到界限框的距离作为启发式函数。
chap3_para269,1,Korf and Reid (1998) argue that a better way to characterize the effect of A* pruning with a given heuristic h is that it reduces the effective depth by a constant kh compared to the true depth. This means that the total search cost is O(bd–kh) compared to O(bd) for an uninformed search. Their experiments on Rubik’s Cube and n-puzzle problems show that this formula gives accurate predictions for total search cost for sampled problem instances across a wide range of solution lengths—at least for solution lengths larger than kh.,双向搜索有时比单向搜索更有效，有时则不然。
chap3_para269,2,,一般来说，如果我们有一个很好的启发式函数，那么A*搜索会生成专注于目标的搜索等值线，使用双向搜索则增益不大。
chap3_para269,3,,使用一般的启发式函数时，在中间相遇的双向搜索往往会扩展较少的节点，因此双向搜索是首选方法。
chap3_para269,4,,在启发式函数较差的最坏情况下，搜索算法将不再专注于目标，并且双向搜索具有与A*相同的渐近复杂性。
chap3_para269,5,,使用f2评价函数和可容许的启发式函数h的双向搜索算法是完备且最优的。
chap3_para27,1,The state space can be represented as a graph in which the vertices are states and the directed edges between them are actions.,"● 动作代价函数（action cost function），在编程中记作Action-Cost(s, a, s' )，在数学运算中记作c(s, a, s' )。"
chap3_para27,2,The map of Romania shown in Figure 3.,它给出了在状态s中执行动作a从而转移到状态s'的数值代价。
chap3_para27,3,"1 is such a graph, where each road indicates two actions, one in each direction.",问题求解智能体应该使用反映其自身性能指标的代价函数；例如，对于寻径智能体，动作代价可能是以英里为单位的长度（如图3-1所示），也可能是完成动作所花费的时间。
chap3_para270,1,For Figure 3.,
chap3_para270,2,"26 we generated random 8-puzzle problems and solved them with an uninformed breadth-first search and with A* search using both h1 and h2, reporting the average number of nodes generated and the corresponding effective branching factor for each search strategy and for each solution length.",
chap3_para270,3,"The results suggest that h2 is better than h1, and both are better than no heuristic at all.",
chap3_para271,1,Description A square labeled Start state has three rows and three columns.,在本节中，我们将研究启发式函数的准确性是如何影响搜索性能的，并考虑如何构造启发式函数。
chap3_para271,2,"Row 1: Column 1, Asterisk.",我们将8数码问题作为主要示例。
chap3_para271,3,"Column 2, 2.",如3.2节所述，它的目标是将滑块水平或竖直地滑动到空格中，直到棋盘布局与目标布局一致（图3-25）。
chap3_para271,4,"Column 3, 4.",
chap3_para271,5,"Row 2: Column 1, Asterisk.",
chap3_para271,6,"Column 2, blank.",
chap3_para271,7,"Column 3, Asterisk.",
chap3_para271,8,"Row 3: Column 1, Asterisk.",
chap3_para271,9,"Column 2, 3.",
chap3_para271,10,"Column 3, 1.",
chap3_para271,11,Another square labeled Goal state has three rows and three columns.,
chap3_para271,12,"Row 1: Column 1, blank.",
chap3_para271,13,"Column 2, 1.",
chap3_para271,14,"Column 3, 2.",
chap3_para271,15,"Row 2: Column 1, 3.",
chap3_para271,16,"Column 2, 4.",
chap3_para271,17,"Column 3, Asterisk.",
chap3_para271,18,"Row 3: Column 1, Asterisk.",
chap3_para271,19,"Column 2, Asterisk.",
chap3_para271,20,"Column 3, Asterisk.",
chap3_para272,1,Figure 3.,图3-25　8数码问题的典型实例。
chap3_para272,2,"26 Comparison of the search costs and effective branching factors for 8-puzzle problems using breadth-first search, A* with h1 (misplaced tiles), and A* with h2 (Manhattan distance).",最短的解需要26步动作
chap3_para272,3,Data are averaged over 100 puzzles for each solution length d from 6 to 28.,
chap3_para273,1,"One might ask whether h2 is always better than h1. The answer is “Essentially, yes.” It is easy to see from the definitions of the two heuristics that for any node n, h2 (n) ≥ h1 (n). We thus say that h2 dominates h1. Domination translates directly into efficiency: A* using h2 will never expand more nodes than A* using h1 (except in the case of breaking ties unluckily). The argument is simple. Recall the observation on page 108 that every node with f(n) < C* will surely be expanded. This is the same as saying that every node with h(n) < C* – g(n) is surely expanded when h is consistent. But because h2 is at least as big as h1 for all nodes, every node that is surely expanded by A* search with h2 is also surely expanded with h1, and h1 might cause other nodes to be expanded as well. Hence, it is generally better to use a heuristic function with higher values, provided it is consistent and that the computation time for the heuristic is not too long.",在一个8数码问题中，存在9!/2 = 181 400个可达状态，所以搜索算法可以轻松地将它们全部保存在内存中。
chap3_para273,2,,但是对于15数码问题，存在16!/2个状态（超过10万亿个），因此，为了搜索这个空间，我们需要借助一个较好的可容许的启发式函数。
chap3_para273,3,,对于15数码问题，这样的启发式函数有着悠久的历史。
chap3_para273,4,,下面介绍两个常用的选择。
chap3_para274,1,3.,● h1 = 错位滑块的数量（不包括空格）。
chap3_para274,2,6.,图3-25中，所有的8个滑块都不在原位，所以开始状态的h1 = 8。
chap3_para274,3,2Generating heuristics from relaxed problems,h1是一个可容许的启发式函数，因为任何错位滑块都至少需要一次移动才能回到正确的位置。
chap3_para275,1,We have seen that both h1 (misplaced tiles) and h2 (Manhattan distance) are fairly good heuristics for the 8-puzzle and that h2 is better.,● h2 = 滑块到其目标位置距离的总和。
chap3_para275,2,How might one have come up with h2?,因为滑块不能沿对角线移动，所以距离是水平距离和垂直距离之和——有时称为城市街区距离或曼哈顿距离（Manhattan distance）。
chap3_para275,3,Is it possible for a computer to invent such a heuristic mechanically?,h2也是可容许的，因为任何移动操作所能做的就是将一个滑块向目标移近一步。
chap3_para275,4,,图3-25中开始状态的滑块1到滑块8得到的曼哈顿距离为
chap3_para276,1,"h1 and h2 are estimates of the remaining path length for the 8-puzzle, but they are also perfectly accurate path lengths for simplified versions of the puzzle.",正如我们希望的那样，这两种方法都没有高估实际的解代价26。
chap3_para276,2,"If the rules of the puzzle were changed so that a tile could move anywhere instead of just to the adjacent empty square, then h1 would give the exact length of the shortest solution.",
chap3_para276,3,"Similarly, if a tile could move one square in any direction, even onto an occupied square, then h2 would give the exact length of the shortest solution.",
chap3_para276,4,A problem with fewer restrictions on the actions is called a relaxed problem .,
chap3_para276,5,The state-space graph of the relaxed problem is a supergraph of the original state space because the removal of restrictions creates added edges in the graph.,
chap3_para277,1,"Because the relaxed problem adds edges to the state-space graph, any optimal solution in the original problem is, by definition, also a solution in the relaxed problem; but the relaxed problem may have better solutions if the added edges provide shortcuts.",3.6.1　启发式函数的准确性对性能的影响
chap3_para277,2,"Hence, the cost of an optimal solution to a relaxed problem is an admissible heuristic for the original problem.",
chap3_para277,3,"Furthermore, because the derived heuristic is an exact cost for the relaxed problem, it must obey the triangle inequality and is therefore consistent (see page 106).",
chap3_para278,1,"If a problem definition is written down in a formal language, it is possible to construct relaxed problems automatically.",一种描述启发式函数质量的方法是有效分支因子（effective branching factor）b*。
chap3_para278,2,"14 For example, if the 8-puzzle actions are described as",如果针对一个特定问题，A*搜索所生成的总节点数是n，而解的深度是d，那么b*就是深度为d的均衡树要包含n + 1个节点所必需的分支因子。
chap3_para278,3,,因此有
chap3_para279,1,A tile can move from square X to square Y if,例如，如果A*用52个节点在第5层上找到了一个解，那么有效分支因子是1.92。
chap3_para279,2,,在不同的问题实例中，有效分支因子可能会发生变化，但通常对于特定领域（如8数码问题），在所有复杂的问题实例中它都是相当恒定的。
chap3_para279,3,,因此，对一小部分问题的b*进行实验测量可以为启发式函数的总体有用性提供良好的指导。
chap3_para279,4,,设计良好的启发式函数的b*接近1，使得我们能以合理的计算代价求解相当大的问题。
chap3_para28,1,3.,一个动作序列形成一条路径（path），而解（solution）是一条从初始状态到某个目标状态的路径。
chap3_para28,2,1.,我们假设动作代价是可累加的；也就是说，一条路径的总代价是各个动作代价的总和。
chap3_para28,3,2Formulating problems,最优解（optimal solution）是所有解中路径代价最小的解。
chap3_para28,4,,在本章中，我们假设所有的动作代价都为正，以减少复杂性。
chap3_para28,5,,[3]
chap3_para280,1,"X is adjacent to Y and Y is blank,","科尔夫和里德（Korf and Reid, 1998）认为，对于一个使用给定启发式函数h的A*剪枝，刻画其效果的一个更好方式是：有效深度（effective depth）相比于真实深度的减少量kh（一个常数）。"
chap3_para280,2,,这意味着相较于无信息搜索的代价O(bd)，上述方法的总搜索代价为。
chap3_para280,3,,他们在魔方和n数码问题上的实验结果表明，这一公式可以准确地预测各种解长度范围内（至少对于大于kh的解长度）的抽样问题实例的总搜索代价。
chap3_para281,1,we can generate three relaxed problems by removing one or both of the conditions:,在图3-26中，我们生成了随机8数码问题，并使用无信息广度优先搜索和使用h1或h2的A*搜索求解该问题，报告了每种搜索策略和每种解长度所生成的平均节点数及相应的有效分支因子。
chap3_para281,2,,结果表明，h2优于h1，两者都优于无启发式算法。
chap3_para282,1,(a) A tile can move from square X to square Y if X is adjacent to Y.,图3-26　使用广度优先搜索、使用h1（错位滑块）的A*搜索或使用h2（曼哈顿距离）的A*搜索求解8数码问题的搜索代价和有效分支因子的比较。
chap3_para282,2,,每个解长度d（6～28）的数据为100多个实例的平均结果
chap3_para283,1,(b) A tile can move from square X to square Y if Y is blank.,有人可能会问，h2是否总是优于h1。
chap3_para283,2,,答案是“基本上，是的”。
chap3_para283,3,,从这两种启发式函数的定义可以看出，对于任意节点n，都有。
chap3_para283,4,,因此我们说h2占优于（dominate）h1。
chap3_para283,5,,优势可以直接转化为效率：使用h2的A*永远不会比使用h1的A*扩展更多的节点（除了的节点）。
chap3_para283,6,,证明很简单。
chap3_para283,7,,回想一下3.5.3节观察到的，每个的节点都一定会被扩展。
chap3_para283,8,,也就是说，当h一致时，每个的节点都一定会被扩展。
chap3_para283,9,,但是，因为对于所有节点，h2至少和h1一样大，每个在h2下一定会被扩展的节点在h1下也一定会被扩展，而h1还可能导致其他的节点也被扩展。
chap3_para283,10,,因此，通常情况下，只要启发式函数是一致的并且其计算时间不太长，使用具有较高值的启发式函数效果都会更好。
chap3_para284,1,(c) A tile can move from square X to square Y.,3.6.2　从松弛问题出发生成启发式函数
chap3_para285,1,"From (a), we can derive h2 (Manhattan distance).",我们已经看到，对于8数码问题，h1（错位滑块）和h2（曼哈顿距离）都是相当好的启发式函数，其中h2更好。
chap3_para285,2,The reasoning is that h2 would be the proper score if we moved each tile in turn to its destination.,人们是怎么想出h2这样的启发式函数的？
chap3_para285,3,The heuristic derived from (b) is discussed in Exercise 3.,计算机是否有可能自动地设计出这种启发式函数？
chap3_para285,4,GASC.,
chap3_para285,5,"From (c), we can derive h1 (misplaced tiles) because it would be the proper score if tiles could move to their intended destination in one action.",
chap3_para285,6,"Notice that it is crucial that the relaxed problems generated by this technique can be solved essentially without search, because the relaxed rules allow the problem to be decomposed into eight independent subproblems.",
chap3_para285,7,"If the relaxed problem is hard to solve, then the values of the corresponding heuristic will be expensive to obtain.",
chap3_para286,1,"A program called ABSOLVER can generate heuristics automatically from problem definitions, using the “relaxed problem” method and various other techniques (Prieditis, 1993). ABSOLVER generated a new heuristic for the 8-puzzle that was better than any preexisting heuristic and found the first useful heuristic for the famous Rubik’s Cube puzzle.",h1和h2是对8数码问题剩余路径长度的估计，但对简化版本的问题来说，它们也是非常精确的路径长度。
chap3_para286,2,,如果改变游戏规则，即滑块可以移动到任何地方，而不是只能移动到相邻的空格，那么h1将给出最短解的准确长度。
chap3_para286,3,,类似地，如果一个滑块可以向任意方向移动一个方格，甚至移动到一个被占用的方格上，那么h2将给出最短解的准确长度。
chap3_para286,4,,减少了对动作的限制条件的问题称为松弛问题（relaxed problem）。
chap3_para286,5,,松弛问题的状态空间图是原始状态空间的一个超图，因为删除限制条件会导致原图中边的增加。
chap3_para287,1,If a collection of admissible heuristics h1 .,因为松弛问题向状态空间图中添加了一些边，根据定义，原问题的任一最优解也是松弛问题的一个解；但是，如果增加的边提供了捷径，松弛问题可能有更好的解。
chap3_para287,2,.,因此，松弛问题中最优解的代价可以作为原问题的一个可容许的启发式函数。
chap3_para287,3,.,此外，因为得到的启发式函数是松弛问题的准确代价，所以它一定满足三角不等式，因此它是一致的（见3.5.2节）。
chap3_para287,4,"hm is available for a problem and none of them is clearly better than the others, which should we choose?",
chap3_para287,5,"As it turns out, we can have the best of all worlds, by defining",
chap3_para288,1,"h(n) = max{h1(n),.",如果用形式语言定义一个问题，则可以自动构造它的松弛问题。
chap3_para288,2,.,[14]例如，如果将8数码问题的行动描述为
chap3_para288,3,.,
chap3_para288,4,",hk(n)}.",
chap3_para289,1,This composite heuristic picks whichever function is most accurate on the node in question.,
chap3_para289,2,"Because the hi components are admissible, h is admissible (and if hi are all consistent, h is consistent).",
chap3_para289,3,"Furthermore, h dominates all of its component heuristics.",
chap3_para289,4,The only drawback is that h(n) takes longer to compute.,
chap3_para289,5,"If that is an issue, an alternative is to randomly select one of the heuristics at each evaluation, or use a machine learning algorithm to predict which heuristic will be best.",
chap3_para289,6,"Doing this can result in a heuristic that is inconsistent (even if every hi is consistent), but in practice it usually leads to faster problem solving.",
chap3_para29,1,"Our formulation of the problem of getting to Bucharest is a model—an abstract mathematical description—and not the real thing. Compare the simple atomic state description Arad to an actual cross-country trip, where the state of the world includes so many things: the traveling companions, the current radio program, the scenery out of the window, the proximity of law enforcement officers, the distance to the next rest stop, the condition of the road, the weather, the traffic, and so on. All these considerations are left out of our model because they are irrelevant to the problem of finding a route to Bucharest.",
chap3_para290,1,3.,[14]　在第8章和第11章中，我们将介绍适用于此任务的形式语言：有了可操纵的形式化描述，就可以自动化地构建松弛问题。
chap3_para290,2,6.,现在，我们先使用自然语言。
chap3_para290,3,3Generating heuristics from subproblems: Pattern databases,
chap3_para291,1,Admissible heuristics can also be derived from the solution cost of a subproblem of a given problem.,如果方格X与方格Y相邻，且Y是空格，那么滑块可以从方格X移动到方格Y。
chap3_para291,2,"For example, Figure 3.",
chap3_para291,3,27 shows a subproblem of the 8-puzzle instance in Figure 3.,
chap3_para291,4,25.,
chap3_para291,5,"The subproblem involves getting tiles 1, 2, 3, 4, and the blank into their correct positions.",
chap3_para291,6,"Clearly, the cost of the optimal solution of this subproblem is a lower bound on the cost of the complete problem.",
chap3_para291,7,It turns out to be more accurate than Manhattan distance in some cases.,
chap3_para292,1,"Description The map shows various highways, signs, and city and place names.",我们可以通过删除一个或两个条件来生成3种松弛问题。
chap3_para292,2,Two possible routes between Arad and Bucharest are shown.,
chap3_para292,3,"The first route passes through Sibiu, Rimnicu Vilcea, Pitesti, and reaches Bucharest.",
chap3_para292,4,"The distance and estimated time are displayed to be 578 kilometers and 7 hours 17 minutes, respectively.",
chap3_para292,5,"The second route passes through Lugoj, Drobeta, Pitesti, and reaches Bucharest.",
chap3_para292,6,The estimated time is displayed to be 7 hours and 35 minutes.,
chap3_para292,7,The first road is highlighted in blue as the selected route.,
chap3_para292,8,A window pane to the left of the map shows the exact directions to start from Arad and reach Bucharest.,
chap3_para293,1,Figure 3.,（a）如果方格X与方格Y相邻，那么滑块可以从方格X移动到方格Y。
chap3_para293,2,27 A subproblem of the 8-puzzle instance given in Figure 3.,
chap3_para293,3,25.,
chap3_para293,4,"The task is to get tiles 1, 2, 3, 4, and the blank into their correct positions, without worrying about what happens to the other tiles.",
chap3_para294,1,"The idea behind pattern databases is to store these exact solution costs for every possible subproblem instance—in our example, every possible configuration of the four tiles and the blank. (There will be 9 × 8 × 7 × 6 × 5 = 15,120 patterns in the database. The identities of the other four tiles are irrelevant for the purposes of solving the subproblem, but moves of those tiles do count toward the solution cost of the subproblem.) Then we compute an admissible heuristic hDB for each state encountered during a search simply by looking up the corresponding subproblem configuration in the database. The database itself is constructed by searching back from the goal and recording the cost of each new pattern encountered;15 the expense of this search is amortized over subsequent problem instances, and so makes sense if we expect to be asked to solve many problems.",（b）如果方格Y是空格，那么滑块可以从方格X移动到方格Y。
chap3_para295,1,"The choice of tiles 1-2-3-4 to go with the blank is fairly arbitrary; we could also construct databases for 5-6-7-8, for 2-4-6-8, and so on.",（c）滑块可以从方格X移动到方格Y。
chap3_para295,2,"Each database yields an admissible heuristic, and these heuristics can be combined, as explained earlier, by taking the maximum value.",
chap3_para295,3,A combined heuristic of this kind is much more accurate than the Manhattan distance; the number of nodes generated when solving random 15-puzzles can be reduced by a factor of 1000.,
chap3_para295,4,"However, with each additional database there are diminishing returns and increased memory and computation costs.",
chap3_para296,1,"One might wonder whether the heuristics obtained from the 1-2-3-4 database and the 5-6-7-8 could be added, since the two subproblems seem not to overlap. Would this still give an admissible heuristic? The answer is no, because the solutions of the 1-2-3-4 subproblem and the 5-6-7-8 subproblem for a given state will almost certainly share some moves—it is unlikely that 1-2-3-4 can be moved into place without touching 5-6-7-8, and vice versa. But what if we don’t count those moves—what if we don’t abstract the other tiles to stars, but rather make them disappear? That is, we record not the total cost of solving the 1-2-3-4 subproblem, but just the number of moves involving 1-2-3-4. Then the sum of the two costs is still a lower bound on the cost of solving the entire problem. This is the idea behind disjoint pattern databases. With such databases, it is possible to solve random 15-puzzles in a few milliseconds—the number of nodes generated is reduced by a factor of 10,000 compared with the use of Manhattan distance. For 24-puzzles, a speedup of roughly a factor of a million can be obtained. Disjoint pattern databases work for sliding-tile puzzles because the problem can be divided up in such a way that each move affects only one subproblem—because only one tile is moved at a time.",由（a）可以推导出h2（曼哈顿距离）。
chap3_para296,2,,原因是，如果我们将每个滑块依次移动到其目标位置，那么h2就是准确的步数。
chap3_para296,3,,由（b）推导出的启发式函数将在习题3.GASC中讨论。
chap3_para296,4,,由（c）我们可以推导出h1（错位滑块），因为如果可以仅用一步就将滑块移动到其预期目标位置，那么h1就是准确的步数。
chap3_para296,5,,需要注意的是，通过这种方法生成的松弛问题本质上不需要搜索就能求解，因为松弛规则将问题分解为8个独立的子问题。
chap3_para296,6,,如果松弛问题本身很难求解，那么获取相应的启发式函数值的代价将非常高。
chap3_para297,1,3.,"Absolver程序可以通过“松弛问题”方法及各种其他技术从问题定义中自动生成启发式函数（Prieditis, 1993）。"
chap3_para297,2,6.,Absolver为8数码问题生成了一种新的启发式函数，它优于任何已有的启发式函数。
chap3_para297,3,4Generating heuristics with landmarks,此外，Absolver为著名的魔方问题找到了第一种有效的启发式函数。
chap3_para298,1,There are online services that host maps with tens of millions of vertices and find cost-optimal driving directions in milliseconds (Figure 3.,"如果一个可容许的启发式函数集合h1, …, hm可以求解同一个问题，但没有一个函数明显优于其他函数，那么我们应该选择哪个函数？"
chap3_para298,2,28).,事实证明，我们可以通过如下定义，得到最优的启发式函数：
chap3_para298,3,"How can they do that, when the best search algorithms we have considered so far are about a million times slower?",
chap3_para298,4,"There are many tricks, but the most important one is precomputation of some optimal path costs.",
chap3_para298,5,"Although the precomputation can be time-consuming, it need only be done once, and then can be amortized over billions of user search requests.",
chap3_para299,1,,这种复合启发式函数将选择对于所讨论节点最准确的函数。
chap3_para299,2,,因为hi都是可容许的，所以h也是可容许的（如果hi都是一致的，则h也是一致的）。
chap3_para299,3,,此外，h优于所有组成它的启发式函数。
chap3_para299,4,,唯一的缺点是h(n)的计算时间更长。
chap3_para299,5,,如果考虑这一问题，另一种选择是在每次评价时随机选择一个启发式函数，或者使用机器学习算法来预测哪个启发式函数是最优的。
chap3_para299,6,,这样做可能会导致启发式函数失去一致性（即使每个hi都是一致的），但在实践中，它通常能更快地求解问题。
chap3_para3,1,"When the correct action to take is not immediately obvious, an agent may need to plan ahead: to consider a sequence of actions that form a path to a goal state.",如2.4.7节所述，问题求解智能体使用原子（atomic）表示，也就是说，世界状态被视为一个整体，其内部结构对问题求解算法来说是不可见的。
chap3_para3,2,"Such an agent is called a problem-solving agent, and the computational process it undertakes is called search.",使用状态的因子化（factored）表示或结构化（structured）表示的智能体称为规划智能体（planning agent），第7章和第11章中将会讨论。
chap3_para30,1,"The process of removing detail from a representation is called abstraction. A good problem formulation has the right level of detail. If the actions were at the level of “move the right foot forward a centimeter” or “turn the steering wheel one degree left,” the agent would probably never find its way out of the parking lot, let alone to Bucharest.",[3]　在任何存在负代价环的问题中，代价最优解为在这个环中循环无限次。
chap3_para30,2,,不存在负代价环时，Bellman-Ford算法和Floyd-Warshall算法（本章暂未涉及）可以处理负代价动作。
chap3_para30,3,,只要连续的零代价动作的数量是有限的，处理零代价动作就很容易。
chap3_para30,4,,例如，假设有一个机器人，其移动的代价为正，但旋转90°的代价为0；只要连续旋转90°动作的数量不超过3个，本章的算法就可以处理这个问题。
chap3_para30,5,,存在无限多个任意小的动作代价的问题也很复杂。
chap3_para30,6,,考虑Zeno悖论的情况，存在一个动作，它每次向目标移动剩余距离的二分之一，代价为上一次移动代价的二分之一。
chap3_para30,7,,这个问题不存在动作数量有限的解，但为了防止搜索在没有完全到达目标的情况下采取无限数量的动作，我们可以要求所有动作的代价至少为，为某个较小的正值。
chap3_para300,1,Figure 3.,3.6.3　从子问题出发生成启发式函数：模式数据库
chap3_para300,2,"28 A Web service providing driving directions, computed by a search algorithm.",
chap3_para301,1,"We could generate a perfect heuristic by precomputing and storing the cost of the optimal path between every pair of vertices. That would take O(|V|2) space, and O(|E|3) time—practical for graphs with 10 thousand vertices, but not 10 million.",可容许的启发式函数也可以由给定问题的子问题（subproblem）的解代价推导得到。
chap3_para301,2,,例如，图3-27为图3-25中8数码问题实例的一个子问题。
chap3_para301,3,,子问题涉及将滑块1、2、3、4和空格分别放置到正确位置。
chap3_para301,4,,显然，这个子问题最优解的代价是完整问题代价的一个下界。
chap3_para301,5,,在某些情况下，它比曼哈顿距离更准确。
chap3_para302,1,"A better approach is to choose a few (perhaps 10 or 20) landmark points16 from the vertices. Then for each landmark L and for each other vertex v in the graph, we compute and store C* (v, L), the exact cost of the optimal path from v to L. (We also need C* (L, v); on an undirected graph this is the same as C* (v, L); on a directed graph—e.g., with one-way streets—we need to compute this separately.) Given the stored C* tables, we can easily create an efficient (although inadmissible) heuristic: the minimum, over all landmarks, of the cost of getting from the current node to the landmark, and then to the goal:",图3-27　图3-25中所给出的8数码实例的子问题。
chap3_para302,2,,任务是将滑块1、2、3、4和空格放置到正确位置，而不考虑其他滑块的情况
chap3_para303,1,"If the optimal path happens to go through a landmark, this heuristic will be exact; if not it is inadmissible—it overestimates the cost to the goal. In an A* search, if you have exact heuristics, then once you reach a node that is on an optimal path, every node you expand from then on will be on an optimal path. Think of the contour lines as following along this optimal path. The search will trace along the optimal path, on each iteration adding an action with cost c to get to a result state whose h-value will be c less, meaning that the total f = g + h score will remain constant at C* all along the path.",模式数据库（pattern database）的思想是为每个可能的子问题（在我们的示例中，为4个滑块和空格的所有可能排列）存储准确的解代价。
chap3_para303,2,,（数据库中将有9×8×7×6×5 = 15 120种模式。
chap3_para303,3,,其他4个滑块与子问题的求解无关，但移动这些滑块将计入子问题的解代价。
chap3_para303,4,,）然后，通过在数据库中查找相应的子问题，为搜索过程中遇到的每个状态计算一个可容许的启发式函数hDB。
chap3_para303,5,,数据库本身是从目标状态反向搜索并记录所遇到的每个新模式的代价来构建的[15]；这一搜索的开销将分摊到后续的问题实例中，因此如果我们需要求解很多问题，那么这种方法是有意义的。
chap3_para304,1,"Some route-finding algorithms save even more time by adding shortcuts—artificial edges in the graph that define an optimal multi-action path. For example, if there were shortcuts predefined between all the 100 biggest cities in the U.S., and we were trying to navigate from the Berkeley campus in California to NYU in New York, we could take the shortcut between Sacramento and Manhattan and cover 90% of the path in one action.",
chap3_para305,1,hL(n) is efficient but not admissible.,[15]　通过从目标反向回溯，可以立即获得所遇到的每个实例的准确的解代价。
chap3_para305,2,"But with a bit more care, we can come up with a heuristic that is both efficient and admissible:",这是动态规划的一个示例，我们将在第17章进一步讨论。
chap3_para306,1,"This is called a differential heuristic (because of the subtraction). Think of this with a landmark that is somewhere out beyond the goal. If the goal happens to be on the optimal path from n to the landmark, then this is saying “consider the entire path from n to L, then subtract off the last part of that path, from goal to L, giving us the exact cost of the path from n to goal ” To the extent that the goal is a bit off of the optimal path to the landmark, the heuristic will be inexact, but still admissible. Landmarks that are not out beyond the goal will not be useful; a landmark that is exactly halfway between n and goal will give hDH = 0, which is not helpful.",与空格搭配的滑块1-2-3-4的选择是相当随意的；我们还可以为5-6-7-8、2-4-6-8等建立数据库。
chap3_para306,2,,每个数据库产生一种可容许的启发式函数，正如前文所述，可以通过取最大值对这些启发式函数进行组合。
chap3_para306,3,,这种组合的启发式函数要比曼哈顿距离精确得多；求解随机15数码问题时所生成的节点数可以减少到千分之一。
chap3_para306,4,,然而，每增加一个数据库，收益会随之减少，内存和计算成本也会增加。
chap3_para307,1,There are several ways to pick landmark points.,你们可能想知道从1-2-3-4数据库和5-6-7-8数据库中得到的启发式函数是否可以相加，因为这两个子问题似乎没有重叠。
chap3_para307,2,"Selecting points at random is fast, but we get better results if we take care to spread the landmarks out so they are not too close to each other.",这会是一个可容许的启发式函数吗？
chap3_para307,3,"A greedy approach is to pick a first landmark at random, then find the point that is furthest from that, and add it to the set of landmarks, and continue, at each iteration adding the point that maximizes the distance to the nearest landmark.",答案是否定的，因为对于一个给定的状态，1-2-3-4子问题和5-6-7-8子问题的解一定会有一些重复操作——1-2-3-4不可能在不接触5-6-7-8的情况下移动到位，反之亦然。
chap3_para307,4,"If you have logs of past search requests by your users, then you can pick landmarks that are frequently requested in searches.",但是，如果我们不计入这些操作，换句话说，如果我们让其他滑块直接消失呢？
chap3_para307,5,For the differential heuristic it is good if the landmarks are spread around the perimeter of the graph.,也就是说，我们不记录求解1-2-3-4子问题的总代价，而只记录与1-2-3-4有关的操作数。
chap3_para307,6,"Thus, a good technique is to find the centroid of the graph, arrange k pie-shaped wedges around the centroid, and in each wedge select the vertex that is farthest from the center.",那么这两个代价的和仍然是求解完整问题代价的一个下界。
chap3_para307,7,,这就是不相交模式数据库（disjoint pattern database）的思想。
chap3_para307,8,,有了这样的数据库，可以在几毫秒内求解随机的15数码问题——与使用曼哈顿距离相比，生成的节点数不到原来的万分之一。
chap3_para307,9,,对于24数码问题，则可以获得大约一百万倍的加速。
chap3_para307,10,,不相交模式数据库适用于滑块数码问题，因为每次移动只涉及一个滑块，因而原问题可以被划分成若干个子问题使得每次移动只影响一个子问题。
chap3_para308,1,"Landmarks work especially well in route-finding problems because of the way roads are laid out in the world: a lot of traffic actually wants to travel between landmarks, so civil engineers build the widest and fastest roads along these routes; landmark search makes it easier to recover these routes.",3.6.4　使用地标生成启发式函数
chap3_para309,1,3.,一些在线服务可以托管含有数千万个顶点的地图，并在毫秒内找到代价最优的驾驶路线。
chap3_para309,2,6.,即使是我们之前提到的最优的搜索算法，做到这一点也要比这些在线服务多耗费100万倍的时间。
chap3_para309,3,5Learning to search better,那在线服务是怎么做到这一点的呢？
chap3_para309,4,,这里有很多技巧，但最重要的是对一些最优路径代价的预计算（precomputation）。
chap3_para309,5,,虽然预计算可能相当耗时，但只需完成一次预计算，就可以摊销数十亿用户的搜索请求。
chap3_para31,1,Can we be more precise about the appropriate level of abstraction?,状态空间可以用图（graph）来表示，图中的顶点表示状态，顶点之间的有向边表示动作。
chap3_para31,2,Think of the abstract states and actions we have chosen as corresponding to large sets of detailed world states and detailed action sequences.,图3-1所示的罗马尼亚地图就是这样一个图，每条道路表示两种动作，即两个方向各表示一种。
chap3_para31,3,"Now consider a solution to the abstract problem: for example, the path from Arad to Sibiu to Rimnicu Vilcea to Pitesti to Bucharest.",
chap3_para31,4,This abstract solution corresponds to a large number of more detailed paths.,
chap3_para31,5,"For example, we could drive with the radio on between Sibiu and Rimnicu Vilcea, and then switch it off for the rest of the trip.",
chap3_para310,1,"We have presented several fixed search strategies—breadth-first, A*, and so on—that have been carefully designed and programmed by computer scientists. Could an agent learn how to search better? The answer is yes, and the method rests on an important concept called the metalevel state space. Each state in a metalevel state space captures the internal (computational) state of a program that is searching in an ordinary state space such as the map of Romania. (To keep the two concepts separate, we call the map of Romania an object-level state space.) For example, the internal state of the A* algorithm consists of the current search tree. Each action in the metalevel state space is a computation step that alters the internal state; for example, each computation step in A* expands a leaf node and adds its successors to the tree. Thus, Figure 3.18, which shows a sequence of larger and larger search trees, can be seen as depicting a path in the metalevel state space where each state on the path is an object-level search tree.",我们可以通过预计算并存储每对顶点之间的最优路径代价来生成完美的启发式函数。
chap3_para310,2,,这需要空间和时间——对于含有1万个顶点的图很实用，但对于1000万个顶点，这样的复杂性不可接受。
chap3_para311,1,"Now, the path in Figure 3.",更好的方法是从顶点中选择一些（也许10个或20个）地标点（landmark point）[16]。
chap3_para311,2,"18 has five steps, including one step, the expansion of Fagaras, that is not especially helpful.","然后，对于图中每个地标L和每个其他顶点v，我们计算并存储C*(v, L)，即从v到L的最优路径的准确代价。"
chap3_para311,3,"For harder problems, there will be many such missteps, and a metalevel learning algorithm can learn from these experiences to avoid exploring unpromising subtrees.","（我们同样需要C*(L, v)；在无向图上，C*(L, v)与C*(v, L)相同；在有向图上，如单行道，我们则需要单独计算C*(L, v)。"
chap3_para311,4,The techniques used for this kind of learning are described in Chapter 23.,）给定存储的C*表，我们可以很容易地创建出一个高效的（尽管是不可容许的）启发式函数：在所有地标中，从当前节点到地标然后到目标节点代价的最小值为
chap3_para311,5,"The goal of learning is to minimize the total cost of problem solving, trading off computational expense and path cost.",
chap3_para312,1,3.,
chap3_para312,2,6.,
chap3_para312,3,6Learning heuristics from experience,
chap3_para313,1,"We have seen that one way to invent a heuristic is to devise a relaxed problem for which an optimal solution can be found easily. An alternative is to learn from experience. “Experience” here means solving lots of 8-puzzles, for instance. Each optimal solution to an 8-puzzle problem provides an example (goal, path) pair. From these examples, a learning algorithm can be used to construct a function h that can (with luck) approximate the true path cost for other states that arise during search. Most of these approaches learn an imperfect approximation to the heuristic function, and thus risk inadmissibility. This leads to an inevitable tradeoff between learning time, search run time, and solution cost. Techniques for machine learning are demonstrated in Chapter 19. The reinforcement learning methods described in Chapter 23 are also applicable to search.",[16]　地标点有时被称为“枢轴”或“锚点”。
chap3_para314,1,"Some machine learning techniques work better when supplied with features of a state that are relevant to predicting the state’s heuristic value, rather than with just the raw state description. For example, the feature “number of misplaced tiles” might be helpful in predicting the actual distance of an 8-puzzle state from the goal. Let’s call this feature x1(n). We could take 100 randomly generated 8-puzzle configurations and gather statistics on their actual solution costs. We might find that when x1(n) is 5, the average solution cost is around 14, and so on. Of course, we can use multiple features. A second feature x2(n) might be “number of pairs of adjacent tiles that are not adjacent in the goal state.” How should x1(n) and x2(n) be combined to predict h(n)? A common approach is to use a linear combination:",如果最优路径刚好经过一个地标，这个启发式函数将是准确的；否则，这个启发式函数就是不可容许的——它高估了到目标的代价。
chap3_para314,2,,在A*搜索中，如果启发式函数是准确的，那么一旦到达一个位于最优路径上的节点，此后所扩展的每个节点都将位于最优路径上。
chap3_para314,3,,把等值线想象为沿着这条最优路径前进。
chap3_para314,4,,搜索将沿着最优路径进行，在每次迭代中加入一个代价为c的动作，然后到达一个h值减少c的结果状态，这意味着在整条路径上总的f = g + h得分将保持在常量C*。
chap3_para315,1,The constants c1 and c2 are adjusted to give the best fit to the actual data across the randomly generated configurations.,一些寻径算法通过在图中添加捷径（shortcut）——人工定义的对应于一条最优多行动路径的边——来节省更多的时间。
chap3_para315,2,One expects both c1 and c2 to be positive because misplaced tiles and incorrect adjacent pairs make the problem harder to solve.,例如，如果我们在美国最大的100个城市之间预先定义了捷径，并且尝试从位于加利福尼亚州的加利福尼亚大学伯克利分校校区导航到纽约的纽约大学，那么我们可以走萨克拉门托（Sacramento）到曼哈顿（Manhattan）之间的捷径，一次动作就能覆盖90%的路径。
chap3_para315,3,"Notice that this heuristic satisfies the condition h(n) = 0 for goal states, but it is not necessarily admissible or consistent.",
chap3_para316,1,"This chapter has introduced search algorithms that an agent can use to select action sequences in a wide variety of environments—as long as they are episodic, single-agent, fully observable, deterministic, static, discrete, and completely known. There are tradeoffs to be made between the amount of time the search takes, the amount of memory available, and the quality of the solution. We can be more efficient if we have domain-dependent knowledge in the form of a heuristic function that estimates how far a given state is from the goal, or if we precompute partial solutions involving patterns or landmarks.",hL(n)是高效的，但不是可容许的。
chap3_para316,2,,只要稍加注意，我们就可以提出一种既高效又可容许的启发式函数：
chap3_para317,1,"•Before an agent can start searching, a well-defined problem must be formulated.",这被称为差分启发式（differential heuristic）函数（因为包含减法）。
chap3_para317,2,,可以把它理解为在比目标还要远的某个位置设置一个地标点。
chap3_para317,3,,如果目标恰好在从n到该地标点的最优路径上，那么“考虑从n到L的完整路径，然后减去这条路径的最后一部分，即从goal到L，即可得到从n到goal的这段路径的准确代价”。
chap3_para317,4,,如果目标稍微偏离到地标的最优路径，启发式函数将是不准确的，但仍然是可容许的。
chap3_para317,5,,比目标近的地标是没有用的；例如，一个恰好位于n和goal正中间的地标将导致hDH = 0，这是没有用的。
chap3_para318,1,"•A problem consists of five parts: the initial state, a set of actions, a transition model describing the results of those actions, a set of goal states, and an action cost function.",下面我们介绍几种选择地标点的方法。
chap3_para318,2,,随机选择速度较快，但如果我们多花些功夫将地标分散开来，使得它们彼此之间不太接近，我们将得到更好的结果。
chap3_para318,3,,贪心方法是随机选择第一个地标，然后找到离它最远的点，将其添加到地标集合中，接着在每次迭代中添加离最近地标最远的点。
chap3_para318,4,,如果你有用户过去的搜索请求日志，那么你可以选择搜索中经常请求的地点作为地标。
chap3_para318,5,,对于差分启发式函数，地标分布在图的周界上更好。
chap3_para318,6,,因此，一个比较好的技术是找到图的质心，围绕质心划分出k个楔形（就像饼状图一样），并在每个楔形中选择离中心最远的顶点。
chap3_para319,1,•The environment of the problem is represented by a state space graph. A path through the state space (a sequence of actions) from the initial state to a goal state is a solution.,地标在寻径问题上尤其有效，这是由世界上道路的布局方式导致的：许多交通运输实际上都是在地标之间穿行，所以土木工程师在这些路线上修建最宽、最快的道路；地标式搜索可以更轻松地复原这些路线。
chap3_para32,1,"The abstraction is valid if we can elaborate any abstract solution into a solution in the more detailed world; a sufficient condition is that for every detailed state that is “in Arad,” there is a detailed path to some state that is “in Sibiu,” and so on.4 The abstraction is useful if carrying out each of the actions in the solution is easier than the original problem; in our case, the action “drive from Arad to Sibiu” can be carried out without further search or planning by a driver with average skill. The choice of a good abstraction thus involves removing as much detail as possible while retaining validity and ensuring that the abstract actions are easy to carry out. Were it not for the ability to construct useful abstractions, intelligent agents would be completely swamped by the real world.",3.1.2　问题形式化
chap3_para320,1,"•Search algorithms generally treat states and actions as atomic, without any internal structure (although we introduced features of states when it came time to do learning).",3.6.5　学习以更好地搜索
chap3_para321,1,"•Search algorithms are judged on the basis of completeness, cost optimality, time complexity, and space complexity.",我们介绍了几种固定的搜索策略（广度优先、A*等），这些都是计算机科学家精心设计和编程实现的。
chap3_para321,2,,那么智能体能自己学习如何更好地搜索吗？
chap3_para321,3,,答案是肯定的，这种方法基于一个重要的概念，元级状态空间（metalevel state space）。
chap3_para321,4,,元级状态空间中的每个状态将捕捉在普通状态空间（例如罗马尼亚地图）进行搜索的程序的内部（计算）状态。
chap3_para321,5,,［为了区分这两个概念，我们将罗马尼亚地图称为对象级状态空间（object-level state space）。
chap3_para321,6,,］例如，A*算法的内部状态由当前搜索树组成。
chap3_para321,7,,元级状态空间中的每个动作都是一个改变内部状态的计算步；例如，A*中的每一个计算步扩展一个叶节点，并将其后续节点添加到树中。
chap3_para321,8,,因此，图3-18展示了一个逐渐增大的搜索树序列，它描述了元级状态空间中的一条路径，路径上的每个状态都是一棵对象级搜索树。
chap3_para322,1,•Uninformed search methods have access only to the problem definition. Algorithms build a search tree in an attempt to find a solution. Algorithms differ based on which node they expand first:,现在，图3-18中的路径共有5步，包括一个扩展Fagaras的步骤，这一步不是非常有用。
chap3_para322,2,,对于更困难的问题，将存在很多这样的错误步骤，元级学习（metalevel learning）算法可以从这些经验中学习，以避免探索毫无希望的子树。
chap3_para322,3,,这种学习算法将在第22章中介绍。
chap3_para322,4,,学习的目标是对计算开销和路径代价进行权衡，以最小化求解问题的总代价。
chap3_para323,1,–Best-first search selects nodes for expansion using an evaluation function.,3.6.6　从经验中学习启发式函数
chap3_para324,1,"–Breadth-first search expands the shallowest nodes first; it is complete, optimal for unit action costs, but has exponential space complexity.",我们已经看到，生成启发式函数的一种方法是设计一个容易找到最优解的松弛问题，另一种选择是从经验中学习。
chap3_para324,2,,这里的“经验”意味着，例如，求解大量8数码问题。
chap3_para324,3,,"一个8数码问题的每个最优解都提供了一个“(目标,路径)”对作为示例。"
chap3_para324,4,,可以利用学习算法通过这些示例构造一个函数h，（幸运的话）它可以近似搜索过程中出现的其他状态的真实路径代价。
chap3_para324,5,,这些方法中的大多数学习到的都是启发式函数的一个不完美的近似，因此存在启发式函数不可容许的风险。
chap3_para324,6,,这必然导致算法需要在学习时间、搜索运行时间和解的代价之间进行权衡。
chap3_para324,7,,机器学习技术将在第19章中介绍。
chap3_para324,8,,第22章中介绍的强化学习方法也适用于搜索问题。
chap3_para325,1,"–Uniform-cost search expands the node with lowest path cost, g(n), and is optimal for general action costs.",如果除了原始状态描述外，还提供与预测启发式函数值相关的状态特征（feature），那么一些机器学习技术将表现得更好。
chap3_para325,2,,例如，“错位滑块数”这一特征可能有助于预测8数码问题中状态与目标的实际距离。
chap3_para325,3,,我们将这一特征记作x1(n)。
chap3_para325,4,,我们可以使用100个随机生成的8数码配置，并收集其真实解代价的统计数据。
chap3_para325,5,,我们可能会发现，当x1(n) = 5时，平均的解代价大约是14，等等。
chap3_para325,6,,当然，可以使用多种特征。
chap3_para325,7,,例如，第二个特征x2(n)可能是“在当前状态相邻而在目标状态中不相邻的滑块对的数量”。
chap3_para325,8,,如何对x1(n)和x2(n)进行组合来预测h(n)？
chap3_para325,9,,一种常见的方法是线性组合：
chap3_para326,1,"–Depth-first search expands the deepest unexpanded node first. It is neither complete nor optimal, but has linear space complexity. Depth-limited search adds a depth bound.",可以调整常数c1和c2以适应随机生成的配置中实际数据的值。
chap3_para326,2,,我们希望c1和c2都是正值，因为错位滑块和不正确的相邻对都会使得问题更难求解。
chap3_para326,3,,注意，这个启发式函数满足目标状态h(n) = 0的条件，但它不一定是可容许的或一致的。
chap3_para327,1,"–Iterative deepening search calls depth-first search with increasing depth limits until a goal is found. It is complete when full cycle checking is done, optimal for unit action costs, has time complexity comparable to breadth-first search, and has linear space complexity.",
chap3_para328,1,"–Bidirectional search expands two frontiers, one around the initial state and one around the goal, stopping when the two frontiers meet.",本章对搜索算法进行了介绍，智能体可以用这些算法在各种环境中选择动作序列——只要环境是回合式的、单智能体的、完全可观测的、确定性的、静态的、离散的和已知的。
chap3_para328,2,,算法需要在搜索所需时间、可用内存和解的质量之间进行权衡。
chap3_para328,3,,如果我们对于启发式函数的形式拥有额外的领域相关知识来估计给定状态离目标有多远，或者我们预计算涉及模式或地标的部分解，算法会更高效。
chap3_para329,1,•Informed search methods have access to a heuristic function h(n) that estimates the cost of a solution from n. They may have access to additional information such as pattern databases with solution costs.,● 在智能体开始搜索之前，必须形式化一个良定义的问题。
chap3_para33,1,3.,我们将前文中去往Bucharest的问题形式化为一个模型（model）——一种抽象的数学描述，而不是真实存在的实物。
chap3_para33,2,2Example Problems,与简单的原子状态描述Arad相比，实际的旅行的世界状态包括很多内容：旅行伙伴、当时的广播节目、窗外的风景、附近是否有执法人员、到下一个休息站的距离、道路状况、天气、交通等。
chap3_para33,3,,所有这些因素都被排除在我们的模型之外，因为它们与寻找前往Bucharest的路线问题无关。
chap3_para330,1,–Greedy best-first search expands nodes with minimal h(n). It is not optimal but is often efficient.,● 问题由5部分组成：初始状态、动作集合、描述这些动作结果的转移模型、目标状态集合和动作代价函数。
chap3_para331,1,"–A* search expands nodes with minimal f(n) = g(n) + h(n). A* is complete and optimal, provided that h(n) is admissible. The space complexity of A* is still an issue for many problems.",● 问题的环境用状态空间图表示。
chap3_para331,2,,通过状态空间（一系列动作）从初始状态到达一个目标状态的路径是一个解。
chap3_para332,1,–Bidirectional A* search is sometimes more efficient than A* itself.,● 搜索算法通常将状态和动作看作原子的，即没有任何内部结构（尽管我们在学习时引入了状态特征）。
chap3_para333,1,"–IDA* (iterative deepening A* search) is an iterative deepening version of A*, and thus adresses the space complexity issue.",● 根据完备性、代价最优性、时间复杂性和空间复杂性来评估搜索算法。
chap3_para334,1,"–RBFS (recursive best-first search) and SMA* (simplified memory-bounded A*) are robust, optimal search algorithms that use limited amounts of memory; given enough time, they can solve problems for which A* runs out of memory.",● 无信息搜索方法只能访问问题定义。
chap3_para334,2,,算法构建一棵搜索树，试图找到一个解。
chap3_para334,3,,算法会根据其首先扩展的节点而有所不同。
chap3_para335,1,"–Beam search puts a limit on the size of the frontier; that makes it incomplete and suboptimal, but it often finds reasonably good solutions and runs faster than complete searches.",❏ 最佳优先搜索根据评价函数选择节点进行扩展。
chap3_para336,1,"–Weighted A* search focuses the search towards a goal, expanding fewer nodes, but sacrificing optimality.",❏ 广度优先搜索首先扩展深度最浅的节点；它是完备的，对于单位动作代价是最优的，但具有指数级空间复杂性。
chap3_para337,1,"•The performance of heuristic search algorithms depends on the quality of the heuristic function. One can sometimes construct good heuristics by relaxing the problem definition, by storing precomputed solution costs for subproblems in a pattern database, by defining landmarks, or by learning from experience with the problem class.",❏ 一致代价搜索扩展路径代价g(n)最小的节点，对于一般的动作代价是最优的。
chap3_para338,1,Bibliographical and Historical Notes,❏ 深度优先搜索首先扩展最深的未扩展节点。
chap3_para338,2,,它既不是完备的也不是最优的，但具有线性级空间复杂性。
chap3_para338,3,,深度受限搜索增加了一个深度限制。
chap3_para339,1,The topic of state-space search originated in the early years of AI. Newell and Simon’s work on the Logic Theorist (1957) and GPS (1961) led to the establishment of search algorithms as the primary tool for 1960s AI researchers and to the establishment of problem solving as the canonical AI task. Work in operations research by Richard Bellman (1957) showed the importance of additive path costs in simplifying optimization algorithms. The text by Nils Nilsson (1971) established the area on a solid theoretical footing.,❏ 迭代加深搜索在不断增加的深度限制上调用深度优先搜索，直到找到一个目标。
chap3_para339,2,,当完成全部循环检查时，它是完备的，同时对于单位动作代价是最优的，且具有与广度优先搜索相当的时间复杂性和线性级空间复杂性。
chap3_para34,1,The problem-solving approach has been applied to a vast array of task environments.,从表示中剔除细节的过程称为抽象（abstraction）。
chap3_para34,2,"We list some of the best known here, distinguishing between standardized and real-world problems.",一个良好的问题形式化应该具有适度的细节层次。
chap3_para34,3,A standardized problem is intended to illustrate or exercise various problem-solving methods.,如果智能体的动作细化到“右脚向前移动1厘米”或“方向盘向左转动1度”的层次上，那它可能永远都找不到走出停车场的路，更不用说去Bucharest了。
chap3_para34,4,"It can be given a concise, exact description and hence is suitable as a benchmark for researchers to compare the performance of algorithms.",
chap3_para34,5,"A real-world problem, such as robot navigation, is one whose solutions people actually use, and whose formulation is idiosyncratic, not standardized, because, for example, each robot has different sensors that produce different data.",
chap3_para340,1,"The 8-puzzle is a smaller cousin of the 15-puzzle, whose history is recounted at length by Slocum and Sonneveld (2006). In 1880, the 15-puzzle attracted broad attention from the public and mathematicians (Johnson and Story, 1879; Tait, 1880). The editors of the American Journal of Mathematics stated, “The ‘15’ puzzle for the last few weeks has been prominently before the American public, and may safely be said to have engaged the attention of nine out of ten persons of both sexes and all ages and conditions of the community,” while the Weekly News-Democrat of Emporia, Kansas wrote on March 12, 1880 that “It has become literally an epidemic all over the country.”",❏ 双向搜索扩展两个边界，一个围绕初始状态，另一个围绕目标，当两个边界相遇时搜索停止。
chap3_para341,1,"The famous American game designer Sam Loyd falsely claimed to have invented the 15 puzzle (Loyd, 1959); actually it was invented by Noyes Chapman, a postmaster in Canastota, New York, in the mid-1870s (although a generic patent covering sliding blocks was granted to Ernest Kinsey in 1878). Ratner and Warmuth (1986) showed that the general n × n version of the 15-puzzle belongs to the class of NP-complete problems.",● 有信息搜索方法可以访问启发式函数h(n)来估计从n到目标的解代价。
chap3_para341,2,,它们可以访问一些附加信息，例如，存有解代价的模式数据库。
chap3_para342,1,"Rubik’s Cube was of course invented in 1974 by Ernő Rubik, who also discovered an algorithm for finding good, but not optimal solutions. Korf (1997) found optimal solutions for some random problem instances using pattern databases and IDA* search. Rokicki et al. (2014) proved that any instance can be solved in 26 moves (if you consider a 180° twist to be two moves; 20 if it counts as one). The proof consumed 35 CPU years of computation; it does not lead immediately to an efficient algorithm. Agostinelli et al. (2019) used reinforcement learning, deep learning networks, and Monte Carlo tree search to learn a much more efficient solver for Rubik’s cube. It is not guaranteed to find a cost-optimal solution, but does so about 60% of the time, and typical solutions times are less than a second.",❏ 贪心最佳优先搜索扩展h(n)值最小的节点。
chap3_para342,2,,它不是最优的，但通常效率很高。
chap3_para343,1,Each of the real-world search problems listed in the chapter has been the subject of a good deal of research effort.,❏ A*搜索扩展f(n) = g(n) + h(n)值最小的节点。
chap3_para343,2,"Methods for selecting optimal airline flights remain proprietary for the most part, but Carl de Marcken has shown by a reduction to Diophantine decision problems that airline ticket pricing and restrictions have become so convoluted that the problem of selecting an optimal flight is formally undecidable (Robinson, 2002).",在h(n)可容许的条件下，A*是完备的、最优的。
chap3_para343,3,The traveling salesperson problem (TSP) is a standard combinatorial problem in theoretical computer science (Lawler et al.,对于许多问题，A*的空间复杂性仍然很高。
chap3_para343,4,", 1992).",
chap3_para343,5,"Karp (1972) proved the TSP decision problem to be NP-hard, but effective heuristic approximation methods were developed (Lin and Kernighan, 1973).",
chap3_para343,6,Arora (1998) devised a fully polynomial approximation scheme for Euclidean TSPs.,
chap3_para343,7,"VLSI layout methods are surveyed by LaPaugh (2010), and many layout optimization papers appear in VLSI journals.",
chap3_para343,8,Robotic navigation is discussed in Chapter 26.,
chap3_para343,9,"Automatic assembly sequencing was first demonstrated by FREDDY (Michie, 1972); a comprehensive review is given by (Bahubalendruni and Biswal, 2016).",
chap3_para344,1,Uninformed search algorithms are a central topic of computer science (Cormen et al.,❏ 双向A*搜索有时比A*搜索本身更高效。
chap3_para344,2,", 2009) and operations research (Dreyfus, 1969).",
chap3_para344,3,Breadth-first search was formulated for solving mazes by Moore (1959).,
chap3_para344,4,"The method of dynamic programming (Bellman, 1957; Bellman and Dreyfus, 1962), which systematically records solutions for all subproblems of increasing lengths, can be seen as a form of breadth-first search.",
chap3_para345,1,"Dijkstra’s algorithm in the form it is usually presented in (Dijkstra, 1959) is applicable to explicit finite graphs. Nilsson (1971) introduced a version of Dijkstra’s algorithm that he called uniform-cost search (because the algorithm “spreads out along contours of equal path cost”) that allows for implicitly defined, infinite graphs. Nilsson’s work also introduced the idea of closed and open lists, and the term “graph search.” The name BEST-FIRST-SEARCH was introduced in the Handbook of AI (Barr and Feigenbaum, 1981). The Floyd–Warshall (Floyd, 1962) and Bellman-Ford (Bellman, 1958; Ford, 1956) algorithms allow negative step costs (as long as there are no negative cycles).",❏ IDA*（迭代加深A*搜索）是A*搜索的迭代加深版本，它解决了空间复杂性问题。
chap3_para346,1,A version of iterative deepening designed to make efficient use of the chess clock was first used by Slate and Atkin (1977) in the CHESS 4.5 game-playing program. Martelli’s algorithm B (1977) also includes an iterative deepening aspect. The iterative deepening technique was introduced by Bertram Raphael (1976) and came to the fore in work by Korf (1985a).,❏ RBFS（递归最佳优先搜索）和SMA*（简化的内存受限A*）搜索是健壮的最优搜索算法，它们仅使用有限的内存；如果时间充足，它们可以解决对A*来说内存不足的问题。
chap3_para347,1,"The use of heuristic information in problem solving appears in an early paper by Simon and Newell (1958), but the phrase “heuristic search” and the use of heuristic functions that estimate the distance to the goal came somewhat later (Newell and Ernst, 1965; Lin, 1965). Doran and Michie (1966) conducted extensive experimental studies of heuristic search. Although they analyzed path length and “penetrance” (the ratio of path length to the total number of nodes examined so far), they appear to have ignored the information provided by the path cost g(n). The A* algorithm, incorporating the current path cost into heuristic search, was developed by Hart, Nilsson, and Raphael (1968). Dechter and Pearl (1985) studied the conditions under which A* is optimally efficient (in number of nodes expanded).",❏ 束搜索限制了边界的大小；因此它是非完备的、次优的，但束搜索通常能找到相当好的解，运行速度也比完备搜索更快。
chap3_para348,1,The original A* paper (Hart et al.,❏ 加权A*搜索将搜索专注于一个目标，以扩展更少的节点，但它牺牲了最优性。
chap3_para348,2,", 1968) introduced the consistency condition on heuristic functions.",
chap3_para348,3,"The monotone condition was introduced by Pohl (1977) as a simpler replacement, but Pearl (1984) showed that the two were equivalent.",
chap3_para349,1,"Pohl (1977) pioneered the study of the relationship between the error in heuristic functions and the time complexity of A*. Basic results were obtained for tree-like search with unit action costs and a single goal state (Pohl, 1977; Gaschnig, 1979; Huyn et al., 1980; Pearl, 1984) and with multiple goal states (Dinh et al., 2007). Korf and Reid (1998) showed how to predict the exact number of nodes expanded (not just an asymptotic approximation) on a variety of actual problem domains. The “effective branching factor” was proposed by Nilsson (1971) as an empirical measure of efficiency. For graph search, Helmert and Röger (2008) noted that several well-known problems contained exponentially many nodes on optimal-cost solution paths, implying exponential time complexity for A*.",● 启发式搜索算法的性能取决于启发式函数的质量。
chap3_para349,2,,我们有时可以通过松弛问题定义、在模式数据库中存储预计算的子问题的解代价、定义地标点，或者从问题类的经验中学习来构建良好的启发式函数。
chap3_para35,1,3.,我们能更精确地定义合适的抽象层级（level of abstraction）吗？
chap3_para35,2,2.,我们所选择的抽象状态和动作对应于大量具体的世界状态和动作序列。
chap3_para35,3,1Standardized problems,现在考虑抽象问题的解，例如，从Arad到Sibiu，到Rimnicu Vilcea，到Pitesti，再到Bucharest的路径。
chap3_para35,4,,这个抽象解对应于大量更详细的路径。
chap3_para35,5,,例如，从Sibiu开往Rimnicu Vilcea的途中，我们可以打开收音机，而在其他的旅程中关掉收音机。
chap3_para350,1,There are many variations on the A* algorithm.,
chap3_para350,2,"Pohl (1970) introduced weighted A* search, and later a dynamic version (1973), where the weight changes over the depth of the tree.",
chap3_para350,3,Ebendt and Drechsler (2009) synthesize the results and examine some applications.,
chap3_para350,4,Hatem and Ruml (2014) show a simplified and improved version of weighted A* that is easier to implement.,
chap3_para350,5,"Wilt and Ruml (2014) introduce speedy search as an alternative to greedy search that focuses on minimizing search time, and Wilt and Ruml (2016) show that the best heuristics for satisficing search are different from the ones for optimal search.",
chap3_para350,6,Burns et al.,
chap3_para350,7,"(2012) give some implementation tricks for writing fast search code, and Felner (2018) considers how the implementation changes when using an early goal test.",
chap3_para351,1,Pohl (1971) introduced bidirectional search.,微信扫码关注【异步社区】微信公众号，回复“e59810”获取本书配套资源以及异步社区15天VIP会员卡，近千本电子书免费畅读。
chap3_para351,2,Holte et al.,
chap3_para351,3,"(2016) describe the version of bidirectional search that is guaranteed to meet in the middle, making it more widely applicable.",
chap3_para351,4,Eckerle et al.,
chap3_para351,5,"(2017) describe the set of surely expanded pairs of nodes, and show that no bidirectional search can be optimally efficient.",
chap3_para351,6,The NBS algorithm (Chen et al.,
chap3_para351,7,", 2017) makes explicit use of a queue of pairs of nodes.",
chap3_para352,1,"A combination of bidirectional A* and known landmarks was used to efficiently find driving routes for Microsoft’s online map service (Goldberg et al., 2006). After caching a set of paths between landmarks, the algorithm can find an optimal-cost path between any pair of points in a 24-million-point graph of the United States, searching less than 0.1% of the graph. Korf (1987) shows how to use subgoals, macro-operators, and abstraction to achieve remarkable speedups over previous techniques. Delling et al. (2009) describe how to use bidirectional search, landmarks, hierarchical structure, and other tricks to find driving routes. Anderson et al. (2008) describe a related technique, called coarse-to-fine search, which can be thought of as defining landmarks at various hierarchical levels of abstraction. Korf (1987) describes conditions under which coarse-to-fine search provides an exponential speedup. Knoblock (1991) provides experimental results and analysis to quantify the advantages of hierarchical search.",第4章　复杂环境中的搜索
chap3_para353,1,"A* and other state-space search algorithms are closely related to the branch-and-bound techniques that are widely used in operations research (Lawler and Wood, 1966; Rayward-Smith et al., 1996). Kumar and Kanal (1988) attempt a “grand unification” of heuristic search, dynamic programming, and branch-and-bound techniques under the name of CDP—the “composite decision process.”",在本章中，我们放宽了第3章的简化假设，以更接近真实世界。
chap3_para354,1,"Because most computers in the 1960s had only a few thousand words of main memory, memory-bounded heuristic search was an early research topic.",第3章讨论了完全可观测的、确定性的、静态的、已知的环境中的问题，问题的解是一个动作序列。
chap3_para354,2,"The Graph Traverser (Doran and Michie, 1966), one of the earliest search programs, commits to an action after searching best-first up to the memory limit.",在本章中，我们将放宽这些限制。
chap3_para354,3,"IDA* (Korf, 1985b) was the first widely used length- optimal, memory-bounded heuristic search algorithm, and a large number of variants have been developed.",首先，我们考虑这样一个问题，即寻找一个好的状态而不考虑到达该状态的路径，状态包括离散状态（4.1节）和连续状态（4.2节）。
chap3_para354,4,An analysis of the efficiency of IDA* and of its difficulties with real-valued heuristics appears in Patrick et al.,然后，我们放宽了确定性假设（4.3节）和可观测性假设（4.4节）。
chap3_para354,5,(1992).,在一个非确定性的世界中，智能体将需要一个条件规划，并根据它所观测到的情况执行不同的动作——例如，红灯停，绿灯行。
chap3_para354,6,,对于部分可观测性环境，智能体还需要记录它的可能状态。
chap3_para354,7,,最后，4.5节将指导智能体使用在线搜索（online search）通过一个未知空间，在未知空间中一边前进一边学习。
chap3_para355,1,"The original version of RBFS (Korf, 1993) is actually somewhat more complicated than the algorithm shown in Figure 3.22, which is actually closer to an independently developed algorithm called iterative expansion or IE (Russell, 1992). RBFS uses a lower bound as well as the upper bound; the two algorithms behave identically with admissible heuristics, but RBFS expands nodes in best-first order even with an inadmissible heuristic. The idea of keeping track of the best alternative path appeared earlier in Bratko’s (2009) elegant Prolog implementation of A* and in the DTA* algorithm (Russell and Wefald, 1991). The latter work also discusses metalevel state spaces and metalevel learning.",4.1　局部搜索和最优化问题
chap3_para356,1,The MA* algorithm appeared in Chakrabarti et al.,在第3章的搜索问题中，我们希望找到一条通过搜索空间的路径，如一条从Arad到Bucharest的路径。
chap3_para356,2,(1989).,但有时我们只关心最终状态，而不是到达状态的路径。
chap3_para356,3,"SMA*, or Simplified MA*, emerged from an attempt to implement MA* (Russell, 1992).",例如，在8皇后问题中（图4-3），我们只关心如何找到8个皇后的有效最终配置（因为如果知道配置，重构它的创建步骤就非常简单）。
chap3_para356,4,Kaindl and Khorsand (1994) applied SMA* to produce a bidirectional search algorithm that was substantially faster than previous algorithms.,这也适用于许多重要应用，例如集成电路设计、工厂车间布局、作业车间调度、自动编程、电信网络优化、农作物种植规划和投资组合管理。
chap3_para356,5,"Korf and Zhang (2000) describe a divide-and-conquer approach, and Zhou and Hansen (2002) introduce memory-bounded A* graph search and a strategy for switching to breadth-first search to increase memory-efficiency (Zhou and Hansen, 2006).",
chap3_para357,1,"The idea that admissible heuristics can be derived by problem relaxation appears in the seminal paper by Held and Karp (1970), who used the minimum-spanning-tree heuristic to solve the TSP.",局部搜索（local search）算法的操作是从一个起始状态搜索到其相邻状态，它不记录路径，也不记录已达状态集。
chap3_para357,2,(See Exercise 3.,这意味着它们不是系统性的——可能永远不会探索问题的解实际所在的那部分搜索空间。
chap3_para357,3,MSTR.,但是，它们有两个主要优点：（1）使用很少的内存；（2）通常可以在系统性算法不适用的大型或无限状态空间中找到合理的解。
chap3_para357,4,) The automation of the relaxation process was implemented successfully by Prieditis (1993).,
chap3_para357,5,There is a growing literature on the application of machine learning to discover heuristic functions (Samadi et al.,
chap3_para357,6,", 2008; Arfaee et al.",
chap3_para357,7,", 2010; Thayer et al.",
chap3_para357,8,", 2011; Lelis et al.",
chap3_para357,9,", 2012).",
chap3_para358,1,"The use of pattern databases to derive admissible heuristics is due to Gasser (1995) and Culberson and Schaeffer (1996, 1998); disjoint pattern databases are described by Korf and Felner (2002); a similar method using symbolic patterns is due to Edelkamp (2009).",局部搜索算法也可以求解最优化问题（optimization problem），其目标是根据目标函数（objective function）找到最优状态。
chap3_para358,2,Felner et al.,
chap3_para358,3,(2007) show how to compress pattern databases to save space.,
chap3_para358,4,The probabilistic interpretation of heuristics was investigated by Pearl (1984) and Hansson and Mayer (1989).,
chap3_para359,1,"Pearl’s (1984) Heuristics and Edelkamp and Schrödl’s (2012) Heuristic Search are influential textbooks on search. Papers about new search algorithms appear at the International Symposium on Combinatorial Search (SoCS) and the International Conference on Automated Planning and Scheduling (ICAPS), as well as in general AI conferences such as AAAI and IJCAI, and journals such as Artificial Intelligence and Journal of the ACM.",为了理解局部搜索，我们考虑在状态空间地形图（state-space landscape）中布局的问题状态，如图4-1所示。
chap3_para359,2,,地形图中的每个点（状态）都有一个“标高”，由目标函数值定义。
chap3_para359,3,,如果标高对应于目标函数，那么目的就是找到最高峰——全局极大值（global maximum）——我们称这个过程为爬山（hill climbing）；如果标高对应于代价，那么目的就是找到最低谷——全局极小值（global minimum）——我们称之为梯度下降（gradient descent）。
chap3_para36,1,"A grid world problem is a two-dimensional rectangular array of square cells in which agents can move from cell to cell. Typically the agent can move to any obstacle-free adjacent cell—horizontally or vertically and in some problems diagonally. Cells can contain objects, which the agent can pick up, push, or otherwise act upon; a wall or other impassible obstacle in a cell prevents an agent from moving into that cell. The vacuum world from Section 2.1 can be formulated as a grid world problem as follows:",如果我们能够将任何抽象解细化为更详细的世界中的解，那么这种抽象就是合理的；一个充分条件是，对于“in Arad”的每个详细状态，都有一条到达“in Sibiu”状态的详细路径，以此类推。
chap3_para36,2,,[4]如果执行解中的每个动作都比原始问题更容易，那么抽象是有用的；在我们的示例中，“从Arad开车到Sibiu”的动作，任何一个一般水平的司机都可以在不进一步搜索或规划的情况下完成。
chap3_para36,3,,因此，选择一个好的抽象需要删除尽可能多的细节，同时保留合理性，并确保抽象动作易于执行。
chap3_para36,4,,如果没有构造有用的抽象的能力，智能体将被真实世界完全淹没。
chap3_para360,1,1We are assuming that most readers are in the same position and can easily imagine themselves to be as clueless as our agent.,图4-1　一维状态空间地形图，其标高对应于目标函数。
chap3_para360,2,We apologize to Romanian readers who are unable to take advantage of this pedagogical device.,目的是找到全局极大值
chap3_para361,1,2For problems with an infinite number of actions we would need techniques that go beyond this chapter.,4.1.1　爬山搜索
chap3_para362,1,"3In any problem with a cycle of net negative cost, the cost-optimal solution is to go around that cycle an infinite number of times. The Bellman–Ford and Floyd–Warshall algorithms (not covered here) handle negative-cost actions, as long as there are no negative cycles. It is easy to accommodate zero-cost actions, as long as the number of consecutive zero-cost actions is bounded. For example, we might have a robot where there is a cost to move, but zero cost to rotate 90o; the algorithms in this chapter can handle this as long as no more than three consecutive 90o turns are allowed. There is also a complication with problems that have an infinite number of arbitrarily small action costs. Consider a version of Zeno’s paradox where there is an action to move half way to the goal, at a cost of half of the previous move. This problem has no solution with a finite number of actions, but to prevent a search from taking an unbounded number of actions without quite reaching the goal, we can require that all action costs be at least ϵ, for some small positive value ϵ.",爬山搜索算法如图4-2所示。
chap3_para362,2,,它记录当前状态并在每次迭代中移动到值最大的相邻状态，也就是说，它朝最陡上升（steepest ascent）的方向前进。
chap3_para362,3,,当它到达一个没有邻居具有更高值的“峰值”时，算法终止。
chap3_para362,4,,爬山法不会考虑超出当前状态的直接邻居之外的状态。
chap3_para362,5,,这就像是一个健忘的人在大雾中试图找到珠穆朗玛峰的顶峰。
chap3_para362,6,,注意，使用爬山搜索的一种方法是使用启发式代价函数的负值作为目标函数；算法将局部地爬升至到目标的启发式距离最小的状态。
chap3_para363,1,4See Section 11.,图4-2　爬山搜索算法是最基本的局部搜索技术。
chap3_para363,2,4.,在每一步中，当前节点被其最优邻居节点替换
chap3_para364,1,"5Some authors call the frontier the open list, which is both geographically less evocative and computationally less appropriate, because a queue is more efficient than a list here.",我们将使用8皇后问题（图4-3）进一步说明爬山法。
chap3_para364,2,"Those authors use the term closed list to refer to the set of previously expanded nodes, which in our terminology would be the reached nodes minus the frontier.",我们将使用一个完整状态形式化（complete-state formulation），即每个状态都包含解的所有组成部分，但它们可能并不都在正确的位置。
chap3_para364,3,,在这种情况下，每个状态都包括在棋盘上放置8个皇后，每列一个。
chap3_para364,4,,初始状态是随机选择的，状态后继是通过将一个皇后移动到同一列中的另一格所生成的所有可能状态（所以每个状态有8×7 = 56个后继）。
chap3_para364,5,,启发式代价函数h是可相互攻击的皇后对的数量；只有当该状态是一个解时，h值才是0。
chap3_para364,6,,（如果两个皇后在同一条线上，即使它们之间存在一个中间棋子，这两个皇后也会被视为形成相互攻击。
chap3_para364,7,,）图4-3b展示了一个h = 17的状态以及它所有后继的h值。
chap3_para365,1,"6We say “tree-like search” because the state space is still the same graph no matter how we search it; we are just choosing to treat it as if it were a tree, with only one path from each node back to the root.",爬山法有时被称为贪心局部搜索（greedy local search），因为它只是选择最优的邻居状态，而不事先考虑下一步该如何走。
chap3_para365,2,,虽然贪婪被视为七宗罪之一，但事实证明，贪心算法往往相当有效。
chap3_para365,3,,爬山法可以在求解问题时取得快速进展，因为它通常可以很容易地改善一个差的状态。
chap3_para365,4,,例如，只需5步就可以从图4-3b的状态到达图4-3a的状态，该状态的h = 1，与解非常接近。
chap3_para365,5,,遗憾的是，爬山法可能会由于以下原因而陷入困境。
chap3_para366,1,"7Some authors use the term “admissibility” for the property of finding the lowest-cost solution, and some use just “optimality,” but that can be confused with other types of optimality.",● 局部极大值（local maxima）：局部极大值是一个比它每个相邻状态都高但比全局极大值低的峰顶。
chap3_para366,2,,爬山法到达局部极大值附近就会被向上拉向峰顶，但随后将困在局部极大值处无路可走。
chap3_para366,3,,图4-1示意性地说明了这一问题。
chap3_para366,4,,更具体地说，图4-3a中的状态是一个局部极大值（即代价h的局部极小值）；不管移动哪个皇后都会让情况变得更差。
chap3_para367,1,"8Here, and throughout the book, the “star” in C* means an optimal value for C.",图4-3　（a）8皇后问题：在棋盘上放置8个皇后，使得它们不能互相攻击。
chap3_para367,2,,（皇后会攻击同一行、同一列或对角线上的任何棋子。
chap3_para367,3,,）当前状态非常接近于一个解，除了第4列和第7列的两个皇后会沿对角线互相攻击。
chap3_para367,4,,（b）一个8皇后状态，其启发式代价估计值h = 17。
chap3_para367,5,,棋盘显示了通过在同一列移动皇后而获得的每一个可能后继的h值。
chap3_para367,6,,有8个移动并列最优，其h = 12。
chap3_para367,7,,爬山法将选择它们中的一个
chap3_para368,1,"9In our implementation, the reached data structure supports a query asking whether a given state is a member, and the frontier data structure (a priority queue) does not, so we check for a collision using reached; but conceptually we are asking if the two frontiers have met up.",● 岭（ridge）：如图4-4 所示。
chap3_para368,2,The implementation can be extended to handle multiple goal states by loading the node for each goal state into the backwards frontier and backwards reached table.,岭的存在将导致一系列局部极大值，对于贪心算法，这是很难处理的。
chap3_para369,1,"10It may seem odd that the heuristic function operates on a node, when all it really needs is the node’s state. It is traditional to use h(n) rather than h(s) to be consistent with the evaluation function f(n) and the path cost g(n).",图4-4　岭为爬山法带来困难的示意图。
chap3_para369,2,,状态网格（蓝色圆点）叠加在从左到右上升的岭上，形成了一个彼此不直接相连的局部极大值序列。
chap3_para369,3,,从每个局部极大值出发，所有可选动作都指向下坡。
chap3_para369,4,,这样的拓扑在低维状态空间中很常见，例如二维平面中的点。
chap3_para369,5,,但是在具有成百上千个维度的状态空间中，这种直观图并不成立，而且通常至少存在几个维度使得算法有可能漏掉岭和平台区
chap3_para37,1,"•States: A state of the world says which objects are in which cells. For the vacuum world, the objects are the agent and any dirt. In the simple two-cell version, the agent can be in either of the two cells, and each cell can either contain dirt or not, so there are 2 · 2 · 2 = 8 states (see Figure 3.2). In general, a vacuum environment with n cells has n · 2n states.",
chap3_para370,1,"11Again, assuming all action costs are > ϵ > 0, and the state space either has a solution or is finite.",● 平台区（plateau）：平台区是指状态空间地形图中的平坦区域。
chap3_para370,2,,它可能是一块平坦的局部极大值，不存在上坡的出口；也可能是一个山肩（shoulder），从山肩出发还有可能继续前进（参见图4-1）。
chap3_para370,3,,爬山搜索可能会迷失在平台区上。
chap3_para371,1,"12Technically, we say “strictly monotonic” for costs that always increase, and “monotonic” for costs that never decrease, but might remain the same.",在每种情况下，算法都会到达一个无法再取得进展的点。
chap3_para371,2,,从一个随机生成的8皇后状态开始，在86%的情况下，最陡上升爬山法会被卡住，它只能解决14%的问题实例。
chap3_para371,3,,但是，它求解速度很快，成功找到解时平均步数为4，被卡住时平均步数为3，这对一个具有万个状态的状态空间来说不算糟糕。
chap3_para372,1,"13In fact, the term “monotonic heuristic” is a synonym for “consistent heuristic.” The two ideas were developed independently, and then it was proved that they are equivalent (Pearl, 1984).",我们怎么才能求解更多问题？
chap3_para372,2,,一个答案是当我们到达一个平台区时继续前进——允许横向移动（sideways move），希望这个平台区真的是一个山肩，如图4-1所示。
chap3_para372,3,,但如果我们实际上位于一块平坦的局部极大值上，那么算法就会陷入死循环。
chap3_para372,4,,因此，我们可以限制连续横向移动的次数，如在100次连续横向移动之后停止。
chap3_para372,5,,这种方法将爬山法成功求解问题实例的百分比从14%提高到了94%。
chap3_para372,6,,成功是有代价的：平均下来，对每个成功实例算法需要运行约21步，失败实例约64步。
chap3_para373,1,"14In Chapters 8 and 11, we describe formal languages suitable for this task; with formal descriptions that can be manipulated, the construction of relaxed problems can be automated.",爬山法存在很多变体。
chap3_para373,2,"For now, we use English.",随机爬山法（stochastic hill climbing）在上坡行动中随机选择一个；被选中的概率随着上坡陡度的变化而变化。
chap3_para373,3,,这种方法通常比最陡上升法收敛得更慢，但在某些状态地形图中，它能找到更好的解。
chap3_para373,4,,首选爬山法（first-choice hill climbing）通过不断随机地生成后继直到生成一个比当前状态更好的后继为止来实现随机爬山。
chap3_para373,5,,当一个状态存在众多（如数千个）后继时，这是一个很好的策略。
chap3_para374,1,"15By working backward from the goal, the exact solution cost of every instance encountered is immediately available.",另一种变体是随机重启爬山法（random-restart hill climbing），它来自于一句格言：“如果一开始没有成功，那么尝试，再尝试。
chap3_para374,2,"This is an example of dynamic programming, which we discuss further in Chapter 16.",”它从随机生成的初始状态开始，执行一系列爬山搜索，直到找到目标。
chap3_para374,3,,算法完备的概率为1，因为它最终会生成一个目标状态作为初始状态。
chap3_para374,4,,如果每一次爬山搜索成功的概率为p，那么需要重启的期望次数为1 / p。
chap3_para374,5,,对于不允许横向移动的8皇后实例，，所以大概需要7次迭代才能找到一个目标（6次失败，1次成功）。
chap3_para374,6,,所需步数的期望为一次成功迭代的代价加上(1−p)/p倍的失败代价，总共约为22步。
chap3_para374,7,,当允许横向移动时，平均需要次迭代，步。
chap3_para374,8,,因此，对于8皇后问题，随机重启爬山法是非常有效的。
chap3_para374,9,,即使有300万个皇后，这种方法也能在很短的时间内找到解。
chap3_para374,10,,[1]
chap3_para375,1,16Landmark points are sometimes called “pivots” or “anchors.”,
chap3_para376,1,,"[1]　卢比等人（Luby et al., 1993）建议在搜索固定次数之后重启，并表明这比让每次搜索都无限期地继续下去要有效得多。"
chap3_para377,1,,爬山法是否能成功在很大程度上取决于状态空间地形图的形状：如果几乎不存在局部极大值和平台区，那么随机重启爬山法可以很快找到一个好的解。
chap3_para377,2,,但是，许多实际问题的地形图看起来更像是平地上散布着一群秃顶豪猪，每个豪猪的刺上还住着微型豪猪。
chap3_para377,3,,NP困难问题（参见附录 A）通常存在指数级数量的局部极大值。
chap3_para377,4,,尽管如此，在几次重启后，通常也可以找到相当好的局部极大值。
chap3_para378,1,,4.1.2　模拟退火
chap3_para379,1,,从不“下坡”，即从不向值较低（或代价较高）的状态移动的爬山算法总是很容易陷入局部极大值。
chap3_para379,2,,相比之下，纯粹的随机游走算法不考虑状态值，而是随机移动到一个后继状态，它最终能够找到全局极大值，但它的效率非常低。
chap3_para379,3,,因此，尝试将爬山法和随机游走结合起来以同时获得高效性和完备性，似乎是合理的。
chap3_para38,1,•Initial state: Any state can be designated as the initial state.,[4]　参见11.4节。
chap3_para380,1,,模拟退火（simulated annealing）就是这样一种算法。
chap3_para380,2,,在冶金学中，退火（annealing）是一种通过将金属或玻璃加热到高温然后逐渐冷却的方法使材料达到低能量结晶态以进行回火或硬化的过程。
chap3_para380,3,,为了更好地解释模拟退火，我们将关注点从爬山转换为梯度下降（gradient descent）（即，最小化代价），想象这样一项任务，把一个乒乓球放入一个崎岖表面的最深的裂缝中。
chap3_para380,4,,如果只是让球滚动，它会停在一个局部极小值。
chap3_para380,5,,如果晃动平面，乒乓球会从局部极小值中弹出来——也许会弹到更深的局部极小值中，在那里它将耗费更多的时间。
chap3_para380,6,,诀窍是晃动幅度要足够大，以使球从局部极小值中弹出，但又不能太大，以至于从全局极小值中弹出。
chap3_para380,7,,模拟退火就是开始时用力晃动（即高温），然后逐渐降低晃动强度（即降低温度）。
chap3_para381,1,,模拟退火算法的总体结构（图4-5）与爬山法类似。
chap3_para381,2,,然而，它不是选择最佳移动，而是选择随机移动。
chap3_para381,3,,如果该移动使得情况改善，那么它总是会被接受。
chap3_para381,4,,否则，算法以小于1的概率接受该移动。
chap3_para381,5,,概率随着该移动的“坏的程度”——评估值变差的量——呈指数级下降。
chap3_para381,6,,概率也会随“温度”T的降低而减小：开始时T较高，“坏”的移动更有可能被接受，当T降低时，可能性也逐渐降低。
chap3_para381,7,,如果schedule所设置的T降到0的速度足够慢，那么玻尔兹曼分布的一个性质是所有概率都集中在全局极大值上，即算法将以接近1的概率找到全局极大值。
chap3_para382,1,,图4-5　模拟退火算法，一种允许某些下坡移动的随机爬山法。
chap3_para382,2,,输入的schedule是关于时间的函数，它决定了“温度”T的值
chap3_para383,1,,从20世纪80年代开始，模拟退火就被用于求解VLSI布图问题。
chap3_para383,2,,它已广泛应用于工厂调度和其他大规模优化任务。
chap3_para384,1,,4.1.3　局部束搜索
chap3_para385,1,,对于内存限制问题，在内存中只保存一个节点似乎有些极端。
chap3_para385,2,,局部束搜索（local beam search）算法记录k个状态而不是只记录一个。
chap3_para385,3,,它从k个随机生成的状态开始。
chap3_para385,4,,在每一步中，生成全部k个状态的所有后继状态。
chap3_para385,5,,如果其中任意一个是目标状态，那么算法停止。
chap3_para385,6,,否则，它将从完整列表中选择k个最佳后继并重复上述操作。
chap3_para386,1,,从第一印象来看，具有k个状态的局部束搜索似乎只不过是并行（而非串行）地运行k次随机重启。
chap3_para386,2,,事实上，这两种算法是完全不同的。
chap3_para386,3,,在随机重启搜索中，每个搜索进程独立运行。
chap3_para386,4,,而在局部束搜索中，有用信息将在并行的搜索线程之间传递。
chap3_para386,5,,实际上，生成最佳后继的那些状态会对其他状态说：“过来，这里的草更绿！
chap3_para386,6,,”算法将很快放弃那些没有效果的搜索并把资源转移到取得最大进展的路径上。
chap3_para387,1,,如果k个状态之间缺乏多样性，局部束搜索可能会受到影响——k个状态可能聚集在状态空间的一块小区域内，导致搜索只不过是k倍慢版本的爬山法。
chap3_para387,2,,一种被称作随机束搜索（stochastic beam search）的变体可以帮助缓解这个问题，它类似于随机爬山法。
chap3_para387,3,,随机束搜索不是选择最佳的k个后继状态，而是选择概率与它对应的目标函数值成正比的后继状态，从而增加了多样性。
chap3_para388,1,,4.1.4　进化算法
chap3_para389,1,,进化算法（evolutionary algorithm）可以看作随机束搜索的变体，算法的动机明显来自生物学中自然选择的隐喻：一个由个体（状态）组成的种群，其中最适应环境（值最高）的个体可以生成后代（后继状态）来繁衍下一代，这个过程被称为重组（recombination）。
chap3_para389,2,,进化算法存在无数种形式，它们按照以下方式变化。
chap3_para39,1,"•Actions: In the two-cell world we defined three actions: Suck, move Left, and move Right. In a two-dimensional multi-cell world we need more movement actions. We could add Upward and Downward, giving us four absolute movement actions, or we could switch to egocentric actions, defined relative to the viewpoint of the agent—for example, Forward, Backward, TurnRight, and TurnLeft.",
chap3_para391,1,,● 每个个体的表示。
chap3_para391,2,,在遗传算法（genetic algorithm）中，每个个体都是有限字母表上的一个字符串（通常是一个布尔字符串），就像DNA是字母表ACGT上的一个字符串一样。
chap3_para391,3,,在进化策略（evolution strategy）中，个体是实数序列，而在遗传编程（genetic programming）中，个体是计算机程序。
chap3_para392,1,,● 混合数，，是一起形成后代的亲本的数量。
chap3_para392,2,,最常见的情况是：双亲结合它们的“基因”（它们表示的一部分）来形成后代。
chap3_para392,3,,当时，为随机束搜索（可以看作无性繁殖）。
chap3_para392,4,,也是可能的，这在自然界中很少发生，但很容易在计算机上进行模拟。
chap3_para393,1,,● 选择（selection）过程。
chap3_para393,2,,选择将成为下一代亲本的个体：一种可能是从所有个体中选择，被选中的概率与其适应度得分成正比。
chap3_para393,3,,另一种可能是随机选择n个个体（），然后选择最适合的个个体作为亲本。
chap3_para394,1,,● 重组过程。
chap3_para394,2,,一种常见的方法（假设）是随机选择一个杂交点（crossover point）来分割每个父字符串，并将这些部分重新组合以形成两个子串，一个是亲本1的第一部分和亲本2的第二部分的组合；另一个是亲本1的第二部分和亲本2的第一部分的组合。
chap3_para395,1,,● 突变率（mutation rate），它决定了后代在其表示上发生随机突变的频率。
chap3_para395,2,,一旦产生了一个后代，其组成中的每位都将以与突变率相等的概率被翻转。
chap3_para396,1,,● 下一代的构成。
chap3_para396,2,,可能只包括新形成的后代，也可能还包括一些上一代中得分最高的个体［这种做法被称为精英主义（elitism），它确保总体适应度永远不会随着时间的推移而下降］。
chap3_para396,3,,"而淘汰（culling），即丢弃所有分数低于给定阈值的个体，会使得进化加速（Baum et al., 1995）。"
chap3_para397,1,,图4-6a为由4个8位数字符串组成的种群，每个字符串代表8皇后问题的一个状态：第c位数字表示第c列中皇后的行号。
chap3_para397,2,,在图4-6b中，每个状态根据适应度函数进行评级。
chap3_para397,3,,适应度越高越好，所以对于8皇后问题，我们使用非攻击皇后对的数量作为适应度，解的适应度为8×7/2 = 28。
chap3_para397,4,,图4-6b中4个状态的值分别为24、23、20和11。
chap3_para397,5,,然后将适应度得分归一化为概率，结果显示在图4-6b中的适应度旁边。
chap3_para398,1,,图4-6　遗传算法，图示为表示8皇后状态的数字字符串。
chap3_para398,2,,（a）中的初始种群根据（b）中的适应度函数进行排序从而得到（c）中的配对，（d）是产生的后代，（e）是可能发生的突变
chap3_para399,1,,在图4-6c中，根据图4-6b中的概率选出两对父字符串。
chap3_para399,2,,注意，有一个个体被选择了两次，还有一个没有被选择。
chap3_para399,3,,对于每一对被选择的亲本，随机选择一个杂交点（虚线）。
chap3_para399,4,,在图4-6d中，我们在杂交点处交叉两个父串，以生成新的后代。
chap3_para399,5,,例如，第一对亲本中的第一个子串从第一个父串获得前三个数字（327），从第二个父串获得剩余数字（48552）。
chap3_para399,6,,这一重组步骤中所包含的8皇后状态如图4-7所示。
chap3_para4,1,"Problem-solving agents use atomic representations, as described in Section 2.4.7—that is, states of the world are considered as wholes, with no internal structure visible to the problem-solving algorithms. Agents that use factored or structured representations of states are called planning agents and are discussed in Chapters 7 and 11.",我们将在本书中介绍若干搜索算法。
chap3_para4,2,,在本章中，我们将只考虑最简单的环境，即回合式的、单智能体的、完全可观测的、确定性的、静态的、离散的和已知的环境，并对有信息（informed）算法和无信息（uninformed）算法进行区分。
chap3_para4,3,,在有信息算法中，智能体可以估计自己到目标的距离，而在无信息算法中不能进行这样的估计。
chap3_para4,4,,第4章会讨论更一般的环境中的问题，第5章则考虑了多智能体的情形。
chap3_para40,1,"•Transition model: Suck removes any dirt from the agent’s cell; Forward moves the agent ahead one cell in the direction it is facing, unless it hits a wall, in which case the action has no effect. Backward moves the agent in the opposite direction, while TurnRight and TurnLeft change the direction it is facing by 90°.",问题求解的方法已被应用于大量任务环境中。
chap3_para40,2,,我们在这里列出一些典型问题，区分为标准化问题和真实世界问题。
chap3_para40,3,,标准化问题（standardized problem）常用于说明或训练各种问题求解方法。
chap3_para40,4,,它具有简洁、准确的描述，因此适合作为研究人员比较算法性能的基准。
chap3_para40,5,,真实世界问题（real-world problem），如机器人导航，则意味着这一问题的解是人们实际使用的，且问题的形式化是独特的而非标准化的，因为例如在机器人导航问题中，每个机器人具有不同的传感器，产生不同的数据。
chap3_para400,1,,图4-7　对应于图4-6c中前两个亲本和图4-6d中第一个后代的8皇后状态。
chap3_para400,2,,在杂交步中，丢弃绿色列，保留红色列。
chap3_para400,3,,（图4-6中数字的解释：第1行是最下面一行，第8行是最上面一行）
chap3_para401,1,,最后，在图4-6e中，每个字符串中的每个位置都以某个很小的独立概率发生随机突变。
chap3_para401,2,,第一个、第三个和第四个后代的某个位发生了突变。
chap3_para401,3,,在8皇后问题中，这相当于随机选择一个皇后，并将其随机移动到它所在列的某个位置。
chap3_para401,4,,通常情况下，早期的种群是多样化的，所以在搜索过程的早期阶段，杂交常常在状态空间中采取较大的步调（类似于模拟退火）。
chap3_para401,5,,在经过许多代选择提高了适应度后，种群的多样性减少，步调也随之变小。
chap3_para401,6,,图4-8介绍了实现所有这些步骤的算法。
chap3_para402,1,,图4-8　遗传算法。
chap3_para402,2,,在这个函数中，population是种群中个体的有序列表，weights是每个个体所对应的适应度值的列表，而fitness是计算这些值的函数
chap3_para403,1,,遗传算法类似于随机束搜索，但增加了杂交操作。
chap3_para403,2,,如果存在可以执行有用功能的区域，杂交操作是有利的。
chap3_para403,3,,例如，将前3列皇后分别放在第2行、第4行和第6行（在这些位置上它们不会互相攻击），就组成了一个有用的区域，它可以与其他个体中出现的其他有用区域相结合，从而形成一个解。
chap3_para403,4,,数学上可以证明，如果这些区域没有任何用途——例如，如果遗传密码的位置是随机排列的——那么杂交就没有任何优势。
chap3_para404,1,,遗传算法理论用模式（schema）思想来解释它是如何运作的，模式是指其中某些位未确定的子串。
chap3_para404,2,,例如，模式246*****表示前3个皇后分别位于位置2、4和6的所有8皇后状态。
chap3_para404,3,,与该模式相匹配的字符串（例如24613578）称作该模式的实例（instance）。
chap3_para404,4,,可以证明，如果某模式实例的平均适应度高于平均值，那么该模式的实例数量将随着时间推移而不断增加。
chap3_para406,1,,"进化论是由查尔斯·达尔文（Charles Darwin）（Darwin, 1859）和艾尔弗雷德·拉塞尔·华莱士（Alfred Russel Wallace）（Wallace, 1858）各自独立提出的。"
chap3_para406,2,,它的中心思想很简单：变异发生在繁殖过程中，并将在后代中以一定比例保存下来，大概与它们对生殖适应度的影响成比例。
chap3_para407,1,,达尔文在《物种起源》（On the Origin of Species by Means of Natural Selection）中的理论没有解释生物体的特征是如何遗传和改变的。
chap3_para407,2,,"控制这些过程的概率定律由修道士格雷戈尔·孟德尔（Gregor Mendel）（Mendel, 1866）首先发现，他使用豌豆进行了实验。"
chap3_para407,3,,"很久之后，沃森和克里克（Watson and Crick, 1953）确定了DNA分子的结构及其AGTC（腺嘌呤、鸟嘌呤、胸腺嘧啶、胞嘧啶）序列。"
chap3_para407,4,,在标准模型中，基因序列上某点发生突变和“杂交”（后代的DNA通过合成父母双方的DNA长片段产生）都会导致变异。
chap3_para408,1,,进化和局部搜索算法的相似性前文已经介绍过了；随机束搜索和进化的主要区别在于是否为有性生殖，有性生殖中后代是由多个而非单个个体产生的。
chap3_para408,2,,然而，进化的实际机制比大多数遗传算法要丰富得多。
chap3_para408,3,,例如，突变包括DNA的逆转、复制和大段移动；有些病毒会从一个生物体中借用DNA再将其自身插入另一个生物体；还有一些转座基因只是在基因组中把自己复制成千上万次。
chap3_para409,1,,甚至还有一些基因会破坏不携带该基因的可能配对对象的细胞，从而增加它们自身的复制机会。
chap3_para409,2,,最重要的是，基因自身对基因组复制和翻译成生物体的机制进行编码。
chap3_para409,3,,在遗传算法中，这些机制是单独的程序，不体现在被操作的字符串中。
chap3_para41,1,•Goal states: The states in which every cell is clean.,3.2.1　标准化问题
chap3_para410,1,,达尔文进化论可能看起来效率很低，它盲目地产生了大约1043个生物体，却丝毫没有改进它的搜索启发式函数。
chap3_para410,2,,但是学习在进化中确实起着作用。
chap3_para410,3,,"尽管另一位伟大的法国博物学家让·拉马克（Jean Lamarck）（Lamarck, 1809）曾错误地提出，生物体一生中通过适应而获得的特性会遗传给后代，但詹姆斯·鲍德温（James Baldwin）（Baldwin, 1896）提出的表面上相似的理论则是正确的：学习可以有效地放宽适应度要求，从而加快进化速度。"
chap3_para410,4,,如果一个生物体具有一种不太适应环境的特性，但它也具有足够的可塑性，可以学习以一种有益的方式适应环境，那么生物体会将这种特性传递下去。
chap3_para410,5,,"计算机仿真（Hinton and Nowlan, 1987）证实了鲍德温效应（Baldwin effect）是真实存在的，其结果是，难以学习的事情最终会存在于基因组中，而容易学习的事情不必进入基因组（Morgan and Griffiths, 2015）。"
chap3_para411,1,,显然，如果相邻位之间完全不相关，效果就没那么显著，因为几乎不存在功能一致的连续区域。
chap3_para411,2,,当模式对应于解中有意义的组件时，遗传算法效果最优。
chap3_para411,3,,例如，如果字符串表示天线，那么模式则表示天线的各组成部分，如反射器和导向器。
chap3_para411,4,,一个好的组件可能在各种不同的设计中都是好的。
chap3_para411,5,,这表明，遗传算法的成功依赖于精细的表示工程。
chap3_para412,1,,"实际上，遗传算法在广泛的最优化方法中占有一席之地（Marler and Arora, 2004），尤其是复杂结构问题，如电路布图或作业车间调度，以及最近的深度神经网络架构演变（Miikkulainen et al., 2019）。"
chap3_para412,2,,目前还不清楚遗传算法的吸引力是来自于它在特定任务上的性能优势，还是来自于进化本身。
chap3_para413,1,,4.2　连续空间中的局部搜索
chap3_para414,1,,在第2章中，我们解释了离散环境和连续环境之间的区别，并指出大多数的真实世界环境都是连续的。
chap3_para414,2,,连续动作空间的分支因子是无限的，因此我们目前介绍的大多数算法（除了首选爬山法和模拟退火）都无法处理连续空间。
chap3_para415,1,,本节将非常简要地介绍一些连续空间的局部搜索技术。
chap3_para415,2,,关于这个主题的文献有很多。
chap3_para415,3,,许多基本技术起源于牛顿和莱布尼茨发明微积分之后的17世纪。
chap3_para415,4,,[2]本书的一些章节会介绍这些技术的应用，包括学习、视觉和机器人技术相关的章节。
chap3_para417,1,,[2]　向量、矩阵和导数的知识对于学习本节内容很有帮助（见附录A）。
chap3_para418,1,,考虑一个实例。
chap3_para418,2,,假设我们希望在罗马尼亚新建3个机场，使得地图上每个城市到其最近机场的直线距离平方和最小。
chap3_para418,3,,（罗马尼亚地图见图3-1。
chap3_para418,4,,"）状态空间定义为3个机场的坐标：(x1, y1)、(x2, y2)和(x3, y3)。"
chap3_para418,5,,这是一个六维空间；我们也可以说状态由6个变量（variable）定义。
chap3_para418,6,,一般地，状态定义为n 维向量，x。
chap3_para418,7,,在这个空间中移动对应于移动地图上的一个或多个机场。
chap3_para418,8,,"对于任一特定状态，一旦计算出最近城市，目标函数f(x) = f (x1, y1, x2, y2, x3, y3)的计算就会变得相对容易。"
chap3_para418,9,,设Ci是最近机场（在状态x下）为机场 i 的城市集合。
chap3_para418,10,,那么，我们有
chap3_para42,1,•Action cost: Each action costs 1.,网格世界（grid world）问题是一个由正方形单元格组成的二维矩形阵列，在这个阵列中，智能体可以从一个单元格移动到另一个单元格。
chap3_para42,2,,一般来说，智能体可以水平或垂直地移动到任何无障碍的相邻单元格，在某些问题中还可以沿对角线移动。
chap3_para42,3,,单元格中可以包含智能体能拿起、推开或施加其他动作的物体，也可以存在阻止智能体进入单元格内的墙壁或其他不可逾越的障碍。
chap3_para42,4,,2.1节中的真空吸尘器世界（vacuum world）可以表示为一个网格世界问题。
chap3_para420,1,,这一方程不仅对于状态x是正确的，而且对于x局部邻域中的状态也是正确的。
chap3_para420,2,,然而，对全局来说，它是不正确的；如果我们偏离x太远（通过大幅改变一个或多个机场的位置），那么该机场的最近城市集合会发生变化，我们需要重新计算Ci。
chap3_para421,1,,处理连续状态空间的一种方法是离散化（discretize）。
chap3_para421,2,,"例如，我们可以将(xi, yi)的位置限制在矩形网格上间距为的固定点，而不是允许它的位置可以为连续二维空间中的任意点。"
chap3_para421,3,,那么，空间中的每个状态将存在12个后继（对应于将6个变量分别增加），而不是之前的无限多个。
chap3_para421,4,,然后我们就可以对离散空间应用任意局部搜索算法。
chap3_para421,5,,或者，我们可以通过随机采样后继状态，即在随机方向上移动一个小量，使分支因子变为有限值。
chap3_para421,6,,通过两个相邻点之间目标函数值的变化来衡量进度的方法称为经验梯度（empirical gradient）法。
chap3_para421,7,,经验梯度搜索与离散化状态空间中的最陡上升爬山法相同。
chap3_para421,8,,随着时间逐渐减小的值可以得到更准确的解，但不一定在极限范围内收敛到全局最优值。
chap3_para422,1,,通常我们有一个以数学形式表达的目标函数，这样我们就可以用微积分来解析地而非经验地求解问题。
chap3_para422,2,,许多方法都试图利用地形图的梯度（gradient）来找到最大值。
chap3_para422,3,,目标函数的梯度是一个向量∇f，它给出了最陡斜面的长度和方向。
chap3_para422,4,,对于我们的问题，有
chap3_para423,1,,在某些情况下，我们可以通过解∇f = 0方程找到一个极大值。
chap3_para423,2,,（这是可以做到的，例如，如果我们只新建一个机场；问题的解是所有城市坐标的算术平均值。
chap3_para423,3,,）然而，在许多情况下，这个方程不存在闭式解。
chap3_para423,4,,例如，对于3个机场的情况，梯度的表达式依赖于当前状态中哪些城市离各个机场最近。
chap3_para423,5,,这意味着我们只能局部地（而非全局地）计算梯度，例如，
chap3_para425,1,,给定一个局部正确的梯度表达式，我们可以根据下式来更新当前状态从而实现最陡上升爬山法：
chap3_para426,1,,其中是一个很小的常数，通常称为步长（step size）。
chap3_para426,2,,存在很多调整的方法。
chap3_para426,3,,基本问题是，如果太小，需要的迭代步太多；如果太大，搜索可能会越过最大值。
chap3_para426,4,,线搜索（line search）技术试图通过不断延伸当前梯度方向——通常通过对反复加倍——直到f再次开始减小来克服上述困境。
chap3_para426,5,,出现上述现象的点成为新的当前状态。
chap3_para426,6,,在这点上如何选择新的方向，有几种不同的方法。
chap3_para427,1,,对于许多问题，最有效的算法是古老的牛顿-拉弗森法（Newton-Raphson method）。
chap3_para427,2,,这是一种求函数根（即求解g(x) = 0形式的方程）的通用方法。
chap3_para427,3,,它的工作原理是根据牛顿公式计算根x的一个新的估计值：
chap3_para428,1,,要找到f的最大值或最小值，需要找到使得梯度为零向量（即）的x。
chap3_para428,2,,因此，牛顿公式中的g(x)为，更新方程可以写成矩阵-向量形式：
chap3_para429,1,,其中Hf(x)为二阶导数的黑塞矩阵（Hessian matrix），其元素Hij由给出。
chap3_para429,2,,对于上述机场问题实例，从式（4-2）可以看出，Hf(x)相当简单：非对角元素为零，机场i的对角线元素的值恰好为Ci中城市数目的两倍。
chap3_para429,3,,每一时刻的计算表明，每一步更新将机场i直接移动到Ci的质心处，即式（4-1）中f的局部表达式的最小值。
chap3_para429,4,,[3]然而，对于高维问题，计算黑塞矩阵的n2个元素以及对它求逆的开销可能非常昂贵，因此产生了许多牛顿-拉弗森法的近似版本。
chap3_para43,1,Description A square labeled Start state has three rows and three columns.,● 状态：即哪些对象在哪些单元格中。
chap3_para43,2,"Row 1: Column 1, 7.",在真空吸尘器世界中，对象就是智能体和灰尘。
chap3_para43,3,"Column 2, 2.",对于只有两个单元格的简单情形，智能体可以位于这两个单元格中的任何一个，每个单元格都可能存在灰尘，所以共有2×2×2 = 8个状态（见图3-2）。
chap3_para43,4,"Column 3, 4.",一般来说，存在n个单元格的真空吸尘器环境有n×2n 个状态。
chap3_para43,5,"Row 2: Column 1, 5.",
chap3_para43,6,"Column 2, blank.",
chap3_para43,7,"Column 3, 6.",
chap3_para43,8,"Row 3: Column 1, 8.",
chap3_para43,9,"Column 2, 3.",
chap3_para43,10,"Column 3, 1.",
chap3_para43,11,Another square labeled Goal state has three rows and three columns.,
chap3_para43,12,"Row 1: Column 1, blank.",
chap3_para43,13,"Column 2, 1.",
chap3_para43,14,"Column 3, 2.",
chap3_para43,15,"Row 2: Column 1, 3.",
chap3_para43,16,"Column 2, 4.",
chap3_para43,17,"Column 3, 5.",
chap3_para43,18,"Row 3: Column 1, 6.",
chap3_para43,19,"Column 2, 7.",
chap3_para43,20,"Column 3, 8.",
chap3_para431,1,,[3]　一般来说，牛顿-拉弗森更新可以看作在x处用一个二次曲面拟合f，下一步则直接移动到该曲面的最小值——如果f是二次的，则也是f的最小值。
chap3_para432,1,,局部搜索方法在连续状态空间和离散状态空间中一样，同样受到局部极大值、岭和平台区的影响。
chap3_para432,2,,随机重启和模拟退火通常很有用。
chap3_para432,3,,然而，高维连续空间非常大，算法很容易陷入困境。
chap3_para433,1,,最后一个话题是约束优化（constrained optimization）。
chap3_para433,2,,如果一个优化问题的解必须满足对变量值的一些硬性约束，那么这个问题就是受约束的。
chap3_para433,3,,例如，在机场选址问题中，我们可能会将选址限制在罗马尼亚境内的陆地上（而不是某个湖中心）。
chap3_para433,4,,约束优化问题的难度取决于约束和目标函数的性质。
chap3_para433,5,,最著名的一类问题是线性规划（linear programming）问题，其约束必须是能构成凸集的线性不等式[4]，目标函数也必须是线性的。
chap3_para433,6,,线性规划的时间复杂性是关于变量数目的多项式。
chap3_para435,1,,[4]　如果点集S中任意两点的连线也包含在S中，则称S是凸的。
chap3_para435,2,,凸函数（convex function）是指其上方空间构成凸集的函数；根据定义，凸函数没有局部（相对于全局）极小值。
chap3_para436,1,,线性规划可能是最广泛研究和最有用的优化方法。
chap3_para436,2,,它是更一般的凸优化（convex optimization）问题的一种特例，允许约束区域为任意凸区域，目标函数为约束区域内的任意凸函数。
chap3_para436,3,,在一定条件下，凸优化问题也是多项式时间内可解的，即使有上千个变量，也可能是实际可行的。
chap3_para436,4,,机器学习和控制理论中的几个重要问题可以形式化为凸优化问题（见第20章）。
chap3_para437,1,,4.3　使用非确定性动作的搜索
chap3_para438,1,,在第3章中，我们假设环境为完全可观测的、确定性的、已知的。
chap3_para438,2,,因此，智能体可以观测到初始状态，计算出可以到达目标的动作序列，然后“闭着眼睛”执行这些动作，而不需要使用自己的感知。
chap3_para439,1,,然而，当环境部分可观测时，智能体并不确定它处于什么状态；当环境是非确定性的时，智能体不知道在执行某个动作后将转移到什么状态。
chap3_para439,2,,这意味着智能体所思考的不再是“我现在位于s1状态，如果我执行a动作，我将会进入s2状态”，而是“我现在位于s1或s3状态，如果我执行a动作，我将会进入s2、s4或s5状态”。
chap3_para439,3,,我们把智能体认为其可能位于的物理状态集合称为信念状态（belief state）。
chap3_para44,1,Figure 3.,● 初始状态：任一状态都可以被指定为初始状态。
chap3_para44,2,2 The state-space graph for the two-cell vacuum world.,
chap3_para44,3,"There are 8 states and three actions for each state: L = Left, R = Right, S = Suck.",
chap3_para440,1,,在部分可观测的和非确定性的环境中，问题的解不再是一个序列，而是一个条件规划（conditional plan）（有时也称为应变规划或策略），条件规划根据智能体在执行规划时接收到的感知来指定动作。
chap3_para440,2,,本节先讨论非确定性，部分可观测性留待4.4节讨论。
chap3_para441,1,,4.3.1　不稳定的真空吸尘器世界
chap3_para442,1,,如图4-9所示，第2章中的真空吸尘器世界具有8种状态。
chap3_para442,2,,有3种动作——向左Left、向右Right和吸尘Suck，目标是清理所有的灰尘（状态7和8）。
chap3_para442,3,,如果环境是完全可观测的、确定性的和完全已知的，那么使用第3章的任意算法都很容易求解这个问题，它的解是一个动作序列。
chap3_para442,4,,"例如，如果初始状态是1，那么动作序列[Suck, Right, Suck]可以到达目标状态8。"
chap3_para443,1,,图4-9　真空吸尘器世界的8种可能状态；状态7和8是目标状态
chap3_para444,1,,现在假设我们以一个功能强大但不稳定的真空吸尘器的形式引入非确定性。
chap3_para444,2,,在不稳定的真空吸尘器世界中，Suck的工作原理如下。
chap3_para445,1,,● 在一个脏的方格中，Suck会清理这一方格，有时也会清理它的相邻方格。
chap3_para446,1,,● 在一个干净方格中，Suck有时反而会把灰尘弄到地面上。
chap3_para446,2,,[5]
chap3_para448,1,,[5]　我们假设大多数读者都会遇到类似的问题，并且会共情我们的智能体。
chap3_para448,2,,我们向那些拥有现代化高效清洁设备从而无法利用这一教学设计的读者道歉。
chap3_para449,1,,为了更准确地形式化这一问题，我们需要推广第3章的转移模型概念。
chap3_para449,2,,我们不使用返回单个结果状态的Result函数来定义转移模型，而是使用返回一组可能的结果状态的新的Result函数。
chap3_para449,3,,例如，在不稳定的真空吸尘器世界中，状态1中的Suck动作要么只清理当前位置，要么同时清理两个位置：
chap3_para45,1,"Another type of grid world is the sokoban puzzle, in which the agent’s goal is to push a number of boxes, scattered about the grid, to designated storage locations. There can be at most one box per cell. When an agent moves forward into a cell containing a box and there is an empty cell on the other side of the box, then both the box and the agent move forward.",● 动作：在只有两个单元格的情形中，我们可以定义3种动作，即吸尘（Suck）、向左（Left）移动和向右（Right）移动。
chap3_para45,2,,在二维多单元格世界中，我们则需要更多种移动动作。
chap3_para45,3,,我们可以增加向上（Upward）和向下（Downward）的动作，从而得到4种绝对的（absolute）移动动作，或者可以将其转换为以自我为中心的动作，即从相对于智能体的角度来定义，例如，向前（Forward）、向后（Backward）、右转（TurnRight）和左转（TurnLeft）。
chap3_para450,1,,如果我们是从状态1开始，那么没有任何一个单独的动作序列能够求解问题，因此我们需要如下的条件规划：
chap3_para452,1,,我们看到，条件规划可以包含if–then–else步骤；这意味着解是树而不是序列。
chap3_para452,2,,这里的if语句中的条件用来测试当前状态；这是智能体在运行时能够观测到的，但规划时还不知道。
chap3_para452,3,,或者，我们也可以用公式来测试感知而不是状态。
chap3_para452,4,,真实物理世界中的许多问题都是应变问题，因为不可能对未来进行准确预测。
chap3_para452,5,,因此，许多人在走路时都会睁着眼睛。
chap3_para453,1,,4.3.2　与或搜索树
chap3_para454,1,,我们如何得到这些非确定性问题的条件解？
chap3_para454,2,,和第3章一样，我们首先从构造搜索树开始，但是这里的树有一个不同的特性。
chap3_para454,3,,在确定性环境中，分支是由智能体在每个状态下自己的选择引入的：我可以执行这个动作或那个动作。
chap3_para454,4,,我们称这些节点为或节点（OR node）。
chap3_para454,5,,例如，在真空吸尘器世界中，智能体在或节点上选择Left、Right或Suck。
chap3_para454,6,,而在非确定性环境中，环境对每个动作的结果的选择也会引入分支。
chap3_para454,7,,我们称这些节点为与节点（AND node）。
chap3_para454,8,,"例如，状态1中的Suck动作会产生信念状态{5,7}，因此智能体需要为状态5与状态7分别找到一个规划。"
chap3_para454,9,,这两种节点交替出现，形成如图4-10所示的与或树（AND–OR tree）。
chap3_para455,1,,图4-10　不稳定的真空吸尘器世界搜索树的前两层。
chap3_para455,2,,状态节点是必须选择某个动作的或节点。
chap3_para455,3,,与节点（用圆圈表示）上的每个结果都必须处理，结果分支间用弧线连接。
chap3_para455,4,,找到的解用粗线标识
chap3_para456,1,,与或搜索问题的解是完整搜索树的一棵子树：（1）每个叶子都是一个目标节点，（2）在每个或节点上选择一个动作，（3）每个与节点包括所有结果分支。
chap3_para456,2,,解在图中用粗线标识；对应于式（4-3）中的规划。
chap3_para457,1,,图4-11给出了与或图搜索的深度优先递归算法。
chap3_para457,2,,该算法的一个关键是它处理环的方法，环经常出现在非确定性问题中（例如，动作有时不起作用，或者一个意外的影响被纠正）。
chap3_para457,3,,如果当前状态与从根到它的路径上的某个状态相同，就返回失败。
chap3_para457,4,,这并不意味着从当前状态出发没有解；这仅仅意味着，如果存在一个非循环解，那么它肯定可以从当前状态的早期镜像到达，因此可以丢弃新的镜像。
chap3_para457,5,,有了这一检查，可以确保算法在任何有限状态空间中都能终止，因为每条路径都必定到达一个目标、一个死胡同或一个重复状态。
chap3_para457,6,,注意，该算法并不检查当前状态是否是从根出发的其他路径上的某个状态的重复状态，这一点对效率来说很重要。
chap3_para458,1,,图4-11　非确定性环境生成的与或图的搜索算法。
chap3_para458,2,,解是一个条件规划，它考虑每一个非确定性的结果，并为每个结果制定规划
chap3_para459,1,,与或图也可以使用广度优先或最佳优先的方式进行探索。
chap3_para459,2,,我们必须修改启发式函数的概念，即估计一个条件解而不是一个序列的代价，但可容许性的概念可以继续保留，而且存在类似的用于寻找最优解的A*算法（参见本章末尾的参考文献与历史注释）。
chap3_para46,1,"The agent can’t push a box into another box or a wall. For a world with n non-obstacle cells and b boxes, there are n × n!/(b!(n – b)!) states; for example on an 8 × 8 grid with a dozen boxes, there are over 200 trillion states.",● 转移模型：Suck将去除单元格内的任何灰尘；Forward将智能体朝它所面对的方向向前移动一个单元格，除非它撞到墙（在这种情况下，这个行动不起作用）。
chap3_para46,2,,Backward让智能体朝相反的方向移动一个单元格，而TurnRight和TurnLeft则将智能体的朝向旋转90°。
chap3_para460,1,,4.3.3　反复尝试
chap3_para461,1,,考虑一个光滑的真空吸尘器世界，它与普通的（稳定的）真空吸尘器世界基本相同，但移动操作有时会失效，使得智能体停在原地。
chap3_para461,2,,"例如，在状态1中执行Right将产生信念状态{1,2}。"
chap3_para461,3,,图4-12为部分搜索图；显然，从状态1出发不存在非循环解，And-Or-Search将返回失败。
chap3_para461,4,,然而，存在一个循环解（cyclic solution），即反复尝试Right动作，直到它生效。
chap3_para461,5,,我们可以用一个新的while结构来表示上述过程：
chap3_para462,1,,或者用标签（label）表示规划的某一部分，之后可以引用这个标签：
chap3_para463,1,,什么时候可以考虑将循环规划作为解？
chap3_para463,2,,最小条件是每个叶节点都是一个目标状态，并且叶节点可以从规划中的任意点到达。
chap3_para463,3,,除此之外，我们还要考虑造成非确定性的原因。
chap3_para463,4,,如果情况确实是，真空吸尘器机器人的驱动机制在某些时间工作，但在其他时间真空吸尘器会发生随机、独立地滑动，那么智能体可以保证，如果动作重复足够多次，最终总会生效，规划也会成功。
chap3_para463,5,,但是，如果这种非确定性来自机器人或环境的一些尚未观测到的原因（例如，传动带断了，那么机器人将永远不会移动），重复这个动作也没有用。
chap3_para464,1,,为了便于理解，我们可以认为，它是将初始问题形式（完全可观测的，非确定性的）转化为另一种形式（部分可观测的，确定性的），其中循环规划的失败正是由于传动带的某个不可观测的特性。
chap3_para464,2,,在第12章中，我们将讨论如何判断几种不确定可能性中哪个可能性更大。
chap3_para465,1,,图4-12　光滑的真空吸尘器世界的部分搜索图，（一些）循环已经明确地标出。
chap3_para465,2,,这个问题的所有解都是循环规划，因为真空吸尘器无法稳定地移动
chap3_para466,1,,4.4　部分可观测环境中的搜索
chap3_para467,1,,现在我们考虑部分可观测性问题，即智能体的感知不足以确定准确的状态。
chap3_para467,2,,这意味着，智能体的一些动作将致力于减少当前状态的不确定性。
chap3_para468,1,,4.4.1　无观测信息的搜索
chap3_para469,1,,当智能体的感知根本不提供任何信息时，问题就变成了无传感器（sensorless）问题，或称一致性（conformant）问题。
chap3_para469,2,,起初，你可能会认为，如果无传感器智能体不知道起始状态，那它就无法求解问题，但出人意料的是，无传感器解非常普遍且有用，主要是因为它们不依赖于传感器是否正常工作。
chap3_para469,3,,例如，在制造系统中，已经开发出许多巧妙的方法，通过使用一系列行动而无须任何感知，从未知初始位置正确定位零件。
chap3_para469,4,,有时，即使存在可感知的条件规划，无传感器规划也会更好。
chap3_para469,5,,例如，医生通常会开一种广谱抗生素，而不是使用条件规划：先验血，接着等待结果，然后再开一种更具体的抗生素。
chap3_para469,6,,这种无传感器规划节省了时间和金钱，并且避免了在检测结果出来之前感染恶化的风险。
chap3_para47,1,"In a sliding-tile puzzle, a number of tiles (sometimes called blocks or pieces) are arranged in a grid with one or more blank spaces so that some of the tiles can slide into the blank space. One variant is the Rush Hour puzzle, in which cars and trucks slide around a 6 × 6 grid in an attempt to free a car from the traffic jam. Perhaps the best-known variant is the 8-puzzle (see Figure 3.3), which consists of a 3 × 3 grid with eight numbered tiles and one blank space, and the 15-puzzle on a 4 × 4 grid. The object is to reach a specified goal state, such as the one shown on the right of the figure. The standard formulation of the 8 puzzle is as follows:",● 目标状态： 每个单元格都保持干净的状态。
chap3_para470,1,,考虑一个（确定性）真空吸尘器世界的无传感器版本。
chap3_para470,2,,假设智能体知道它所在世界的地理环境，但不知道它自己的位置和灰尘的分布。
chap3_para470,3,,"在这种情况下，它的初始信念状态为{1, 2, 3, 4, 5, 6, 7, 8}（见图4-9）。"
chap3_para470,4,,"现在，如果智能体执行Right动作，它将位于{2, 4, 6, 8}中的某个状态——智能体在没有感知的情况下获得了信息！"
chap3_para470,5,,"执行[Right, Suck]之后，智能体将总是位于{4, 8}中的某个状态。"
chap3_para470,6,,"最终，无论初始状态是什么，执行[Right, Suck, Left, Suck]之后，智能体必定会到达目标状态7。"
chap3_para470,7,,我们称，智能体可以强迫（coerce）世界到达状态7。
chap3_para471,1,,无传感器问题的解是一个动作序列，而不是条件规划（因为它没有感知）。
chap3_para471,2,,但是，我们是在信念状态空间而非物理状态空间中进行搜索。
chap3_para471,3,,[6]在信念状态空间中，问题是完全可观测的，因为智能体始终知道自己的信念状态。
chap3_para471,4,,此外，无传感器问题的解（如果有的话）始终是一个动作序列。
chap3_para471,5,,这是因为，正如第3章的原始问题一样，每个动作后接收到的感知是完全可预测的——它们总是空的！
chap3_para471,6,,所以不存在需要规划的偶发事件。
chap3_para471,7,,即使环境是非确定性的，这也是正确的。
chap3_para473,1,,[6]　在完全可观测的环境中，每个信念状态只包含一个物理状态。
chap3_para473,2,,因此，我们可以将第3章的算法看作在信念状态为单元素的信念状态空间中搜索。
chap3_para474,1,,我们可以为无传感器搜索问题介绍新的算法。
chap3_para474,2,,但是，如果我们将底层物理问题转化为信念状态问题，我们就可以使用第3章中现有的算法，即，对信念状态而非物理状态进行搜索。
chap3_para474,3,,原问题P，由ActionsP、ResultP等组成，信念状态问题则包括以下部分。
chap3_para475,1,,● 状态：信念状态空间包含物理状态的每一个可能子集。
chap3_para475,2,,如果原问题P有N个状态，那么信念状态问题有2N个信念状态，尽管有很多状态都无法从初始状态到达。
chap3_para476,1,,● 初始状态：通常，初始信念状态包含P中的所有状态，尽管在某些情况下，智能体具有更多的先验知识。
chap3_para477,1,,● 动作：这部分有点棘手。
chap3_para477,2,,假设智能体位于信念状态，但是；那么智能体就无法确定哪些动作是合法的。
chap3_para477,3,,如果我们假定非法动作不会对环境产生影响，那么执行当前信念状态b下的任意物理状态的所有动作的并集都是安全的。
chap3_para478,1,,但是，如果非法动作可能导致严重后果，那么只允许执行动作的交集（对所有状态都合法的动作的集合）更安全。
chap3_para478,2,,对于真空吸尘器世界，每个状态都具有相同的合法动作，所以两种方法将给出相同的结果。
chap3_para479,1,,● 转移模型：对于确定性动作，对于每个当前可能状态，新的信念状态中都存在一个如下结果状态（尽管一些结果状态可能是相同的）。
chap3_para48,1,Description Two squares with a common vertical side represent a state.,● 动作代价： 每个动作的代价都是1。
chap3_para48,2,Each square represents a cell.,
chap3_para48,3,Eight states are arranged in three rows.,
chap3_para48,4,"Th top row contains two states, the middle row contains four states, and the bottom row contains two states.",
chap3_para48,5,The first state of the top row has a vacuum cleaner and dirt in the left cell and dirt in the right cell.,
chap3_para48,6,The second state of the top row has dirt in the left cell and a vacuum cleaner and dirt in the right cell.,
chap3_para48,7,An arrow labeled L from the left cell of the first state loops back to the same cell.,
chap3_para48,8,An arrow labeled R from the right cell of the first state points to the left cell of the second state.,
chap3_para48,9,An arrow labeled L from the left cell of the second state points to the right cell of the first state.,
chap3_para48,10,An arrow labeled R from the right cell of the second state loops back to the same cell.,
chap3_para48,11,An arrow labeled S from the first state in the top row points to the first state in the middle row.,
chap3_para48,12,The first state in the middle row has a vacuum cleaner in the left cell and dirt in the right cell.,
chap3_para48,13,An arrow labeled L from the left cell of the first state loops back to the same cell.,
chap3_para48,14,An arrow labeled S from the left cell of the first state points to the right cell of the same state.,
chap3_para48,15,The second state in the middle row has an empty left cell and a vacuum cleaner and dirt in the right cell.,
chap3_para48,16,An arrow labeled R from the right cell of the second state loops back to the same cell.,
chap3_para48,17,An arrow labeled R from the right cell of the first state points to the left cell of the second state.,
chap3_para48,18,An arrow labeled L from the left cell of the second state points to the right cell of the first state.,
chap3_para48,19,The third state in the middle row has a vacuum cleaner and dirt in the left cell and an empty right cell.,
chap3_para48,20,An arrow labeled L from the left cell of the third state loops back to the same cell.,
chap3_para48,21,The fourth state in the middle row has dirt in the left cell and a vacuum cleaner in the right cell.,
chap3_para48,22,An arrow labeled R from the right cell of the fourth state loops back to the same cell.,
chap3_para48,23,An arrow labeled S from the left cell of the fourth state points to the right cell of the same state.,
chap3_para48,24,An arrow labeled R from the right cell of the third state points to the left cell of the fourth state.,
chap3_para48,25,An arrow labeled L from the left cell of the fourth state points to the right cell of the third state.,
chap3_para48,26,An arrow labeled S from the second state in the top row points to the fourth state in the middle row.,
chap3_para48,27,An arrow from the third state in the middle row points to the first state of the bottom row.,
chap3_para48,28,The first state on the bottom row has a vacuum cleaner in the left cell and an empty right cell.,
chap3_para48,29,An arrow labeled L from the left cell of the first state loops back to the same cell.,
chap3_para48,30,An arrow labeled S from the left cell of the first state points to the right cell of the same state.,
chap3_para48,31,The second state in the bottom row has an empty left cell and a vacuum cleaner in the right cell.,
chap3_para48,32,An arrow labeled R from the right cell of the second state loops back to the same cell.,
chap3_para48,33,An arrow labeled S from the left cell of the second state points to the right cell of the same state.,
chap3_para48,34,An arrow labeled R from the right cell of the first state points to the left cell of the second state.,
chap3_para48,35,An arrow labeled L from the left cell of the second state points to the right cell of the first state.,
chap3_para48,36,An arrow labeled S from the second state in the middle row points to the second state in the third row.,
chap3_para481,1,,对于非确定性动作，新的信念状态则包含了将该动作应用于当前信念状态中的任一状态的所有可能结果。
chap3_para482,1,,对于确定性动作，b'不会大于b，而对于非确定性动作，b'可能会大于b（见图4-13）。
chap3_para483,1,,图4-13　（a）预测在无传感器真空吸尘器世界执行确定性动作Right后的下一个信念状态；（b）在光滑的无传感器真空吸尘器世界中的同一状态下执行同一动作的预测
chap3_para484,1,,● 目标测试：如果信念状态中的任一状态s满足底层问题的目标测试，Is-GoalP(s)，则智能体有可能到达了目标。
chap3_para484,2,,如果所有状态都满足Is-GoalP(s)，则智能体必定到达了目标。
chap3_para484,3,,我们的目标是使得智能体必定到达了目标。
chap3_para485,1,,● 路径代价：这部分也很棘手。
chap3_para485,2,,如果同一动作在不同状态下代价不同，那么在给定信念状态下执行动作的代价是几种不同值中的一种。
chap3_para485,3,,（这导致了一类新的问题，我们将在习题4.MVAL中讨论。
chap3_para485,4,,）现在我们假定同一动作在所有状态下具有相同代价，因此动作代价可以直接从底层物理问题中转换。
chap3_para486,1,,图4-14为确定性无传感器真空吸尘器世界的可达信念状态空间。
chap3_para486,2,,在28 = 256种可能信念状态中只有12种可以到达。
chap3_para487,1,,图4-14　确定性无传感器真空吸尘器世界的信念状态空间的可达部分。
chap3_para487,2,,每个矩形框对应一个信念状态。
chap3_para487,3,,在任何给定点，智能体都有一个信念状态，但它不知道自己位于哪个物理状态。
chap3_para487,4,,初始信念状态（完全未知）位于最上面的中间方框
chap3_para488,1,,上述定义确保信念状态问题的形式化能够从底层物理问题的定义自动构建。
chap3_para488,2,,一旦完成，就可以用第3章的任何普通搜索算法求解无传感器问题。
chap3_para489,1,,在一般的图搜索中，需要检测新到达的状态之前是否已经到达过。
chap3_para489,2,,"这也适用于信念状态；例如，在图4-14中，动作序列[Suck, Left, Suck]从初始状态出发，到达与序列[Right, Left, Suck]相同的信念状态，即，{5, 7}。"
chap3_para489,3,,"现在，考虑[Left]到达的信念状态，{1, 3, 5, 7}。"
chap3_para489,4,,"显然，这与{5, 7}不同，但它是{5, 7}的超集。"
chap3_para489,5,,我们可以抛弃（剪枝）任何一个这样的信念状态超集。
chap3_para489,6,,为什么？
chap3_para489,7,,"因为从{1, 3, 5, 7}出发的解一定也是任何单一状态1、3、5和7的解，因此，它也是这些单一状态任意组合的解，例如{5, 7}；因此我们没有必要试着求解{1, 3, 5, 7}，可以专注于求解更严格简单的信念状态{5, 7}。"
chap3_para49,1,Figure 3.,图3-2　两个单元格的真空吸尘器世界的状态空间图。
chap3_para49,2,3 A typical instance of the 8-puzzle.,共有8个状态，每个状态有3种动作：L = Left（向左）、R = Right（向右）、S = Suck（吸尘）
chap3_para490,1,,"反过来，如果已经生成{1, 3, 5, 7}，并且发现它是可解的，那么它的任何子集，如{5, 7}，可以确保也是可解的。"
chap3_para490,2,,（如果我有一个解，它在我对自己处于何种状态“非常困惑”时都是有效的，那么在我“不那么困惑”时它仍然是有效的。
chap3_para490,3,,）这种额外剪枝可能会显著提高无传感器问题的求解效率。
chap3_para491,1,,然而，即使有这样的改进，我们所介绍的无传感器问题求解方法在实践中也几乎是不可行的。
chap3_para491,2,,一个问题是信念状态空间非常庞大——我们在第3章中看到过，一个大小为N的搜索空间已经过于庞大，而现在我们搜索空间的大小为2N。
chap3_para491,3,,此外，搜索空间中的每个元素都是一个不超过N个元素的集合。
chap3_para491,4,,对于较大的N，内存空间甚至不足以表示单个的信念状态。
chap3_para492,1,,一种解决方案是用更紧凑的描述来表示信念状态。
chap3_para492,2,,例如，在英语中，我们可以用“Nothing”表示初始状态；我们可以用“Not in the rightmost column”表示执行Left动作后的信念状态，等等。
chap3_para492,3,,第7章介绍了如何在形式化表示模式中实现上述表示。
chap3_para493,1,,另一种方法是避免使用标准搜索算法，它们将信念状态看作和任何其他问题状态一样的黑盒。
chap3_para493,2,,然而，我们可以选择查看信念状态内部，并设计增量信念状态搜索（incremental belief-state search）算法，即，每次只为一个物理状态建立解。
chap3_para493,3,,"例如，在无传感器真空吸尘器世界中，初始信念状态为{1, 2, 3, 4, 5, 6, 7, 8}，我们必须找到一个在所有8种状态下都有效的动作序列。"
chap3_para493,4,,我们可以先找到状态1的解；然后检查它对于状态2是否有效；如果无效，则回溯寻找状态1的另一个解，以此类推。
chap3_para494,1,,正如与或搜索必须为与节点上的每个分支找到解一样，这一算法也必须为信念状态下的每个物理状态找到解；区别在于与或搜索可以为每个分支找到不同的解，而增量信念状态搜索必须找到一个对所有状态都有效的解。
chap3_para495,1,,增量方法的主要优点是，它通常能够快速检测出失败——当一个信念状态无解时，通常情况下，它的子集（包含最先检测的几个状态）也是无解的。
chap3_para495,2,,在某些情况下，这将导致与信念状态规模成正比的加速，信念状态本身可能就和物理状态空间一样大。
chap3_para496,1,,4.4.2　部分可观测环境中的搜索
chap3_para497,1,,对许多问题来说，没有感知就无法求解。
chap3_para497,2,,例如，求解无传感器8数码问题是不可能的。
chap3_para497,3,,但是，一点点感知可能就有很大帮助：如果我们能够看到左上角的方格，就能求解8数码问题。
chap3_para497,4,,解包括依次将每个滑片移动到可观测的方格中，并从那时起记录该滑片的位置。
chap3_para498,1,,对于部分可观测问题，问题形式化将定义一个Percept(s)函数，它返回智能体在给定状态下接收到的感知。
chap3_para498,2,,如果感知是非确定性的，那么我们可以使用Percepts函数返回可能感知的集合。
chap3_para498,3,,对于完全可观测问题，每个状态s下，Percept(s) = s，对于无传感器问题，Percept(s)= null。
chap3_para499,1,,考虑一个局部感知真空吸尘器世界，智能体拥有一个位置传感器（在左侧方格中生成感知L，右侧方格中生成感知R）和一个灰尘传感器（当前方格内有灰尘时生成感知Dirty，否则生成Clean）。
chap3_para499,2,,"因此，状态1的Percept为[L, Dirty]。"
chap3_para499,3,,"对于部分可观测的情况，通常会存在几个状态产生相同感知的情况；状态3也会产生[L, Dirty]。"
chap3_para499,4,,"因此，给定这一初始感知，初始信念状态将为{1,3}。"
chap3_para499,5,,我们可以将部分可观测问题信念状态之间的转移模型分为3个阶段，如图4-15所示。
chap3_para5,1,We will cover several search algorithms.,本章使用了渐近复杂性的概念（即O(n)表示法）。
chap3_para5,2,"In this chapter, we consider only the simplest environments: episodic, single agent, fully observable, deterministic, static, discrete, and known.",不熟悉这些概念的读者可以参阅附录A。
chap3_para5,3,"We distinguish between informed algorithms, in which the agent can estimate how far it is from the goal, and uninformed algorithms, where no such estimate is available.",
chap3_para5,4,"Chapter 4 relaxes the constraints on environments, and Chapter 6 considers multiple agents.",
chap3_para50,1,•States: A state description specifies the location of each of the tiles.,另一种类型的网格世界是推箱子问题（sokoban puzzle），在这个问题中，智能体的目标是将一些散落在网格中的箱子推到指定的存储位置。
chap3_para50,2,,每个单元格最多容纳一个箱子。
chap3_para50,3,,当智能体向前移动到放有一个箱子的单元格，而箱子另一侧的单元格为空时，箱子和智能体都向前移动一格。
chap3_para50,4,,智能体不能把一个箱子推到另一个箱子上或墙上。
chap3_para50,5,,对于存在n个无障碍单元格和b个箱子的世界，共有个状态；例如，在一个存在12个箱子的8×8网格中，有超过200万亿个状态。
chap3_para500,1,,"● 预测（prediction）阶段与无传感器问题相同，计算由动作所导致的信念状态，Result(b, a)。"
chap3_para500,2,,"为了强调这是一个预测，我们将其记为bˆ = Result(b, a)，其中b上方的“hat”表示“估计值”，我们还可以使用Predict(b, a)代替Result(b, a)。"
chap3_para501,1,,● 可能感知（possible percept）阶段计算在预测的信念状态下可以观测到的感知集合（用字母o表示观测到的感知）：
chap3_para502,1,,● 更新（update）阶段为每个可能感知计算其可能得到的信念状态。
chap3_para502,2,,更新后的信念状态bo是bˆ中可能产生这一感知的状态集合：
chap3_para503,1,,● 智能体需要在规划阶段处理可能的感知，因为在执行规划之前它不知道实际的感知。
chap3_para503,2,,注意，在预测阶段，物理环境中的非确定性会扩大信念状态，但每个更新后的信念状态bo不会大于预测的信念状态bˆ；观测到的感知只能帮助减少不确定性。
chap3_para503,3,,此外，对于确定性感知，不同感知的信念状态是不相交的，从而形成原始预测信念状态的一个划分。
chap3_para504,1,,图4-15　局部感知真空吸尘器世界中的两个转移实例。
chap3_para504,2,,"（a）确定性世界中，在初始信念状态下执行Right动作，所得到的新的预测信念状态有两个可能的物理状态；对于这些状态，可能的感知是[R, Dirty]和[R, Clean]，从而得到两种信念状态，每种都只包含一个物理状态。"
chap3_para504,3,,"（b）光滑世界中，在初始信念状态下执行Right动作，所得到的新的信念状态具有4个物理状态；对于这些状态，可能的感知是[L, Dirty]、[R, Dirty]和[R, Clean]，从而得到图中所示的3种信念状态"
chap3_para505,1,,综合这3个阶段，我们可以得到由给定动作及后续的可能感知所产生的可能信念状态：
chap3_para507,1,,4.4.3　求解部分可观测问题
chap3_para508,1,,4.4.2节介绍了在给定Percept函数的情况下，如何从底层物理问题推导出非确定性信念状态问题的Results函数。
chap3_para508,2,,使用这一形式化，可以直接应用图4-11的与或搜索算法得到问题的解。
chap3_para508,3,,"图4-16为局部感知真空吸尘器世界的部分搜索树，假定初始感知为[L, Dirty]。"
chap3_para508,4,,它的解是一个条件规划：
chap3_para509,1,,注意，因为我们是在信念状态问题中应用与或搜索算法，所以它返回的条件规划所测试的是信念状态，而非实际状态。
chap3_para509,2,,这是应该的：在部分可观测环境中，智能体并不知道实际状态。
chap3_para51,1,•Initial state: Any state can be designated as the initial state. Note that a parity property partitions the state space—any given goal can be reached from exactly half of the possible initial states (see Exercise 3.PART).,在滑块问题（sliding-tile puzzle）中，若干滑块（有时称为块或片）排列在一个有若干空白区域的网格中，其中滑块可以滑进空白区域。
chap3_para51,2,,它的一个变体是汽车华容道问题（Rush Hour puzzle），在这个问题中，我们需要在6×6的网格中滑动汽车和卡车，目标是将一辆汽车从交通堵塞中解救出来。
chap3_para51,3,,滑块问题中最著名的变体是8数码问题（8-puzzle）（见图3-3），它由一个3×3的网格、8个带编号的滑块和一个空格组成，目标是达到指定的状态，如图3-3中右侧所示。
chap3_para51,4,,类似的还有由4×4的网格组成的15数码问题（15-puzzle）。
chap3_para51,5,,对8数码问题做如下形式化处理。
chap3_para510,1,,图4-16　局部感知真空吸尘器世界问题的第一层与或搜索树，Suck是解序列中的第一个动作
chap3_para511,1,,与标准搜索算法应用于无传感器问题的情况一样，与或搜索算法将信念状态看作和任何其他问题状态一样的黑盒。
chap3_para511,2,,可以通过检查先前生成的信念状态——它们是当前状态的子集或超集——来改进这一点，就像求解无传感器问题一样。
chap3_para511,3,,同样可以推导出与无传感器问题中描述的那些算法类似的增量搜索算法。
chap3_para511,4,,与黑盒方法相比，它们提供了显著的加速。
chap3_para512,1,,4.4.4　部分可观测环境中的智能体
chap3_para513,1,,部分可观测环境中的智能体先对问题形式化，接着调用搜索算法（例如And-Or-Search）求解，然后执行解步骤。
chap3_para513,2,,这种智能体和完全可观测确定性环境中的智能体之间有两个主要区别。
chap3_para513,3,,首先，问题的解将是一个条件规划而不是一个序列；为了执行if-then-else表达式，智能体需要测试if语句中的条件并执行正确的条件分支。
chap3_para513,4,,其次，智能体需要在执行动作和接收感知时维护其信念状态。
chap3_para513,5,,这一过程类似于式（4-5）中的预测-观测-更新过程，但更加简单，因为感知是由环境给出的，而不是由智能体自己计算的。
chap3_para513,6,,给定初始信念状态b、动作a、感知o，则新的信念状态为
chap3_para515,1,,考虑一个类幼儿园真空吸尘器世界，智能体只能感知当前方格的状态，任一方格在任一时刻都有可能变脏，除非智能体恰好在那一时刻主动清理该方格。
chap3_para515,2,,[7]图4-17为此环境中所维护的信念状态。
chap3_para517,1,,[7]　向那些不熟悉幼儿对环境影响的人表示歉意。
chap3_para518,1,,在部分可观测环境中——涵盖绝大多数真实世界环境——维护自身的信念状态是任何智能系统的核心功能。
chap3_para518,2,,这一功能有很多不同的名称，包括监视（monitoring）、过滤（filtering）和状态评估（state estimation）。
chap3_para518,3,,式（4-6）称为递归状态评估器，因为它根据前一状态计算新的信念状态，而不是检查整个感知序列。
chap3_para518,4,,如果智能体不想“落后”，计算速度必须和感知进入的速度一样快。
chap3_para518,5,,随着环境越来越复杂，智能体将只有时间计算近似信念状态，它可能重点关注感知对当前感兴趣的环境方面的影响。
chap3_para518,6,,关于这一问题的大部分工作都是用概率论的工具处理随机的连续状态的环境，详见第14章。
chap3_para519,1,,图4-17　在局部感知的类幼儿园真空吸尘器世界中，信念状态维护的两个预测-更新周期
chap3_para52,1,"•Actions: While in the physical world it is a tile that slides, the simplest way of describing an action is to think of the blank space moving Left, Right, Up, or Down. If the blank is at an edge or corner then not all actions will be applicable.",● 状态：指定每个滑块位置的状态描述。
chap3_para520,1,,在本节中，我们将展示一个离散环境中的实例，其传感器是确定性的，动作是非确定性的。
chap3_para520,2,,这个实例中涉及的机器人具有特定的状态评估任务，该任务称为定位（localization）：即在给定世界地图和一系列感知及行动的情况下，找到自己的位置。
chap3_para520,3,,机器人放置在图4-18所示的迷宫环境中。
chap3_para520,4,,它配备了4个声呐传感器，可以判断在4个罗盘方向上是否存在障碍物——外墙或者图中的深色阴影方格。
chap3_para520,5,,感知以位向量的形式出现，每一位依次代表北、东、南、西方向，所以1011表示北、南、西方向有障碍物。
chap3_para521,1,,图4-18　机器人的可能位置，⊙，（a）一次观测E1 = 1011后。
chap3_para521,2,,（b）移动一个方格并进行第二次观测E2 = 1010后。
chap3_para521,3,,如果传感器没有噪声且转移模型是准确的，那么只有一个可能位置与这两个观测序列一致
chap3_para522,1,,我们假设传感器所提供的数据完全正确，而且机器人拥有正确的环境地图。
chap3_para522,2,,但遗憾的是，机器人的导航系统发生故障，所以当它执行Right动作时，会随机移动到一个相邻方格。
chap3_para522,3,,机器人的任务是确定它的当前位置。
chap3_para523,1,,假设机器人刚刚启动，并不知道自己的位置——那么它的初始信念状态b为包含所有位置的集合。
chap3_para523,2,,接着机器人接收到感知1011，并使用公式bo = Update(1011)进行更新，得到如图4-18a所示的4个位置。
chap3_para523,3,,查看整个迷宫你会发现这是仅有的4个可以产生感知1011的位置。
chap3_para524,1,,接下来，机器人执行Right动作，但结果是非确定性的。
chap3_para524,2,,"新的信念状态，ba = Predict(bo, Right)，包含了与bo中的位置相邻的所有位置。"
chap3_para524,3,,"当接收到第二个感知1010时，机器人执行Update(ba, 1010)，此时信念状态已经只剩图4-18b所示的一个位置。"
chap3_para524,4,,这是下式得到的唯一位置：
chap3_para525,1,,对于非确定性动作，Predict阶段信念状态增加，但是Update阶段信念状态又减少回去——只要感知提供了有用的识别信息。
chap3_para525,2,,有时感知对定位帮助不大：如果存在一个或多个很长的东西向走廊，那么机器人可能会接收到一个很长的1010感知序列，但它永远不会知道它在走廊的哪一位置。
chap3_para525,3,,但对于地理上存在合理差异的环境，定位往往会迅速收敛到单个点，即使动作是非确定性的。
chap3_para526,1,,如果传感器发生故障怎么办？
chap3_para526,2,,如果我们只能用布尔逻辑进行推理，那么我们就无法判断每个传感器位的正误，相当于没有任何感知信息。
chap3_para526,3,,但我们将看到，概率推理（第12章）允许我们从故障传感器中提取有用信息，只要它出错的时间不超过一半。
chap3_para527,1,,4.5　在线搜索智能体和未知环境
chap3_para528,1,,到目前为止，我们主要关注使用离线搜索（offline search）算法的智能体。
chap3_para528,2,,它们在执行第一个动作之前就已经计算出一个完整的解。
chap3_para528,3,,相比之下，在线搜索（online search）[8]智能体则交替进行计算和动作：它首先执行一个动作，然后观测环境并计算下一个动作。
chap3_para528,4,,在线搜索适用于动态或半动态环境，因为在这些环境中停止不动或计算时间太长都要付出代价。
chap3_para528,5,,在线搜索在非确定性领域也很有用，因为它允许智能体将计算精力集中在实际发生的偶然事件上，而不是那些也许会发生但很可能不会发生的事件。
chap3_para53,1,"•Transition model: Maps a state and action to a resulting state; for example, if we apply Left to the start state in Figure 3.3, the resulting state has the 5 and the blank switched.",● 初始状态：任何状态都可以被指定为初始状态。
chap3_para53,2,,注意，可以根据奇偶性划分状态空间——任何给定目标都可以从恰好一半的可能初始状态到达（见习题 3.PART）。
chap3_para530,1,,[8]　这里的“在线”指的是必须在接收到输入时立即进行处理的算法，而不是等待整个输入数据集都可用时再进行处理。
chap3_para530,2,,“在线”的这种用法与“因特网连接”的概念无关。
chap3_para531,1,,当然，这里需要权衡：智能体提前规划得越多，发现自己陷入困境的频率越低。
chap3_para531,2,,在未知环境中，智能体不清楚存在什么状态或者动作会产生什么结果，必须使用自身的动作作为实验来了解环境。
chap3_para532,1,,在线搜索的一个典型实例是地图构建问题（mapping problem）：机器人放置在一个未知建筑中，它必须进行探索以绘制一个从A到B的地图。
chap3_para532,2,,逃离迷宫的方法——有抱负的古代英雄所需的知识——也是在线搜索算法的实例。
chap3_para532,3,,然而，空间探索并不是在线探索的唯一形式。
chap3_para532,4,,以一个新生儿为例：它可能可以做许多举动，却不知道这些动作的后果，而且它只体验过少数几个它能达到的可能状态。
chap3_para533,1,,4.5.1　在线搜索问题
chap3_para534,1,,求解在线搜索问题需要交替进行计算、感知和动作。
chap3_para534,2,,我们首先假设环境是确定性的和完全可观测的（第17章放宽了这些假设），并规定智能体只知道以下内容。
chap3_para535,1,,● Actions(s)，状态s下的合法动作。
chap3_para536,1,,"● c(s, a, s')，在状态s下执行动作a到达状态s'的代价。"
chap3_para536,2,,注意，前提是智能体知道s'是结果。
chap3_para537,1,,● Is-Goal(s)，目标测试。
chap3_para538,1,,"特别要注意的是，智能体不能确定Result(s, a)的值，除非它确实在s中执行了a。"
chap3_para538,2,,"例如，在图4-19所示的迷宫问题中，智能体并不知道从(1, 1)执行Up动作会到达(1, 2)；也不知道再执行Down动作会回到(1, 1)。"
chap3_para538,3,,在某些应用中可以减少这种无知——例如，机器人探测器可能知道它是如何移动的，只是不知道障碍物的位置。
chap3_para539,1,,最后，智能体可能可以访问一个可容许的启发式函数h(s)，该函数对从当前状态到目标状态的距离进行估计。
chap3_para539,2,,例如，在图4-19中，智能体可能知道目标的位置，从而可以使用曼哈顿距离启发式函数（3.6节）。
chap3_para54,1,"•Goal state: Although any state could be the goal, we typically specify a state with the numbers in order, as in Figure 3.3.",● 动作：虽然在真实世界中是滑块在移动，但描述动作的最简单方法是假设空格执行Left、Right、Up或Down动作。
chap3_para54,2,,如果空格位于边缘或角落，则不是所有的动作都可用。
chap3_para540,1,,图4-19　一个简单的迷宫问题。
chap3_para540,2,,智能体必须从S出发到达G，但它对环境一无所知
chap3_para541,1,,通常，智能体的目标是以最小代价到达目标状态。
chap3_para541,2,,（另一个可能目标是简单地探索整个环境。
chap3_para541,3,,）代价是智能体在移动过程中产生的总的路径代价。
chap3_para541,4,,通常将它与智能体事先知道搜索空间时所产生的路径代价（即已知环境中的最优路径）进行比较。
chap3_para541,5,,在在线算法的术语中，这种比较被称为竞争比（competitive ratio），我们希望它尽可能地小。
chap3_para542,1,,在线探索器很容易陷入死胡同（dead-end）：无法到达任何目标状态的状态。
chap3_para542,2,,如果智能体不知道每个动作的后果，它可能会“跳进陷阱”，因此永远无法到达目标。
chap3_para542,3,,一般来说，没有一种算法能在所有状态空间中都避免进入死胡同。
chap3_para542,4,,以图4-20a中的两个死胡同状态空间为例。
chap3_para542,5,,对已经访问过状态S和A的在线搜索算法来说，它无法分辨自己是处于顶部的状态还是底部的状态；根据智能体观测到的感知信息，这两个状态看起来是相同的。
chap3_para542,6,,因此，它不可能知道如何在两个状态空间中选择正确的动作。
chap3_para542,7,,这是一个对手论证（adversary argument）的实例——想象对手在智能体探索状态空间时构建状态空间，并将目标和死胡同放在它所选择的任何地方，如图4-20b所示。
chap3_para543,1,,图4-20　（a）两个可能将在线搜索智能体引入死胡同的状态空间。
chap3_para543,2,,任何给定智能体都会在至少一个空间中失败。
chap3_para543,3,,（b）二维环境实例，将导致在线搜索智能体沿着一条任意低效的路线到达目标。
chap3_para543,4,,无论智能体做出何种选择，对手都会用另一堵很长很薄的墙来阻挡这条路线，这样智能体所走的路径就会比最优可能路径长得多
chap3_para544,1,,死胡同是机器人探索中的一个真正的难点——楼梯、斜坡、悬崖、单行道甚至自然地形中都存在从它出发某些动作不可逆（irreversible）的状态——没有办法回到之前的状态。
chap3_para544,2,,我们提出的探索算法只保证在可安全探索（safely explorable）的状态空间中是有效的，也就是说，从每个可达状态出发都存在可以到达的目标状态。
chap3_para544,3,,所有动作都可逆的状态空间，如迷宫和8数码，显然是可安全探索的（如果它们有解的话）。
chap3_para544,4,,我们将在22.3.2节中更深入地讨论安全探索的话题。
chap3_para545,1,,即使在可安全探索的环境中，如果存在代价无界的路径，也不能保证竞争比有界。
chap3_para545,2,,在动作不可逆的环境中，很容易发现上述结论，但事实上，可逆情况下也是如此，如图4-20b所示。
chap3_para545,3,,因此，通常会根据整个状态空间的大小来描述在线搜索算法的性能，而不是仅仅根据最浅层目标的深度。
chap3_para546,1,,4.5.2　在线搜索智能体
chap3_para547,1,,可观测环境中的在线智能体在每个动作之后都会接收到一个感知，告诉它目前到达了哪一状态，通过这些信息，智能体可以更新它的环境地图。
chap3_para547,2,,更新后的地图将用于规划下一步。
chap3_para547,3,,规划和动作交替进行意味着在线搜索算法与之前介绍的离线搜索算法有很大不同：离线算法探索其状态空间模型，而在线算法探索真实世界。
chap3_para547,4,,例如，A*可以在空间的某部分扩展一个节点，然后马上在空间的另一相距很远的部分扩展另一个节点，因为节点扩展设计的是模拟动作而非真实动作。
chap3_para548,1,,另外，在线算法只能找到其实际占据的状态的后继。
chap3_para548,2,,为了避免长途跋涉到一个相距较远的状态来扩展下一个节点，按照局部顺序扩展节点似乎更好。
chap3_para548,3,,深度优先搜索恰好具有这一性质，因为（如果算法不用回溯）下一个扩展节点是前一个扩展节点的子节点。
chap3_para549,1,,图4-21为在线深度优先探索智能体（动作是确定性但未知的）。
chap3_para549,2,,"智能体将它的地图存储在一个result[s, a]表中，记录了在状态s下执行动作a所产生的状态。"
chap3_para549,3,,"（对于非确定性动作，智能体可以在results[s, a]中记录状态集合。"
chap3_para549,4,,）只要当前状态存在未探索过的动作，智能体就会尝试其中一个动作。
chap3_para549,5,,当智能体尝试完某个状态下的所有动作时，问题就来了。
chap3_para549,6,,在离线深度优先搜索中，我们只是将状态从队列中删除；而在线搜索中，智能体必须在物理世界中回溯。
chap3_para549,7,,在深度优先搜索中，这意味着回溯到智能体进入当前状态前的最近状态。
chap3_para549,8,,为了实现这一点，算法需要维护另一个表，表中列出了每个状态尚未回溯到的前驱状态。
chap3_para549,9,,如果智能体已经没有可回溯的状态，那么搜索就完成了。
chap3_para55,1,,● 转移模型：将状态和动作映射为一个结果状态；例如，图3-3中，对于初始状态，我们采取Left动作，那么结果状态中滑块5和空格将交换位置。
chap3_para550,1,,图4-21　使用深度优先探索的在线搜索智能体。
chap3_para550,2,,智能体只有在每个动作都可以被其他动作“撤消”的状态空间中才能安全地探索
chap3_para551,1,,我们建议读者在求解图4-19中的迷宫问题时跟踪Online-DFS-Agent的进度。
chap3_para551,2,,很容易看到，最坏情况下，智能体最终恰好要遍历状态空间中的每个连接两次。
chap3_para551,3,,对探索来说，这是最优的；但是，对寻找目标来说，如果在初始状态旁边恰好有一个目标状态，智能体的竞争比将变得无限差。
chap3_para551,4,,在线迭代加深算法可以解决这一问题；对于均衡树环境，这样一个智能体的竞争比是一个很小的常数。
chap3_para552,1,,由于其回溯方法，Online-DFS-Agent只在动作可逆的状态空间中有效。
chap3_para552,2,,在一般的状态空间中，有一些更复杂的算法，但是这类算法的竞争比都不是有界的。
chap3_para553,1,,4.5.3　在线局部搜索
chap3_para554,1,,与深度优先搜索一样，爬山搜索在节点扩展上也有局部性。
chap3_para554,2,,事实上，因为爬山搜索在内存中只保存一个当前状态，它已经是在线搜索算法！
chap3_para554,3,,遗憾的是，基础算法并不适用于探索，因为智能体会陷入局部极大值而无路可走。
chap3_para554,4,,此外，不能使用随机重启，因为智能体无法将自己瞬移到一个新的初始状态。
chap3_para555,1,,相比于随机重启，我们可以考虑使用随机游走（random walk）来探索环境。
chap3_para555,2,,随机游走只是从当前状态中随机选择一个可用动作，可以优先考虑尚未尝试的动作。
chap3_para555,3,,容易证明，当空间有限且可安全探索时，随机游走最终会找到一个目标或完成探索。
chap3_para555,4,,[9]但是，这一过程可能非常慢。
chap3_para555,5,,图4-22为一个环境实例，在这个环境中，随机游走将耗费指数级的步骤来寻找目标，因为对于第一行除S之外的每个状态，后退的可能性是前进的两倍。
chap3_para555,6,,当然，这个例子是人为设计的，但是真实世界中许多状态空间的拓扑结构都会导致这类随机游走“陷阱”。
chap3_para557,1,,[9]　随机游走在无限的一维和二维网格上是完备的。
chap3_para557,2,,"在三维网格上，游走返回起点的概率只有大约0.3405（Hughes, 1995）。"
chap3_para558,1,,图4-22　环境实例，随机游走需要耗费指数级的步骤来寻找目标
chap3_para559,1,,事实证明，增加爬山法的内存而非随机性是一种更有效的方法。
chap3_para559,2,,基本思想是，存储从已访问的每个状态出发到达目标所需代价的“当前最佳估计”H(s)。
chap3_para559,3,,H(s)开始时只是启发式估计，然后根据智能体在状态空间中获得的经验不断更新。
chap3_para56,1,Note that every problem formulation involves abstractions.,● 目标状态：尽管任何状态都可以作为目标状态，但我们通常用有序编号指定目标状态，如图3-3所示。
chap3_para56,2,"The 8-puzzle actions are abstracted to their beginning and final states, ignoring the intermediate locations where the tile is sliding.",
chap3_para56,3,We have abstracted away actions such as shaking the board when tiles get stuck and ruled out extracting the tiles with a knife and putting them back again.,
chap3_para56,4,"We are left with a description of the rules, avoiding all the details of physical manipulations.",
chap3_para560,1,,图4-23为一维状态空间中的一个简单示例。
chap3_para560,2,,在图4-23a中，智能体似乎陷入了位于红色状态的局部极小值。
chap3_para560,3,,智能体不应该停留在原地，而应该根据其邻居节点的当前代价估计值选择到达目标的最优路径。
chap3_para560,4,,"经由邻居节点s'到达目标的估计代价等于到达s'的代价加上从s'到达目标的估计代价，即c(s, a, s') + H(s')。"
chap3_para560,5,,在这个示例中，有2个动作，估计代价分别为向左1 + 9，向右1 + 2，因此最好向右移动。
chap3_para561,1,,在图4-23b中，显然，将图4-23a中红色状态的代价估计为2是过于乐观的。
chap3_para561,2,,因为最佳移动的代价为1，而且其结果状态离目标状态至少还有2步，所以红色状态离目标一定至少还有3步，所以应该相应地更新红色状态的H，如图4-23b所示。
chap3_para561,3,,继续上述过程，智能体将再来回移动两次，每次都会更新H并“拉平”局部极小值，直到它逃逸到右侧。
chap3_para562,1,,能够实现上述方案的智能体称为实时学习A*（learning real-time A*，LRTA*）智能体，如图4-24所示。
chap3_para562,2,,同Online-DFS-Agent一样，它用result表构建环境地图。
chap3_para562,3,,它首先更新刚刚离开的状态的代价估计值，然后根据当前的代价估计值选择“显然最佳”移动。
chap3_para562,4,,一个重要的细节是，在状态s下尚未尝试的动作总是被假定为以最少的可能代价，即h(s)直接到达目标。
chap3_para562,5,,这种不确定性下的乐观主义（optimism under uncertainty）鼓励智能体去探索新的、可能更有希望的路径。
chap3_para563,1,,图4-23　一维状态空间上LRTA*的5次迭代。
chap3_para563,2,,每个状态都标有H(s)，即到达目标的当前代价估计值，每个连接的动作代价为1。
chap3_para563,3,,红色状态表示智能体的位置，每次迭代所更新的代价估计值以双圈标记
chap3_para564,1,,图4-24　LRTA*-Agent根据相邻状态的值选择动作，智能体在状态空间中移动时更新状态值
chap3_para565,1,,LRTA* 智能体保证在任何有限的、可安全探索的环境中都能找到目标。
chap3_para565,2,,然而，不同于A*，LRTA*在无限状态空间中是不完备的——在某些情况下，它可能被无限地引入歧途。
chap3_para565,3,,在最坏情况下，探索状态数为n的环境可能需要O(n2)步，但通常情况下会比这种情况好得多。
chap3_para565,4,,LRTA* 智能体只是一个庞大的在线智能体家族中的一员，可以通过以不同方式指定动作选择规则和更新规则来定义。
chap3_para565,5,,我们将在第22章中详细讨论这一发源于随机环境的在线智能体家族。
chap3_para566,1,,4.5.4　在线搜索中的学习
chap3_para567,1,,在线搜索智能体初始时对环境的无知为我们提供了一些学习的机会。
chap3_para567,2,,首先，智能体通过记录它们的每一次经验来学习环境“地图”——更准确地说，学习每种状态下每个动作的结果。
chap3_para567,3,,其次，当智能体以正确的方式探索状态空间时，局部搜索智能体可以利用局部更新规则获得每个状态代价更准确的估计值。
chap3_para567,4,,一旦知道代价的准确值，只需移动到代价最低的后继状态就能实现最优决策，也就是说，纯粹的爬山法就是一个最优策略。
chap3_para568,1,,如果按照我们的建议在图4-19的环境中跟踪Online-DFS-Agent的行为，你会注意到智能体不是非常聪明。
chap3_para568,2,,"例如，在它已经知道Up动作能够从(1, 1)到达(1, 2)后，它仍然不知道Down动作能回到(1, 1)，或者Up动作还能从(2, 1)到(2, 2)，从(2, 2)到(2, 3)，等等。"
chap3_para568,3,,一般来说，我们希望智能体能够学到，Up在不遇到墙的情况下使得y坐标值增加，Down则使得y坐标值降低，等等。
chap3_para569,1,,要实现这一点，我们需要做两件事。
chap3_para569,2,,首先，需要对这类一般规则有一个形式的、可显式操纵的表示；到目前为止，信息都被隐藏在名为Result函数的黑盒中。
chap3_para569,3,,第8～11章将专门讨论这个问题。
chap3_para569,4,,其次，需要能够根据智能体所得到的具体观测信息构造合适的一般规则的算法。
chap3_para569,5,,这些内容将在第19章中讨论。
chap3_para57,1,Our final standardized problem was devised by Donald Knuth (1964) and illustrates how infinite state spaces can arise.,● 动作代价：每个动作的代价都为1。
chap3_para57,2,"Knuth conjectured that starting with the number 4, a sequence of square root, floor, and factorial operations can reach any desired positive integer.",
chap3_para57,3,"For example, we can reach 5 from 4 as follows:",
chap3_para570,1,,如果我们预计将来会被要求求解多个类似问题，那么投入时间（和内存）使得这些未来搜索更容易是有意义的。
chap3_para570,2,,有几种方法可以做到这一点，它们都属于增量搜索（incremental search）的范畴。
chap3_para570,3,,我们可以将搜索树保留在内存中，并复用在新问题中未发生改变的部分。
chap3_para570,4,,我们可以保留启发式代价函数h的值，并在获得新信息时更新它们——要么是因为世界发生改变，要么是因为我们计算出了更好的估计值。
chap3_para570,5,,或者我们可以保留最优路径的g值，用它们拼凑出一个新的解，并在世界发生改变时对它们进行更新。
chap3_para572,1,,本章讨论了部分可观测的、非确定性的、未知的和连续的环境中问题的搜索算法。
chap3_para573,1,,● 局部搜索算法，如爬山法，在内存中只保留少量状态。
chap3_para573,2,,这些方法已被应用于优化问题，其思想是找到一个高分值的状态，而不考虑进入该状态的路径。
chap3_para573,3,,研究人员已经开发了一些随机局部搜索算法，包括模拟退火，当给定适当的冷却方案时它能返回最优解。
chap3_para574,1,,● 许多局部搜索方法同样适用于连续空间中的问题。
chap3_para574,2,,线性规划和凸优化问题服从状态空间形状和目标函数性质上的某些限制，并且允许多项式时间算法，这些算法在实践中往往非常高效。
chap3_para574,3,,对于一些数学上合式的问题，我们可以使用微积分找到梯度为零的最大值；对于其他问题，我们必须使用经验梯度，即测量两个邻近点间的适应度差值。
chap3_para575,1,,● 进化算法是一种维护状态种群的随机爬山搜索。
chap3_para575,2,,通过突变和杂交（结合状态对）产生新状态。
chap3_para576,1,,● 在非确定性环境中，智能体可以应用与或搜索算法生成应变规划，无论执行过程中出现何种结果，它都能实现目标。
chap3_para577,1,,● 如果环境是部分可观测的，信念状态表示智能体可能位于的可能状态的集合。
chap3_para578,1,,● 标准搜索算法可以直接应用于信念状态空间求解无传感器问题，而信念状态与或搜索算法可以求解一般的部分可观测问题。
chap3_para578,2,,在一个信念状态中逐状态构造解的增量算法通常效率更高。
chap3_para579,1,,● 探索问题发生在智能体对环境的状态和动作一无所知时。
chap3_para579,2,,对于可安全探索的环境，在线搜索智能体能够构建地图并找到目标（如果存在的话）。
chap3_para579,3,,根据经验来更新启发式估计值提供了一种避免局部极小值的有效方法。
chap3_para58,1,The problem definition is simple:,注意，每个问题的形式化都涉及抽象。
chap3_para58,2,,8数码问题中的动作被抽象为它们的开始状态和结束状态，忽略滑块滑动的中间位置。
chap3_para58,3,,我们已经通过抽象除去了一些动作，例如，当滑块被卡住时需要晃动木板，并排除了用刀取出滑块然后再放回去的可能性。
chap3_para58,4,,最终只剩下对规则的描述，避免了实际操作的所有细节。
chap3_para582,1,,第5章　对抗搜索和博弈
chap3_para583,1,,在本章中，我们将探索有其他智能体计划与我们对抗时的环境。
chap3_para584,1,,在本章中，我们将讨论竞争环境（competitive environment），在这种环境中，两个或两个以上的智能体具有互相冲突的目标，这引出了对抗搜索（adversarial search）问题。
chap3_para584,2,,我们将专注于讨论博弈[1]，如国际象棋、围棋和扑克，而不是处理真实世界中的混乱冲突。
chap3_para584,3,,对人工智能研究人员来说，这些博弈的简化特性是一个优势：博弈状态很容易表示，智能体通常仅能执行少数几个动作，而且动作的效果由明确的规则定义。
chap3_para584,4,,对于体育比赛（如槌球和冰球），描述更加复杂，可能动作的范围更大，而且定义动作合法性的规则也不够明确。
chap3_para584,5,,除足球机器人外，体育比赛并没有引起人工智能社区的很大兴趣。
chap3_para586,1,,[1]　对应英文game在博弈论中译为“博弈”，但在本书中不同语境下会根据具体情况使用博弈、游戏、比赛等。
chap3_para586,2,,——译者注
chap3_para588,1,,对于多智能体环境，我们至少可以有3种观点。
chap3_para588,2,,第一种观点适用于智能体数量非常大的情况，即把它们看作一个经济（economy）整体来考虑，这让我们可以做出例如“需求增长会导致价格上涨”这样的预测，而不需要预测任何个体智能体的动作。
chap3_para589,1,,第二种观点是，我们可以认为对抗智能体只是环境的一部分——这一部分让环境变成非确定性的。
chap3_para589,2,,但如果我们以对雨建模一样的方式（例如，雨有时下，有时不下）对对手进行建模，我们就会忽略对手正在积极地尝试击败我们这一事实，而雨没有这样的意图。
chap3_para59,1,•States: Positive real numbers.,图3-3　8数码问题的一个典型实例
chap3_para590,1,,第三种观点是用对抗博弈树搜索技术显式地对对抗智能体建模。
chap3_para590,2,,这就是本章所涵盖的内容。
chap3_para590,3,,我们从一类受限的博弈开始，定义最优移动并寻找最优移动的算法——极小化极大搜索（minimax search），它是与或搜索的一种推广（见图4-11）。
chap3_para590,4,,我们指出，剪枝（pruning）通过忽略搜索树中对最优移动没有影响的部分来提高搜索效率。
chap3_para590,5,,对于非平凡博弈，我们通常没有足够的时间以确保找到最优移动（即使使用剪枝），我们不得不在某个时刻停止搜索。
chap3_para591,1,,对于每一个我们选择在那里停止搜索的状态，我们都需要知道谁是获胜者。
chap3_para591,2,,要回答这个问题，有一个选择：可以基于状态特征应用启发式评价函数来估计谁是获胜者（5.3节），或者可以从该状态开始快速模拟至博弈结束，再取多次模拟结果的平均值（5.4节）。
chap3_para592,1,,5.5节讨论了包含机会因素（通过掷骰子或洗牌）的博弈，5.6节讨论了不完美信息（imperfect information）博弈（如扑克和桥牌，即并非所有牌对所有玩家都可见）。
chap3_para594,1,,人工智能领域中最常研究的博弈（例如国际象棋和围棋）是博弈论学者所称的确定性、双人、轮流、完美信息（perfect information）的零和博弈（zero-sum game）。
chap3_para594,2,,“完美信息”是“完全可观测”的同义词[2]，“零和”意味着对一方有利的东西将对另一方同等程度有害：不存在“双赢”结果。
chap3_para594,3,,在博弈论中，我们通常用移动（move）作为“动作”（action）的同义词，用局面（position）作为“状态”（state）的同义词。
chap3_para596,1,,[2]　对应英文player在博弈论中为“参与者”，但在本书中不同语境下会根据具体情况使用参与者、玩家、选手等。
chap3_para596,2,,——译者注
chap3_para597,1,,我们将两个参与者[3]分别称为max和min，这么命名的原因稍后解释。
chap3_para597,2,,max先移动，然后两个参与者轮流移动，直到博弈结束。
chap3_para597,3,,博弈结束时，获胜者得分，而失败者受到惩罚。
chap3_para597,4,,可以使用以下元素对博弈进行形式化定义。
chap3_para599,1,,[3]　一些作者对此进行了区分，用“不完美信息博弈”指扑克之类的游戏，其中玩家将获得其他玩家没有的关于自己手牌的私人信息，而用“部分可观测博弈”指《星际争霸II》之类的游戏，其中每个玩家可以看到其附近的环境，但看不到远处的环境。
chap3_para6,1,"This chapter uses the concepts of asymptotic complexity (that is, O(n) notation).",3.1　问题求解智能体
chap3_para6,2,Readers unfamiliar with these concepts should consult Appendix A.,
chap3_para60,1,•Initial state: 4.,"我们介绍的最后一个标准化问题是由高德纳（Knuth, 1964）设计的，它说明了无限状态空间是如何产生的。"
chap3_para60,2,,高德纳推测，通过只由平方根、向下取整和阶乘操作组成的序列可以从数字4得到任何正整数。
chap3_para60,3,,例如，我们可以这样从4得到5：
chap3_para600,1,,● S0：初始状态，指定博弈开始时如何设置。
chap3_para601,1,,● To-Move(s)：在状态s下，轮到其移动的参与者。
chap3_para602,1,,● Actions(s)：在状态s下，全体合法移动的集合
chap3_para603,1,,"● Result(s, a)：转移模型，定义状态s下执行动作a所产生的结果状态。"
chap3_para604,1,,● Is-Terminal(s)：终止测试（terminal test），博弈结束时返回真，否则返回假。
chap3_para604,2,,博弈结束时的状态称为终止状态（terminal state）。
chap3_para605,1,,"● Utility(s, p)：效用函数（也称为目标函数或收益函数），定义博弈结束时终止状态s下参与者p得到的最终的数值收益。"
chap3_para605,2,,在国际象棋中，结果为赢、输或平局，收益分别为1、0或1/2。
chap3_para605,3,,[4]一些博弈存在更大范围的可能结果，例如，西洋双陆棋的收益范围为0～192。
chap3_para607,1,,[4]　国际象棋被认为是一种“零和”游戏，尽管两个选手每局游戏的结果之和为+1，而不是0。
chap3_para607,2,,“常量和”是一个更准确的术语，但“零和”更传统，你可以将其看作每个选手被收取了1/2的入场费。
chap3_para608,1,,同第3章一样，初始状态、Actions函数和Result函数定义了状态空间图（state space graph）——在图中，顶点表示状态，边表示移动，一个状态可以通过多条路径到达。
chap3_para608,2,,如第3章所述，我们可以在图的一部分上叠加搜索树（search tree）以确定下一步移动。
chap3_para608,3,,我们将完整的博弈树（game tree）定义为搜索树，它会记录每个一直到终止状态的移动序列。
chap3_para608,4,,如果状态空间本身是无界的，或者博弈规则允许局面可以无限次重复，那么博弈树可能是无限的。
chap3_para609,1,,图5-1为井字棋（圈叉游戏tic-tac-toe）的部分博弈树。
chap3_para609,2,,从初始状态开始，max有9种可能的移动。
chap3_para609,3,,游戏交替进行，max放x，min放o，直到到达对应于终止状态的叶节点，即一个玩家占据某一行，或者所有方格都被填满。
chap3_para609,4,,每个叶节点上的数字是对max来说该终止状态的效用值，值越高对max越有利，对min越不利（这也是玩家名字的由来）。
chap3_para61,1,"•Actions: Apply square root, floor, or factorial operation (factorial for integers only).",问题定义很简单，如下所述。
chap3_para610,1,,对井字棋来说，博弈树相对较小——不超过9!= 362 880个终止节点（只有5478个不同状态）。
chap3_para610,2,,但是对国际象棋来说，节点数超过1040，所以博弈树被认为是一个在物理世界中无法实现的理论结构。
chap3_para611,1,,图5-1　井字棋的（部分）博弈树。
chap3_para611,2,,最上面的节点是初始状态，max先移动，在某个空位上放一个x。
chap3_para611,3,,我们展示了树的一部分，给出min(o)和max(x)的交替移动，直到最终到达终止状态，根据博弈规则为终止状态分配效用值
chap3_para612,1,,5.2　博弈中的优化决策
chap3_para613,1,,max想要找到通往胜利的动作序列，但min不希望max获胜。
chap3_para613,2,,这意味着max的策略必须是一个条件规划——一个随机应变策略，指定对min的每个可能移动的响应。
chap3_para613,3,,在具有二元结果（赢或输）的博弈中，我们可以使用与或搜索（4.3.2节）生成条件规划。
chap3_para613,4,,事实上，对于这类博弈，博弈的获胜策略的定义与非确定性规划问题的解的定义相同：在这两种情况下，无论“另一方”做什么，都必须保证己方能获得理想结果。
chap3_para613,5,,对于具有多个结果分数的博弈，我们需要一种更一般的算法，即极小化极大搜索。
chap3_para614,1,,考虑图5-2中的简单博弈。
chap3_para614,2,,根节点上max的可能移动被标记为a1、a2和a3。
chap3_para614,3,,min对a1的可能响应为b1、b2、b3等。
chap3_para614,4,,这个特殊游戏在max和min各移动一次后结束。
chap3_para614,5,,（注意，在某些游戏中，“move”一词意味着双方都执行了一次移动，因此，ply一词被用来明确表示一个玩家的一次移动，即我们在博弈树中又深入了一层。
chap3_para614,6,,）博弈中终止状态的效用值范围为2～14。
chap3_para615,1,,图5-2　二层博弈树。
chap3_para615,2,,△节点为“max节点”，即轮到max移动，节点为“min节点”。
chap3_para615,3,,终止节点显示max的效用值，其他节点标记有它们的极小化极大值。
chap3_para615,4,,max在根节点的最佳移动是a1，因为它指向极小化极大值最高的状态，而min的最佳响应是b1，因为它指向极小化极大值最低的状态
chap3_para616,1,,给定博弈树，可以通过计算树中每个状态的极小化极大值（minimax value）确定最优策略，记为Minimax(s)。
chap3_para616,2,,某一状态的极小化极大值是指，假设从该状态到博弈结束两个参与者都以最优策略行动，到达的终止状态对于max的效用值。
chap3_para616,3,,终止状态的极小化极大值就是它的效用值。
chap3_para616,4,,在非终止状态下，轮到max移动时，max倾向于移动到极小化极大值最大的状态，而min倾向于移动到极小化极大值最小的状态（对max来说值最小，因此对min来说值最大）。
chap3_para616,5,,所以有：
chap3_para617,1,,让我们将上述定义应用于图5-2中的博弈树。
chap3_para617,2,,底层的终止节点从Utility函数中获取它们的效用值。
chap3_para617,3,,第一个min节点，标记为B，存在3个后继状态，值分别为3、12和8，因此它的极小化极大值为3。
chap3_para617,4,,类似地，另外两个min节点的极小化极大值都为2。
chap3_para617,5,,根节点为max节点，它的后继状态的极小化极大值分别为3、2和2，因此，它的极小化极大值为3。
chap3_para617,6,,我们还可以在根节点处确定极小化极大决策（minimax decision）：动作a1是max的最优选择，因为它指向极小化极大值最大的状态。
chap3_para618,1,,max的最优策略假设min也是按照最优策略动作。
chap3_para618,2,,如果min不按照最优策略动作呢？
chap3_para618,3,,那么max至少会表现得与它面对最优对手时一样好，甚至可能更好。
chap3_para618,4,,然而，这并不意味着，面对次优对手时选择极小化极大最优移动总是最好的。
chap3_para618,5,,考虑这样一种情况，双方均按照最优策略行动，结果为平局，但max有一种冒险的走法，在这种走法导致的状态下，min有10种可能的响应，这些响应似乎都是合理的，但其中9种都会使min输掉游戏，只有1种会使max输掉游戏。
chap3_para618,6,,如果max认为min没有足够的计算能力找到最优移动，那么max可能会尝试这种冒险的走法，因为9/10的获胜机会要比一个确定的平局好。
chap3_para619,1,,5.2.1　极小化极大搜索算法
chap3_para62,1,•Transition model: As given by the mathematical definitions of the operations.,
chap3_para620,1,,现在我们来计算Minimax(s)，我们可以将其转化为一个搜索算法，即尝试所有动作然后选择其结果状态的Minimax值最大的动作作为max的最佳移动。
chap3_para620,2,,算法如图5-3所示。
chap3_para620,3,,这是一种递归算法，它一直向下进行到叶节点，然后随着递归的展开通过搜索树倒推极小化极大值。
chap3_para620,4,,例如，图5-2中的算法，首先递归到左下角的3个节点，并对它们调用Utility函数，发现它们的值分别为3、12和8。
chap3_para620,5,,然后选择其中的最小值，3，并将其返回，作为节点B的倒推值。
chap3_para620,6,,同理可得，C和D的倒推值都为2。
chap3_para620,7,,最后，我们选择3、2和2中的最大值3作为根节点的倒推值。
chap3_para621,1,,极小化极大算法对博弈树进行完整的深度优先探索。
chap3_para621,2,,如果树的最大深度为m，并且在每个点都有b种合法移动，那么极小化极大算法的时间复杂度为O(bm)。
chap3_para621,3,,对于一次生成所有动作的算法，空间复杂度为O(bm)，对于一次只生成一个动作的算法，空间复杂度为O(m)（见3.4.3节）。
chap3_para621,4,,指数级的复杂度使得Minimax无法应用于复杂博弈。
chap3_para621,5,,例如，国际象棋的分支因子约为35，平均深度约为80层，搜索个状态显然是不可行的。
chap3_para621,6,,然而，Minimax确实是对博弈进行数学分析的基础。
chap3_para621,7,,通过以各种方式近似极小化极大分析，我们可以推导出更实用的算法。
chap3_para622,1,,图5-3　使用极小化极大计算最优移动的算法。
chap3_para622,2,,最优移动是指，在假定对手移动是为了使效用值最小的前提下，使终止状态效用值最大的移动。
chap3_para622,3,,函数Max-Value和Min-Value遍历整个博弈树直到叶节点，以确定每个状态的倒推值以及如何移动以到达该状态
chap3_para623,1,,5.2.2　多人博弈中的最优决策
chap3_para624,1,,许多流行游戏都允许多个玩家参与。
chap3_para624,2,,让我们来看看如何将极小化极大思想推广到多人博弈中。
chap3_para624,3,,从技术角度来看，这很自然，但是也产生了一些有趣的新的概念上的问题。
chap3_para625,1,,首先，我们需要将每个节点的单一值替换为值向量。
chap3_para625,2,,例如，在玩家A、B和C参与的3人博弈中，每个节点都与一个向量相关联。
chap3_para625,3,,对于终止状态，这一向量表示每个玩家各自在该状态得到的效用值。
chap3_para625,4,,（在双人零和博弈中，二元向量可以简化为一个值，因为两个值总是互为相反数。
chap3_para625,5,,）最简单的实现方法是让Utility函数返回效用值向量。
chap3_para626,1,,现在我们要考虑非终止状态。
chap3_para626,2,,考虑图5-4的博弈树中标为X的节点。
chap3_para626,3,,此时，轮到玩家C选择如何移动。
chap3_para626,4,,两种选择产生了效用值向量分别为和的两种终止状态，因为6大于3，所以C应该选择第一种移动。
chap3_para626,5,,这意味着，如果到达状态X，后续的博弈将产生效用值为的终止状态。
chap3_para626,6,,因此，这个向量就是X的倒推值。
chap3_para626,7,,一般地，节点n的倒推值是对在该点进行选择的玩家来说效用值最大的后继状态的效用值向量。
chap3_para627,1,,任何参与多人博弈（如Diplomacy或Settlers of Catan游戏）的参与者都会很快意识到，比起双人博弈，多人博弈要复杂得多。
chap3_para627,2,,多人博弈通常涉及参与者之间的正式或非正式联盟（alliance）。
chap3_para627,3,,联盟会随着博弈的发展建立和瓦解。
chap3_para627,4,,我们如何理解这种行为？
chap3_para627,5,,联盟是多人博弈中每个参与者都按照最优策略行动的自然结果吗？
chap3_para627,6,,事实证明的确如此。
chap3_para628,1,,例如，假设现在A和B处于弱势，而C处于强势。
chap3_para628,2,,那么，对A和B来说，最理想的做法往往是一起攻击C，而不是彼此攻击，以免C对它们逐个消灭。
chap3_para628,3,,这样的话，合作其实产生于纯粹的自私行为。
chap3_para628,4,,当然，一旦C在联合攻击下被削弱，联盟就失去了价值，A或B都有可能违反协议。
chap3_para629,1,,图5-4　三人博弈的博弈树的前三层，3个玩家为A、B、C。
chap3_para629,2,,每个节点都标有3个玩家各自的效用值。
chap3_para629,3,,最佳移动标示在根节点上
chap3_para63,1,•Goal state: The desired positive integer.,
chap3_para630,1,,在某些情况下，显式联盟只是将无论如何都会发生的事情具体化。
chap3_para630,2,,而在其他情况下，破坏联盟会被记录为社会污点，所以参与者必须权衡破坏联盟所带来的即时优势和失去信任所造成的长期劣势。
chap3_para630,3,,有关这些复杂问题的更多讨论，详见18.2节。
chap3_para631,1,,如果博弈不是零和博弈，那么在只有两个参与者时，合作也可能发生。
chap3_para631,2,,例如，假设存在一个效用值为的终止状态，并且每个参与者最高的可能效用值也是1000。
chap3_para631,3,,那么最优策略是双方都尽一切可能到达该状态，也就是说，参与者会自动合作以实现共同的期望目标。
chap3_para633,1,,博弈的状态数关于树的深度是指数量级的。
chap3_para633,2,,没有一种算法可以完全消除指数项，但有时可以将它减半，即通过剪枝（见3.5.3节）消除对结果没有影响的树的大部分，从而不需要检查所有状态就能计算出正确的极小化极大决策。
chap3_para633,3,,这种技术称为剪枝（alpha-beta pruning）。
chap3_para634,1,,再次考虑图5-2中的双层博弈树。
chap3_para634,2,,让我们再进行一次最优决策的计算，这一次要仔细观察在这个过程中的每个点上都获得了什么信息。
chap3_para634,3,,步骤如图5-5所示。
chap3_para634,4,,结果是，我们可以在无须评估其中两个叶节点的情况下就能确定极小化极大决策。
chap3_para635,1,,另一种考虑这一问题的方式是将Minimax公式简化。
chap3_para635,2,,假设图5-5中节点C的两个未评估的后继节点的值分别为x和y，则根节点的值为
chap3_para636,1,,也就是说，根节点的值以及极小化极大决策与叶节点x和y的值无关，因此可以将它们剪枝。
chap3_para637,1,,剪枝可以应用于任何深度的树，而且通常可以将整个子树而不只是叶节点剪枝。
chap3_para637,2,,一般原则是：考虑树中某个位置的节点n（见图5-6），玩家可以选择移动到n。
chap3_para637,3,,如果玩家在树中同一层（如图5-6中的m'）或更上层的任何位置（如图5-6中的m）有更好的选择，那么玩家永远都不愿移动到n。
chap3_para637,4,,所以，一旦我们对n有了足够的了解（通过检查它的某些后继）来得出上述结论，就可以将它剪枝。
chap3_para638,1,,图5-5　图5-2中博弈树的最优决策计算过程。
chap3_para638,2,,每一步都标有每个节点可能的值的范围。
chap3_para638,3,,（a）B下面的第一个叶节点值为3。
chap3_para638,4,,因此，作为min节点，B的值最多为3。
chap3_para638,5,,（b）B下面的第二个叶节点值为12，min将避免移动到该节点，所以B的值仍然最多为3。
chap3_para638,6,,（c）B下面的第三个叶节点值为8，此时我们已经检查完了B的所有后继状态，所以B的值就是3。
chap3_para638,7,,现在我们可以推断根节点的值至少是3，因为max在根节点处有值为3的选择。
chap3_para638,8,,（d）C下面的第一个叶节点值为2。
chap3_para638,9,,因此，作为min节点，C的值最多为2。
chap3_para638,10,,但是我们知道B的值为3，所以max永远不会选择C。
chap3_para638,11,,因此，没有必要再去检查C的其他后继状态。
chap3_para638,12,,这是剪枝的一个实例。
chap3_para638,13,,（e）D下面的第一个叶节点值为14，所以D的值最多为14。
chap3_para638,14,,这仍然高于max的最佳选择（即3），所以我们需要继续探索D的后继状态。
chap3_para638,15,,注意，此时根节点的所有后继都有界，所以根节点的值也最多为14。
chap3_para638,16,,（f）D的第二个后继值为5，所以我们又需要继续探索。
chap3_para638,17,,第三个后继值为2，所以D的值就是2。
chap3_para638,18,,最终，max在根节点处的决策是移动到值为3的节点B
chap3_para639,1,,图5-6　剪枝的一般情况。
chap3_para639,2,,如果对玩家来说m或m'要好于n，那么我们永远都不会在博弈中到达n
chap3_para64,1,,● 动作：应用平方根、向下取整或阶乘操作（阶乘仅用于整数）。
chap3_para640,1,,记住，极小化极大搜索是深度优先的，所以在任何时候我们只需考虑树中单个路径上的节点。
chap3_para640,2,,"剪枝得名于Max-Value(state, , )（见图5-7）中的两个额外参数，它们分别是路径上任何位置的倒推值的下界和上界。"
chap3_para641,1,,= 到目前为止，路径上发现的max的任一选择点中最佳（即最大值）选择的值。
chap3_para641,2,,也就是 说， = “至少”。
chap3_para642,1,,= 到目前为止，路径上发现的min的任一选择点中最佳（即最小值）选择的值。
chap3_para642,2,,也就是 说， = “至多”。
chap3_para643,1,,搜索不断更新和的值，并且一旦当前节点的值比此时的（对于max）或（对于min）值更差，就剪掉该节点的剩余分支（即终止递归调用）。
chap3_para643,2,,完整算法如图5-7所示。
chap3_para643,3,,图5-5跟踪了博弈树上的算法进程。
chap3_para644,1,,图5-7　搜索算法。
chap3_para644,2,,注意，这些函数与图5-3中的Minimax-Search函数相同，除了需要维护变量和，以及在值超出边界时截断搜索
chap3_para645,1,,5.2.4　移动顺序
chap3_para646,1,,剪枝的有效性很大程度上依赖于状态的检查顺序。
chap3_para646,2,,例如，在图5-5e和图5-5f中，根本不能剪掉D的任何后继，因为最差的后继（从min的角度来看）是最先生成的。
chap3_para646,3,,如果最先生成D的第三个后继，它的值为2，那么我们就可以剪掉另外两个后继。
chap3_para646,4,,这表明，应该先检查有可能是最佳选择的后继节点。
chap3_para647,1,,如果能够完美地实现这一点，搜索算法只需要检查个节点就能选出最佳移动，而极小化极大算法需要O(bm)。
chap3_para647,2,,这意味着有效分支因子从b变为了，对国际象棋来说，大约从35变为了6。
chap3_para647,3,,换句话说，在相同时间内，拥有完美移动顺序的剪枝可以求解的树的深度大约是极小化极大算法的两倍。
chap3_para647,4,,如果移动顺序随机，对于适当大小的b，需要检查的节点总数约为。
chap3_para647,5,,显然我们现在无法实现完美移动顺序，否则，在这种情况下，可以用排序函数玩一个完美的游戏！
chap3_para647,6,,但通常我们可以非常接近完美。
chap3_para647,7,,对国际象棋来说，一个非常简单的排序函数（例如，先尝试吃子，然后是威胁，再后是前进和后退）就能让检查的节点数减少到不超过最好情况的大约2倍。
chap3_para648,1,,增加动态的移动排序方案，例如先尝试之前发现的最佳移动，能让我们非常接近理论极限。
chap3_para648,2,,“之前”可能指上一次移动（通常面临同样的威胁），也可能来自之前通过迭代加深（见3.4.4节）过程对当前移动的探索。
chap3_para648,3,,首先，搜索一层并根据它们的评估结果记录这些移动的排名。
chap3_para648,4,,然后再深入搜索一层，利用之前的排名指导移动顺序，以此类推。
chap3_para648,5,,由于迭代加深过程而增加的搜索时间可以通过更好的移动顺序来弥补。
chap3_para648,6,,这些最佳移动称为绝招（killer move），首先尝试绝招称为绝招启发式评价函数。
chap3_para649,1,,在3.3.3节中，我们指出通往重复状态的冗余路径会导致搜索代价呈指数级增长，而维护一个先前到达状态的表可以解决这个问题。
chap3_para649,2,,在博弈树搜索中，重复状态的产生是由于换位（transposition）——移动序列的不同排列最终导致相同的局面，这个问题可以通过换位表（transposition table）解决，它将缓存状态的启发式值。
chap3_para65,1,The state space for this problem is infinite: for any integer greater than 2 the factorial operator will always yield a larger integer.,● 转移模型：根据运算的数学定义给出。
chap3_para65,2,The problem is interesting because it explores very large numbers: the shortest path to 5 goes through (4!,
chap3_para65,3,)!,
chap3_para65,4,"= 620,448,401,733,239,439,360,000.",
chap3_para65,5,"Infinite state spaces arise frequently in tasks involving the generation of mathematical expressions, circuits, proofs, programs, and other recursively defined objects.",
chap3_para650,1,,"例如，假设白方进行了移动w1，而黑方用b1应对，在棋盘的另一边有一个不相关的移动w2，黑方可以用b2应对，我们搜索移动序列[w1, b1, w2, b2]，将其结果状态记为s。"
chap3_para650,2,,在探索了s下面一棵较大的子树之后，我们找到了它的倒推值，并将其存储在换位表中。
chap3_para650,3,,"当我们之后搜索移动序列[w2, b2, w1, b1]时，我们再次到达s，这时我们可以在表中查找它的值而无须重复搜索。"
chap3_para650,4,,在国际象棋中，换位表非常有效，在相同时间内能到达的搜索深度将扩大一倍。
chap3_para651,1,,即使采用剪枝和精巧的移动顺序，极小化极大算法也不适用于国际象棋和围棋这样的游戏，因为在可用时间内仍然有太多状态需要探索。
chap3_para651,2,,"在关于计算机博弈的第一篇论文“Programming a Computer for Playing Chess”（Shannon, 1950）中，克劳德·香农意识到这一问题，并提出了两种策略。"
chap3_para651,3,,A型策略（Type A strategy）考虑搜索树中某一深度的所有可能的移动，然后使用启发式评价函数估计该深度下状态的效用值。
chap3_para651,4,,它探索了树的宽但浅的部分。
chap3_para651,5,,B型策略（Type B strategy）舍弃了那些看起来就很差的移动，“尽可能”走那些更有可能的路线。
chap3_para651,6,,它探索了树的深但窄的部分。
chap3_para652,1,,历史上，大多数国际象棋程序都是A型策略（我们将在5.3节讨论），而围棋程序通常是B型策略（将在5.4节讨论），因为围棋的分支因子要高得多。
chap3_para652,2,,"最近，B型程序在各种游戏中都达到了世界冠军级水平，包括国际象棋（Silver et al., 2018）。"
chap3_para653,1,,5.3　启发式树搜索
chap3_para654,1,,为了充分利用有限的计算时间，我们可以提前截断搜索，并对状态应用启发式评价函数，从而有效地将非终止节点转变为终止节点。
chap3_para654,2,,换句话说，我们用Eval函数代替Utility函数，Eval对状态效用值进行估计。
chap3_para654,3,,用截断测试（cutoff test）代替终止测试，对于终止状态，截断测试必定返回真，但是它可以根据搜索深度和当前状态的任意属性自由决定何时终止搜索。
chap3_para654,4,,"这样我们得到了搜索深度d处状态s的启发式极小化极大值的计算公式H-Minimax(s, d)："
chap3_para655,1,,5.3.1　评价函数
chap3_para656,1,,"就像第3章的启发式函数返回到目标距离的估计值一样，启发式评价函数Eval(s, p)向参与者p返回状态s的期望效用的估计值。"
chap3_para656,2,,"对于终止状态，一定是Eval(s, p) = Utility(s, p)，而对于非终止状态，估计值必须介于输和赢之间：。"
chap3_para657,1,,除了满足这些需求之外，一个好的评价函数是由什么组成的？
chap3_para657,2,,首先，计算时间不能太长！
chap3_para657,3,,（重点是加快搜索速度。
chap3_para657,4,,）其次，评价函数应与实际的获胜机会密切相关。
chap3_para657,5,,你可能会对“获胜机会”一词感到疑惑。
chap3_para657,6,,毕竟，国际象棋并不是一种碰运气的游戏：我们确定地知道当前的状态，博弈没有任何随机性；如果双方都没有犯错，结果是预先确定的。
chap3_para657,7,,但是，如果搜索必须在非终止状态截断，那么算法对这些状态的最终结果必然是不确定的（即使这种不确定性可以通过提供无限的计算资源来解决）。
chap3_para658,1,,让我们把这一思想进一步具体化。
chap3_para658,2,,大多数评价函数需要计算状态的各种特征（feature），例如，在国际象棋中，我们将拥有白兵数目、黑兵数目、白后数目、黑后数目等特征。
chap3_para658,3,,这些特征合在一起，定义了状态的各种类别或等价类：同一类别中的状态，对所有特征都具有相同值。
chap3_para658,4,,例如，某一类别包含所有的“两兵对一兵”残局。
chap3_para658,5,,任何给定类别都可能包含一些通往（以完美玩法）胜利的状态，一些通往平局的状态和一些通往失败的状态。
chap3_para659,1,,评价函数不知道到底是处于哪种状态，但它可以返回一个值来估计每个结果的状态比例。
chap3_para659,2,,例如，假设我们的经验表明，在“两兵对一兵”类中，82%的状态通向胜利（效用值+1），2%导致失败（效用值0），16%为平局（效用值1/2）。
chap3_para659,3,,那么，该类别中状态的合理评估为期望值（expected value）：(0.82×+1) + (0.02×0) + (0.16×1/2) = 0.90。
chap3_para659,4,,原则上，可以为每一个状态类确定一个期望值，这样我们就得到了适用于任何状态的评价函数。
chap3_para66,1,3.,● 目标状态：所求的正整数。
chap3_para66,2,2.,
chap3_para66,3,2Real-world problems,
chap3_para660,1,,在实践中，这种方法需要分析太多类别，因此需要非常多的经验去估计所有的可能性。
chap3_para660,2,,与上述方法不同，大多数评价函数会分别计算每个特征的数值贡献，将它们结合起来得到总数值。
chap3_para660,3,,几个世纪以来，国际象棋棋手们已经提出了一些使用这一思想评估局面价值的方法。
chap3_para660,4,,例如，国际象棋入门书籍给出了各个棋子的子力价值（material value）估计：兵值1分，马或象值3分，车值5分，后值9分。
chap3_para660,5,,其他特征，如“好的兵阵”和“王的安全”可能值半个兵。
chap3_para660,6,,这些特征值简单地相加即可得到局面的评估值。
chap3_para661,1,,数学上，这种评价函数称为加权线性函数（weighted linear function），因为它可以表示为如下形式：
chap3_para662,1,,其中fi是局面的某一特征（例如“白象数目”），wi是其权重（表明该特征的重要性）。
chap3_para662,2,,权重需要归一化，使总和始终保持在输（0）到赢（+1）的范围内。
chap3_para662,3,,如图5-8a所示，一个兵的确定优势提供了很大的获胜可能性，而3个兵的确定优势则几乎必胜。
chap3_para662,4,,之前提到，评价函数应与实际的获胜机会密切相关，但并不需要线性相关：如果状态s获胜的可能性是状态s'的两倍，并不意味着Eval(s)必须是Eval(s')的两倍，只需要Eval(s) Eval(s')。
chap3_para663,1,,将特征的值相加似乎是合理的，但实际上它涉及一个很强的假设：每个特征的贡献独立于其他特征的值。
chap3_para663,2,,因此，目前的国际象棋和其他游戏程序也会使用特征的非线性组合。
chap3_para663,3,,例如，一对象的价值可能比单个象价值的两倍还要大，并且在残局时，象比之前价值更大，即当移动数这一特征很大或剩余棋子数这一特征很小时。
chap3_para664,1,,如何得到特征和权重？
chap3_para664,2,,它们不属于国际象棋规则，而是来自人类下棋的经验。
chap3_para664,3,,在没有这种经验的游戏中，评价函数的权重可以通过第22章的机器学习技术来估计。
chap3_para664,4,,将这些技术应用到国际象棋中，结果表明一个象确实相当于大约3个兵，而且似乎几个世纪的人类经验都可以在短短几小时的机器学习中被复制。
chap3_para665,1,,图5-8　两个国际象棋局面，只有右下角车的位置不同。
chap3_para665,2,,在（a）中，黑方有一个马两个兵的优势，这足以取胜。
chap3_para665,3,,在（b）中，白方将吃掉对方的皇后，这几乎是必胜的优势
chap3_para666,1,,5.3.2　截断搜索
chap3_para667,1,,下一步是修改Alpha-Beta-Search，让它在合适的时候调用启发式Eval函数截断搜索。
chap3_para667,2,,我们把图5-7中提到Is-Terminal的两行代码替换为下面这行代码：
chap3_para668,1,,我们还必须记录一些信息，这样在每一次递归调用时可以逐渐增加当前的depth。
chap3_para668,2,,"控制搜索量最直接的方法是设置一个固定的深度限制，这样的话，对所有大于固定深度d的depth（以及所有终止状态），Is-Cutoff(state, depth)都返回true。"
chap3_para668,3,,深度d的选择取决于分配时间内所选择的移动。
chap3_para668,4,,更稳健的方法是使用迭代加深（见第3章）。
chap3_para668,5,,当时间耗尽时，程序将返回最深的已完成搜索所选择的移动。
chap3_para668,6,,如果在每一轮迭代加深中，我们都维护换位表中的条目，那么作为奖励，后续轮次的速度将加快，我们可以使用评估值改进移动顺序。
chap3_para669,1,,由于评价函数只是一种近似，这些简单方法可能导致误差。
chap3_para669,2,,重新考虑象棋中基于子力优势的简单评价函数。
chap3_para669,3,,假设程序搜索到达了深度限制，例如到达图5-8b中的局面，即黑方多了一个马、两个兵。
chap3_para669,4,,程序会将其报告为该状态的启发式值，从而认为该状态很可能导致黑方获胜。
chap3_para669,5,,但其实白方下一步就可以不留退路地吃掉黑方的皇后。
chap3_para669,6,,因此，这个局面实际上对白方有利，但这只有通过向前看才能知道。
chap3_para67,1,We have already seen how the route-finding problem is defined in terms of specified locations and transitions along edges between them.,
chap3_para67,2,Route-finding algorithms are used in a variety of applications.,
chap3_para67,3,"Some, such as Web sites and in-car systems that provide driving directions, are relatively straightforward extensions of the Romania example.",
chap3_para67,4,"(The main complications are varying costs due to traffic-dependent delays, and rerouting due to road closures.",
chap3_para67,5,") Others, such as routing video streams in computer networks, military operations planning, and airline travel-planning systems, involve much more complex specifications.",
chap3_para67,6,Consider the airline travel problems that must be solved by a travel-planning Web site:,
chap3_para670,1,,评价函数只能应用于静态（quiescent）局面，也就是说，在这些局面中不存在会使评估值大幅度摇摆变化的待定移动（例如吃掉皇后）。
chap3_para670,2,,对于非静态局面，Is-Cutoff将返回false，并继续搜索直到到达静态局面。
chap3_para670,3,,这种额外的静态搜索（quiescence search）有时会被进一步限制为只考虑特定类型的移动（例如吃子），它能快速消除当前局面的不确定性。
chap3_para671,1,,视野效应（horizon effect）则更难消除。
chap3_para671,2,,它是指程序面临一个将给我方造成严重损失而且基本无法避免的对方移动，但可以使用拖延战术暂时避开。
chap3_para671,3,,考虑图5-9中的国际象棋局面。
chap3_para671,4,,很明显，黑象已经无路可逃。
chap3_para671,5,,例如，白车可以通过依次移动到h1、a1、a2吃掉黑象，在第6步完成吃子。
chap3_para672,1,,但黑方确实可以采取一系列移动，将象被吃掉这一结果推向“视野”以外。
chap3_para672,2,,假设黑方搜索深度为8层。
chap3_para672,3,,黑方的大多数出招都会导致象最终被吃掉，因此被标记为“坏招”。
chap3_para672,4,,但黑棋也会考虑这样的移动序列，即先用兵来阻挡王，引诱王去吃兵。
chap3_para672,5,,然后黑方可以同样地处理第二个兵。
chap3_para672,6,,上述过程占用了太多步，在剩余的搜索步数内，象不会被吃掉。
chap3_para672,7,,黑方自认为这一策略用两个兵保住了象，但实际上它所做的只是白白浪费了兵，象被吃掉是不可避免的，只是被推到了黑方能搜索到的视野之外。
chap3_para673,1,,缓解视野效应的一种策略是允许单步延伸（singular extension），该策略是说，即使搜索本应在此状态截断，但是，如果在给定局面中有比其他所有移动都“明显更好”的一种移动，我们就允许算法继续沿着这个移动延伸搜索。
chap3_para673,2,,在我们的例子中，搜索将发现白车的3次移动——h2到h1，h1到a1，从a1吃掉a2处的象——依次都是明显更好的移动，因此，即使兵的某个移动序列将搜索推到视野之外，这些明显更好的移动将有机会被延伸搜索。
chap3_para673,3,,这会使树变得更深，但由于单步延伸通常很少，这一策略并不会增加很多节点，在实践中，它已被证明是有效的。
chap3_para674,1,,图5-9　视野效应。
chap3_para674,2,,黑方移动后，黑象注定难逃厄运。
chap3_para674,3,,但是黑方可以用兵来阻挡白方的王，引诱王去吃掉兵。
chap3_para674,4,,这会将不可避免的象的损失推到视野之外，因此，搜索算法将牺牲兵的这一步看作“好招”
chap3_para675,1,,5.3.3　前向剪枝
chap3_para676,1,,剪枝将剪掉对最终评估没有影响的树的分支，但前向剪枝（forward pruning）将剪掉那些看上去很糟糕但也可能实际很好的移动。
chap3_para676,2,,因此，这一策略以出错风险增大的代价节省了计算时间。
chap3_para676,3,,用香农的话说，这是B型策略。
chap3_para676,4,,显然，大多数人类棋手都会这么做，仅考虑每个局面的几步移动（至少是潜意识地）。
chap3_para677,1,,前向剪枝的一种方法是束搜索（见4.1.3节）：在每一层，只考虑一“束”n个最佳移动（根据评价函数），而不是所有可能的移动。
chap3_para677,2,,遗憾的是，这种方法相当危险，因为无法保证最佳移动不被剪枝。
chap3_para678,1,,"ProbCut（概率截断，probabilistic cut）算法（Buro, 1995）是搜索的前向剪枝版本，它使用从先前经验中获得的统计数据来减少最佳移动被剪除的概率。"
chap3_para678,2,,搜索将剪除所有可证明位于当前窗口之外的节点。
chap3_para678,3,,ProbCut算法则剪除有可能位于窗口之外的节点。
chap3_para678,4,,它通过执行浅层搜索计算某个节点的倒推值v，然后利用过去的经验估计树中深度为d的节点的值v位于范围之外的可能性。
chap3_para678,5,,布罗（Buro）将这种技术应用到了他的黑白棋程序Logistello，发现即使常规版本的黑白棋程序拥有两倍的可用时间，ProbCut版本依然以64%的获胜率击败了常规版本。
chap3_para679,1,,另一种技术，即后期移动缩减（late move reduction）技术，假设移动顺序已经调整好，因此在可能的移动的列表中后期才出现的移动不太可能是好的移动。
chap3_para679,2,,这一技术没有将后期的移动完全删除，只是减少了搜索这些移动的深度，从而节省了时间。
chap3_para679,3,,如果缩减后的搜索返回的值高于当前值，我们可以重新运行全深度搜索。
chap3_para68,1,"•States: Each state obviously includes a location (e.g., an airport) and the current time. Furthermore, because the cost of an action (a flight segment) may depend on previous segments, their fare bases, and their status as domestic or international, the state must record extra information about these “historical” aspects.",这一问题的状态空间是无限的：对于任意大于2的整数，阶乘操作总是产生一个更大的整数。
chap3_para68,2,,这个问题很有趣，因为它探索了非常大的数字：从4到5的最短路径生成了数字(4!)! = 620 448 401 733 239 439 360 000。
chap3_para68,3,,无限状态空间经常出现在涉及数学表达式生成、电路、证明、程序和其他递归定义对象的任务中。
chap3_para680,1,,结合本章介绍的所有技术，可以得到一个国际象棋（或其他游戏）程序。
chap3_para680,2,,我们假设，已经实现了一个国际象棋评价函数——一个使用静态搜索的合理截断测试。
chap3_para680,3,,我们还假设，经过几个月的努力，可以在最新的个人计算机上每秒生成并评估大约100万个节点。
chap3_para680,4,,国际象棋的分支因子平均约为35，而355约等于5000万，因此，如果我们使用极小化极大搜索，在大约1分钟的计算时间内只能向前搜索5层。
chap3_para680,5,,按照比赛规则，我们没有足够的时间去搜索第6层。
chap3_para680,6,,平均水平的人类棋手就可以击败这样的程序，因为他们偶尔会向前规划6～8步。
chap3_para681,1,,通过搜索和大型换位表，我们可以向前搜索大约14层，已经到达了专家级水平。
chap3_para681,2,,我们可以将个人计算机换成一台拥有8个GPU的工作站，每秒可以计算超过10亿个节点，但如果要达到大师级水平，还需要一个经过精心调整的评价函数和一个存储残局招式的大型数据库。
chap3_para681,3,,像Stockfish这样的顶级国际象棋程序拥有所有这些功能，它在搜索树中通常能达到超过30的深度，远远超过任何一个人类棋手的能力。
chap3_para682,1,,5.3.4　搜索和查表
chap3_para683,1,,对一个国际象棋程序来说，开局就考虑一个包含10亿个博弈状态的树似乎有些过犹不及：漫长的搜索得出的结论仅仅是将兵放到e4（最常见的第一步）。
chap3_para683,2,,"一个世纪以来，许多国际象棋书籍都介绍了如何下好开局和残局（Tattersall, 1911）。"
chap3_para683,3,,因此，许多游戏程序使用查表而非搜索来处理开局和残局也就不足为奇了
chap3_para684,1,,对于开局，计算机主要依靠人类的专业知识。
chap3_para684,2,,可以从书中复制人类专家关于如何打好每个开局的最佳建议并将其输入表中供计算机使用。
chap3_para684,3,,此外，计算机还可以从以前玩过的游戏的数据库中收集统计数据，以判断哪种开局最容易取胜。
chap3_para684,4,,最开始的几步可能的局面很少，大多数局面都能存储在表中。
chap3_para684,5,,通常，移动10～15步后，我们会到达一个很少见到的局面，程序必须从查表切换到搜索。
chap3_para685,1,,在游戏接近结束时，可能的局面又变少，因此更容易查表。
chap3_para685,2,,这是计算机的专长：计算机对残局的分析能力远远超过了人类。
chap3_para685,3,,新手玩家按照一些简单的规则就能在王、车对王（KRK）残局中获胜。
chap3_para685,4,,而其他残局，例如王、象、马对王（KBNK），则很难掌握，也不存在简明的策略。
chap3_para686,1,,另外，计算机可以通过生成一种策略完全解决残局问题，这一策略是从每种可能状态到该状态下最佳移动的映射。
chap3_para686,2,,这样计算机就可以在这个表中查到正确移动从而完美完成棋局。
chap3_para686,3,,这个表由逆向（retrograde）极小化极大搜索构建：首先考虑在棋盘上放置KBNK的所有方法。
chap3_para686,4,,有些局面是白方获胜，将它们标为“赢”。
chap3_para686,5,,然后反转国际象棋规则，做逆向移动。
chap3_para686,6,,无论黑方的应对是什么，白方的任何一步最终位于“赢”局面的移动，都标为“赢”。
chap3_para686,7,,继续上述搜索，直到所有可能局面都被解析为赢、输或平局，这样就得到了一个包含所有KBNK残局的准确无误的查询表。
chap3_para686,8,,这种做法不仅适用于KBNK残局，也适用于所有棋子数不超过7的残局，这样的表格包含400万亿个状态。
chap3_para686,9,,棋子数为8的表则包含40 000万亿个状态。
chap3_para687,1,,5.4　蒙特卡罗树搜索
chap3_para688,1,,对围棋来说，启发式树搜索有两个主要缺点：首先，围棋的分支因子开始时为361，这意味着搜索被限制在4～5层。
chap3_para688,2,,其次，很难为围棋定义一个好的评价函数，因为子力价值并不是一个强有力的指标，而且大多数状态直到最后阶段都在不断变化。
chap3_para688,3,,为了应对这两个挑战，现代围棋程序已经放弃了搜索，而是使用一种称为蒙特卡罗树搜索（Monte Carlo tree search，MCTS）的策略。
chap3_para688,4,,[5]
chap3_para69,1,•Initial state: The user’s home airport.,3.2.2　真实世界问题
chap3_para690,1,,[5]　“蒙特卡罗”算法是以摩纳哥蒙特卡罗赌场命名的随机算法。
chap3_para691,1,,基本的MCTS策略不使用启发式评价函数。
chap3_para691,2,,相反，状态值是根据从该状态开始的多次完整博奕模拟（simulation）的平均效用值估算的。
chap3_para691,3,,一次模拟（也被称为一个playout或rollout）先为一个参与者选择移动，接着为另一个参与者选择，重复上述操作直到到达某个终止局面。
chap3_para691,4,,这时，博弈规则（而非不可靠的启发式）决定输赢以及比分。
chap3_para691,5,,对于那些只有输赢两种结果的博弈，“平均效用值”为“获胜百分比”。
chap3_para692,1,,在模拟中我们如何选择要采取的移动？
chap3_para692,2,,如果只是随机选择，那么多次模拟之后，我们仅能得到“如果两个参与者都随机选择，那么最佳移动是什么？
chap3_para692,3,,”这一问题的答案。
chap3_para692,4,,对于一些简单游戏，这恰好与“如果两名参与者都玩得很好，那么最佳移动是什么？
chap3_para692,5,,”的答案相同，但对大多数游戏却并非如此。
chap3_para692,6,,为了从模拟中获得有用信息，我们需要一个模拟策略（playout policy），使其偏向于好的行动。
chap3_para692,7,,对围棋和其他游戏来说，人们已经使用神经网络成功地从自我对弈中学习到了模拟策略。
chap3_para692,8,,有时还会根据游戏的不同，使用不同的启发式方法，如国际象棋中的“考虑吃子”，或黑白棋中的“占据角落”。
chap3_para693,1,,给定了模拟策略，我们接下来需要决定两件事：从什么局面开始模拟，以及分配给每个局面多少次模拟？
chap3_para693,2,,最简单的答案是纯蒙特卡罗搜索（pure Monte Carlo search），即从博弈当前状态开始做N次模拟，并记录从当前局面开始哪一种可能移动胜率最高。
chap3_para694,1,,对于一些随机游戏，随着N的增加，这一策略会收敛到最优策略，但对大多数博弈来说，这还不够——我们需要一个选择策略（selection policy），有选择地将计算资源集中在博弈树的重要部分上。
chap3_para694,2,,选择策略需要平衡两个因素以做出更准确的估计：对那些模拟次数很少的状态的探索（exploration），以及对那些在过去的模拟中表现良好的状态的利用（exploitation）。
chap3_para694,3,,（有关探索/利用权衡的更多信息，请参阅17.3节。
chap3_para694,4,,）蒙特卡罗树搜索维护一个搜索树，它在每次迭代（包含以下4个步骤）中不断增长，如图5-10所示。
chap3_para695,1,,图5-10　使用蒙特卡罗树搜索（MCTS）选择移动的算法的一次迭代，该算法使用“应用于树搜索的置信上界”法（UCT）作为选择度量，此时已完成了100次迭代。
chap3_para695,2,,（a）选择移动，沿着树一直向下，到标记为27/35（35次模拟中黑方赢了27次）的叶节点结束。
chap3_para695,3,,（b）扩展所选节点并进行模拟，最终黑方获胜。
chap3_para695,4,,（c）将模拟结果沿树反向传播
chap3_para696,1,,● 选择：从搜索树的根节点开始，选择一个移动（在选择策略的指导下），到达一个后继节点，然后重复该过程，沿着树向下移动到叶节点。
chap3_para696,2,,图5-10a为一棵搜索树，根表示白方刚刚移动的状态，到目前为止，白方已经在100次模拟中赢了37次。
chap3_para696,3,,粗箭头表示黑方选择的移动，在它指向的节点上黑方赢了60/79次。
chap3_para696,4,,这是3种移动中最高的胜率，所以选择它是一次利用。
chap3_para696,5,,但为了探索，选择2/11节点也是合理的——只有11次模拟，该节点的估值仍有很高的不确定性，如果我们获得更多相关信息，它最终可能是最好的。
chap3_para696,6,,继续选择直到到达标有27/35的叶节点。
chap3_para697,1,,● 扩展：我们通过为所选节点生成一个新的子节点的方式增长搜索树，图5-10b中展示了标记为0/0的新节点。
chap3_para697,2,,（一些版本在这一步中会生成多个子节点。
chap3_para697,3,,）
chap3_para698,1,,● 模拟：我们从新生成的子节点开始执行一次模拟，根据模拟策略为两个参与者选择移动。
chap3_para698,2,,这些移动不会记录在搜索树中。
chap3_para698,3,,在图中，模拟结果为黑方获胜。
chap3_para699,1,,● 反向传播：我们现在使用模拟结果自底向上地更新所有搜索树节点。
chap3_para699,2,,因为这次模拟的结果是黑方获胜，所以黑方节点的获胜次数和模拟次数都会增加，27/35变为28/36，60/79变为61/80。
chap3_para699,3,,因为白方失败，其节点只增加模拟次数，所以16/53变为16/54，根节点的37/100变为37/101。
chap3_para7,1,3.,想象一下，一个智能体正在罗马尼亚度假。
chap3_para7,2,1Problem-Solving Agents,它想参观景点，想学习罗马尼亚语，想享受罗马尼亚的夜生活但又不想宿醉，等等。
chap3_para7,3,,这一决策问题是复杂的。
chap3_para7,4,,现在，假设智能体目前位于Arad，并且买了一张第二天从Bucharest起飞且不能退款的机票。
chap3_para7,5,,智能体观察路牌后发现，从Arad出发有3条路：一条通往Sibiu，一条通往Timisoara，还有一条通往Zerind。
chap3_para7,6,,但这都不是它的目的地，所以除非智能体熟悉罗马尼亚的地理环境，不然它不知道该走哪条路。
chap3_para7,7,,[1]
chap3_para70,1,"•Actions: Take any flight from the current location, in any seat class, leaving after the current time, leaving enough time for within-airport transfer if needed.",我们已经了解了如何根据指定的位置和沿着它们之间的边进行的位置转移来定义寻径问题（route-finding problem）。
chap3_para70,2,,寻径算法有许多应用场景。
chap3_para70,3,,其中一些是上文中罗马尼亚例子的直接扩展，例如提供导航的网站和车载系统等。
chap3_para70,4,,（需要考虑的主要复杂因素是因与交通相关的延迟而导致的代价变化，以及因道路封闭而导致的路线变更。
chap3_para70,5,,）另一些例如计算机网络中的视频流路由、军事行动规划和飞机航线规划系统等，则更加复杂。
chap3_para70,6,,下面介绍旅行规划网站必须解决的航空旅行问题。
chap3_para700,1,,我们在固定次数的迭代中重复这4个步骤，或者迭代到所分配的时间耗尽，然后返回模拟次数最多的移动。
chap3_para701,1,,一种非常有效的选择策略称为“应用于树搜索的置信上界”，即UCT。
chap3_para701,2,,它根据称为UCB1的置信上界公式对每个可能的移动排序。
chap3_para701,3,,（详见17.3.3节。
chap3_para701,4,,）对节点n来说，公式为
chap3_para702,1,,其中U(n)为经过节点n的所有模拟的总效用值，N(n)是经过节点n的模拟次数，Parent(n)是树中n的父节点。
chap3_para702,2,,因此为利用项，即节点n的平均效用值。
chap3_para702,3,,带有平方根的项是探索项：分母为N(n)，这意味着对只探索过几次的节点来说，这一项的值比较高；分子记录了我们对n的父节点的探索次数，这意味着，如果我们选择n的概率不是0，那么随着计数的增加，探索项会趋于零，最终模拟次数将被分配给平均效用值最高的节点。
chap3_para703,1,,C是一个平衡利用和探索的常数。
chap3_para703,2,,有一种理论认为C应该是，但在实践中，程序员会尝试多个C值，从中选择一个表现最好的。
chap3_para703,3,,（有些程序则使用一些稍微不同的公式。
chap3_para703,4,,例如，AlphaZero增加了一个行动概率项，由根据之前的自我对弈训练得到的神经网络计算。
chap3_para703,5,,）当C = 1.4时，图5-10中60/79节点的UCB1值最高，而当C = 1.5时，2/11节点分值最高。
chap3_para704,1,,图5-11给出了完整的UCT MCTS算法。
chap3_para704,2,,当迭代终止时，算法返回模拟次数最多的移动。
chap3_para704,3,,你可能认为应该返回平均效用值最高的节点，但算法的思想是获胜65/100次的节点优于获胜2/3次的节点，因为后者有很多不确定性。
chap3_para704,4,,在任何情况下，UCB1公式确保模拟次数最多的节点几乎总是拥有最高的获胜概率，因为随着模拟次数的增加，选择过程将越来越偏向获胜概率。
chap3_para705,1,,图5-11　蒙特卡罗树搜索算法。
chap3_para705,2,,首先，初始化博弈树tree，然后重复Select/Expand/Simulate/Back-Propagate的循环，直到时间耗尽，最后返回指向模拟次数最多的节点的移动
chap3_para706,1,,计算一次模拟结果的时间对博弈树的深度来说是线性的，而不是指数级的，因为在每个选择点上只采用一个移动。
chap3_para706,2,,这样我们就有足够的时间进行多次模拟。
chap3_para706,3,,例如，假设有一个分支因子为32的博弈，博弈平均持续100步。
chap3_para706,4,,如果我们有足够的计算能力可以在执行移动前考虑10亿个博弈状态，那么极小化极大算法可以搜索6层深度，具有完美行动顺序的算法可以搜索12层深度，蒙特卡罗搜索算法可以搜索1000万次模拟。
chap3_para706,5,,哪种方法更好呢？
chap3_para706,6,,这取决于所用的启发式函数与选择策略、模拟策略的准确性的高下。
chap3_para707,1,,传统观点认为，对于围棋这种分支因子非常高（因此搜索不够深）或者很难定义一个好的评价函数的游戏，蒙特卡罗搜索要优于搜索。
chap3_para707,2,,考虑到对手的目标是最小化得分，搜索将选择指向可实现评价函数得分最高的节点的路径。
chap3_para707,3,,因此，如果评价函数不准确，搜索也会不准确。
chap3_para707,4,,对单个节点的错误计算可能导致搜索错误地选择（或避开）指向该节点的路径。
chap3_para707,5,,而蒙特卡罗搜索依赖于多次模拟的聚合，因此不容易受到单次错误的影响。
chap3_para707,6,,我们也可以将MCTS和评价函数结合起来：对一定数量的移动进行模拟，然后截断模拟，并在截断的节点上应用评价函数。
chap3_para708,1,,也可以将搜索和蒙特卡罗搜索结合。
chap3_para708,2,,例如，在可以持续很多步的博弈中，我们可能希望提前终止模拟（early playout termination），即终止持续太多步的模拟，并使用启发式评价函数对其进行评估，或者干脆宣布平局。
chap3_para709,1,,蒙特卡罗搜索可以应用于没有任何经验可以用来定义评价函数的全新博弈。
chap3_para709,2,,只要我们知道博弈规则，蒙特卡罗搜索不需要任何附加信息。
chap3_para709,3,,选择和模拟策略可以充分利用人工制定的专家知识，也可以通过仅仅使用自我对弈训练得到的神经网络来学习好的策略。
chap3_para71,1,•Transition model: The state resulting from taking a flight will have the flight’s destination as the new location and the flight’s arrival time as the new time.,● 状态：每个状态显然包括当前位置（例如，某个机场）和当前时间。
chap3_para71,2,,此外，由于每个动作（一个航段）的代价可能依赖于之前的航段、票价基础以及它们是国内航班还是国际航班，状态必须记录这些额外的“历史”信息。
chap3_para710,1,,当单步移动可以改变游戏进程时，蒙特卡罗搜索存在缺陷，因为蒙特卡罗搜索的随机性意味着它可能不会考虑这一移动。
chap3_para710,2,,换句话说，蒙特卡罗搜索中的B型剪枝意味着它可能根本没有探索关键路线。
chap3_para710,3,,当博弈状态“明显”是一方或另一方获胜时（根据人类的知识和评价函数），蒙特卡罗搜索也存在缺陷，它仍然需要模拟很多步来验证获胜者。
chap3_para710,4,,长期以来，人们一直认为，在国际象棋等具有较低分支因子和较好评价函数的游戏中，搜索更好。
chap3_para710,5,,但最近，蒙特卡罗方法在国际象棋及其他游戏中也取得了成功。
chap3_para711,1,,模拟未来的行动，观测结果，并根据结果来确定哪些行动是好的，这样的一般思想其实就是一种强化学习思想，我们将在第22章中介绍。
chap3_para713,1,,包含随机因素（例如掷骰子）的随机博弈（stochastic game）使我们更接近现实生活的不可预测性。
chap3_para713,2,,西洋双陆棋是一种典型的运气和技巧相结合的随机游戏。
chap3_para713,3,,在图5-12的西洋双陆棋局面中，黑方掷出“6-5”，有4种可能走法［每种走法将一个棋子向前（顺时针）移动5步，另一个棋子向前移动6步］。
chap3_para714,1,,图5-12　一个典型的西洋双陆棋局面。
chap3_para714,2,,游戏的目标是把自己的所有棋子移出棋盘。
chap3_para714,3,,黑方向25顺时针移动，白方向0逆时针移动。
chap3_para714,4,,一个棋子可以移动到任何位置，除非那里有多个对方棋子；如果只有一个对方棋子，对方棋子就会被吃掉，然后必须从起点重新开始。
chap3_para714,5,,"图中所示的局面，黑棋已经掷出了6-5，必须从(5−11, 5−10)、(5−11, 19−24)、(5−10, 10−16)和(5−11, 11−16)这4种合法移动中选择，其中符号(5−11, 11−16)表示将一个棋子从位置5移动到位置11，另一个棋子从位置11移动到位置16"
chap3_para715,1,,此时，黑方知道可以走什么棋，但不知道白方会掷出什么，因此也不知道白方的合法移动会是什么。
chap3_para715,2,,这意味着黑方无法构建我们在国际象棋和井字棋中看到的那种标准博弈树。
chap3_para715,3,,西洋双陆棋的博弈树除了max和min节点外，还必须包括机会节点（chance node）。
chap3_para715,4,,机会节点如图5-13中的圆圈所示。
chap3_para715,5,,从每个机会节点引出的分支表示可能掷出的骰子点数，每个分支都标有掷出的点数及其概率。
chap3_para715,6,,两个骰子有36种组合，每一种都是等可能的，但是，因为6-5和5-6是一样的，所以只有21种不同的点数组合。
chap3_para715,7,,6个点数相同的组合（1-1到6-6）的概率都是1/36，即P(1−1) = 1/36。
chap3_para715,8,,其他15种不同组合的概率都是1/18。
chap3_para716,1,,图5-13　西洋双陆棋局面的博弈树图解
chap3_para717,1,,下一步是了解如何做出正确决策。
chap3_para717,2,,显然，我们仍然想选择能够到达最佳局面的那一步棋。
chap3_para717,3,,然而，局面没有明确的极小化极大值。
chap3_para717,4,,我们只能计算局面的期望值（expected value）：机会节点所有可能结果的平均值。
chap3_para718,1,,可以将确定性博弈的极小化极大值推广为包含机会节点的博弈的期望极小化极大值（expectiminimax value）。
chap3_para718,2,,终止节点、max节点和min节点的工作方式与之前完全相同（注意，max和min的合法移动取决于前一个机会节点的掷骰子结果）。
chap3_para718,3,,对于机会节点，我们则计算期望值，即用每个机会动作的概率加权的所有结果的值之和：
chap3_para719,1,,"其中，r表示可能的掷骰子结果（或其他概率事件），而Result(s, r)仍表示状态s，附加了掷骰子结果r。"
chap3_para72,1,"•Goal state: A destination city. Sometimes the goal can be more complex, such as “arrive at the destination on a nonstop flight.”",● 初始状态：用户家所在的机场。
chap3_para721,1,,和极小化极大算法一样，可以通过在某点截断搜索并对每个叶节点应用评价函数来近似估计期望极小化极大值。
chap3_para721,2,,有人可能会认为，西洋双陆棋等游戏的评价函数应该与国际象棋的评价函数类似——更好的局面得分更高。
chap3_para721,3,,但事实上，机会节点的存在意味着我们必须更加仔细地定义这些值。
chap3_para722,1,,"图5-14表明：如果评价函数给叶节点分配的值为[1, 2, 3, 4]，那么移动a1是最佳的；如果值为[1, 20, 30, 400]，移动a2是最佳的。"
chap3_para722,2,,因此，如果我们更改一些评估值，即使优先顺序保持不变，程序的选择也会完全不同。
chap3_para723,1,,图5-14　在保持叶节点值排序不变的情况下，不同的叶节点赋值改变了最佳移动
chap3_para724,1,,为了避免这一问题，评价函数应该返回获胜概率（对于结果非输或赢的博弈返回的是期望效用值）的正线性变换值。
chap3_para724,2,,这是在不确定性下非常重要和普遍的性质，将在第16章进一步讨论。
chap3_para725,1,,如果程序事先知道游戏接下来的所有掷骰子结果，那么求解有骰子的游戏和求解没有骰子的游戏是一样的，即极小化极大算法的时间复杂度为O(bm)，其中b为分支因子，m为博弈树的最大深度。
chap3_para725,2,,因为期望极小化极大值还要考虑所有可能的掷骰子序列，它的时间复杂度为O(bmnm)，其中n是掷骰子的不同结果的数目。
chap3_para726,1,,即使将搜索深度限制在某个很小的值d内，与极小化极大算法相比，额外代价的存在也使得在大多数机会博弈中向前看很远是不现实的。
chap3_para726,2,,在西洋双陆棋中，n是21，b通常是20左右，但在某些情况下，骰子数翻倍，b可能高达4000。
chap3_para726,3,,我们大概只能搜索3层。
chap3_para727,1,,换一种方式考虑这一问题：搜索的优势在于，在采取最佳玩法的情况下它忽略了那些未来不可能发生的情况。
chap3_para727,2,,因此，它将精力集中于可能发生的情况。
chap3_para727,3,,但在一个每次移动前都要掷两个骰子的游戏中，没有可能的移动序列，即使是最有可能的移动也只在2/36的情况下出现，因为执行移动的前提是，骰子点数是正确的组合从而使该移动合法。
chap3_para727,4,,这是不确定性下的一个普遍问题：可能性急剧增多，制定详细的动作规划变得毫无意义，因为世界可能不会朝你规划的方向发展。
chap3_para728,1,,你可能会想到像剪枝这样的方法也可以应用于包含机会节点的博弈树。
chap3_para728,2,,事实证明的确可以。
chap3_para728,3,,对min和max节点的分析不变，但可以用一点聪明才智对机会节点剪枝。
chap3_para728,4,,考虑图5-13中的机会节点C，以及在计算其子节点时它的值发生了什么变化。
chap3_para728,5,,在我们检查完C的所有子节点之前是否有可能找到C的上界？
chap3_para728,6,,（回想一下，这是剪枝剪除某个节点及其子树时需要的。
chap3_para728,7,,）
chap3_para729,1,,乍一看，这似乎是不可能的，因为C的值是它子节点值的平均，为了计算一组数字的平均值，我们必须查看所有的数字。
chap3_para729,2,,但如果限制效用函数的可能值的范围，那么就可以得到平均值的范围而不需要查看每一个数字。
chap3_para729,3,,例如，假设所有效用值都在−2和+2之间，那么叶节点的值是有界的，反过来，我们就可以在不检查所有子节点的情况下为机会节点的值设置上界。
chap3_para73,1,"•Action cost: A combination of monetary cost, waiting time, flight time, customs and immigration procedures, seat quality, time of day, type of airplane, frequent-flyer reward points, and so on.",● 动作：在当前时间之后，从当前位置乘坐任意航班任意舱位起飞，如果需要，还要留出足够的时间在机场中转。
chap3_para730,1,,在机会节点分支因子较高的博弈中——考虑Yahtzee这样的游戏，即每回合掷5个骰子——你可能要考虑前向剪枝，即采样少数几个可能的机会分支。
chap3_para730,2,,或者，你可能想要完全避免使用评价函数，而选择蒙特卡罗树搜索，其中每次模拟都包含随机掷骰子。
chap3_para731,1,,5.6　部分可观测博弈
chap3_para732,1,,博比·费希尔（Bobby Fischer）认为“国际象棋就是战争”，但国际象棋缺少真实战争的一个主要特征——部分可观测性。
chap3_para732,2,,在《战争之雾》（Fog of War）游戏中，敌人的行踪往往是未知的，除非与他直接接触。
chap3_para732,3,,因此，战争中常常使用侦察兵和间谍来收集信息，用隐匿处和虚张声势来迷惑敌人。
chap3_para733,1,,部分可观测游戏也具有这些特征，因此与前文提到的游戏有本质不同。
chap3_para733,2,,像《星际争霸》这样的电子游戏尤其具有挑战性，因为它是部分可观测、多智能体、非确定性、动态且未知的。
chap3_para734,1,,在确定性部分可观测博弈中，关于棋盘状态的不确定性完全来自无法获知对手做出的选择。
chap3_para734,2,,这类博弈包括Battleship（每个玩家战舰的放置位置都对敌人隐藏）和Stratego（棋子的位置已知，但种类隐藏）这样的儿童游戏。
chap3_para734,3,,我们考虑四国军棋（Kriegspiel）游戏，它是国际象棋的部分可观测变体，即完全看不到对方的棋子。
chap3_para734,4,,其他游戏也有部分可观测版本：幻影围棋、幻影井字棋和Screen Shogi。
chap3_para735,1,,5.6.1　四国军棋：部分可观测的国际象棋
chap3_para736,1,,四国军棋的规则如下：白方和黑方各自只能看到自己一方的棋子。
chap3_para736,2,,裁判可以看到所有棋子，他对比赛进行判定并定期向双方宣布。
chap3_para736,3,,首先，白方向裁判提出合法移动（只要位置上没有黑方）。
chap3_para736,4,,如果该位置有黑方占位，裁判会宣布移动“非法”，白方不断向裁判提出下一步的走法，直到找到一个合法移动——在这个过程中也了解到了黑方的位置。
chap3_para737,1,,一旦提出了一个合法移动，裁判会宣布以下一项或多项内容：如果在X处有吃子则宣布“在X上吃子”，如果黑王被将军，则宣布“被D将军”，其中D是将军的方向，可以是“马”“行”“列”“长对角线”或“短对角线”。
chap3_para737,2,,如果黑方被将死或陷入僵局，裁判也会宣布；否则，轮到黑方行棋。
chap3_para738,1,,四国军棋看起来非常难处理，但人类可以很好地掌握它，计算机程序也开始迎头赶上。
chap3_para738,2,,回顾4.4节和图4-14中介绍的信念状态的概念——在给定目前为止所有历史感知的情况下，所有逻辑可能的棋盘状态的集合。
chap3_para738,3,,初始时，白方的信念状态只有一个元素，因为黑方还没有移动。
chap3_para738,4,,白方下了一步且黑方做出应对后，白方的信念状态就包含了20种局面，因为黑方对白方的任意一种开局都存在20种回应。
chap3_para739,1,,在游戏过程中跟踪信念状态正是状态评估问题，4.4.4节中的式（4-6）给出了更新步骤。
chap3_para739,2,,如果我们把对手看作不确定性的来源，那么可以把四国军棋的状态评估直接映射到4.4节的部分可观测的、非确定性的框架中；也就是说，白方所选移动的Results由白方自身移动带来的（可预测）结果和黑方回应给出的不可预测结果组成。
chap3_para739,3,,[6]
chap3_para74,1,"Commercial travel advice systems use a problem formulation of this kind, with many additional complications to handle the airlines’ byzantine fare structures. Any seasoned traveler knows, however, that not all air travel goes according to plan. A really good system should include contingency plans—what happens if this flight is delayed and the connection is missed?",● 转移模型：乘坐航班产生的结果状态将航班的目的地作为新的当前位置，将航班的到达时间作为新的当前时间。
chap3_para741,1,,[6]　有时，信念状态会变得非常大以至于无法仅用棋盘状态列表表示，但我们将暂时忽略这个问题，第7章和第8章将介绍大型信念状态的紧凑表示方法。
chap3_para742,1,,给定当前的信念状态，白方可能会问：“我能赢吗？
chap3_para742,2,,”对于部分可观测游戏，策略的概念会发生改变，我们不需要规定如何回应对手的每个可能移动，而是需要规定如何回应玩家可能接收到的每种可能感知序列。
chap3_para743,1,,对四国军棋来说，必胜策略或确保将死（guaranteed checkmate）是指，对于每种可能感知序列和当前信念状态中的每种可能棋盘状态，不管对手如何移动，该策略都会取胜。
chap3_para743,2,,在这种定义下，对手的信念状态无关紧要——即使对手能看到所有棋子，这一策略也必须奏效。
chap3_para743,3,,这大大简化了计算。
chap3_para743,4,,图5-15为KRK（王车对王）残局必胜策略的一部分。
chap3_para743,5,,在这种情况下，黑方只有一个棋子（王），所以可以通过在单个棋盘上标记黑王的所有可能位置来表示白方的信念状态。
chap3_para744,1,,如4.4节中所述，可以将一般的与或搜索算法应用于信念状态空间来寻找必胜策略。
chap3_para744,2,,4.4.2节提到的增量信念状态算法通常能在中盘找到深度高达9的必胜策略——这远远超过了大多数人类棋手的能力。
chap3_para745,1,,除确保将死之外，四国军棋还存在一个在完全可观测游戏中毫无意义的全新概念：概率将死（probabilistic checkmate）。
chap3_para745,2,,在信念状态中的每一种棋盘状态下，这种将死都要奏效，而概率一词则来源于获胜玩家移动的随机性。
chap3_para745,3,,要了解它的基本思想，可以考虑只用白王来捉住黑王的问题。
chap3_para745,4,,通过简单地随机移动，白王最终一定会吃掉黑王，这是因为，即使黑王总是设法逃跑，它也不可能永远都猜对正确的逃跑方向。
chap3_para745,5,,在概率论的术语中，这一事件以概率1发生。
chap3_para746,1,,在这种意义上，KBNK残局——王、象、马对王——一定会赢，白方为黑方提供一个无限的随机选择序列，黑方总是会猜错其中一个，因此暴露自己的位置，然后被将死。
chap3_para746,2,,另外，KBBK残局的获胜概率是。
chap3_para746,3,,白方要想获胜，只能移动象（此时这个象不受保护）。
chap3_para746,4,,如果黑方碰巧在正确的位置上并吃掉了象（如果象是受保护的，那么这步棋就是非法的），游戏就会变成平局。
chap3_para746,5,,白方可以在一段很长的序列中随机选择一点来走这步险棋，这样会使减小到一个任意小的常数，但无法将减小到零。
chap3_para747,1,,有时将死策略只对当前信念状态中的某些棋盘状态有效，而对其他状态无效。
chap3_para747,2,,尝试这种策略可能会成功，导致意外将死（accidental checkmate）。
chap3_para747,3,,这里的意外是指，如果黑方刚好在特定的位置，白方不会知道自己将会将死对方。
chap3_para747,4,,（在人类博弈中，大多数将死都是偶然的。
chap3_para747,5,,）这个想法自然引出了一个问题，给定策略有多大可能获胜，这又引出了一个问题，当前信念状态中的每种棋盘状态有多大可能是真正的棋盘状态。
chap3_para748,1,,图5-15　KRK残局必胜策略的一部分，图中为缩减后的棋盘。
chap3_para748,2,,在初始信念状态中，黑王位于3种可能位置之一。
chap3_para748,3,,通过一系列探索移动，该策略将黑王的范围缩小到其中一种。
chap3_para748,4,,将死策略的剩余部分留作习题
chap3_para749,1,,人们的第一倾向可能认为当前信念状态中的所有棋盘状态都是等可能的——但这是错误的。
chap3_para749,2,,例如，考虑黑方走第一步棋后白方的信念状态。
chap3_para749,3,,根据定义（假设黑方遵循最优策略），黑方一定采取了最优移动，所以由次优移动产生的所有棋盘状态的概率应该为零。
chap3_para75,1,"Touring problems describe a set of locations that must be visited, rather than a single goal destination.",● 目标状态：目的地城市。
chap3_para75,2,The traveling salesperson problem (TSP) is a touring problem in which every city on a map must be visited.,有时目标可能更复杂一点，例如“乘坐直达航班到达目的地”。
chap3_para75,3,"The aim is to find a tour with cost < C (or in the optimization version, to find a tour with the lowest cost possible).",
chap3_para75,4,An enormous amount of effort has been expended to improve the capabilities of TSP algorithms.,
chap3_para75,5,The algorithms can also be extended to handle fleets of vehicles.,
chap3_para75,6,"For example, a search and optimization algorithm for routing school buses in Boston saved $5 million, cut traffic and air pollution, and saved time for drivers and students (Bertsimas et al.",
chap3_para75,7,", 2019).",
chap3_para75,8,"In addition to planning trips, search algorithms have been used for tasks such as planning the movements of automatic circuit-board drills and of stocking machines on shop floors.",
chap3_para750,1,,这一论点也不完全正确，因为每个玩家的目标不仅仅是将棋子移动到正确的方格中，还需要最小化对手能掌握的关于自己位置的信息。
chap3_para750,2,,遵循任何可预测的“最优”策略都能为对手提供信息。
chap3_para750,3,,因此，在部分可观测博弈中，最佳玩法需要一定随机性。
chap3_para750,4,,（这也是餐厅卫生检查员进行随机检查的原因。
chap3_para750,5,,）这意味着他们偶尔要选择一些“本质上”较差的移动——但他们能从不可预测性上获益，因为对手不大可能为防御这些移动做好准备。
chap3_para751,1,,从这些考虑来看，似乎只有在给定最优随机策略的情况下，才能计算出当前信念状态中各种棋盘状态的概率；反过来，计算这一策略似乎需要知道棋盘可能处于的各种状态的概率。
chap3_para751,2,,这个难题可以利用博弈论中均衡解的概念解决，我们将在第17章中进一步探讨。
chap3_para751,3,,均衡为每个玩家指定了一个最优随机策略。
chap3_para751,4,,对四国军棋来说，计算均衡的代价太昂贵了。
chap3_para751,5,,目前，一般四国军棋游戏的有效算法设计是一个开放的研究课题。
chap3_para751,6,,大多数系统在自己的信念状态空间中执行有限深度的前瞻搜索，而不考虑对手的信念状态。
chap3_para751,7,,评价函数与完全可观测博弈的评价函数类似，但包含一个新的组成部分，信念状态大小——越小越好！
chap3_para751,8,,我们将在18.2节的博弈论主题下重新讨论部分可观测博弈。
chap3_para752,1,,5.6.2　纸牌游戏
chap3_para753,1,,桥牌、惠斯特牌、红心大战和扑克等纸牌游戏都具有随机的部分可观测性，即无法观测的信息是由随机发牌产生的。
chap3_para754,1,,乍一看，这些纸牌游戏似乎很像掷骰子：纸牌是随机分配的，并且决定了每个玩家的可能移动，但所有的“掷骰子”都发生在游戏的开始！
chap3_para754,2,,尽管将纸牌游戏类比为掷骰子是错误的，但它提出了一种算法：将游戏的开始视为一个机会节点，每一种可能的发牌视为一个结果，然后使用Expectiminimax公式选择最佳移动。
chap3_para754,3,,注意，在这种方法中，唯一的机会节点是根节点；在那之后，游戏则是完全可观测的。
chap3_para754,4,,这种方法有时被称为观测力平均，因为它假设，一旦发牌实际发生，游戏对双方都是完全可观测的。
chap3_para754,5,,尽管这种策略在直观上具有吸引力，但有可能让人误入歧途。
chap3_para754,6,,考虑下面这个故事。
chap3_para755,1,,第一天：道路A通向一桶金子，道路B通向一个岔路口。
chap3_para755,2,,你可以看到，岔路口左转是两桶金子，右转则会撞上一辆公共汽车。
chap3_para756,1,,第二天：道路A通向一桶金子，道路B通向一个岔路口。
chap3_para756,2,,你可以看到，岔路口右转是两桶金子，左转则会撞上一辆公共汽车。
chap3_para757,1,,第三天：道路A通向一桶金子，道路B通向一个岔路口。
chap3_para757,2,,你知道岔路口的一个分支通向两桶金子，另一个分支会撞上一辆公共汽车。
chap3_para757,3,,遗憾地是，你不知道哪个分支通向金子。
chap3_para758,1,,观测力平均会得出以下推论：第一天，B是正确选择；第二天，B也是正确选择；第三天，情况和第一天或第二天一样，所以B仍然是正确选择。
chap3_para759,1,,现在我们可以看出观测力平均为什么会失败：它没有考虑智能体执行行动后所处的信念状态。
chap3_para759,2,,完全忽略信念状态是不可取的，特别是当其中一种可能性是必死时。
chap3_para759,3,,因为它假设每种未来状态都自动成为一个完美知识，观测力方法从不选择那些收集信息的行动（例如图5-15中的第一个移动），也不会选择那些向对手隐藏信息或向同伴提供信息的行动，因为它假定对方已经知道这些信息。
chap3_para759,4,,在扑克游戏中，它永远不会虚张声势（bluff）[7]，因为它假设对手知道自己的牌。
chap3_para759,5,,在第17章中，我们将介绍如何构造算法解决真正的部分可观测决策问题，得到最优均衡策略（见18.2节）。
chap3_para76,1,"A VLSI layout problem requires positioning millions of components and connections on a chip to minimize area, minimize circuit delays, minimize stray capacitances, and maximize manufacturing yield.",● 动作代价：金钱成本、等待时间、飞行时间、海关和入境手续、舱位质量、当日时间、飞机类型、常旅客奖励积分等的组合。
chap3_para76,2,The layout problem comes after the logical design phase and is usually split into two parts: cell layout and channel routing.,
chap3_para76,3,"In cell layout, the primitive components of the circuit are grouped into cells, each of which performs some recognized function.",
chap3_para76,4,Each cell has a fixed footprint (size and shape) and requires a certain number of connections to each of the other cells.,
chap3_para76,5,The aim is to place the cells on the chip so that they do not overlap and so that there is room for the connecting wires to be placed between the cells.,
chap3_para76,6,Channel routing finds a specific route for each wire through the gaps between the cells.,
chap3_para76,7,"These search problems are extremely complex, but definitely worth solving.",
chap3_para761,1,,[7]　虚张声势——即使自己的手牌很差，也要装作很好——是扑克策略的核心部分。
chap3_para762,1,,尽管存在上述缺陷，观测力平均仍是一个有效策略，通过一些技巧可以使其更好地发挥作用。
chap3_para762,2,,在大多数纸牌游戏中，可能的发牌结果数量都相当大。
chap3_para762,3,,例如，在桥牌中，每个玩家只能看到四手牌中的两手，剩余两手各包含13张牌，所以可能的发牌结果有= 10 400 600种。
chap3_para762,4,,即使求解一种发牌结果也是相当困难的，所以求解1000万种更是不可能的。
chap3_para762,5,,处理这样巨大数目的一种方法是抽象（abstraction）：将相似的手牌视为相同手牌。
chap3_para762,6,,例如，手牌中的A和K非常重要，但是4或5就不那么重要了，可以将其抽象。
chap3_para763,1,,另一种处理方法是前向剪枝：只考虑一个小随机样本（样本数为N），再次计算Expectiminimax得分。
chap3_para763,2,,即使是相当小的N （例如100～1000），这种方法也能提供很好的近似值。
chap3_para763,3,,它也可以应用于确定性博弈，例如四国军棋（在四国军棋中，我们对游戏的可能的状态进行采样，而不是可能的发牌），只要我们有方法估计每个状态的可能性。
chap3_para763,4,,除了搜索整个博弈树，使用深度截断进行启发式搜索也很有帮助。
chap3_para764,1,,到目前为止，我们假设每种发牌结果的可能性相等。
chap3_para764,2,,对于惠斯特牌和红心大战，这样的假设是有意义的。
chap3_para764,3,,但是对于桥牌，比赛之前为叫牌阶段，在这个阶段中，每支队伍都会表明它要赢多少。
chap3_para764,4,,由于玩家是根据自己持有的牌出价，因此其他玩家可以了解到每种发牌结果的概率P(s)。
chap3_para764,5,,在决定如何玩这手牌时考虑这一点是很难的，原因就像我们在四国军棋的描述中所提到的：玩家在出价时，可能会尽量最小化传达给对手的信息。
chap3_para765,1,,计算机在扑克牌上的表现已经超出了人类水平。
chap3_para765,2,,在为期20天的无限注德州扑克比赛中，扑克程序Libratus与4位世界顶尖的扑克玩家展开较量，并果断地将他们全部击败。
chap3_para765,3,,因为在扑克中存在很多可能状态，Libratus使用抽象法减少状态空间：它可能会认为手牌AAA72和AAA64是等价的（它们都是“3个A和一些小牌”），并且可能认为赌200美元与赌201美元是一样的。
chap3_para765,4,,但是Libratus也会监视其他玩家，如果它发现他们正在使用抽象法，它会立即做一些额外的计算填补这个漏洞。
chap3_para765,5,,总的来说，它在超级计算机上耗费了2500万CPU小时才取得胜利。
chap3_para766,1,,Libratus的计算开销（以及AlphaZero和其他系统的开销）表明，预算有限的研究人员可能无法达到世界冠军水平。
chap3_para766,2,,从某种程度上来说，这是正确的：就像你不能指望在你的车库里用零部件组装出一辆F1冠军赛车一样，拥有超级计算机或专业硬件（如TPU）是有优势的。
chap3_para766,3,,训练一个系统时尤其如此，但训练也可以通过众包完成。
chap3_para766,4,,例如，开源LeelaZero系统是AlphaZero的复现，它通过志愿参与者计算机上的自我对弈进行训练。
chap3_para766,5,,一旦训练完成，实际比赛中的计算需求是适中的。
chap3_para766,6,,AlphaStar在使用单个GPU的商用台式计算机上赢得了《星际争霸II》比赛，而AlphaZero也可以在这种模式下运行。
chap3_para767,1,,5.7　博弈搜索算法的局限性
chap3_para768,1,,计算复杂博弈中的最优决策是非常困难的，因此所有算法都必须做出一些假设和近似。
chap3_para768,2,,搜索使用启发式评价函数作为近似，而蒙特卡罗搜索计算随机选择的模拟的近似平均值。
chap3_para768,3,,选择哪种算法在一定程度上取决于每种博弈的特征：当分支因子较高或评价函数难以定义时，首选蒙特卡罗搜索。
chap3_para768,4,,但这两种算法都存在其基本的局限性。
chap3_para769,1,,搜索的一个局限性是它容易受到启发式函数的近似误差的影响。
chap3_para769,2,,图5-16为一个二层博弈树，极小化极大搜索会选择右边的分支，因为100 99。
chap3_para769,3,,如果所有的评估值都是精确的，那么这就是正确的选择。
chap3_para769,4,,但假设每个节点的评估值都有一个独立于其他节点的随机分布的误差，其标准差为s。
chap3_para769,5,,当s = 5时，实际上71%的情况下是左侧分支更好，当s = 2时，58%的情况下左侧分支更好（因为在这些情况下，右侧分支的4个叶节点之一可能小于99）。
chap3_para769,6,,如果评价函数中的误差不是独立的，那么发生错误的可能性更大。
chap3_para769,7,,这是很难避免的，因为我们没有一个很好的兄弟节点值之间依赖关系的模型。
chap3_para77,1,"Robot navigation is a generalization of the route-finding problem described earlier. Rather than following distinct paths (such as the roads in Romania), a robot can roam around, in effect making its own paths. For a circular robot moving on a flat surface, the space is essentially two-dimensional. When the robot has arms and legs that must also be controlled, the search space becomes many-dimensional—one dimension for each joint angle. Advanced techniques are required just to make the essentially continuous search space finite (see Chapter 26). In addition to the complexity of the problem, real robots must also deal with errors in their sensor readings and motor controls, with partial observability, and with other agents that might alter the environment.",商业旅行咨询系统使用的就是上述问题的形式化。
chap3_para77,2,,不过，在处理航空公司错综复杂的票价结构时，还会有许多额外的复杂因素。
chap3_para77,3,,例如，任何有经验的旅行者都知道，并不是所有的航空旅行都能按计划进行。
chap3_para77,4,,因此，一个真正好的系统应该包括应变规划——如航班延误或者错过转机时的应对方案。
chap3_para770,1,,图5-16　启发式极小化极大算法可能出错的二层博弈树
chap3_para771,1,,搜索和蒙特卡罗搜索的第二个局限性是，它们都是设计用于计算合法移动的（边界）值的。
chap3_para771,2,,但有时其中一种移动显然是最佳的（例如，合法移动只有一种），在这种情况下，浪费时间计算它的值是没有意义的——最好是直接选择该移动。
chap3_para771,3,,更好的搜索算法应该使用节点扩展的效用值的思想，选择效用值高的节点扩展，所谓高效用值的节点是指，有可能导致算法发现一个明显更好的移动。
chap3_para771,4,,如果没有一个节点扩展的效用值高于它的代价（从时间上考虑），那么算法应该停止搜索并执行一个移动。
chap3_para771,5,,这不仅适用于存在明显更好移动的情况，也适用于对称情况，在这种情况下，再多的搜索也无法证明一种移动比另一种更好。
chap3_para772,1,,这种关于计算该做什么的推理叫作元推理（metareasoning）（关于推理的推理）。
chap3_para772,2,,它不仅适用于博弈，也适用于任意一种推理。
chap3_para772,3,,所有计算都是为了做出更好的决策，所有计算都有代价，并且都有可能导致决策质量的一定程度上的改进。
chap3_para772,4,,蒙特卡罗搜索的确尝试进行元推理，将资源分配给树中最重要的部分，但不是以最优方式。
chap3_para773,1,,第三个局限性是搜索和蒙特卡罗搜索都是在单步移动的层级上进行所有推理的。
chap3_para773,2,,显然，这与人类玩游戏的方式不同：人类可以在更抽象的层级上进行推理，会考虑更高层级的目标（例如，诱捕对方的后），并使用该目标有选择地生成看似合理的规划。
chap3_para773,3,,在第11章中，我们将学习这种类型的规划，在11.4节中，我们将介绍如何用从抽象表示到具体表示的层次结构进行规划。
chap3_para774,1,,第四个问题是能否将机器学习融入博弈搜索过程。
chap3_para774,2,,早期的游戏程序依靠人类的专业知识人为制定评价函数、开局库、搜索策略和高效技巧。
chap3_para774,3,,"我们才刚刚开始看到像AlphaZero这样的程序（Silver et al., 2018），它依赖于自我对弈的机器学习，而非人类在特定游戏上的专业知识。"
chap3_para774,4,,我们将从第19章开始深入探讨机器学习。
chap3_para776,1,,我们探讨了各种各样的博弈，以理解什么是最佳玩法以及如何在实际中玩好游戏，还了解了智能体在任意类型的对抗性环境中应该如何行动。
chap3_para776,2,,最重要的思想如下。
chap3_para777,1,,● 博弈可以由初始状态（棋盘如何设置）、每个状态下的合法动作、每个动作的结果、终止测试（说明什么时候博弈结束）以及应用于终止状态表明输赢和最终比分的效用函数定义。
chap3_para778,1,,● 在具有完美信息的离散、确定性、轮流的双人零和博弈中，极小化极大算法可以通过对博弈树的深度优先枚举选出最优移动。
chap3_para779,1,,● 搜索算法可以计算出与极小化极大算法相同的最优移动，通过消除可证明与结果无关的子树来提高效率。
chap3_para78,1,Automatic assembly sequencing of complex objects (such as electric motors) by a robot has been standard industry practice since the 1970s.,旅行问题（touring problem）描述的是一组必须访问的地点，而非单一目的地。
chap3_para78,2,Algorithms first find a feasible assembly sequence and then work to optimize the process.,旅行商问题（traveling salesperson problem，TSP），就是一个旅行问题，即地图上每个城市都必须被访问。
chap3_para78,3,Minimizing the amount of manual human labor on the assembly line can produce significant savings in time and cost.,其目标是找到代价小于C的旅行路线（在优化版本中，目标是找到代价最低的旅行路线）。
chap3_para78,4,"In assembly problems, the aim is to find an order in which to assemble the parts of some object.",为了提高TSP算法的性能，科研人员付出了大量的努力。
chap3_para78,5,"If the wrong order is chosen, there will be no way to add some part later in the sequence without undoing some of the work already done.",该算法也可以扩展到处理车队问题。
chap3_para78,6,Checking an action in the sequence for feasibility is a difficult geometrical search problem closely related to robot navigation.,"例如，规划波士顿校车路线的搜索优化算法为人们节约了500万美元，减少了交通拥堵和空气污染，同时还为司机和学生节省了时间（Bertsimas et al., 2019）。"
chap3_para78,7,"Thus, the generation of legal actions is the expensive part of assembly sequencing.",除了规划行程，搜索算法还被用于规划自动电路板钻孔机钻头的运动和装料机在车间内的移动等任务。
chap3_para78,8,Any practical algorithm must avoid exploring all but a tiny fraction of the state space.,
chap3_para78,9,"One important assembly problem is protein design, in which the goal is to find a sequence of amino acids that will fold into a three-dimensional protein with the right properties to cure some disease.",
chap3_para780,1,,● 通常，考虑整个博弈树是不可行的（即使是搜索），所以我们需要在某个点截断搜索，然后应用启发式评价函数估计状态的效用值。
chap3_para781,1,,● 蒙特卡罗树搜索（MCTS）则是另一种方法，它不是通过应用启发式函数来评估状态，而是通过将游戏模拟到结束使用游戏规则来判断输赢。
chap3_para781,2,,因为在模拟过程中选择的移动可能不是最优移动，所以这个过程需要重复多次，对结果求平均值作为评估值。
chap3_para782,1,,● 许多游戏程序会预先计算开局和残局的最佳移动表，这样它们就可以直接查表而不用搜索。
chap3_para783,1,,● 机会博弈可以通过期望极小化极大算法（极小化极大算法的扩展）来处理，该算法通过计算所有子节点的平均效用值并按每个子节点的概率加权来估计机会节点的平均效用值。
chap3_para784,1,,● 在不完美信息博弈中，例如四国军棋和扑克，最佳玩法需要对每个玩家当前和将来的信念状态进行推理。
chap3_para784,2,,可以通过对缺失信息的每种可能配置上的动作值取平均得到一个简单的近似。
chap3_para785,1,,● 在国际象棋、跳棋、黑白棋、围棋、扑克及许多其他游戏中，程序已经彻底击败了人类冠军选手。
chap3_para785,2,,在一些不完美信息博弈中人类仍然保持优势，如桥牌和四国军棋。
chap3_para785,3,,在像《星际争霸》和《刀塔2》这样的电子游戏中，程序可以与人类专家媲美，但它们的成功可能一部分要归功于它们可以快速执行许多动作的能力。
chap3_para788,1,,第6章　约束满足问题
chap3_para789,1,,在本章中，我们不把状态仅仅当作小黑盒，从而导出新的搜索方法和对问题结构的更深入理解。
chap3_para79,1,3.,超大规模集成电路布图（VLSI layout）问题需要在一个芯片上定位数百万个元件和连接点，以最小化芯片面积、电路延迟和杂散电容，并最大化成品率。
chap3_para79,2,3Search Algorithms,布图问题在逻辑设计阶段之后，通常分为两个部分：单元布图（cell layout）和通道布线（channel routing）。
chap3_para79,3,,在单元布图中，电路的基本元件分组为若干单元，每个单元执行一些特定功能。
chap3_para79,4,,每个单元都有固定的占用区域（大小和形状），并且需要与其他每个单元建立一定数量的连接。
chap3_para79,5,,单元布图的目的是将单元彼此不重叠地放置在芯片上，并且单元之间有足够的空间布置连线。
chap3_para79,6,,通道布线的目的则是通过单元之间的间隙为每条导线寻找特定的路线。
chap3_para79,7,,这些搜索问题极其复杂，但绝对值得研究。
chap3_para790,1,,第3章和第4章讨论了通过搜索状态空间进行问题求解的思想：状态空间是一个由节点表示状态，边表示动作的图。
chap3_para790,2,,我们看到，领域特定的启发式算法可以估计从给定状态到达目标的代价，但从搜索算法的角度来看，每个状态都是原子的，即不可分割的——一个没有内部结构的黑盒。
chap3_para790,3,,对于每个问题，我们需要领域特定的代码来描述状态之间的转移。
chap3_para791,1,,在本章中，我们通过对每个状态使用因子化表示（factored representation）来打破黑盒：因子化表示为一组变量，每个变量都有自己的值。
chap3_para791,2,,当每个变量的值都满足对该变量的所有约束时，问题就解决了。
chap3_para791,3,,以上述方式描述的问题称为约束满足问题（constraint satisfaction problem，CSP）。
chap3_para792,1,,CSP搜索算法利用了状态结构的优势，并且使用通用的而不是领域特定的启发式算法来求解复杂问题。
chap3_para792,2,,其主要思想是，通过识别违反约束的变量/值组合来一次性消除大部分搜索空间。
chap3_para792,3,,CSP的另一个优势是可以从问题描述中推导出行动和转移模型。
chap3_para793,1,,6.1　定义约束满足问题
chap3_para794,1,,约束满足问题由3个部分组成，即X、D和C。
chap3_para796,1,,● D是域集合，，每个变量有一个域。
chap3_para797,1,,● C是约束集合，用来规定允许的值的组合。
chap3_para798,1,,域Di，由变量Xi的一组允许的值组成。
chap3_para798,2,,例如，布尔变量的域为。
chap3_para798,3,,不同变量可以有不同大小的域。
chap3_para798,4,,每个约束Cj由对组成，其中scope是该约束中的变量元组，而rel定义了这些值应该满足的关系（relation）。
chap3_para798,5,,关系可以表示为满足约束的所有元组值的显式集合，或者表示为判断一个元组是否为关系成员的函数。
chap3_para798,6,,"例如，如果X1和X2的域都是{1, 2, 3}，那么约束“X1必须大于X2”可以表示为或。"
chap3_para799,1,,CSP要处理变量赋值（assignment）问题，即。
chap3_para799,2,,不违反任何约束的赋值称为一致（consistent）或合法赋值。
chap3_para799,3,,完整赋值（complete assignment）是指每个变量都已被赋值；CSP的解（solution）是一致完整赋值。
chap3_para799,4,,部分赋值（partial assignment）是指某些变量还未赋值，而部分解（partial solution）是一致部分赋值。
chap3_para799,5,,一般来说，CSP求解是NP完全问题，尽管CSP的一些重要子类已经可以非常高效地求解。
chap3_para8,1,Imagine an agent enjoying a touring vacation in Romania.,
chap3_para8,2,"The agent wants to take in the sights, improve its Romanian, enjoy the nightlife, avoid hangovers, and so on.",
chap3_para8,3,The decision problem is a complex one.,
chap3_para8,4,"Now, suppose the agent is currently in the city of Arad and has a nonrefundable ticket to fly out of Bucharest the following day.",
chap3_para8,5,"The agent observes street signs and sees that there are three roads leading out of Arad: one toward Sibiu, one to Timisoara, and one to Zerind.",
chap3_para8,6,"None of these are the goal, so unless the agent is familiar with the geography of Romania, it will not know which road to follow.",
chap3_para8,7,1,
chap3_para80,1,"A search algorithm takes a search problem as input and returns a solution, or an indication of failure.",机器人导航（robot navigation）是寻径问题的一个推广。
chap3_para80,2,"In this chapter we consider algorithms that superimpose a search tree over the state-space graph, forming various paths from the initial state, trying to find a path that reaches a goal state.",机器人不必沿着明确的路径（如罗马尼亚的道路）行走，而是可以四处游走，实际上是自己走自己的路。
chap3_para80,3,Each node in the search tree corresponds to a state in the state space and the edges in the search tree correspond to actions.,对于在平面上移动的圆形机器人，空间本质上是二维的。
chap3_para80,4,The root of the tree corresponds to the initial state of the problem.,当机器人的手臂和腿也必须受到控制时，搜索空间就变成了多维的——每个关节角都是一个维度。
chap3_para80,5,,为了使基本上连续的搜索空间变成有限空间，需要一些更先进的技术（见第26章）。
chap3_para80,6,,除了问题的复杂性外，真正的机器人还必须处理传感器读取错误、电动机控制中的错误、部分可观测性以及可能改变环境的其他智能体等问题。
chap3_para800,1,,6.1.1　问题示例：地图着色
chap3_para801,1,,也许你已经逛够了罗马尼亚，现在来看看澳大利亚地图（如图6-1a所示）[1]，地图显示了澳大利亚的州和地区，分别是：西澳大利亚州（Western Australia）、北部地区（North Territory）、昆士兰州（Queensland）、新南威尔士州（New South Wales）、维多利亚州（Victoria）、南澳大利亚州（South Australia）、塔斯马尼亚州（Tasmania）、澳大利亚首都直辖区（Australia Capital Territory）。
chap3_para801,2,,我们的任务是给每个区域涂上红色、绿色或蓝色，要求相邻的两个区域颜色不能相同。
chap3_para801,3,,[2]为了将其形式化为CSP，我们将图中的区域定义为变量，变量名为各区域的英文名缩写：
chap3_para803,1,,[1]　本图系原书原图。
chap3_para804,1,,[2]　本书未将澳大利亚首都直辖区作为一个待着色区域，这使该地图着色问题更简洁明晰。
chap3_para804,2,,——编者注
chap3_para805,1,,每个变量的域为集合。
chap3_para805,2,,约束要求相邻区域颜色不同。
chap3_para805,3,,由于相邻区域的边界线有9段，所以有9个约束：
chap3_para806,1,,这里我们使用缩写。
chap3_para806,2,,是的缩写，其中可以依次完整枚举为：
chap3_para807,1,,这个问题有很多可能的解，例如：
chap3_para808,1,,将CSP可视化为约束图（constraint graph）非常有用，如图6-1b所示。
chap3_para808,2,,图的节点对应于问题的变量，图的边连接同一约束中的任意两个变量。
chap3_para809,1,,为什么要将问题形式化为CSP呢？
chap3_para809,2,,第一个原因是CSP可以自然地表示各种问题，将一个问题形式化为CSP通常很容易；第二个原因是多年的研究工作使得CSP求解器快速而高效；第三个原因是相比于原子的状态空间搜索器，CSP求解器可以快速消除大面积搜索空间。
chap3_para809,3,,例如，一旦我们在澳大利亚问题中选择了，就可以得出结论，它的5个相邻变量都不能取值为blue。
chap3_para809,4,,不使用约束的搜索过程必须考虑这5个相邻变量的35 = 243种赋值；有了约束，我们只需考虑25 = 32种赋值，计算量减少了87%。
chap3_para81,1,It is important to understand the distinction between the state space and the search tree.,自20世纪70年代以来，由机器人对复杂物体（例如电动机）进行自动装配排序（automatic assembly sequencing）已成为标准的工业实践。
chap3_para81,2,"The state space describes the (possibly infinite) set of states in the world, and the actions that allow transitions from one state to another.",算法首先找到一个可行的装配序列，然后对装配过程进行优化。
chap3_para81,3,"The search tree describes paths between these states, reaching towards the goal.",将装配线上的人工劳动减少到最低限度可以节省大量时间和成本。
chap3_para81,4,"The search tree may have multiple paths to (and thus multiple nodes for) any given state, but each node in the tree has a unique path back to the root (as in all trees).",装配问题的目标是找到某个对象的各个零件的组装顺序。
chap3_para81,5,,如果顺序错误，那么只能撤消某些已完成的工序，否则无法在序列的后面添加其他部分。
chap3_para81,6,,检查序列中动作的可行性是与机器人导航问题密切相关的几何搜索难题。
chap3_para81,7,,因此，合法动作的生成是装配排序问题中代价较高的部分。
chap3_para81,8,,任何实用算法都必须尽量避免探索全部的状态空间，而应只探索状态空间中的很小一部分。
chap3_para81,9,,一类重要的装配问题是蛋白质设计（protein design），其目的是找到一种氨基酸序列，该序列能够折叠成具有正确特性的三维蛋白质结构，以治疗某些疾病。
chap3_para810,1,,图6-1　（a）澳大利亚的州和地区。
chap3_para810,2,,对该地图着色可以看作约束满足问题（CSP）。
chap3_para810,3,,目标是为每个区域分配颜色，使得相邻区域颜色不同。
chap3_para810,4,,（b）用约束图表示地图着色问题
chap3_para811,1,,在原子的状态空间搜索中，我们只能问：这个特定状态是目标状态吗？
chap3_para811,2,,不是？
chap3_para811,3,,那么这一个呢？
chap3_para811,4,,使用CSP，一旦发现某个部分赋值违反了约束，我们可以马上放弃对该部分赋值的进一步改进。
chap3_para811,5,,此外，我们可以看出为什么某个赋值不是解——可以看出哪些变量违反了约束——从而把注意力集中在关键变量上。
chap3_para811,6,,因此，许多原子状态空间搜索难以求解的问题形式化为CSP后都可以快速求解。
chap3_para812,1,,6.1.2　问题示例：车间作业调度
chap3_para813,1,,工厂有很多日常工作调度问题，要满足各种约束。
chap3_para813,2,,在实践中，使用CSP技术可以求解很多这样的问题。
chap3_para813,3,,考虑汽车装配调度问题。
chap3_para813,4,,整个作业由不同任务组成，我们可以将每个任务建模成一个变量，其中每个变量的值为任务开始时间，由整数分钟数表示。
chap3_para813,5,,约束为“一个任务必须在另一个任务之前完成”（例如，安装车轮必须在安装轮毂盖之前完成）和“一次只能同时执行一定数量的任务”等断言。
chap3_para813,6,,约束还可以指定任务完成所需的时间。
chap3_para814,1,,我们考虑汽车装配的一小部分环节，包括15个任务：安装轮轴（axle）（前、后），固定4个车轮（wheel）（左和右、前和后），拧紧每个车轮的螺母（nuts），固定轮毂盖（cap），并检查（inspect）最终装配。
chap3_para814,2,,我们可以将任务表示为15个变量：
chap3_para815,1,,接着，我们需要表示各个任务间的优先约束（precedence constraint）。
chap3_para815,2,,当任务T1必须在T2之前完成且任务T1所需时间为d1时，我们将添加一个如下形式的算术约束：
chap3_para816,1,,在这个示例中，轮轴必须在车轮安装前到位，安装一个轮轴需要10分钟，所以有
chap3_para817,1,,接下来，我们必须固定每个车轮（需要1分钟），拧紧螺母（2分钟），最后安装轮毂盖（1分钟，但暂未表示）：
chap3_para818,1,,假设有4个工人来安装车轮，但他们必须共用一个工具来辅助安装轮轴。
chap3_para818,2,,此时我们需要一个析取约束（disjunctive constraint）表示AxleF和AxleB在时间上不能重叠：要么先做AxleF，要么先做AxleB：
chap3_para819,1,,这一约束看起来更加复杂，结合了算术约束和逻辑约束。
chap3_para819,2,,但它仍可以简化为AxleF和AxleB可以取的一组值。
chap3_para82,1,Figure 3.,
chap3_para82,2,4 shows the first few steps in finding a path from Arad to Bucharest.,
chap3_para82,3,"The root node of the search tree is at the initial state, Arad.",
chap3_para82,4,"We can expand the node, by considering the available ACTIONS for that state, using the RESULT function to see where those actions lead to, and generating a new node (called a child node or successor node) for each of the resulting states.",
chap3_para82,5,Each child node has Arad as its parent node.,
chap3_para820,1,,我们还需要说明，检查是最后一项任务，需要3分钟。
chap3_para820,2,,对于除Inspect外的每个变量，我们都需要添加一个形式的约束。
chap3_para820,3,,最后，假设我们需要在30分钟内完成整个装配任务。
chap3_para820,4,,因此，所有变量的域被限制为
chap3_para821,1,,这一特定问题的求解非常琐碎，但CSP已经成功地应用于此类具有几千个变量的车间作业调度问题。
chap3_para822,1,,6.1.3　CSP形式体系的变体
chap3_para823,1,,"最简单的CSP所涉及的变量具有离散有限域（discrete, finite domain）。"
chap3_para823,2,,地图着色问题和带有时间限制的调度问题都属于这类问题。
chap3_para823,3,,8皇后问题（图4-3）也可以看作是一个有限域CSP，其中变量对应第1～8列中的皇后，每个变量的域为该列皇后可能的行号，。
chap3_para823,4,,约束为不允许两个皇后在同一行或同一对角线上。
chap3_para824,1,,离散域也可以是无限的（infinite），例如整数集或字符串集。
chap3_para824,2,,（如果我们不对作业调度问题设置截止时间，那么每个变量的开始时间构成的域将是无限的。
chap3_para824,3,,）对于无限域，我们必须使用类似这样的隐式约束，而不是显式的值元组。
chap3_para824,4,,对于整数变量的线性约束（linear constraint）（像刚刚给出的约束一样，每个变量都只以线性形式出现）存在特殊的求解算法（在这里不讨论）。
chap3_para824,5,,可以证明，不存在求解整数变量上一般非线性约束（nonlinear constraint）的算法——这个问题是不可判定的。
chap3_para825,1,,连续域（continuous domain）约束满足问题是真实世界中的常见问题，在运筹学领域得到了广泛研究。
chap3_para825,2,,例如，哈勃太空望远镜的实验调度需要非常精确的观测时间，每次观测和机动的开始时间、结束时间都是连续值变量，必须服从各种天文的、优先级的和电力的约束。
chap3_para825,3,,最著名的一类连续域CSP是线性规划问题，其约束必须为线性等式或不等式。
chap3_para825,4,,线性规划（linear programming）问题可以在关于变量个数的多项式时间内求解。
chap3_para825,5,,此外人们还研究了具有不同类型约束和目标函数的问题——二次规划、二阶锥规划等。
chap3_para825,6,,这些问题构成了应用数学的一个重要领域。
chap3_para826,1,,除了检查CSP中变量的类型以外，检查约束的类型也是很有用。
chap3_para826,2,,最简单的类型是一元约束（unary constraint），它限制单个变量的值。
chap3_para826,3,,例如，在地图着色问题中，南澳大利亚州人可能不喜欢绿色，我们可以用一元约束表示。
chap3_para826,4,,（变量的域的初始说明也可以看作一元约束。
chap3_para826,5,,）
chap3_para827,1,,二元约束（binary constraint）关系到两个变量。
chap3_para827,2,,例如，是一个二元约束。
chap3_para827,3,,二元CSP（binary CSP）只存在一元约束和二元约束，可以用如图6-1b所示的约束图表示。
chap3_para828,1,,我们也可以定义高阶约束。
chap3_para828,2,,"例如，三元约束Between(X, Y, Z)可以定义为。"
chap3_para829,1,,包含任意个数变量的约束称为全局约束（global constraint）。
chap3_para829,2,,（这个名称很传统，但容易混淆，因为它不需要包含问题中的所有变量）。
chap3_para829,3,,最常见的全局约束之一是Alldiff，它表示约束中涉及的所有变量必须具有不同的值。
chap3_para829,4,,在数独问题中（见6.2.6节），一行、一列或3×3框中的所有变量必须满足Alldiff约束。
chap3_para83,1,Description Search tree 1: The root node is lavender-colored and all other nodes are in faint dashed lines.,搜索算法（search algorithm）将搜索问题作为输入并返回问题的解或报告failure（当解不存在时）。
chap3_para83,2,"Root node Arad has three child nodes: Sibiu, Timisoara, and Zerind.",在本章中，我们考虑在状态空间图上叠加一棵搜索树（search tree）的算法，该算法从初始状态形成各条路径，并试图找到一条可以达到某个目标状态的路径。
chap3_para83,3,"Node Sibiu has four child nodes: Arad, Fagaras, Oradea, and Rimnicu Vilcea.",搜索树中的每个节点（node）对应于状态空间中的一个状态，搜索树中的边对应于动作。
chap3_para83,4,Node Timisoara has two child nodes: Arad and Lugoj.,树的根对应于问题的初始状态。
chap3_para83,5,Node Zerind has two child nodes: Arad and Oradea.,
chap3_para83,6,Search tree 2: The root node is lavender colored.,
chap3_para83,7,"Root node Arad has three green-colored child nodes: Sibiu, Timisoara, and Zerind.",
chap3_para83,8,"Node Sibiu has four child nodes in faint dashed lines: Arad, Fagaras, Oradea, and Rimnicu Vilcea.",
chap3_para83,9,Node Timisoara has two child nodes in faint dashed lines: Arad and Lugoj.,
chap3_para83,10,Node Zerind has two child nodes in faint dashed lines: Arad and Oradea.,
chap3_para83,11,Search tree 3: The root node is lavender colored.,
chap3_para83,12,"Root node Arad has three child nodes: lavender-colored Sibiu, green-colored Timisoara, and green-colored Zerind.",
chap3_para83,13,"Node Sibiu has four green-colored child nodes: Arad, Fagaras, Oradea, and Rimnicu Vilcea.",
chap3_para83,14,Node Timisoara has two child nodes in faint dashed lines: Arad and Lugoj.,
chap3_para83,15,Node Zerind has two child nodes in faint dashed lines: Arad and Oradea.,
chap3_para830,1,,另一个例子是密码算术（cryptarithmetic）谜题（图6-2a）。
chap3_para830,2,,密码算术谜题中的每个字母代表一个不同数字。
chap3_para830,3,,"图6-2a中的情况，将表示为全局约束Alldiff(F, T, U, W, R, O)。"
chap3_para830,4,,4列上的加法约束可以写成如下n元约束：
chap3_para831,1,,其中C1、C2和C3为辅助变量，表示十位、百位或千位上的进位数。
chap3_para831,2,,这些约束可以用约束超图（constraint hypergraph）表示，如图6-2b所示。
chap3_para831,3,,超图由普通节点（图中的圆圈）和表示n元约束的超节点（正方形）组成，n元约束为包含n个变量的约束。
chap3_para832,1,,图6-2　（a）密码算术问题。
chap3_para832,2,,不同字母表示不同数字，目的是找到使加法算式成立的代替字母的数字，附加约束为不允许前导零。
chap3_para832,3,,（b）密码算术问题的约束超图，用来表示Alldiff约束（最上面的方框）以及每列的加法约束（中间的4个方框）。
chap3_para832,4,,变量C1、C2和C3表示从右到左3列的进位数
chap3_para833,1,,或者，正如习题6.NARY需要你证明的，如果引入足够多的辅助变量，每个有限域约束都可以简化为一组二元约束。
chap3_para833,2,,这意味着我们可以将任意一个CSP转换为只有二元约束的CSP，这将使算法设计变得更加简单。
chap3_para833,3,,将n元CSP转换为二元CSP的另一种方式是对偶图（dual graph）变换：创建一个新图，原图中的每个约束用新图中的一个变量表示，原图中的每对共享变量的约束用新图中的一个二元约束表示。
chap3_para834,1,,例如，考虑变量为的CSP，每个变量的域为，带有两个约束和。
chap3_para834,2,,对偶图的变量则为，对偶图中C1变量的域为原问题C1约束中的元组的集合，同样地，C2的域是元组的集合。
chap3_para834,3,,对偶图具有二元约束，其中R1是定义C1和C2之间约束的新关系。
chap3_para834,4,,在这种情况下，。
chap3_para835,1,,然而，我们可能更喜欢Alldiff这样的全局约束，而不是一组二元约束，这有两个原因。
chap3_para835,2,,首先，使用Alldiff描述问题更简单而且更不容易出错。
chap3_para835,3,,其次，可以为全局约束设计相比于基元约束更有效的专用推理算法。
chap3_para835,4,,我们将在6.2.5节介绍这些推理算法。
chap3_para836,1,,到目前为止，我们所描述的约束都是绝对约束，违反这些约束的可能解将被排除。
chap3_para836,2,,许多真实世界的CSP包含偏好约束（preference constraint），偏好约束规定哪些解是首选的。
chap3_para836,3,,例如，在大学排课问题中，存在绝对约束，如一个教授不可以同时上两门课。
chap3_para836,4,,但也可能存在偏好约束：R教授可能更喜欢在上午上课，而N教授更喜欢在下午上课。
chap3_para836,5,,让R教授在下午2点上课仍是一个可行解（除非R教授碰巧是系主任），但不是最优解。
chap3_para837,1,,偏好约束通常可以编码为个别变量赋值的代价。
chap3_para837,2,,例如，为R教授分配一个下午时段相对于总体目标函数的代价为2分，而分配上午时段的代价为1分。
chap3_para837,3,,通过这样的形式化，带偏好约束的CSP可以用基于路径的或局部的优化搜索方法求解。
chap3_para837,4,,我们称这样的问题为约束优化问题（constrained optimization problem，COP）。
chap3_para837,5,,线性规划是一类COP。
chap3_para838,1,,6.2　约束传播：CSP中的推断
chap3_para839,1,,原子的状态空间搜索算法只有一种方式：通过扩展节点来访问后继节点。
chap3_para839,2,,CSP算法有不同选择。
chap3_para839,3,,它可以通过选择一个新的变量赋值来生成后继，或者执行一种称为约束传播（constraint propagation）的特定类型推断：使用约束减少一个变量的合法值的数量，这反过来又可以减少另一个变量的合法值，以此类推。
chap3_para839,4,,其思想是，通过这一过程，当我们选择下一个变量赋值时，需要考虑的选项会减少。
chap3_para839,5,,约束传播可以与搜索交替进行，也可以作为搜索开始前的预处理步骤。
chap3_para839,6,,有时这种预处理就可以求解整个问题，所以根本不需要搜索。
chap3_para84,1,"Figure 3.4 Three partial search trees for finding a route from Arad to Bucharest. Nodes that have been expanded are lavender with bold letters; nodes on the frontier that have been generated but not yet expanded are in green; the set of states corresponding to these two types of nodes are said to have been reached. Nodes that could be generated next are shown in faint dashed lines. Notice in the bottom tree there is a cycle from Arad to Sibiu to Arad; that can’t be an optimal path, so search should not continue from there.",理解状态空间和搜索树之间的区别非常重要。
chap3_para84,2,,状态空间描述了世界的（可能无限的）状态集，以及允许从一个状态转移到另一个状态的动作。
chap3_para84,3,,搜索树描述了这些状态之间通向目标的路径。
chap3_para84,4,,搜索树可以有多条路径（因此可以有多个节点）到达任何给定状态，但树中的每个节点都只有唯一一条返回根的路径（与所有树一样）。
chap3_para840,1,,约束传播的核心思想是局部一致性（local consistency）。
chap3_para840,2,,如果我们将每个变量看作图中的一个节点（见图6-1b），将每个二元约束看作一条边，则增强图中每一部分局部一致性的过程会导致整个图中不一致的值被删除。
chap3_para840,3,,局部一致性有几种不同类型，我们现在依次介绍。
chap3_para841,1,,6.2.1　节点一致性
chap3_para842,1,,如果单个变量的域中的所有值都满足该变量的一元约束，则该变量（对应于CSP图中的某个节点）是节点一致的。
chap3_para842,2,,例如，在澳大利亚地图着色问题（图6-1）的变体中，南澳大利亚州人不喜欢绿色，变量SA的初始域为，可以通过删除green使其保持节点一致，SA的域缩减为。
chap3_para842,3,,如果图中的每个变量都是节点一致的，那么整个图是节点一致的。
chap3_para843,1,,在求解过程开始时，通过缩减具有一元约束的变量的域，可以很容易地消除CSP中的所有一元约束。
chap3_para843,2,,如前文所述，还可以将所有n元约束转换为二元约束。
chap3_para843,3,,因此，一些CSP求解器只处理二元约束，要求用户提前消除其他约束。
chap3_para843,4,,除非特别说明，本章的剩余部分都基于这一假设。
chap3_para844,1,,6.2.2　弧一致性
chap3_para845,1,,如果CSP中某一变量的域内的所有值都满足该变量的二元约束，那么该变量就是弧一致的（arc consistent）[3]。
chap3_para845,2,,"更正式地说，对于变量Xi、Xj，如果对于当前域Di中的每个值，Dj中都存在一些值满足弧(Xi, Xj)上的二元约束，则称Xi相对于Xj是弧一致的。"
chap3_para845,3,,如果每个变量相对所有其他变量都是弧一致的，那么这个图就是弧一致的。
chap3_para845,4,,例如，考虑约束Y = X2，其中X和Y的域都是十进制数字。
chap3_para845,5,,我们可以将这一约束显式地写为。
chap3_para845,6,,"为了使X相对于Y弧一致，我们将X的域缩减为{0, 1, 2, 3}。"
chap3_para845,7,,"如果要使Y相对于X弧一致，那么Y的域为{0, 1, 4, 9}，此时整个CSP是弧一致的。"
chap3_para845,8,,但是，弧一致性对澳大利亚地图着色问题没有任何帮助。
chap3_para845,9,,"考虑(SA, WA)的如下不同色约束："
chap3_para847,1,,[3]　我们一直使用的术语是“边”而不是“弧”，所以将其称为“边一致”会更合适，但历史上使用的术语是“弧一致”。
chap3_para848,1,,无论为SA（或WA）选择哪个值，另一变量都存在一个有效值。
chap3_para848,2,,所以应用弧一致性对两个变量的域都没有影响。
chap3_para849,1,,最流行的增强弧一致性的算法为AC-3（见图6-3）。
chap3_para849,2,,为了使每个变量保持弧一致，AC-3算法将维护一个弧队列。
chap3_para849,3,,初始时，队列包含CSP中的所有弧。
chap3_para849,4,,（每个二元约束都有两条弧，每个方向各一条。
chap3_para849,5,,"）然后AC-3从队列中弹出任意一条弧(Xi, Xj)并使Xi相对于Xj弧一致。"
chap3_para849,6,,如果Di保持不变，算法就会处理下一条弧。
chap3_para849,7,,"但是如果Di得以修正（域变小），那么我们将所有的弧(Xk, Xi)添加到队列中，其中Xk是Xi的邻居。"
chap3_para849,8,,这样做的原因是，即使之前已经处理过Xk，Di的变化也可能会进一步缩减Dk。
chap3_para849,9,,如果Di变为空集，那么表示整个CSP不存在一致解，AC-3可以马上返回失败。
chap3_para849,10,,否则，我们继续检查，不断尝试缩减变量的域，直到队列中没有弧。
chap3_para849,11,,此时，我们得到了一个与原始CSP等价的CSP（它们的解相同），但弧一致CSP搜索起来会更快，因为它的变量的域更小。
chap3_para849,12,,在某些情况下，它可以完全求解问题（通过将每个域的大小缩减为1），而在其他情况下，它可以证明解不存在（通过将某些域的大小缩减为0）。
chap3_para85,1,Now we must choose which of these three child nodes to consider next. This is the essence of search—following up one option now and putting the others aside for later. Suppose we choose to expand Sibiu first. Figure 3.4 (bottom) shows the result: a set of 6 unexpanded nodes (outlined in bold). We call this the frontier of the search tree. We say that any state that has had a node generated for it has been reached (whether or not that node has been expanded).5 Figure 3.5 shows the search tree superimposed on the state-space graph.,图3-4展示了寻找从Arad到Bucharest的路径的前几步。
chap3_para85,2,,搜索树的根节点位于初始状态，Arad。
chap3_para85,3,,我们可以按如下方式扩展（expand）节点：考虑该状态的可用动作Actions，使用Result函数查看这些动作指向何处，并为每个结果状态生成（generating）一个新节点，称为子节点（child node）或后继节点（successor node）。
chap3_para85,4,,每个子节点的父节点（parent node）都是Arad。
chap3_para850,1,,图6-3　弧一致性算法AC-3。
chap3_para850,2,,应用AC-3算法后，要么每条弧都是弧一致的，要么某些变量的域为空集，说明该CSP无解。
chap3_para850,3,,"“AC-3”这个名字来源于算法的发明者（Mackworth, 1977），因为他论文中用到的算法是开发的第三个版本"
chap3_para851,1,,AC-3的算法复杂性可以如下分析。
chap3_para851,2,,假设CSP有n个变量，每个变量的域大小不超过d，带有c个二元约束（弧）。
chap3_para851,3,,"每个弧(Xk, Xi)最多只能插入队列d次，因为Xi最多有d个值要删除。"
chap3_para851,4,,对弧一致性的检查可以在O(d2)时间内完成，因此最坏情况下的时间复杂性为O(cd3)。
chap3_para852,1,,6.2.3　路径一致性
chap3_para853,1,,假设我们要给澳大利亚地图涂上两种颜色，红色和蓝色。
chap3_para853,2,,此时弧一致性不起作用，因为将弧的一端涂成红色，另一端涂成蓝色可以分别满足每个约束。
chap3_para853,3,,但显然这个问题是无解的：因为西澳大利亚州、北领地和南澳大利亚州彼此相邻，仅仅是它们就需要至少3种颜色。
chap3_para854,1,,弧一致性利用弧（二元约束）将域（一元约束）收紧。
chap3_para854,2,,为了求解地图着色等问题，我们需要更强的一致性概念。
chap3_para854,3,,路径一致性（path consistency）使用隐式约束（通过观测变量的三元组推断）将二元约束收紧。
chap3_para855,1,,考虑两个变量的集合和第三个变量Xm，如果对于每个满足上约束（如果有的话）的赋值，都存在Xm的一个赋值满足和上的约束，则称相对于Xm是路径一致的。
chap3_para855,2,,这一名称是指从Xi途经Xm到Xj的路径的整体一致性。
chap3_para856,1,,让我们考虑用两种颜色为澳大利亚地图着色时的路径一致性。
chap3_para856,2,,我们要使集合相对于NT路径一致。
chap3_para856,3,,首先枚举集合的一致赋值。
chap3_para856,4,,在这种情况下，只有两个一致赋值：和。
chap3_para856,5,,可以看到，对于这两种赋值，NT不能是红色或蓝色（因为它会与WA或SA发生冲突）。
chap3_para856,6,,因为NT不存在有效选择，所以我们消除了这两种赋值，最终不存在有效赋值。
chap3_para856,7,,因此，我们知道了这个问题是无解的。
chap3_para857,1,,6.2.4　k一致性
chap3_para858,1,,可以用k一致性（k-consistency）的概念定义更强的传播形式。
chap3_para858,2,,如果对于CSP的任意(k −1)个变量的集合以及这些变量的任意一致赋值，任意第k个变量都存在一个一致赋值，则称该CSP是k一致的。
chap3_para858,3,,1一致性表示，给定空集，我们可以使任何单变量集合满足一致性，这就是我们所说的节点一致性。
chap3_para858,4,,2一致性等价于弧一致性。
chap3_para858,5,,对于二元约束图，3一致性等价于路径一致性。
chap3_para859,1,,如果一个CSP是k一致的，也是(k −1)一致的，(k −2)一致的……一直到1一致的，则称它是强k一致的（strongly k-consistent）。
chap3_para859,2,,现在假设我们有一个包含n个节点的CSP，并且是强n一致的(即当k = n时，强k一致)，那么可以这样求解该问题：首先，为X1选择一个一致值。
chap3_para859,3,,然后因为图是2一致的，所以保证能为X2选出一个一致值，因为它是3一致的，所以能为X3选出一个值，以此类推。
chap3_para859,4,,"对于每个变量Xi，我们只需在它的域的d个值中搜索，就可以找到一个与X1, …, Xi−1一致的值。"
chap3_para859,5,,总运行时间只有O(n2d)。
chap3_para86,1,"Description In all three parts, paths to Arad from Zerind, Sibiu, and Timisoara are highlighted and marked in red.",图3-4　3棵部分搜索树，用于寻找从Arad到Bucharest的路线。
chap3_para86,2,Part 1: The highlighted paths are shown.,已扩展节点用淡紫色和粗体字母表示；边界上已生成但未被扩展的节点用绿色表示；对应于这两种类型节点的状态集被称为已达。
chap3_para86,3,Part 2: Paths in part 1 are shown.,接下来可能生成的节点用虚线表示。
chap3_para86,4,"Additionally, paths to Sibiu from Fagaras and Rimnicu Vilcea are highlighted and marked in red.",注意，在最下面的树中，有一个从Arad到Sibiu再到Arad的环，这不可能是最优路径，因此搜索不应该从那里继续
chap3_para86,5,Paths to Zerind from Oradea and to Timisoara from Lugoj are highlighted and marked in red.,
chap3_para86,6,Part 3: All paths in part 2 are shown.,
chap3_para86,7,"Additionally, paths to Lugoj from Mehadia and to Fagaras from Bucharest are highlighted and marked in red.",
chap3_para86,8,Paths to Rimnicu Vilcea from Craiova and Pitesti are highlighted and marked in red.,
chap3_para860,1,,当然，世界上没有免费的午餐：约束满足问题通常是NP完全的，任何建立n一致性的算法在最坏情况下的时间复杂性都是n的指数级。
chap3_para860,2,,更糟的是，n一致性所需的空间复杂性也是n的指数级。
chap3_para860,3,,在实践中，确定适当的一致性检查层级基本上是一门经验科学。
chap3_para860,4,,比较常见的是计算2一致性，其次是计算3一致性。
chap3_para861,1,,6.2.5　全局约束
chap3_para862,1,,前文提到，全局约束涉及任意个数的变量（但不一定是所有变量）。
chap3_para862,2,,实际问题中经常出现全局约束，可以通过专用算法处理这些约束，这些算法比目前介绍的一般方法更加高效。
chap3_para862,3,,例如，Alldiff约束规定所有相关变量必须取不同的值（如上文的密码算术问题和下文的数独问题）。
chap3_para862,4,,对Alldiff约束进行不一致性检测的一种简单形式如下所示：如果约束中涉及m个变量，而且它们一共具有n个可能的不同值，且，那么约束不可能满足。
chap3_para863,1,,这将导出以下简单算法。
chap3_para863,2,,首先，删除约束中任意一个单值变量（域中只有一个值的变量），并且从其余变量的域中删除该变量的值。
chap3_para863,3,,只要还存在单值变量，就重复上述过程。
chap3_para863,4,,如果在任一点上产生了空集，或者存在比剩余取值数更多的变量，则检测到了不一致性。
chap3_para864,1,,上述方法可以检测图6-1中赋值的不一致性。
chap3_para864,2,,注意，变量SA、NT和Q是通过Alldiff约束有效连接的，因为每对都必须取两种不同颜色。
chap3_para864,3,,将AC-3应用于这个部分赋值后，SA、NT和Q的域都缩减为。
chap3_para864,4,,也就是说，我们有3个变量，但只有两种颜色，这违反了Alldiff约束。
chap3_para864,5,,因此，对高阶约束进行简单一致性处理有时比对等价的二元约束集应用弧一致性更高效。
chap3_para865,1,,另一种重要的高阶约束是资源约束（resource constraint），有时也称为Atmost约束。
chap3_para865,2,,"例如，在一个调度问题中，设P1, …, P4分别表示分配给4个任务的人数。"
chap3_para865,3,,分配总人数不超过10的约束写为。
chap3_para865,4,,通过检验当前域的最小值之和可以检测不一致性。
chap3_para865,5,,"例如，如果每个变量的域都是{3, 4, 5, 6}，则不可能满足Atmost约束。"
chap3_para865,6,,另一个例子是，如果当前某个变量的域中的最大值加上所有其他变量的域的最小值超过约束，则可以通过删除该最大值来保持一致性。
chap3_para865,7,,"因此，如果示例中的每个变量的域都是{2, 3, 4, 5, 6}，那么可以从每个域中删除5和6。"
chap3_para866,1,,对于大规模的、具有整数值的资源有限问题（例如用几百辆车运送几千人的物流问题）将每个变量的域表示为一个大的整数集然后通过一致性检查方法逐渐缩减这个集合通常是不可能的。
chap3_para866,2,,相反，域由上界和下界表示，通过边界传播（bound propagation）处理。
chap3_para866,3,,例如，在航班调度问题中，假设存在两趟航班，F1和F2，其中飞机的容量分别为165和385。
chap3_para866,4,,F1和F2航班上乘客数量的初始域为
chap3_para868,1,,现在假设我们有附加约束，两趟航班所搭载的总乘客数必须是420：。
chap3_para868,2,,通过传播边界约束，我们将域缩减为
chap3_para87,1,"Figure 3.5 A sequence of search trees generated by a graph search on the Romania problem of Figure 3.1. At each stage, we have expanded every node on the frontier, extending every path with all applicable actions that don’t result in a state that has already been reached. Notice that at the third stage, the topmost city (Oradea) has two successors, both of which have already been reached by other paths, so no paths are extended from Oradea.",现在我们必须从这3个子节点中选择一个考虑下一步扩展。
chap3_para87,2,,这就是搜索的本质——先跟踪一个选项，之后再考虑其他选项。
chap3_para87,3,,假定我们选择先扩展Sibiu。
chap3_para87,4,,结果如图3-4中最下面的搜索树所示，我们得到了6个未被扩展的节点（以绿色节点显示）。
chap3_para87,5,,我们称之为搜索树的边界（frontier）。
chap3_para87,6,,任何已经生成过节点的状态都称为已达（reached）状态（无论该节点是否被扩展）。
chap3_para87,7,,[5]图3-5为叠加在状态空间图上的搜索树。
chap3_para870,1,,如果对于任意变量X和它的上下界值，任意变量Y，都存在满足X和Y之间约束的Y的值，则称CSP是边界一致的（bounds-consistent）。
chap3_para870,2,,这种边界传播在实际的约束问题中得到了广泛应用。
chap3_para872,1,,数独（Sudoku）游戏非常流行，它将数百万人引入了约束满足问题，尽管他们可能没有意识到这一点。
chap3_para872,2,,数独棋盘由81个方格组成，有些方格预先填有1到9的数字。
chap3_para872,3,,谜题是将所有剩余方格填满，并且任意一行、一列或3×3方框中不存在相同数字（见图6-4）。
chap3_para872,4,,一行、一列或一个方框称为一个单元（unit）。
chap3_para873,1,,图6-4　（a）一个数独问题。
chap3_para873,2,,（b）它的解
chap3_para874,1,,报纸和益智书籍上的数独游戏都有一个特点，即有且只有一个解。
chap3_para874,2,,尽管有些问题手动求解很难，需要花费几十分钟，但CSP求解器每秒可以处理几千个问题。
chap3_para875,1,,可以将数独游戏看作含有81个变量的CSP，每个变量对应一个方格。
chap3_para875,2,,用变量名A1到A9表示第一行（从左到右），I1到I9表示最后一行。
chap3_para875,3,,"空方格的域为{1, 2, 3, 4, 5, 6, 7, 8, 9}，预先填好的方格的域只有一个值。"
chap3_para875,4,,此外，还有27个不同的Alldiff约束，每个单元（行、列和含有9个方格的方框）各有一个Alldiff约束：
chap3_para876,1,,"Alldiff (A1, A2, A3, A4, A5, A6, A7, A8, A9)"
chap3_para877,1,,"Alldiff (B1, B2, B3, B4, B5, B6, B7, B8, B9)"
chap3_para879,1,,"Alldiff (A1, B1, C1, D1, E1, F1, G1, H1, I1)"
chap3_para88,1,"Note that the frontier separates two regions of the state-space graph: an interior region where every state has been expanded, and an exterior region of states that have not yet been reached.",
chap3_para88,2,This property is illustrated in Figure 3.,
chap3_para88,3,6.,
chap3_para880,1,,"Alldiff (A2, B2, C2, D2, E2, F2, G2, H2, I2)"
chap3_para882,1,,"Alldiff (A1, A2, A3, B1, B2, B3, C1, C2, C3)"
chap3_para883,1,,"Alldiff (A4, A5, A6, B4, B5, B6, C4, C5, C6)"
chap3_para885,1,,让我们看看弧一致性能带我们走多远。
chap3_para885,2,,假设Alldiff约束已被扩展为二元约束（例如A1 A2），这样我们就可以直接应用AC-3算法。
chap3_para885,3,,考虑图6-4a中的变量E6——正中间方框中2、8之间的空格。
chap3_para885,4,,按照方框的约束，我们可以从E6的域中删除1、2、7和8。
chap3_para885,5,,按照它所在列的约束，我们可以删除5、6、2、8、9和3（尽管2和8已经被删除）。
chap3_para885,6,,此时E6的域是{4}；换句话说，我们知道了E6的解。
chap3_para885,7,,现在考虑变量I6——最后一行中间方框中被1、3、3包围的空格。
chap3_para885,8,,在它所在列应用弧一致性，可以删除5、6、2、4（因为我们现在知道E6一定是4）、8、9和3。
chap3_para885,9,,我们利用它和I5的弧一致性删除1，此时I6的域中只剩下7。
chap3_para885,10,,现在第6列中有8个已知值，所以根据弧一致性可以推出A6一定是1。
chap3_para885,11,,沿着这样的思路继续推断，最终AC-3可以求解整个问题——所有变量的域都缩减为单个值，如图6-4b所示。
chap3_para886,1,,当然，如果每个数独问题都可以通过机械地应用AC-3求解，那么它很快就会失去吸引力，实际上AC-3只适用于最简单的数独问题。
chap3_para886,2,,稍微困难一点的问题可以用PC-2求解，但需要花费更大的计算代价：在一个数独问题中，需要考虑255 960个不同的路径约束。
chap3_para886,3,,为了求解最困难的数独问题并取得高效进展，我们必须更聪明一些。
chap3_para887,1,,事实上，数独对人类解谜者的吸引力在于，他们需要足智多谋地应用更复杂的推理策略。
chap3_para887,2,,数独爱好者给这些策略取了各种有趣的名字，如“三链数删减法”。
chap3_para887,3,,它的工作原理如下：在任一单元（行、列或方框）中，找到3个方格，它们的域包含相同的3个数字或这3个数字的子集。
chap3_para887,4,,例如，这3个域可能是、和。
chap3_para887,5,,我们并不知道哪个方格是1、3或8，但我们知道这3个数字一定分布在这3个方格中。
chap3_para887,6,,因此，我们可以将1、3和8从该单元中所有其他方格的域中删除。
chap3_para888,1,,有趣的是，这些方法并不只是专用于数独。
chap3_para888,2,,对于数独，我们确实必须说它有81个变量，域是数字1～9，有27个Alldiff约束。
chap3_para888,3,,但除此之外，所有策略（弧一致性、路径一致性等）普遍适用于所有CSP，而不仅仅是数独问题。
chap3_para888,4,,即使是三链数删减法，也是一种加强Alldiff约束一致性的策略，而不是特定于数独本身。
chap3_para888,5,,这就是CSP形式体系的作用：对于每个新问题域，我们只需按照约束定义问题，然后就可以使用一般的约束求解机制。
chap3_para889,1,,6.3　CSP的回溯搜索
chap3_para89,1,"Description Each rectangular grid has 25 nodes made of five rows and five columns. Each row contains five nodes. The nodes are connected by the paths along the five vertical and five horizontal grid lines. Part (“a”): The node in the third column of the third row is lavender-colored and the nodes that are vertically and horizontally adjacent to it are green-colored. The four paths between the lavender node and green nodes are colored in lavender. All other nodes and paths are in faint dashed lines. Part (b): The two nodes in the third column of the second and third rows are lavender-colored and each of the two has three green-colored adjacent nodes. The paths between the lavender nodes and the green nodes are colored in lavender. All other nodes and paths are in faint dashed lines. Part (c): Five nodes are lavender-colored and are in the following positions: rows 2, 3, and 4 of column 3, and columns 2 and 4 of row 3. The paths from the lavender node at column 3, row 3 to the other four lavender nodes are colored in lavender. The lavender node at row 2 column 3 has three green-colored nodes to the right, left, and top, and the paths from the lavender node to these green nodes are in lavender. The lavender node at row 3, column 4 has two green nodes to the right and below, and the paths from the lavender node to these green nodes are in lavender. The lavender node at row 4, column 3 has two green nodes to the left and below, and the paths from the lavender node to these green nodes are in lavender. The lavender node at row 3, column 2 has one green node to the left, and the path from the lavender node to this green node is in lavender. All other nodes and the paths are in faint dashed lines.",[5]　一些作者将边界称为开节点表，这在地理学上不太容易引起共鸣，在计算上也不太合适，因为在这里，队列比表更有效。
chap3_para89,2,,这些作者还使用闭节点表一词来指代之前已扩展的节点的集合，在我们的术语中，这些节点为已达节点去掉边界节点后的剩余节点。
chap3_para890,1,,有时我们完成约束传播过程后仍存在具有多个可能值的变量。
chap3_para890,2,,在这种情况下，我们必须通过搜索来求解问题。
chap3_para890,3,,本节中我们将介绍用于部分赋值的回溯搜索算法，6.4节中我们将介绍用于完整赋值的局部搜索算法。
chap3_para891,1,,考虑标准的深度受限搜索（第3章）是如何求解CSP的。
chap3_para891,2,,状态可能是一个部分赋值，而动作将对该赋值进行扩展，例如，在澳大利亚地图着色问题中，添加赋值NSW = red或SA = blue。
chap3_para891,3,,对于具有n个变量，域大小为d的CSP，我们最终将得到一个搜索树，所有的完整赋值（因此所有的解）都是深度为n的叶节点。
chap3_para891,4,,但要注意，第一层的分支因子为nd，因为n个变量中的任意变量都可以取d个值中的任意值。
chap3_para891,5,,下一层的分支因子是(n −1)d，以此类推n层。
chap3_para891,6,,所以树总共有n! · dn个叶节点，即使可能的完整赋值只有dn种！
chap3_para892,1,,如果意识到CSP具有的一个关键性质：可交换性（commutativity），我们就可以消去因子n!。
chap3_para892,2,,如果任意给定的动作集合的应用顺序对结果没有影响，则称该问题是可交换的。
chap3_para892,3,,在CSP中，不管我们先赋值NSW = red，再赋值SA = blue，还是交换顺序，都没有区别。
chap3_para892,4,,因此，我们只需考虑搜索树中每个节点上的单个变量。
chap3_para892,5,,在根节点上，我们可能需要在SA = red、SA = green和SA = blue之间做出选择，但我们永远不需要在NSW = red和SA = blue之间做出选择。
chap3_para892,6,,在这一限制下，叶节点的数量减少到dn，这正是我们所希望的。
chap3_para892,7,,在树的每一层中，我们都必须选择要处理哪个变量，但我们永远不需要回溯这一选择。
chap3_para893,1,,图6-5为CSP的回溯搜索过程。
chap3_para893,2,,它不断选择未赋值变量，然后依次尝试该变量的域中的所有值，试图通过递归调用将每个值扩展为一个解。
chap3_para893,3,,如果调用成功，则返回解，如果调用失败，则将赋值恢复到前一状态，然后尝试下一个值。
chap3_para893,4,,如果所有值都不成功，则返回失败。
chap3_para893,5,,澳大利亚地图着色问题的部分搜索树如图6-6所示，其中我们按照WA、 NT、Q……的顺序为变量赋值。
chap3_para894,1,,图6-5　约束满足问题的简单回溯算法。
chap3_para894,2,,该算法以第3章的递归深度优先搜索为模型。
chap3_para894,3,,函数Select-Unassigned- Variable和Order-Domain-Values实现了6.3.1节中讨论的通用启发式算法。
chap3_para894,4,,函数Inference可以根据需要选择性地使用弧一致性、路径一致性或k一致性检测。
chap3_para894,5,,如果一个赋值导致了失败（无论是在Inference还是在Backtrack中），那么该赋值（包括从Inference得到的值）将被撤销，然后重新尝试一个新的赋值
chap3_para895,1,,图6-6　图6-1中地图着色问题的部分搜索树
chap3_para896,1,,注意，Backtracking-Search只维护状态（赋值）的单个表示，然后对它进行修改，而不是创建一个新的表示（见3.4.3节）。
chap3_para897,1,,第3章的无信息搜索算法只能通过提供领域特定的启发式算法来改进，然而，事实证明，回溯搜索可以使用领域无关的启发式算法进行改进，这些算法利用了CSP的因子化表示。
chap3_para897,2,,在接下来的4节中，我们将介绍如何做到这一点。
chap3_para898,1,,● （6.3.1节）下一步应该给哪个变量赋值（Select-Unassigned-Variable），以及应该以什么顺序尝试它的值（Order-Domain-Values）？
chap3_para899,1,,● （6.3.2节）在每步搜索中应该执行怎样的推断（Inference）？
chap3_para9,1,"If the agent has no additional information—that is, if the environment is unknown—then the agent can do no better than to execute one of the actions at random. This sad situation is discussed in Chapter 4. In this chapter, we will assume our agents always have access to information about the world, such as the map in Figure 3.1. With that information, the agent can follow this four-phase problem-solving process:",[1]　我们假设大多数读者都处于同样的处境，并且很容易想象自己和智能体一样毫无头绪。
chap3_para9,2,,我们向不能利用这一教学安排的罗马尼亚读者道歉，因为他们清楚地知晓哪条路更易到达Bucharest。
chap3_para90,1,Figure 3.,图3-5　由图3-1中的罗马尼亚问题的图搜索生成的搜索树序列。
chap3_para90,2,"6 The separation property of graph search, illustrated on a rectangular-grid problem.",在每一阶段，我们扩展边界上的每个节点，使用所有不指向已达状态的可用动作延伸每条路径。
chap3_para90,3,The frontier (green) separates the interior (lavender) from the exterior (faint dashed).,需要注意的是，在第三阶段，最高位置的城市（Oradea）有两个后继城市，这两个城市都已经有其他路径到达，所以没有路径可以从Oradea延伸
chap3_para90,4,The frontier is the set of nodes (and corresponding states) that have been reached but not yet expanded; the interior is the set of nodes (and corresponding states) that have been expanded; and the exterior is the set of states that have not been reached.,
chap3_para90,5,"In (a), just the root has been expanded.",
chap3_para90,6,"In (b), the top frontier node is expanded.",
chap3_para90,7,"In (c), the remaining successors of the root are expanded in clockwise order.",
chap3_para900,1,,● （6.3.3节）我们能在适当的时候回溯（Backtrack）不止一步吗？
chap3_para901,1,,● （6.3.4节）我们可以保存和复用搜索的部分结果吗？
chap3_para902,1,,6.3.1　变量排序和值排序
chap3_para903,1,,回溯算法中包含这样一行：
chap3_para904,1,,Select-Unassigned-Variable的最简单的策略是使用静态排序：按列表顺序选择变量。
chap3_para904,2,,第二简单的策略是随机选择。
chap3_para904,3,,这两种策略都不是最优的。
chap3_para904,4,,例如，图6-6中，进行WA = red和NT = green赋值后，SA只有一个可能的值，因此接下来应该对SA赋值SA = blue而不是对Q赋值：事实上，对SA赋值后，Q、NSW和V的取值都是确定的。
chap3_para905,1,,这种直观的想法——选择“合法”值最少的变量——称为最少剩余值（minimum-remaining-value，MRV）启发式算法，也被称为“最受约束变量”或“失败优先”启发式算法，后一个名字是因为它选择了最有可能马上导致失败的变量，从而可以对搜索树剪枝。
chap3_para905,2,,如果某一变量X没有剩余合法值，那么MRV启发式算法将优先选择X然后马上检测到失败——避免遍历其他变量进行无意义地搜索。
chap3_para905,3,,MRV启发式算法通常比随机或静态排序表现得更好，有时会带来数量级上的效率差异，尽管结果可能因问题而异。
chap3_para906,1,,在选择澳大利亚地图的第一个着色区域时，MRV启发式算法完全不起作用，因为初始时每个区域都有3种合法颜色。
chap3_para906,2,,在这种情况下，度启发式（degree heuristic）算法就派上用场了。
chap3_para906,3,,它通过选择与其他未赋值变量的约束最多的变量来降低未来选择的分支因子。
chap3_para906,4,,在图6-1中，SA的度最大，为5；除了变量T的度为0，其他变量的度为2或3。
chap3_para906,5,,如果先赋值SA，我们就可以按顺时针或逆时针顺序访问5个陆地区域，并为每个区域赋予不同于SA和前一个区域的颜色。
chap3_para906,6,,最少剩余值启发式算法通常效果更好，但度启发式算法可以打破僵局。
chap3_para907,1,,一旦选择了一个变量，算法必须决定按什么顺序检验它的值。
chap3_para907,2,,最少约束值（least-constraining-value）启发式算法对此非常有效。
chap3_para907,3,,它优先选择那些为约束图中相邻变量留下最多选择的值。
chap3_para907,4,,例如，假设在图6-1中，我们已经生成了部分赋值WA = red和NT = green，并且下一步是为Q选择赋值。
chap3_para907,5,,此时蓝色是一个糟糕的选择，因为它消除了Q的邻居SA的最后一个可选的合法值。
chap3_para907,6,,因此，最少约束值启发式算法会优先选择红色而不是蓝色。
chap3_para907,7,,一般来说，启发式算法试图为后续变量赋值留下最大的灵活性。
chap3_para908,1,,为什么变量选择是失败优先，而值选择是失败延后呢？
chap3_para908,2,,每个变量最终都必须被赋值，因此通过选择那些有可能最先失败的变量，在统计意义上，需要通过回溯才能找到的成功赋值就会更少。
chap3_para908,3,,对于值排序，关键在于我们只需要找到一个解；因此，先寻找最有可能的值是有意义的。
chap3_para908,4,,如果我们的目标是枚举所有的解而不只是找到一个解，那么值排序就无关紧要了。
chap3_para909,1,,6.3.2　交替进行搜索和推理
chap3_para91,1,3.,注意，边界分离（separate）了状态空间图的两个区域，即内部区域（其中每个状态都已被扩展）和外部区域（尚未到达的状态）。
chap3_para91,2,3.,该属性如图3-6所示。
chap3_para91,3,1Best-first search,
chap3_para910,1,,我们已经讨论了AC-3算法如何在搜索前缩减变量的域。
chap3_para910,2,,但在搜索过程中，推断的作用可能更大：每次我们为某个变量选择某个值时，都有一个全新的机会推断其相邻变量的新的域缩减。
chap3_para911,1,,推断的最简单形式之一是前向检验（forward checking）。
chap3_para911,2,,当变量X被赋值时，前向检验过程为其建立弧一致性：对于每个通过约束与X连接的未赋值变量Y，从它的域中删除与X的取值不一致的值。
chap3_para912,1,,图6-7为在澳大利亚地图CSP上使用前向检验进行回溯搜索的过程。
chap3_para912,2,,关于这一示例，有两点需要注意。
chap3_para912,3,,首先，需要注意，在赋值WA = red和Q = green后，NT和SA的域缩减为单个值；通过从WA和Q传播信息，我们可以完全消除这些变量上的分支。
chap3_para912,4,,其次，需要注意，赋值V= blue后，SA的域为空集。
chap3_para912,5,,因此，前向检验检测到部分赋值与问题的约束不一致，算法立即回溯。
chap3_para913,1,,图6-7　带前向检验的地图着色搜索过程。
chap3_para913,2,,首先赋值WA = red；然后前向检验从其相邻变量NT和SA的域中删除red。
chap3_para913,3,,赋值Q = green后，从NT、SA和NSW的域中删除green。
chap3_para913,4,,赋值V = blue后，从NSW和SA的域中删除blue，此时SA没有合法值
chap3_para914,1,,对许多问题来说，将MRV启发式算法与前向检验相结合，可以使搜索更有效。
chap3_para914,2,,考虑图6-7中的赋值。
chap3_para914,3,,直观上，这一赋值似乎对它的相邻变量NT和SA有所约束，所以接下来应该先处理这些变量，然后是所有其他变量。
chap3_para914,4,,MRV正是这么做的：NT和SA各有两个值，所以先选择其中一个，接着是另一个，然后依次是Q、NSW和V。
chap3_para914,5,,最后T仍然有3个可能的值，任意一个都是有效的。
chap3_para914,6,,我们可以将前向检验看作一种以增量方式计算MRV启发式算法完成其工作所需信息的有效途径。
chap3_para915,1,,尽管前向检验能够检测出许多不一致，但它无法检测到所有的不一致。
chap3_para915,2,,问题在于，它向前看得不够远。
chap3_para915,3,,例如，考虑图6-7中的Q = green一行。
chap3_para915,4,,我们已经使WA和Q弧一致，但此时NT和SA的唯一可能的值都是蓝色，这违反了一致性，因为它们是相邻变量，相邻变量不能取相同的值。
chap3_para916,1,,维护弧一致性（maintaining arc consistency，MAC）算法能检测出这类不一致性。
chap3_para916,2,,"当变量Xi被赋值后，Inference程序调用AC-3，但我们开始时只考虑所有与Xi相邻的未赋值变量Xj的弧(Xj, Xi)，而不是CSP中的所有弧。"
chap3_para916,3,,从这出发，AC-3以通常的方式进行约束传播，如果任何变量的域缩减为空集，则AC-3调用失败，并立即回溯。
chap3_para916,4,,我们可以看到，MAC严格来说比前向检验更强大，因为前向检验所做的事情与MAC对其队列的初始弧所做的相同；但与MAC不同的是，当变量的域发生变化时，前向检验不会递归地传播约束。
chap3_para917,1,,6.3.3　智能回溯：向后看
chap3_para918,1,,当搜索的一个分支失败时，图6-5中的Backtracking-Search算法将采取一种非常简单的策略：退回到上一个变量，并为其尝试一个不同的值。
chap3_para918,2,,这称为时序回溯（chronological backtracking），因为时间上最近的决策点会被重新访问。
chap3_para918,3,,在本节中，我们考虑更好的可能策略。
chap3_para919,1,,考虑一下，当我们按照固定的变量顺序Q、NSW、V、 T、SA、WA、NT应用图6-1中的简单回溯时会发生什么。
chap3_para919,2,,假设我们已经生成了部分赋值。
chap3_para919,3,,当我们尝试下一个变量SA时，发现所有值都违反了约束。
chap3_para919,4,,我们退回到T，为塔斯马尼亚州尝试一种新颜色！
chap3_para919,5,,显然，这种做法是愚蠢的——重新给塔斯马尼亚州着色并不能解决南澳大利亚州的问题。
chap3_para92,1,How do we decide which node from the frontier to expand next?,图3-6　以矩形网格问题为例说明图搜索的分离性质。
chap3_para92,2,"A very general approach is called best-first search, in which we choose a node, n, with minimum value of some evaluation function, f(n).",边界（绿色）分离了内部（淡紫色）和外部（虚线）。
chap3_para92,3,Figure 3.,边界是已达但尚未扩展的节点（及相应的状态）的集合；内部是已被扩展的节点（及相应的状态）的集合；外部是尚未到达的状态的集合。
chap3_para92,4,7 shows the algorithm.,在（a）中，只有根节点被扩展。
chap3_para92,5,"On each iteration we choose a node on the frontier with minimum f(n) value, return it if its state is a goal state, and otherwise apply EXPAND to generate child nodes.",在（b）中，上面的边界节点被扩展。
chap3_para92,6,"Each child node is added to the frontier if it has not been reached before, or is re-added if it is now being reached with a path that has a lower path cost than any previous path.",在（c）中，按顺时针顺序扩展根节点的其他后继节点
chap3_para92,7,"The algorithm returns either an indication of failure, or a node that represents a path to a goal.",
chap3_para92,8,"By employing different f(n) functions, we get different specific algorithms, which this chapter will cover.",
chap3_para920,1,,一种更智能的方法是回溯到有可能求解这一问题的变量——导致SA的某个可能值变成不可能值的变量。
chap3_para920,2,,为此，我们将记录与SA的某些值冲突的赋值集合。
chap3_para920,3,,该集合（在本例中为）称为SA的冲突集（conflict set）。
chap3_para920,4,,回跳（backjumping）方法将回溯到冲突集中最近的赋值，在本例中，回跳将越过塔斯马尼亚州，为V尝试一个新的值。
chap3_para920,5,,通过修改Backtrack算法，可以很容易地实现上述方法，即在检验合法值时，同时维护冲突集。
chap3_para920,6,,如果找不到合法值，算法应该返回失败指示和冲突集中最近的元素。
chap3_para921,1,,眼尖的读者可能已经注意到，前向检验不需要额外工作就能提供冲突集：当前向检验根据赋值X = x从Y的域中删除一个值时，它应该将X = x添加到Y的冲突集中。
chap3_para921,2,,如果Y的域中的最后一个值也被删除，那么Y的冲突集中的赋值也要被添加到X的冲突集中。
chap3_para921,3,,也就是说，我们现在知道X = x导致了（Y中的）矛盾，因此应该为X尝试不同赋值。
chap3_para922,1,,有眼力的读者可能已经注意到一些奇怪的事情：当域中的每个值都与当前赋值冲突时就会发生回跳，但前向检验能检测出这个事件并阻止搜索到达这样的节点！
chap3_para922,2,,事实上，可以证明，每个被回跳剪除的分支也会被前向检验剪枝。
chap3_para922,3,,因此，在前向检验搜索中，或者在使用更强一致性检验的搜索（如MAC）中，简单的回跳是多余的——你只需执行其中一项。
chap3_para923,1,,尽管存在上一段中的观测结果，回跳背后的思想仍然值得借鉴：基于失败原因进行回溯。
chap3_para923,2,,当变量的域变为空集时，回跳发现失败，但在许多情况下，在很早之前分支就注定要失败。
chap3_para923,3,,再次考虑部分赋值（从我们前面的讨论来看，它是不一致的）。
chap3_para923,4,,假设我们下一步尝试T = red，然后对NT、Q、V和SA赋值。
chap3_para923,5,,我们知道，最后这4个变量不存在有效赋值，所以最终在NT处终止。
chap3_para923,6,,现在，问题是，回溯到哪儿？
chap3_para923,7,,回跳是不可行的，因为NT确实存在与前面赋值过的变量一致的值——NT没有导致失败的前面变量的完整冲突集。
chap3_para923,8,,然而，我们知道，NT、Q、V和SA这4个变量放在一起会失败，是因为前面的一组变量一定与这4个变量有直接冲突。
chap3_para924,1,,这引出了（对于NT这样的变量的）一种不同的、更深层次的冲突集概念：正是前面一组变量共同导致了NT连同任何后续变量都不存在一致解。
chap3_para924,2,,在本例中，该集合是WA和NSW，所以算法应该跳过塔斯马尼亚州回溯到NSW。
chap3_para924,3,,使用以这种方式定义的冲突集的回跳算法称为冲突导向回跳（conflict-directed backjumping）。
chap3_para925,1,,现在我们必须解释如何计算这些新的冲突集。
chap3_para925,2,,方法其实很简单。
chap3_para925,3,,搜索分支的“终端”失败总是因为某个变量的域变为空集，该变量对应一个标准冲突集。
chap3_para925,4,,在我们的例子中，SA失败，它的冲突集是（例如）。
chap3_para925,5,,我们回溯到Q，Q将SA的冲突集（当然要减去Q本身）吸收到它自己的直接冲突集，新的冲突集是。
chap3_para925,6,,也就是说，给定前面对的赋值，从Q向前是没有解的。
chap3_para925,7,,因此，我们回溯到最近的变量NT。
chap3_para925,8,,NT将吸收到它自己的直接冲突集中，得到（如上一段所述）。
chap3_para925,9,,现在算法回跳到NSW，这正是我们所希望的。
chap3_para925,10,,总结一下：设Xj表示当前变量，conf(Xj)表示它的冲突集。
chap3_para925,11,,如果Xj的每个可能值都失败了，则回跳到conf(Xj)中最近的变量Xi，并使用下列公式重新计算Xi的冲突集：
chap3_para926,1,,6.3.4　约束学习
chap3_para927,1,,当我们遇到矛盾时，回跳可以告诉我们要退回多远，这样我们就不会浪费时间去改变那些无法求解问题的变量。
chap3_para927,2,,但我们也希望不要再遇到同样的问题。
chap3_para927,3,,当搜索得出一个矛盾时，我们知道这是冲突集的某个子集引起的。
chap3_para927,4,,约束学习（constraint learning）的思想是从冲突集中找出引起问题的最小变量集。
chap3_para927,5,,这组变量及其相应值称为无用赋值（no-good）。
chap3_para927,6,,如果想要记录无用赋值，要么通过向CSP中添加一个新的约束禁止这种赋值组合，要么通过维护一个单独的缓存。
chap3_para928,1,,例如，考虑图6-6最下面一行中的状态。
chap3_para928,2,,前向检验告诉我们这个状态是一个无用赋值，因为SA不存在有效赋值。
chap3_para928,3,,在这种特定情况下，记录该无用赋值是没有意义的，因为一旦从搜索树中剪掉了这一分支，我们再也不会遇到这种组合。
chap3_para928,4,,但假设图6-6中的搜索树实际上是更大的搜索树的一部分，该搜索树是从V和T的赋值开始的。
chap3_para928,5,,那么将记录为无用赋值是有意义的，因为对于V和T的每一组可能赋值，我们都会再次遇到同样的问题。
chap3_para929,1,,前向检验或回跳可以有效地利用无用赋值。
chap3_para929,2,,约束学习是现代CSP求解器用以提高复杂问题求解效率的最重要技术之一。
chap3_para93,1,"Description All the four binary trees have the root node labeled ""A"".",3.3.1　最佳优先搜索
chap3_para93,2,"Node ""A"" has two child nodes labeled B and C.",
chap3_para93,3,Node B has two child nodes labeled D and E.,
chap3_para93,4,Node C has two child nodes labeled F and G.,
chap3_para93,5,"Binary Tree 1: Node ""A"" is green-colored and a right arrowhead points to node ""A"".",
chap3_para93,6,All other nodes and paths are in faint dashed lines.,
chap3_para93,7,"Binary Tree 2: Node ""A"" is lavender-colored.",
chap3_para93,8,Nodes B and C are green-colored.,
chap3_para93,9,The right arrowhead points to node B.,
chap3_para93,10,"The two paths from node ""A"" to B and C are solid lines.",
chap3_para93,11,All other nodes and paths are in faint dashed lines.,
chap3_para93,12,"Binary Tree 3: Nodes ""A"" and B are lavender-colored.",
chap3_para93,13,"Nodes C, D, and E are green-colored.",
chap3_para93,14,The right arrowhead points to node C.,
chap3_para93,15,"The two paths from node ""A"" to B and C are solid lines.",
chap3_para93,16,The two paths from node B to D and E are solid lines as well.,
chap3_para93,17,All other nodes and paths are in faint dashed lines.,
chap3_para93,18,"Binary Tree 4: Nodes ""A"", B, and C are lavender-colored.",
chap3_para93,19,Other nodes are green-colored.,
chap3_para93,20,The right arrowhead points to node D.,
chap3_para93,21,All paths are solid lines.,
chap3_para930,1,,6.4　CSP的局部搜索
chap3_para931,1,,局部搜索算法（见4.1节）对于许多CSP的求解都非常有效。
chap3_para931,2,,它们使用完整状态形式（见4.1.1节），即每一状态为所有变量赋值，搜索一次改变一个变量的值。
chap3_para931,3,,例如，考虑6.1.3节中定义为CSP的8皇后问题。
chap3_para931,4,,在图6-8中，我们从左边开始，对8个变量进行了完整赋值，通常该赋值会违反一些约束。
chap3_para931,5,,然后我们随机选择一个发生冲突的变量，在此是最右边一列的Q8。
chap3_para931,6,,我们希望改变它的值，从而更接近问题的解。
chap3_para931,7,,最明显的方法是选择与其他变量冲突数最少的值——最少冲突（min-conflict）启发式算法。
chap3_para932,1,,图6-8　使用最少冲突法求解8皇后问题的示例。
chap3_para932,2,,每步选择一个皇后，在其所在列重新分配位置。
chap3_para932,3,,每个方格标有冲突数（在本例中是互相攻击的皇后个数）。
chap3_para932,4,,算法随机选择发生冲突的皇后，将皇后移动到冲突最少的方格
chap3_para933,1,,在图6-8中，我们看到有两行都只违反了一个约束，我们选择让Q8 = 3（也就是说，我们将皇后移动到第8列、第3行）。
chap3_para933,2,,下一次迭代，在图6-8的中间棋盘上，我们选择Q6作为要改变的变量，然后发现将该皇后移动到第8行不会发生冲突。
chap3_para933,3,,此时不再有发生冲突的变量，所以我们找到了一个解。
chap3_para933,4,,最少冲突算法如图6-9所示。
chap3_para933,5,,[4]
chap3_para935,1,,[4]　局部搜索可以很容易地扩展到约束优化问题（COP）。
chap3_para935,2,,在这种情况下，爬山法和模拟退火的所有技术都可以用于优化目标函数。
chap3_para936,1,,图6-9　CSP的Min-Conflicts局部搜索算法。
chap3_para936,2,,初始状态可以随机选择，也可以通过基于贪心法的赋值过程依次为每个变量选择最少冲突值。
chap3_para936,3,,在给定当前赋值的其余部分后，Conflicts函数统计特定值违反约束的数量
chap3_para937,1,,对许多CSP来说，最少冲突法都相当有效。
chap3_para937,2,,神奇的是，在n皇后问题上，如果不计入皇后的初始布局，最少冲突法的运行时间基本上与问题规模无关。
chap3_para937,3,,它甚至可以在（初始赋值后）平均50步内求解百万皇后问题。
chap3_para937,4,,这一不同寻常的现象是20世纪90年代大量研究局部搜索和难易问题间区别的动力，我们将在7.6.3节中讨论这些问题。
chap3_para937,5,,粗略地说，用局部搜索求解n皇后问题非常简单，因为解密集地分布在整个状态空间上。
chap3_para937,6,,最少冲突法也适用于困难问题。
chap3_para937,7,,例如，它已经被用于哈勃太空望远镜的观测调度，安排一周的观测调度所花费的时间可以从3周减少到大约10分钟。
chap3_para938,1,,4.1节中的所有局部搜索技术都可以应用于CSP，有些技术已被证实相当有效。
chap3_para938,2,,最少冲突启发式算法下的CSP地形图通常存在一系列平台区。
chap3_para938,3,,可能有数百万个变量赋值都只存在一个冲突。
chap3_para938,4,,平台区搜索——允许横向移动到另一个得分相同的状态——可以帮助局部搜索走出平台区。
chap3_para938,5,,这种在平台区的漫游可以由一种叫作禁忌搜索的技术导引：维护一个最近访问过的状态的列表，并禁止算法返回那些状态。
chap3_para938,6,,模拟退火也可以用于逃离平台区。
chap3_para939,1,,另一种技术称为约束加权（constraint weighting），旨在集中搜索重要约束。
chap3_para939,2,,每个约束都有一个数值权重，初始时都为1。
chap3_para939,3,,在每步搜索中，算法找出使其所违反的约束的总权重最低的变量，并修改其值。
chap3_para939,4,,然后，增加当前赋值所违反的每个约束的权重。
chap3_para939,5,,这种做法有两个好处：它为平台区增加了地形因素，确保从当前状态进行改进是有可能的；它还引入了学习策略，随着时间推移，难以求解的约束会被分配更高的权重。
chap3_para94,1,Figure 3.,我们如何决定下一步从边界扩展哪个节点？
chap3_para94,2,"7The best-first search algorithm, and the function for expanding a node.",最佳优先搜索（best-first search）是一种非常通用的方法，在这种方法中，我们选择使得某个评价函数（evaluation function）f(n)的值最小的节点n。
chap3_para94,3,The data structures used here are described in Section 3.,算法如图3-7所示。
chap3_para94,4,3.,在每次迭代中，选择边界上具有最小f(n)值的一个节点，如果它的状态是目标状态，则返回这个节点，否则调用Expand生成子节点。
chap3_para94,5,2.,对于每个子节点，如果之前未到达过该子节点，则将其添加到边界；如果到达该子节点的当前路径的代价比之前任何路径都要小，则将其重新添加到边界。
chap3_para94,6,See Appendix B for yield.,该算法要么返回failure，要么返回一个节点（表示一条通往目标的路径）。
chap3_para94,7,,通过使用不同的f(n)函数，可以得到不同的具体算法，本章将介绍这些算法。
chap3_para940,1,,局部搜索的另一个优点是，当问题发生变化时，它可以用于在线设定的问题（见4.5节）。
chap3_para940,2,,考虑一个航空公司每周航班调度问题。
chap3_para940,3,,它可能涉及上千趟航班和上万名人员的分配，但机场的恶劣天气可能会打乱这一调度。
chap3_para940,4,,我们希望以最少的改动修正日程表。
chap3_para940,5,,这可以通过从当前调度开始的局部搜索算法轻松完成。
chap3_para940,6,,使用新约束集的回溯搜索通常要花费更多时间，而且找到的解可能要对当前调度进行很多改动。
chap3_para942,1,,在这一节中，我们将研究如何利用由约束图表示的问题的结构来快速找到解。
chap3_para942,2,,这里的大多数方法也适用于CSP之外的其他问题，例如概率推理。
chap3_para943,1,,处理复杂的真实世界问题的唯一可能方法是将其分解为若干子问题。
chap3_para943,2,,回顾澳大利亚问题的约束图（图6-1b和图6-12a），可以发现一个问题：塔斯马尼亚州和大陆不相连。
chap3_para943,3,,[5]直观上看，对塔斯马尼亚州着色和对大陆着色显然是两个独立子问题（independent subproblem）——任何对大陆着色的解和任何对塔斯马尼亚州着色的解相结合都能得到整个地图的解。
chap3_para945,1,,[5]　细心的制图师或热爱塔斯马尼亚州的塔斯马尼亚人可能会反对将塔斯马尼亚州和离它最近的大陆邻域涂上相同的颜色，以免给人留下它可能是那个州的一部分的印象。
chap3_para946,1,,可以简单地通过寻找约束图的连通分量（connected component）来确定独立性。
chap3_para946,2,,每个连通分量对应一个子问题CSPi。
chap3_para946,3,,如果赋值Si是CSPi的解，那么就是的解。
chap3_para946,4,,为什么这很重要？
chap3_para946,5,,假设每个CSPi具有所有n个变量中的c个变量，其中c是一个常数。
chap3_para946,6,,那么共有n/c个子问题，求解每个子问题最多需要d c工作量，其中d是域的大小。
chap3_para946,7,,因此，总的工作量为O(dcn/c)，关于n是线性的；如果不进行问题分解，总的工作量为O(d n)，关于n是指数级的。
chap3_para946,8,,让我们更具体地说：将一个具有100个变量的布尔CSP分解为4个子问题，那么最坏情况下的求解时间将从宇宙生命周期减少到不到1秒。
chap3_para947,1,,完全独立的子问题很好，但很少见。
chap3_para947,2,,幸运的是，其他一些图结构也很容易求解。
chap3_para947,3,,例如，当任意两个变量都只由一条路径连接时，约束图是一棵树。
chap3_para947,4,,我们将证明任何树状结构的CSP都可以在变量个数的线性时间内求解。
chap3_para947,5,,[6]这里的关键是一种新的一致性概念——定向弧一致性（directional arc consistency）或DAC。
chap3_para947,6,,"变量顺序为X1, X2, …, Xn的CSP称为定向弧一致的，当且仅当，时，每个Xi相对于每个Xj都是弧一致的。"
chap3_para949,1,,[6]　遗憾的是，除了苏拉威西岛（Sulawesi）的地图比较接近树状外，世界上几乎没有一个地区是树状结构的地图。
chap3_para95,1,3.,图3-7　最佳优先搜索算法以及扩展节点的函数。
chap3_para95,2,3.,这里使用的数据结构将在3.3.2节中介绍。
chap3_para95,3,2Search data structures,yield的说明见附录B
chap3_para950,1,,为了求解树状结构的CSP，首先选择任一变量作为树的根节点，然后选择变量顺序，每个变量必须在其父节点之后。
chap3_para950,2,,这种排序称为拓扑排序（topological sort）。
chap3_para950,3,,图6-10a为一棵树，图6-10b为一种可能的排序。
chap3_para950,4,,任何有n个节点的树都有n−1条边，所以可以在O(n)步内使得该图具有定向弧一致性，每一步都必须比较两个变量的最多d个可能的值，总时间为O(nd2)。
chap3_para950,5,,一旦我们有了一个定向弧一致的图，就可以沿着变量列表选择任意剩余值。
chap3_para950,6,,因为从父节点到其子节点的每条边都是弧一致的，所以，对于父节点选择的任何值，子节点都存在一个可选的有效值。
chap3_para950,7,,这意味着我们不必回溯，可以沿着变量线性移动。
chap3_para950,8,,完整算法如图6-11所示。
chap3_para951,1,,图6-10　（a）树状结构CSP的约束图。
chap3_para951,2,,（b）与以A为根节点的树一致的变量的线性排序。
chap3_para951,3,,这称为变量的拓扑排序
chap3_para952,1,,既然我们有了关于树的高效算法，可以考虑更一般的约束图是否可以以某种方式简化为树结构。
chap3_para952,2,,有两种方法可以做到这一点：删除节点（6.5.1节）或合并节点（6.5.2节）。
chap3_para953,1,,图6-11　用于求解树状结构CSP的Tree-CSP-Solver算法。
chap3_para953,2,,如果CSP有解，我们可以在线性时间内找到它；如果无解，将检测到矛盾
chap3_para954,1,,6.5.1　割集调整
chap3_para955,1,,将约束图简化为树的第一种方法是为部分变量赋值使得剩余变量能够形成一棵树。
chap3_para955,2,,考虑澳大利亚问题的约束图，如图6-12a所示。
chap3_para955,3,,如果没有南澳大利亚州，这个图就会变成如图6-12b所示的一棵树。
chap3_para955,4,,幸运的是，我们可以通过将SA固定为某个值并从其他变量的域中删除任何与SA取值不一致的值来从图中删除南澳大利亚州。
chap3_para956,1,,图6-12　（a）图6-1中的原始约束图。
chap3_para956,2,,（b）除去SA后，约束图变成由两棵树组成的森林
chap3_para957,1,,现在，删除SA及其约束后，CSP的任意一个解都与SA的值一致。
chap3_para957,2,,（这适用于二元CSP，在高阶约束下，情况会更加复杂。
chap3_para957,3,,）因此，我们可以用上面给出的算法求解剩余的树，从而求解整个问题。
chap3_para957,4,,当然，在一般情况下（与地图着色不同），为SA选择的值可能是错误的，因此我们需要尝试每个可能的值。
chap3_para957,5,,一般算法如下。
chap3_para958,1,,（1）选择CSP变量的一个子集S，使得约束图在删除S后成为一棵树。
chap3_para958,2,,S称为环割集（cycle cutset）。
chap3_para959,1,,（2）对于满足S上所有约束的S中变量的每种可能赋值，
chap3_para96,1,Search algorithms require a data structure to keep track of the search tree.,3.3.2　搜索数据结构
chap3_para96,2,A node in the tree is represented by a data structure with four components:,
chap3_para960,1,,a. 从剩余变量的域中删除任何与S赋值不一致的值，并且
chap3_para961,1,,b. 如果剩余的CSP存在一个解，那么将其连同S的赋值一起返回。
chap3_para962,1,,如果环割集的大小为c，那么总运行时间为：我们需要尝试S中变量的值的所有d c种组合，对于每种组合，我们需要求解一个大小为(n −c)的树问题。
chap3_para962,2,,如果约束图“几乎是一棵树”，那么c将会非常小，相比于直接使用回溯法，将省掉巨大的开销——对100个布尔变量的示例来说，如果我们能找到一个大小为c = 20的割集，时间开销可以从宇宙生命周期缩短到几分钟。
chap3_para962,3,,然而，在最坏情况下，c可能高达(n −2)。
chap3_para962,4,,寻找最小环割集问题是NP困难的，但有一些高效的近似算法。
chap3_para962,5,,算法的总体过程称为割集调整（cutset conditioning），我们将在第13章详细讨论，在那里它将用于概率推理。
chap3_para964,1,,将约束图简化为树的第二种方法基于构建约束图的树分解（tree decomposition）：将原始图转换为树，树中的每个节点由一组变量组成，如图6-13所示。
chap3_para964,2,,树分解必须满足以下3个要求。
chap3_para965,1,,● 原始问题中的每个变量必须至少出现在一个树节点中。
chap3_para966,1,,● 如果两个变量在原始问题中由一个约束连接，那么它们必须同时出现（连同约束）在至少一个树节点中。
chap3_para967,1,,● 如果一个变量出现在两个树节点中，那么它必须出现在连接这两个节点的路径上的所有节点中。
chap3_para968,1,,前两个条件保证了所有变量和约束在树分解中都有表示。
chap3_para968,2,,第三个条件似乎更具技术性，但保证了原始问题的任何变量无论在哪出现都具有相同的值：树中的约束表明一个树节点中的变量必须与其相邻节点中的相应变量具有相同的值。
chap3_para968,3,,例如，图6-13中SA出现在相连的所有4个节点中，因此树分解中的每条边都包含一个约束，一个节点中SA的值必须与下个节点中SA的值相同。
chap3_para968,4,,你可以从图6-12中验证这种分解是有意义的。
chap3_para969,1,,图6-13　图6-12a中约束图的一个树分解
chap3_para97,1,•node.STATE: the state to which the node corresponds;,搜索算法需要一个数据结构来跟踪搜索树。
chap3_para97,2,,树中的节点（node）由一个包含4个组成部分的数据结构表示。
chap3_para970,1,,一旦我们有了一个树状结构图，我们可以应用Tree-CSP-Solver在O(nd 2)时间内得到解，其中n是树节点的个数，d是最大域的大小。
chap3_para970,2,,但是要注意，在树中，域是一组值元组，而不只是单个值。
chap3_para971,1,,例如，图6-13中的左上节点表示在原始问题层级上，变量为，域为，约束为、和的子问题。
chap3_para971,2,,"而在树的层级上，节点表示单个变量，我们可以将其称为SANTWA，它的值必须是一个由颜色组成的三元组，如(red, green, blue)，但不能是(red, red, blue)，因为违反了原始问题中的约束。"
chap3_para971,3,,"然后我们可以从这个节点移动到相邻节点，其变量为SANTQ，此时只有一个元组(red, green, blue)与SANTWA的选择一致。"
chap3_para971,4,,对后两个节点重复完全相同的过程，但可以独立地为T作出任何选择。
chap3_para972,1,,使用Tree-CSP-Solver算法可以在O(nd2)时间内求解任何树分解问题，只要d保持较小值，它都是高效的。
chap3_para972,2,,回到100个布尔变量的示例，如果每个节点有10个变量，那么d = 210，我们可以在几秒内找到解。
chap3_para972,3,,但如果有一个节点包含30个变量，则需要几个世纪的时间。
chap3_para973,1,,一个给定的图允许多种树分解，在选择分解时，目标是使子问题尽可能小。
chap3_para973,2,,（将所有变量放在同一个节点中在技术上也是一棵树，但对求解问题没有帮助。
chap3_para973,3,,）图的树分解的树宽（tree width）为最大节点的大小减1，图本身的树宽定义为其所有树分解的最小宽度。
chap3_para973,4,,如果一个图的树宽为w，那么给定相应的树分解，该问题可以在O(ndw+1)时间内求解。
chap3_para973,5,,因此，如果CSP的约束图树宽有界，则该CSP在多项式时间内是可解的。
chap3_para974,1,,遗憾的是，找出树宽最小的分解是 一个NP困难问题，但有一些启发式方法在实践中效果很好。
chap3_para974,2,,时间为的割集分解和时间为O(ndw+1)的树分解哪个更好？
chap3_para974,3,,每当有一个大小为c的环割集时，也会有一个大小为的树宽，并且在某些情况下它可能要小得多。
chap3_para974,4,,所以从时间上考虑，应该选择树分解，但环割集方法的优点是，它可以在线性内存中执行，而树分解需要关于w的指数级内存。
chap3_para976,1,,到目前为止，我们已经讨论了约束图的结构。
chap3_para976,2,,在变量的值中，或在约束关系本身的结构中，也可能存在重要的结构。
chap3_para976,3,,考虑有d种颜色的地图着色问题。
chap3_para976,4,,对于每个一致解，实际上都有一组通过排列颜色名形成的d!个解。
chap3_para976,5,,例如，在澳大利亚地图中，我们知道WA、NT和SA肯定具有不同颜色，但实际上，将3种颜色分配给3个区域有3! = 6种方法。
chap3_para976,6,,这称为值对称（value symmetry）。
chap3_para976,7,,我们希望通过打破这种赋值对称性将搜索空间缩小d!倍。
chap3_para976,8,,可以通过引入对称性破缺约束（symmetry-breaking constraint）做到这一点。
chap3_para976,9,,对于我们的例子，可以施加一个任意的排序约束，，即要求3个值按字母顺序排列。
chap3_para976,10,,这个约束保证了d!个解中只有一个是可能解：。
chap3_para977,1,,对于地图着色问题，很容易找到一个消除对称性的约束。
chap3_para977,2,,一般来说，要消除所有的对称性是NP困难的，但打破值对称已被证明在许多问题上都是重要和有效的。
chap3_para979,1,,● 约束满足问题（CSP）的状态为一组变量/值对，解的条件为一组变量约束。
chap3_para979,2,,许多重要的真实问题都可以用CSP描述。
chap3_para98,1,•node.PARENT: the node in the tree that generated this node;,● node.State：节点对应的状态。
chap3_para980,1,,● 许多推断技术利用约束排除某些变量赋值。
chap3_para980,2,,这些约束包括节点一致性、弧一致性、路径一致性和k一致性。
chap3_para981,1,,● 回溯搜索是深度优先搜索的一种形式，通常用于求解CSP。
chap3_para981,2,,推断可以与搜索交替进行。
chap3_para982,1,,● 最少剩余值启发式算法和度启发式算法是领域无关的方法，用于决定在回溯搜索中下一步选择哪个变量。
chap3_para982,2,,最少约束值启发式算法有助于决定对于给定变量首先尝试哪个值。
chap3_para982,3,,回溯发生在某个变量找不到合法赋值时。
chap3_para982,4,,冲突导向回跳直接回溯到问题的根源。
chap3_para982,5,,约束学习记录在搜索过程中遇到的冲突，以免在以后的搜索中出现相同的冲突。
chap3_para983,1,,● 使用最少冲突启发式算法的局部搜索也已成功地应用于约束满足问题。
chap3_para984,1,,● CSP求解的复杂性与其约束图的结构密切相关。
chap3_para984,2,,树状结构问题可以在线性时间内求解。
chap3_para984,3,,割集调整可以将一般的CSP简化为树状结构的CSP，如果能找到一个较小的割集，算法会非常高效（只需线性内存）。
chap3_para984,4,,树分解技术将CSP转化为由子问题构成的树，当约束图的树宽较小时，算法是高效的；然而，它们需要约束图树宽的指数级的内存。
chap3_para984,5,,将割集调整和树分解相结合可以更好地权衡所需内存和时间。
chap3_para987,1,,第三部分　知识、推理和规划
chap3_para989,1,,在本章中，我们设计能够表示复杂世界的智能体，它使用推断过程来获取关于这个世界的新表示，并使用这种表示来推导下一步该怎么做。
chap3_para99,1,•node.ACTION: the action that was applied to the parent’s state to generate this node;,● node.Parent：父节点，即树中生成该节点的节点。
chap3_para990,1,,人类似乎具有知识，人类的知识能够帮助他们做事。
chap3_para990,2,,在人工智能中，基于知识的智能体（knowledge-based agent）对知识的内部表示（representation）进行推理（reasoning）来确定要采取的动作。
chap3_para991,1,,第3章和第4章的问题求解智能体具有知识，但这种知识是非常有限且死板的。
chap3_para991,2,,它们知道可以采取哪些动作，也知道在某个状态采取某个动作将得到哪种结果，但它们不知道一般事实。
chap3_para991,3,,例如，寻路智能体不知道一条路的长度不可能是负数公里，而8数码智能体也不知道两块瓷砖无法放置在同一个空格当中。
chap3_para991,4,,问题求解智能体具有的知识对寻找从起点到终点的路径这种问题非常有用，但也仅限于此。
chap3_para992,1,,问题求解智能体所使用的原子表示也有很大的局限性。
chap3_para992,2,,例如，在部分可观测的环境中，问题求解智能体表示它对当前状态的了解的唯一选项是列出所有可能的具体状态。
chap3_para992,3,,我可以让一个人驱车前往一个人口不超过1万的美国小镇，但如果要让问题求解智能体来做这件事，我只能明确地将目标描述为大约1.6万个符合条件的小镇的集合。
chap3_para993,1,,第6章引入了我们的第一个因子化表示，其中状态被表示为对变量的赋值。
chap3_para993,2,,这是朝正确方向前进的一步，它能使智能体的某些部分以与领域无关的方式运作，并支持更高效的算法。
chap3_para993,3,,在本章中，我们将这一步延伸到它的逻辑结论，可以说，我们将逻辑扩展为一类通用的表示，以支持基于知识的智能体。
chap3_para993,4,,这些智能体可以组合或重组信息以适应各种用途。
chap3_para993,5,,它可以与我们当下的需要毫不相关，就像数学家证明定理或天文学家计算地球的预期寿命一样。
chap3_para993,6,,基于知识的智能体能够接受明确描述的目标作为任务，能够通过主动学习或被告知关于环境的新知识快速地获得完成任务的能力，也能够通过更新相关知识适应环境的变化。
chap3_para994,1,,我们在7.1节开始介绍智能体的总体设计。
chap3_para994,2,,7.2节新引入了一个名为wumpus世界的简单环境，以便在不涉及任何技术细节的前提下，阐明基于知识的智能体的运作方式。
chap3_para994,3,,随后我们在7.3节解释逻辑的一般原理，在7.4节介绍命题逻辑的具体细节。
chap3_para994,4,,命题逻辑是一种因子化表示，尽管它的表达能力不如一阶逻辑（第8章）这种标准的结构化表示，但却能够阐明逻辑的所有基本概念。
chap3_para994,5,,命题逻辑还具有丰富的推断方法，我们将在7.5节和7.6节中描述这些内容。
chap3_para994,6,,最后，7.7节将基于知识的智能体的概念与命题逻辑的技术结合起来，为wumpus世界构建了一个简单的智能体。
chap3_para995,1,,7.1　基于知识的智能体
chap3_para996,1,,基于知识的智能体的核心部件是它的知识库（knowledge base，KB）。
chap3_para996,2,,知识库是一个语句集。
chap3_para996,3,,（此处“语句”是一个术语。
chap3_para996,4,,它与英语或其他自然语言的语句类似，但不完全相同。
chap3_para996,5,,）这些语句用知识表示语言（knowledge representation language）表达，代表了关于世界的某种断言。
chap3_para996,6,,如果一条语句是直接给出的，而不是从其他语句推导而来的，我们就称它为公理（axiom）。
chap3_para997,1,,向知识库添加新语句以及从知识库查询已知语句的方法是必不可少的。
chap3_para997,2,,这些操作的标准名称分别是Tell（告知）和Ask（询问）。
chap3_para997,3,,这两个操作都可能涉及推断（inference），也就是从原有语句中推导出新语句。
chap3_para997,4,,推断必须符合以下要求：当向知识库询问（Ask）时，答案应当遵循先前已经告知（Tell）知识库的内容而生成。
chap3_para997,5,,我们将在本章后续部分仔细讲解何为“遵循”。
chap3_para997,6,,现在，我们暂且将其理解为在推断过程中不能进行捏造。
chap3_para998,1,,图7-1展示了基于知识的智能体程序。
chap3_para998,2,,与所有的智能体一样，基于知识的智能体以一个感知作为输入，返回一个动作。
chap3_para998,3,,该智能体维护一个知识库KB，这个知识库最初可能包括一些背景知识（background knowledge）。
chap3_para999,1,,图7-1　通用的基于知识的智能体。
chap3_para999,2,,给定一个感知，智能体将这一感知添加进知识库，向知识库询问最优动作，并告知知识库它已经采取了这一动作
chap4_para1,1,SEARCH IN COMPLEX ENVIRONMENTS,在本章中，我们放宽了第3章的简化假设，以更接近真实世界。
chap4_para10,1,Figure 4.,爬山搜索算法如图4-2所示。
chap4_para10,2,1A one-dimensional state-space landscape in which elevation corresponds to the objective function.,它记录当前状态并在每次迭代中移动到值最大的相邻状态，也就是说，它朝最陡上升（steepest ascent）的方向前进。
chap4_para10,3,The aim is to find the global maximum.,当它到达一个没有邻居具有更高值的“峰值”时，算法终止。
chap4_para10,4,,爬山法不会考虑超出当前状态的直接邻居之外的状态。
chap4_para10,5,,这就像是一个健忘的人在大雾中试图找到珠穆朗玛峰的顶峰。
chap4_para10,6,,注意，使用爬山搜索的一种方法是使用启发式代价函数的负值作为目标函数；算法将局部地爬升至到目标的启发式距离最小的状态。
chap4_para100,1,"Description The belief states are depicted by circular sections enclosing the vacuum world states. Part (“a”): State 1 and 3 of the vacuum world are enclosed in a single section and states 2 and 4 of the vacuum world are enclosed in another section. An arrow from state 1 points to state 2 and an arrow from state 3 points to state 4 of the vacuum world. Part (b): State 1 and state 3 of the vacuum world are enclosed in a single section. State 1, 2, 3, and 4 of the vacuum world are enclosed in another section. Two arrows from state 1 in the first section point to states 1 and 2 in the second section. Two arrows from state 3 of the first section point to states 3 and 4 of the second section.",我们看到，条件规划可以包含if–then–else步骤；这意味着解是树而不是序列。
chap4_para100,2,,这里的if语句中的条件用来测试当前状态；这是智能体在运行时能够观测到的，但规划时还不知道。
chap4_para100,3,,或者，我们也可以用公式来测试感知而不是状态。
chap4_para100,4,,真实物理世界中的许多问题都是应变问题，因为不可能对未来进行准确预测。
chap4_para100,5,,因此，许多人在走路时都会睁着眼睛。
chap4_para1000,1,,本节我们讨论表示语言的特性。
chap4_para1000,2,,编程语言（如C++、Java或Python）是常用的最大一类形式化语言。
chap4_para1000,3,,程序中的数据结构可以用来表示事实，例如，程序可以使用一个4×4数组表示wumpus世界的内容。
chap4_para1000,4,,"这样的话，编程语言中的语句就是断言在方格[2, 2]中有无底洞的一种很自然的方式。"
chap4_para1000,5,,将一系列这样的语句合起来，就足以对wumpus世界进行模拟。
chap4_para1001,1,,编程语言欠缺的是从其他事实推导事实的通用机制：对数据结构的每次更新都要使用领域特定的过程，而过程中的具体细节是由程序员根据其自身所具有的该领域的知识进行推导的。
chap4_para1001,2,,这种过程性的方法可与命题逻辑的陈述性（declarative）特性相对比，在命题逻辑中知识与推断是独立的，而推断完全是领域无关的。
chap4_para1001,3,,SQL数据库融合了陈述性与过程性知识。
chap4_para1002,1,,"程序（以及数据库）中数据结构的另一个缺点是缺少简便的表示方式来描述像“在方格[2, 2]或[3, 1]中有无底洞”或“如果wumpus在[1, 1]中，则它不在[2, 2]中”这样的概念。"
chap4_para1002,2,,程序可以为每个变量存储一个值，一些系统也允许这个值为“未知”，但它们缺乏直接处理部分信息的表达能力。
chap4_para1003,1,,命题逻辑是说明性语言，因为它的语义是基于语句与可能世界之间的真值关系的。
chap4_para1003,2,,使用析取和否定，命题逻辑有了足够的表达能力来处理部分信息。
chap4_para1003,3,,命题逻辑还有一个在表示语言中很有用的特性，即合成性（compositionality）。
chap4_para1003,4,,在合成语言中，一条语句的含义是其各个组成部分的含义的一个函数。
chap4_para1003,5,,"例如，“S1,4 ∧ S1,2”的含义与“S1,4”和“S1,2”的含义有关。"
chap4_para1003,6,,"如果“S1,4”表示方格[1, 4]有臭味，“S1,2”表示方格[1, 2]有臭味，而“S1,4 ∧ S1,2”却表示法国与波兰在上周的冰球资格赛1∶1打平，就显得非常奇怪。"
chap4_para1004,1,,然而，命题逻辑作为一种因子化表示，缺乏能够简洁描述具有多个对象的环境的表达能力。
chap4_para1004,2,,例如，我们不得不为每个方格分别写出关于微风和无底洞的规则，如：
chap4_para1005,1,,而在英语中，我们似乎可以简单地用一句“Squares adjacent to pits are breezy.”（与无底洞相邻的方格有微风）来一举解决问题。
chap4_para1005,2,,英语的语法和语义使它能够简洁地描述环境：英语是结构化表示，一阶逻辑也是。
chap4_para1006,1,,8.1.1　思想的语言
chap4_para1007,1,,自然语言（如英语或西班牙语）确实富有表达能力。
chap4_para1007,2,,我们设法用自然语言写作这一整本书的几乎全部内容，只偶尔地转用其他语言（主要是数学和图表）。
chap4_para1007,3,,语言学和语言哲学将自然语言视为说明性知识表示语言由来已久。
chap4_para1007,4,,如果我们能够揭示自然语言的规则，我们就能将其用于表示和推理系统，并获益于数十亿页已经用自然语言写就的文字。
chap4_para1008,1,,自然语言的现代观点是将其视作交流的媒介而非单纯的表示。
chap4_para1008,2,,当说者指向一处并说“看！
chap4_para1008,3,,”听者就会明白他说的是超人终于出现在房顶了。
chap4_para1008,4,,但我们不能说是语句“看！
chap4_para1008,5,,”表示了这一事实。
chap4_para1008,6,,实际上，语句的含义既取决于语句本身，也取决于说出这一语句时的语境。
chap4_para1008,7,,显然，如果不在知识库中存储语句语境的表示而是仅存储像“看！
chap4_para1008,8,,”这样的语句，我们就无法搞清其含义——这就引发了语境本身该如何表示的问题。
chap4_para1009,1,,自然语言也受制于模糊性，这也是表示语言面临的问题。
chap4_para1009,2,,"正如平克（Pinker, 1995）所述：“当人们想到spring时，他们绝对不会困惑于他们到底是想到了一个季节还是想到了那个发出‘啵嘤’声的东西——如果一个词语可以对应于两种思想，那么思想就不能是词语。"
chap4_para1009,3,,”[2]
chap4_para101,1,Figure 4.,4.3.2　与或搜索树
chap4_para101,2,10The first two levels of the search tree for the erratic vacuum world.,
chap4_para101,3,State nodes are OR nodes where some action must be chosen.,
chap4_para101,4,"At the AND nodes, shown as circles, every outcome must be handled, as indicated by the arc linking the outgoing branches.",
chap4_para101,5,The solution found is shown in bold lines.,
chap4_para1011,1,,[2]　表示“春天”和“弹簧”的英语单词都是spring。
chap4_para1011,2,,——译者注
chap4_para1012,1,,"著名的萨丕尔-沃尔夫假说（Sapir-Whorf hypothesis）（Whorf, 1956）宣称，我们对世界的理解深受我们所说的语言的影响。"
chap4_para1012,2,,不同的语言群体以不同的方式划分世界。
chap4_para1012,3,,对英语使用者来说，“chair”一词囊括法语中“chaise”和“fauteuil”两个单词的概念，但英语使用者可以轻易地认出fauteuil这个类别，并给它命名——大概是“扶手椅”（open-arm chair）。
chap4_para1012,4,,那么语言真的会对理解有影响吗？
chap4_para1012,5,,沃尔夫主要依靠直觉和猜测，他的想法也已经基本被摒弃，但多年以来我们其实有来自人类学、心理学和神经科学研究的真实数据。
chap4_para1013,1,,例如，你是否还记得下列表述中的哪一个构成了8.1节的开头？
chap4_para1014,1,,“本节我们讨论表示语言的特性……”
chap4_para1015,1,,“本节讲述表示语言的相关知识……”
chap4_para1016,1,,"维纳（Wanner, 1974）进行了类似的实验并发现，实验对象做出正确选择的概率处于随机水平——大概为50%，但对阅读内容记忆的准确率却超过90%。"
chap4_para1016,2,,这意味着，人们会解读其阅读过的文字并形成内在的非文字表示，而确切的用词并不重要。
chap4_para1017,1,,当某个概念在一种语言里根本不存在时，情况就更加有趣。
chap4_para1017,2,,澳大利亚的土著语言Guugu Yimithirr的使用者没有词语来表示如前、后、左、右这样的相对（或自我中心）方向。
chap4_para1017,3,,他们只使用绝对方向，例如“我北边的胳膊有点疼”。
chap4_para1017,4,,这种语言上的区别就导致了行为的区别：Guugu Yimithirr使用者在开阔地形上的定向能力更好，而英语使用者则更擅长于将叉子放在盘子右侧。
chap4_para1018,1,,语言似乎也会通过类似名词的性这种看起来毫无规律的文法特征来影响思维。
chap4_para1018,2,,例如，“桥”在西班牙语中是阳性词，而在德语中是阴性词。
chap4_para1018,3,,"博罗迪茨基（Boroditsky, 2003）要求实验对象选取英语形容词来描述某座桥的照片。"
chap4_para1018,4,,西班牙语使用者选择了大（big）、危险（dangerous）、坚固（strong）、耸立（towering），而德语使用者则选择了优美（beautiful）、优雅（elegant）、脆弱（fragile）、纤细（slender）。
chap4_para1019,1,,词语可以充当我们感知世界的锚点。
chap4_para1019,2,,洛夫特斯和帕尔默（Loftus and Palmer，1974）向实验对象展示了汽车事故的影片，被问及“车辆接触时的车速是多少？
chap4_para1019,3,,”的实验对象报告的平均速度为51.5 km/h，而使用“撞击”替代问题中的“接触”后，对于同一部影片的同一辆车，被提问的实验对象报告的平均速度则为66 km/h。
chap4_para1019,4,,总体来看，不同语言的使用者在认知处理上有微小却可测出的区别，但并没有令人信服的证据能够说明这会引起世界观的重大区别。
chap4_para102,1,"A solution for an AND–OR search problem is a subtree of the complete search tree that (1) has a goal node at every leaf, (2) specifies one action at each of its OR nodes, and (3) includes every outcome branch at each of its AND nodes. The solution is shown in bold lines in the figure; it corresponds to the plan given in Equation (4.3).",我们如何得到这些非确定性问题的条件解？
chap4_para102,2,,和第3章一样，我们首先从构造搜索树开始，但是这里的树有一个不同的特性。
chap4_para102,3,,在确定性环境中，分支是由智能体在每个状态下自己的选择引入的：我可以执行这个动作或那个动作。
chap4_para102,4,,我们称这些节点为或节点（OR node）。
chap4_para102,5,,例如，在真空吸尘器世界中，智能体在或节点上选择Left、Right或Suck。
chap4_para102,6,,而在非确定性环境中，环境对每个动作的结果的选择也会引入分支。
chap4_para102,7,,我们称这些节点为与节点（AND node）。
chap4_para102,8,,"例如，状态1中的Suck动作会产生信念状态{5,7}，因此智能体需要为状态5与状态7分别找到一个规划。"
chap4_para102,9,,这两种节点交替出现，形成如图4-10所示的与或树（AND–OR tree）。
chap4_para1020,1,,在使用合取范式（CNF）的逻辑推理系统中，我们知道语言表达式“”和“”是等价的，因为我们可以看到系统的内部，并能够了解到这两条语句是以完全相同的标准CNF形式存储的。
chap4_para1020,2,,而对人类的大脑进行类似的操作正在成为可能。
chap4_para1020,3,,"米切尔等人（Mitchell et al., 2008）让实验对象进入功能性磁共振成像（fMRI）仪，然后向他们展示如“芹菜”之类的词语，并对他们的大脑进行成像。"
chap4_para1020,4,,"使用(词语, fMRI图像)数据对训练而成的机器学习程序能够在二选一任务（例如，是“芹菜”还是“飞机”）中达到77%的准确率。"
chap4_para1020,5,,这套系统甚至能够对其先前从未见过fMRI图像的词语（通过考虑相关词语的图像）和从未见过的人（证明fMRI揭示了人脑的表示方式具有某种共性）达到超过随机猜测的准确率。
chap4_para1020,6,,"尽管这类研究还相当原始，但fMRI以及其他成像技术，例如颅内电生理学（Sahin et al., 2009），有望将人类的知识表示形式探究得更为详尽。"
chap4_para1021,1,,从形式化逻辑的观点来看，用两种不同的方式表示相同的知识一点区别都没有，无论从何种表示出发都能推出相同的事实。
chap4_para1021,2,,但在实际中，从其中一种表示推出结论的步骤可能更少，这意味着资源有限的推理机只能从这一种表示得出结论，而非其他表示。
chap4_para1021,3,,对于类似从经验中学习这样的非演绎任务，其结果必然地依赖于其所使用的表示。
chap4_para1021,4,,我们在第19章阐述了当学习程序考虑两种关于世界的理论时，如果这两种理论与所有数据都是一致的，那么最为常见的破局方式就是选择最简洁的理论，而这取决于用来表示理论的语言。
chap4_para1021,5,,那么，对任何进行学习的智能体来说，语言对思想的影响就是不可避免的。
chap4_para1022,1,,8.1.2　结合形式语言和自然语言的优点
chap4_para1023,1,,我们可以采用形式逻辑的基础——一种上下文无关的、无歧义的说明性、合成式语义——来构建一种更有表达能力的逻辑，同时又从自然语言中借鉴表示方法并避免其缺点。
chap4_para1023,2,,当我们考察自然语言时，最为显眼的元素就是指代对象的名词和名词性短语（方格、无底洞、wumpus）和动词与动词性短语以及表示对象关系的形容词和副词（有微风、相邻、射击）。
chap4_para1023,3,,这些关系当中有的是函数，即对于一个给定“输入”只有一个“值”的关系。
chap4_para1023,4,,很容易就能列出一些对象、关系和函数。
chap4_para1024,1,,● 对象：人、房屋、数字、理论、麦当劳叔叔、颜色、棒球游戏、战争、世纪等。
chap4_para1025,1,,● 关系：可以是一元关系或属性，如红色的、圆的、伪造的、主要的、多层的等，或更为普适的n元关系，如是……的兄弟、大于、在……里、是……的一部分、有……颜色、发生于……之后、拥有、在……中间等。
chap4_para1026,1,,● 函数： ……的父亲、……最好的朋友、……的第三局比赛、比……多一个、……的开始等。
chap4_para1027,1,,实际上，几乎所有断言都可以看作对对象和属性的指代或关系。
chap4_para1027,2,,下面是一些例子。
chap4_para1028,1,,● “1加2等于3”。
chap4_para1029,1,,对象：1、2、3、1加2。
chap4_para1029,2,,关系：等于。
chap4_para1029,3,,函数：加。
chap4_para1029,4,,（“1加2”是对对象“1”和“2”应用函数“加”后得到的对象的名称。
chap4_para1029,5,,“3”是这个对象的另一个名称。
chap4_para1029,6,,）
chap4_para103,1,"Figure 4.11 gives a recursive, depth-first algorithm for AND–OR graph search. One key aspect of the algorithm is the way in which it deals with cycles, which often arise in nondeterministic problems (e.g., if an action sometimes has no effect or if an unintended effect can be corrected). If the current state is identical to a state on the path from the root, then it returns with failure. This doesn’t mean that there is no solution from the current state; it simply means that if there is a noncyclic solution, it must be reachable from the earlier incarnation of the current state, so the new incarnation can be discarded. With this check, we ensure that the algorithm terminates in every finite state space, because every path must reach a goal, a dead end, or a repeated state. Notice that the algorithm does not check whether the current state is a repetition of a state on some other path from the root, which is important for efficiency.",图4-10　不稳定的真空吸尘器世界搜索树的前两层。
chap4_para103,2,,状态节点是必须选择某个动作的或节点。
chap4_para103,3,,与节点（用圆圈表示）上的每个结果都必须处理，结果分支间用弧线连接。
chap4_para103,4,,找到的解用粗线标识
chap4_para1030,1,,● “与wumpus相邻的方格有臭味”。
chap4_para1031,1,,对象：wumpus、方格。
chap4_para1031,2,,属性：有臭味。
chap4_para1031,3,,关系：相邻。
chap4_para1032,1,,● “邪恶的约翰国王在1200年统治英格兰”。
chap4_para1033,1,,对象：约翰、英格兰、1200年。
chap4_para1033,2,,关系：统治。
chap4_para1033,3,,属性：邪恶的、国王。
chap4_para1034,1,,一阶逻辑语言是围绕对象和关系构建的，我们于下一节定义其语法和语义。
chap4_para1034,2,,它对于数学、哲学和人工智能乃至人类生活的很多方面都非常重要，因为这些领域要处理的正是对象和对象之间的关系。
chap4_para1034,3,,一阶逻辑也可以表示关于全域中的一些和全部对象的事实。
chap4_para1034,4,,这就使我们可以表示各种法则和规则，例如陈述“与wumpus相邻的方格很臭”。
chap4_para1035,1,,命题逻辑和一阶逻辑的主要区别在于其各自的本体论约定（ontological commitment），即它对真实世界性质的假设。
chap4_para1035,2,,数学上来说，这一约定是通过语句真值确定的形式化模型的性质来表示的。
chap4_para1035,3,,例如，命题逻辑假设世界中存在要么成立要么不成立的事实。
chap4_para1035,4,,每个事实都可以为真或假这两种状态中的一个，而每个模型为每个命题符号进行true或false的赋值（见7.4.2节）。
chap4_para1035,5,,一阶逻辑则进行了更多假设，它假设世界是由具有关系的对象组成的，这些关系要么成立要么不成立（见图8-1）。
chap4_para1035,6,,因此，一阶逻辑的形式化模型也就比命题逻辑更为复杂。
chap4_para1036,1,,图8-1　形式化语言及其本体论约定和认识论约定
chap4_para1037,1,,这种本体论约定是逻辑（包括命题逻辑和一阶逻辑）的强项，因为它允许我们从真实的陈述出发来推断其他真实的陈述。
chap4_para1037,2,,这对于每条命题都有清晰边界的领域非常有效，例如数学或wumpus世界。
chap4_para1037,3,,在wumpus世界中，一个方格要么有无底洞要么没有无底洞，那种有个像无底洞一样的大坑的方格是不存在的。
chap4_para1037,4,,但在真实世界中，许多命题的边界是模糊的：维也纳是大城市吗？
chap4_para1037,5,,那家餐厅的菜好吃吗？
chap4_para1037,6,,这个人高吗？
chap4_para1037,7,,这都取决于被你提问的人，而他们的回答可能是“还行吧”。
chap4_para1038,1,,对此，一种解决办法是细化表示：如果将城市分为“大”和“不大”的标准太粗略，使我们上述的应用中存在太多疑问，那么我们可以增加分类的个数，或使用Population这样的函数符号。
chap4_para1038,2,,另一种解决方案来源于模糊逻辑（fuzzy logic），它使用的本体论约定使得命题具有在0到1之间的真实度（degree of truth）。
chap4_para1038,3,,例如，语句“维也纳是大城市”在模糊逻辑中可能真实度是0.8，而“巴黎是一个大城市”则可能真实度是0.9。
chap4_para1038,4,,这更符合我们对真实世界的直观理解，但也更难进行推断：不同于确定A∧B真值的唯一规则，模糊逻辑在不同领域需要不同的规则。
chap4_para1038,5,,还有一个解决办法（将在24.1节阐述）是在多维空间中为每个概念分配一个点，并测量概念“大城市”与概念“巴黎”或“维也纳”的距离。
chap4_para1039,1,,不少特定用途的逻辑还进一步地进行了本体论约定，例如时态逻辑（temporal logic）假设事实在特定的时间成立，而这些时间（可能是时间点或时间区间）是有序的。
chap4_para1039,2,,这样，特定用途的逻辑就使某种对象（以及关于它们的公理）在这种逻辑内更“高级”，而非只是在知识库中对其进行定义。
chap4_para1039,3,,高阶逻辑（higher-order logic）将一阶逻辑中的关系和函数视作其自身的对象。
chap4_para1039,4,,这使我们能对所有关系进行断言，例如，我们可能想定义具有传递性的关系意味着什么。
chap4_para1039,5,,不同于大多数特定用途的逻辑，高阶逻辑的表达能力全面高于一阶逻辑，因为高阶逻辑的一些语句无法用有限数量的一阶逻辑语句来表示。
chap4_para104,1,Description Each of the belief state spaces is depicted by rectangular boxes with states of vacuum world inscribed within the box.,与或搜索问题的解是完整搜索树的一棵子树：（1）每个叶子都是一个目标节点，（2）在每个或节点上选择一个动作，（3）每个与节点包括所有结果分支。
chap4_para104,2,The initial belief state is at the top center with states 1 to 8 of the vacuum world states.,解在图中用粗线标识；对应于式（4-3）中的规划。
chap4_para104,3,"An arrow labeled L from the initial belief state points to a belief state on the left which has states 1, 3, 5, and 7.",
chap4_para104,4,"An arrow labeled R from the initial belief state points to a third belief state on the right which has states 2, 4, 6, and 8.",
chap4_para104,5,An arrow labeled R from the second belief state points to the third and an arrow labeled L from the third belief state points to the second belief state.,
chap4_para104,6,"An arrow labeled S from the initial belief state points to a fourth belief state below, which has states 4, 5, 7, and 8.",
chap4_para104,7,"Arrows labeled L and R from the fourth belief state point to the fifth and sixth belief states that have 5, 3, 7, and 6, 4, 8 vacuum world states, respectively.",
chap4_para104,8,"An arrow labeled L from the sixth belief state points to the fifth, and an arrow labeled R from the fifth belief state points to the sixth.",
chap4_para104,9,"Arrows labeled S from the fifth and the second belief states point to the seventh belief state, which has the states 5 and 7.",
chap4_para104,10,"Arrows labeled S from the sixth and the third belief states point to the eighth belief state, which has 4 and 8 vacuum world states in it.",
chap4_para104,11,An arrow labeled L from the eighth belief state points to the ninth belief state which has 3 and 7 vacuum world states in it.,
chap4_para104,12,An arrow labeled R from the ninth belief state points to the eighth belief state.,
chap4_para104,13,An arrow labeled S from the ninth belief state points to the tenth which has state 7.,
chap4_para104,14,"An arrow labeled R from the tenth belief state points to the eleventh, which has state 8 in it.",
chap4_para104,15,An arrow labeled L from the eleventh belief state points back to the tenth.,
chap4_para104,16,"An arrow labeled S from the twelfth belief state points to the eleventh, and an arrow labeled L from the twelfth belief state points to the seventh belief state.",
chap4_para104,17,An arrow labeled R from the seventh belief state points to the twelfth belief state.,
chap4_para104,18,The twelfth belief state has the vacuum world states 6 and 8 in it.,
chap4_para1040,1,,一种逻辑的特性还包括其认识论约定（epistemological commitment），即这种逻辑允许每个事实所具有的可能知识状态。
chap4_para1040,2,,在命题逻辑和一阶逻辑中，一条语句表示一个事实，智能体只能选择相信其为真、相信其为假或没有意见。
chap4_para1040,3,,因此，这两种逻辑对于任何语句都具有3种可能的知识状态。
chap4_para1041,1,,而使用概率论（probability theory）的系统则可以有信任度或主观可能性，其值可以是从0（完全不信任）到1（完全信任）的任何值。
chap4_para1041,2,,千万不要将概率论中的信任度与模糊逻辑中的真实度搞混了。
chap4_para1041,3,,实际上，一些模糊系统允许对真实度具有不确定性（信任度）。
chap4_para1041,4,,"例如，一个概率的wumpus世界智能体可能相信wumpus在[1, 3]中的概率是0.75，而在[2, 3]中的概率是0.25（尽管wumpus肯定在某一个特定的方格中）。"
chap4_para1042,1,,8.2　一阶逻辑的语法和语义
chap4_para1043,1,,本节我们先更为确切地阐述一阶逻辑的可能世界是如何反映其关于对象和关系的本体论约定的。
chap4_para1043,2,,随后我们介绍这种语言的几个组成部分，并解释其语义。
chap4_para1043,3,,本节的主旨是弄清这种语言如何进行简洁的表示，以及其语义如何形成完备的推理过程。
chap4_para1044,1,,8.2.1　一阶逻辑模型
chap4_para1045,1,,第7章讲过，逻辑语言的模型是组成目前正在考虑的可能世界的形式化结构。
chap4_para1045,2,,每个模型都将逻辑语句的词汇表连接到可能世界的元素，使得任意语句的真值可以被确定。
chap4_para1045,3,,因此，命题逻辑的模型将命题符号连接到预定义的真值表。
chap4_para1046,1,,一阶逻辑模型要有趣得多。
chap4_para1046,2,,首先，它们具有对象！
chap4_para1046,3,,模型的域（domain）是它包含的对象集或域元素的集合。
chap4_para1046,4,,域应当是非空的——每个可能世界至少要含有一个对象。
chap4_para1046,5,,（见习题8.EMTP了解关于空世界的讨论。
chap4_para1046,6,,）数学上来说，对象是什么无所谓——有意义的只是每个特定模型中有多少对象。
chap4_para1046,7,,但出于教学的考虑，我们会使用一个具体的例子。
chap4_para1046,8,,图8-2展示了一个具有5个对象的模型，这5个对象分别是英格兰1189年至1199年的国王狮心理查、1199年至1215年统治英格兰的邪恶的约翰国王（理查的弟弟）、理查的左腿、约翰的左腿和王冠。
chap4_para1047,1,,图8-2　含有5个对象、2个二元关系（兄弟和在头顶）、3个一元关系（人、国王和王冠）和1个一元函数（左腿）的模型
chap4_para1048,1,,这个模型中的对象可能有多方面的关系。
chap4_para1048,2,,图中，理查和约翰是兄弟。
chap4_para1048,3,,从形式上来看，关系就是相关对象的元组集。
chap4_para1048,4,,（一个元组是以固定顺序排列的一系列对象，使用尖括号将对象括起来表示。
chap4_para1048,5,,）这样，模型中的兄弟关系就是集合
chap4_para105,1,Figure 4.,图4-11给出了与或图搜索的深度优先递归算法。
chap4_para105,2,11An algorithm for searching AND-OR graphs generated by nondeterministic environments.,该算法的一个关键是它处理环的方法，环经常出现在非确定性问题中（例如，动作有时不起作用，或者一个意外的影响被纠正）。
chap4_para105,3,A solution is a conditional plan that considers every nondeterministic outcome and makes a plan for each one.,如果当前状态与从根到它的路径上的某个状态相同，就返回失败。
chap4_para105,4,,这并不意味着从当前状态出发没有解；这仅仅意味着，如果存在一个非循环解，那么它肯定可以从当前状态的早期镜像到达，因此可以丢弃新的镜像。
chap4_para105,5,,有了这一检查，可以确保算法在任何有限状态空间中都能终止，因为每条路径都必定到达一个目标、一个死胡同或一个重复状态。
chap4_para105,6,,注意，该算法并不检查当前状态是否是从根出发的其他路径上的某个状态的重复状态，这一点对效率来说很重要。
chap4_para1050,1,,（此处我们已经命名了对象，但如果你愿意的话，你可以用图片代替对象名称。
chap4_para1050,2,,"）王冠在约翰国王的头顶，因此关系“在头顶”仅含有一个元组，〈王冠, 约翰国王〉。"
chap4_para1050,3,,“兄弟”关系和“在头顶”关系都是二元关系，也就是说，它们关联了一对对象。
chap4_para1050,4,,该模型还含有一元关系，或称为属性：“人”属性对于理查和约翰都为真；“国王”属性仅对于约翰为真（假设此时理查已经去世）；而“王冠”属性则仅对王冠为真。
chap4_para1051,1,,最好将某些类型的关系视为函数，因为这样的话给定一个对象，它必然仅关联到一个对象。
chap4_para1051,2,,例如，每个人都有一条左腿，因此模型含有一个一元“左腿”函数，即从一个单元素元组到一个对象的映射，它包括如下的映射：
chap4_para1053,1,,严格来说，一阶逻辑中的模型需要全函数（total function），也就是对于所有输入的元组都要有值。
chap4_para1053,2,,这样，王冠必须要有一条左腿，每条左腿也一样。
chap4_para1053,3,,对于这种尴尬的问题有一个技术解决方案，它需要增加一个“不可见”的对象来作为一切没有左腿的东西的左腿，包括它自己。
chap4_para1053,4,,幸运的是，只要没人对没有左腿的东西的左腿进行断言，这些技术细节就不重要。
chap4_para1054,1,,目前为止，我们已经描述了组成一阶逻辑模型所需的元素。
chap4_para1054,2,,模型的另一个重要部分是这些元素与逻辑语句的词汇表的联系，我们接下来进行介绍。
chap4_para1055,1,,8.2.2　符号与解释
chap4_para1056,1,,我们现在来了解一阶逻辑的语法。
chap4_para1056,2,,不耐烦的读者可以通过图8-3获得对形式化文法的完整描述。
chap4_para1057,1,,图8-3　包含等价关系的一阶逻辑语法，使用巴克斯-诺尔范式（如果你对此不熟悉，见附录B.1）。
chap4_para1057,2,,运算符优先级从高到低定义。
chap4_para1057,3,,量词的优先级为一个量词的优先级高于其右边的一切
chap4_para1058,1,,一阶逻辑的基本语法元素是代表对象、关系和函数的符号。
chap4_para1058,2,,因此，符号分为3种：代表对象的常量符号（constant symbol）、代表关系的谓词符号（predicate symbol）和代表函数的函数符号（function symbol）。
chap4_para1058,3,,我们采用的习惯是用大写字母开头来书写这些符号。
chap4_para1058,4,,例如，我们可以使用常量符号Richard（理查）和John（约翰），谓词符号Brother（是兄弟）、OnHead（在头顶）、Person（是人）、King（是国王）和Crown（是王冠），函数符号LeftLeg（……的左腿）。
chap4_para1058,5,,与命题符号一样，如何命名完全取决于使用者的意愿。
chap4_para1058,6,,每个谓词和函数符号都有一个决定参数数量的元数（arity）。
chap4_para1059,1,,每个模型必须提供所需的信息来确定任意给定语句为真还是为假。
chap4_para1059,2,,因此，除了它的对象、关系和函数，每个模型还要包含一套确切指明常量、谓词和函数符号指代的是哪个对象、关系和函数的解释（interpretation）。
chap4_para1059,3,,在我们的例子中，下面是一种可能的解释，也就是逻辑学家所说的预期解释（intended interpretation）。
chap4_para106,1,AND-OR graphs can be explored either breadth-first or best-first.,图4-11　非确定性环境生成的与或图的搜索算法。
chap4_para106,2,"The concept of a heuristic function must be modified to estimate the cost of a contingent solution rather than a sequence, but the notion of admissibility carries over and there is an analog of the A* algorithm for finding optimal solutions.",解是一个条件规划，它考虑每一个非确定性的结果，并为每个结果制定规划
chap4_para106,3,(See the bibliographical notes at the end of the chapter.,
chap4_para106,4,),
chap4_para1060,1,,● Richard指狮心理查，John指邪恶的约翰国王。
chap4_para1061,1,,● Brother指兄弟关系，也就是式（8-1）给出的对象元组集，Onhead是连接王冠和约翰国王的关系，Person、King和Crown是识别人、国王和王冠的一元关系。
chap4_para1062,1,,● LeftLeg指式（8-2）定义的“左腿”函数。
chap4_para1063,1,,当然，模型还有很多种可能的解释。
chap4_para1063,2,,例如，一种解释将Richard映射到王冠而将John映射到约翰国王的左腿。
chap4_para1063,3,,模型中有5个对象，因此仅对常量符号Richard和John就有25种可能的解释。
chap4_para1063,4,,注意，并非所有对象都有名称。
chap4_para1063,5,,例如，预期解释并没有为王冠和腿命名。
chap4_para1063,6,,一个对象也可以有多个名称，在一种可能的解释中Richard和John都指代王冠。
chap4_para1063,7,,[3]如果你觉得这令人困惑，记住，在命题逻辑中，一个Cloudy（阴天）和Sunny（晴天）都为真的模型是完全可以存在的；排除与我们的知识不符的模型是知识库要做的事情。
chap4_para1065,1,,[3]　在随后的8.2.8节，我们会考察一种语义，其中每个对象只能有一个名称。
chap4_para1066,1,,总之，一阶逻辑中的模型包含一个对象集和一种解释，这种解释将常量符号映射到对象、将函数符号映射到关于这些对象的函数，将谓词符号映射到关系。
chap4_para1066,2,,与命题逻辑一样，蕴含、有效性等都是用所有可能模型来定义的。
chap4_para1066,3,,要大致了解可能模型集是什么样子的，见图8-4。
chap4_para1066,4,,图中显示，模型的区别在于它们包含的对象数量不同（从一到无穷多个），以及常量符号映射到对象的方式不同。
chap4_para1067,1,,图8-4　含有两个常量符号的语言中全部模型的集合的部分成员、R和J以及一个二元关系符号。
chap4_para1067,2,,每种常量符号的解释用灰色箭头标明。
chap4_para1067,3,,每个模型中，相关的对象用箭头连接
chap4_para1068,1,,由于一阶逻辑模型数量没有上限，我们无法通过枚举所有模型的方式（像我们对命题逻辑做的那样）来检验蕴含。
chap4_para1068,2,,即便对象的数量是有限的，其组合也会是巨量的。
chap4_para1068,3,,（见习题8.MCNT。
chap4_para1068,4,,）对图8-4中的例子来说，使用不超过6个对象就会产生137 506 194 466个模型。
chap4_para107,1,4.,与或图也可以使用广度优先或最佳优先的方式进行探索。
chap4_para107,2,3.,我们必须修改启发式函数的概念，即估计一个条件解而不是一个序列的代价，但可容许性的概念可以继续保留，而且存在类似的用于寻找最优解的A*算法（参见本章末尾的参考文献与历史注释）。
chap4_para107,3,"3Try, try again",
chap4_para1070,1,,项（term）是指代对象的逻辑表达式。
chap4_para1070,2,,常量符号是项，但对每个对象都使用不同的符号命名往往不太方便。
chap4_para1070,3,,在语言中我们使用表达“约翰国王的左腿”而不是给他的腿起个名称来称呼。
chap4_para1070,4,,这就是函数符号存在的意义：我们使用LeftLeg(John)，而不是使用常量符号来命名这条腿。
chap4_para1070,5,,[4]
chap4_para1072,1,,[4]　表达式（-expression，lambda表达式）提供了一种很有用的记法，使得新的函数符号可以“即时”构建。
chap4_para1072,2,,例如，对参数进行平方操作的函数可以写作，并可以像其他函数符号那样直接用于参数。
chap4_para1072,3,,一个表达式也可以被定义为谓语符号并用作谓词符号。
chap4_para1072,4,,这与Lisp和Python中的lambda操作符的作用完全一致。
chap4_para1072,5,,注意，像这样使用并不能增加一阶逻辑的形式化表达能力，因为所有含有表达式的语句都能通过“插入”其参数的方式重写，生成一个等价的语句。
chap4_para1073,1,,通常情况下，复合项的组成是一个函数符号后跟随一个括号，括号中是一系列项，作为该函数符号的参数。
chap4_para1073,2,,需要注意的是，复合项只是复杂一些的名称，而非“返回一个值”的“子程序调用”。
chap4_para1073,3,,并不存在以一个人作为输入，返回一条腿的LeftLeg子程序。
chap4_para1073,4,,我们甚至可以在不定义LeftLeg的情况下就进行关于左腿的推理（例如，陈述一条一般规则“每个人都有左腿”，并进而推导出约翰必然有左腿）。
chap4_para1073,5,,这是无法在编程语言中用子程序实现的。
chap4_para1074,1,,项的形式化语义非常直白。
chap4_para1074,2,,"考虑项f(t1, …, tn)。"
chap4_para1074,3,,"函数符号f指代模型中的某个函数（不妨称为F），参数项指代域中的对象（称为d1, …, dn)），整个项就指代将函数F应用于d1, …, dn产生的对象，即函数的值。"
chap4_para1074,4,,例如，假设LeftLeg函数符号代表式（8-2）所示的函数，John代表约翰国王，则LeftLeg(John)代表约翰国王的左腿。
chap4_para1074,5,,这样，解释就确定了每个项的被指代物。
chap4_para1075,1,,8.2.4　原子语句
chap4_para1076,1,,我们现在已经有了指代对象的项以及指代关系的谓词符号，将它们结合起来可以构成陈述事实的原子语句。
chap4_para1076,2,,原子语句（或简称原子）是由谓词符号以及其后可能存在的括号中的一系列项组成的，例如：
chap4_para1077,1,,在先前给定的预期解释下，这条语句表明狮心理查是约翰国王的兄弟。
chap4_para1077,2,,[5]原子语句的参数可以是复合项，如
chap4_para1079,1,,"[5]　我们一般遵循P(x, y)读作“x是y的P”这样的参数排序习惯。"
chap4_para108,1,"Consider a slippery vacuum world, which is identical to the ordinary (non-erratic) vacuum world except that movement actions sometimes fail, leaving the agent in the same location.",4.3.3　反复尝试
chap4_para108,2,"For example, moving Right in state 1 leads to the belief state {1, 2}.",
chap4_para108,3,Figure 4.,
chap4_para108,4,"12 shows part of the search graph; clearly, there are no longer any acyclic solutions from state 1, and AND-OR-SEARCH would return with failure.",
chap4_para108,5,"There is, however, a cyclic solution, which is to keep trying Right until it works.",
chap4_para108,6,We can express this with a new while construct:,
chap4_para1080,1,,表明狮心理查的父亲娶了约翰国王的母亲（再次强调，在合适的解释下）。
chap4_para1080,2,,[6]
chap4_para1082,1,,[6]　这个本体论认为每个人只有一位父亲和一位母亲。
chap4_para1082,2,,更为复杂的本体论可以识别出生物学母亲、生母、养母等。
chap4_para1083,1,,如果谓词符号所指代的关系在参数所指代的对象之间成立，则在给定模型中原子句为真。
chap4_para1084,1,,8.2.5　复合语句
chap4_para1085,1,,我们可以使用逻辑联结词构建更为复杂的语句，这与命题演算的语法和语义一样。
chap4_para1085,2,,下面是4条在我们的预期解释下在图8-2的模型中为真的语句：
chap4_para1087,1,,当我们有了支持对象的逻辑后，就很自然地想要表达很多对象的整体属性而非根据名称逐个列举对象。
chap4_para1087,2,,量词能使我们达到这一目的。
chap4_para1087,3,,一阶逻辑含有两个标准量词——全称量词和存在量词。
chap4_para1089,1,,回想我们在第7章用命题逻辑表示一般规则时面临的困难。
chap4_para1089,2,,像“与wumpus相邻的方格有臭味”和“所有国王都是人”这样的规则对一阶逻辑来说是最基本的。
chap4_para1089,3,,我们将在8.3节中解决第一条规则。
chap4_para1089,4,,而第二条规则“所有国王都是人”在一阶逻辑中写作
chap4_para109,1,"Description The belief states are depicted by circular shapes, and the vacuum world states are depicted by square blocks with the corresponding state labeled on them. Example “a”, Deterministic world: Vacuum world states 1 and 3 are included in the first belief state. An arrow labeled R from state 1 of the first belief state points to state 2 of the second belief state. An arrow from state 3 of the first belief state points to the vacuum world state 4 of the second belief state. An arrow labeled open square bracket B, Dirty close square bracket, points to the vacuum world state 2 of the third belief state. An arrow labeled open square bracket B, Clean close square bracket, from the vacuum world state 4 of the second belief state points to the vacuum world state 4 of the fourth belief state. Example b, Slippery world: An arrow from the vacuum world state 1 of the first belief state points to the vacuum world state 2 and 1 of the second belief state. An arrow from the vacuum world state 3 of the first belief state points to the vacuum world state 3 and 4 of the second belief state. An arrow labeled open square bracket B, Dirty close square bracket, from the vacuum world state 2 of the second belief state points to the vacuum world state 2 of the third belief state. An arrow from the vacuum world state 1 and 3 of the second belief state points to the vacuum world state 1 and 3 of the fourth belief state. An arrow from the vacuum world state 4 of the second belief state points to the vacuum world state 4 of the fifth belief state.",考虑一个光滑的真空吸尘器世界，它与普通的（稳定的）真空吸尘器世界基本相同，但移动操作有时会失效，使得智能体停在原地。
chap4_para109,2,,"例如，在状态1中执行Right将产生信念状态{1,2}。"
chap4_para109,3,,图4-12为部分搜索图；显然，从状态1出发不存在非循环解，And-Or-Search将返回失败。
chap4_para109,4,,然而，存在一个循环解（cyclic solution），即反复尝试Right动作，直到它生效。
chap4_para109,5,,我们可以用一个新的while结构来表示上述过程：
chap4_para1090,1,,全称量词∀通常读作“对所有……”。
chap4_para1090,2,,［记住，上下颠倒的A表示“all”（所有）。
chap4_para1090,3,,］因此，这条语句表示“对所有x，如果x是国王，则x是人”。
chap4_para1090,4,,符号x被称为变量。
chap4_para1090,5,,习惯上，变量用小写字母表示。
chap4_para1090,6,,一个变量本身就是一个项，因此也可以作为函数的参数，例如LeftLeg(x)。
chap4_para1090,7,,一个没有变量的项被称为基本项（ground term）。
chap4_para1091,1,,直观上来说，语句∀x P，其中P为任意逻辑语句，表明P对每个对象x都为真。
chap4_para1091,2,,更确切地说，如果P在根据一个模型的给定解释构建的所有可能扩展解释（extended interpretation）下为真，则∀x P在该模型中为真，其中每个扩展解释给出了x指代的域元素。
chap4_para1092,1,,这听起来很复杂，但它实际上只是陈述全称量词的直观含义的一种严谨的方式。
chap4_para1092,2,,考虑图8-2所示的模型及其相应的预期解释。
chap4_para1092,3,,我们可以用5种方式扩展这个解释：
chap4_para1098,1,,全称量化语句在原模型中为真的前提是语句在这5种扩展解释下都为真。
chap4_para1098,2,,也就是说，全称量化语句等价于如下5个断言：
chap4_para1099,1,,狮心理查是一位国王⇒ 狮心理查是一个人
chap4_para11,1,4.,图4-2　爬山搜索算法是最基本的局部搜索技术。
chap4_para11,2,1.,在每一步中，当前节点被其最优邻居节点替换
chap4_para11,3,1Hill-climbing search,
chap4_para110,1,Figure 4.,或者用标签（label）表示规划的某一部分，之后可以引用这个标签：
chap4_para110,2,"12Part of the search graph for a slippery vacuum world, where we have shown (some) cycles explicitly.",
chap4_para110,3,All solutions for this problem are cyclic plans because there is no way to move reliably.,
chap4_para1100,1,,约翰国王是一位国王 ⇒ 约翰国王是一个人
chap4_para1101,1,,理查的左腿是一位国王 ⇒ 理查的左腿是一个人
chap4_para1102,1,,约翰的左腿是一位国王 ⇒ 约翰的左腿是一个人
chap4_para1103,1,,王冠是一位国王 ⇒ 王冠是一个人
chap4_para1104,1,,让我们仔细研究这些断言。
chap4_para1104,2,,在我们的模型中，由于约翰国王是唯一的国王，因而第二条语句断言他是人，正如我们所料。
chap4_para1104,3,,那么其他4条语句呢？
chap4_para1104,4,,那些声明了腿和王冠的语句呢？
chap4_para1104,5,,这也是“所有国王都是人”含义的一部分吗？
chap4_para1104,6,,实际上，其他4条断言在模型中都为真，但并未对腿、王冠乃至理查作为人的资格进行任何声明。
chap4_para1104,7,,这是因为这些对象都不是国王。
chap4_para1104,8,,回顾⇒的真值表（图7-8），我们可以看到当前提为假时蕴涵式为真——无论其结论的真值是什么。
chap4_para1104,9,,因此，通过断言全称量化语句——它等价于断言每一条蕴涵式，我们最终仅对前提为真的对象断言规则的结论，而对前提为假的对象什么也不说。
chap4_para1104,10,,因此，⇒的真值表定义被证明非常适合用来编写含有全称量词的一般规则。
chap4_para1105,1,,即使是勤奋地将本节读了好几遍的读者也可能会犯的常见错误是使用合取式而非蕴涵式与全称量词搭配。
chap4_para1105,2,,语句
chap4_para1107,1,,狮心理查是国王∧狮心理查是人
chap4_para1108,1,,约翰国王是国王∧约翰国王是人
chap4_para1109,1,,理查的左腿是国王∧理查的左腿是人
chap4_para111,1,or by adding a label to denote some portion of the plan and referring to that label later:,什么时候可以考虑将循环规划作为解？
chap4_para111,2,,最小条件是每个叶节点都是一个目标状态，并且叶节点可以从规划中的任意点到达。
chap4_para111,3,,除此之外，我们还要考虑造成非确定性的原因。
chap4_para111,4,,如果情况确实是，真空吸尘器机器人的驱动机制在某些时间工作，但在其他时间真空吸尘器会发生随机、独立地滑动，那么智能体可以保证，如果动作重复足够多次，最终总会生效，规划也会成功。
chap4_para111,5,,但是，如果这种非确定性来自机器人或环境的一些尚未观测到的原因（例如，传动带断了，那么机器人将永远不会移动），重复这个动作也没有用。
chap4_para1111,1,,显然，这并不是我们想要表达的。
chap4_para1113,1,,全称量词对所有对象进行陈述。
chap4_para1113,2,,反之，我们也可以对某些对象进行陈述而不需指明其名称。
chap4_para1113,3,,使用存在量词就可以实现这一点。
chap4_para1113,4,,例如，要说约翰国王的头顶有王冠，我们写作
chap4_para1114,1,,∃x读作“存在x使得……”或“对于一些x……”。
chap4_para1115,1,,直观上来说，语句∃x P说的是P至少对于一个对象x为真。
chap4_para1115,2,,更准确地说，如果P在至少一个将x分配给域元素的扩展解释下为真，则∃x P在给定模型中为真。
chap4_para1115,3,,也就是，下列语句中至少有一个为真：
chap4_para1116,1,,狮心理查是王冠 ∧ 狮心理查在约翰的头顶
chap4_para1117,1,,约翰国王是王冠 ∧ 约翰国王在约翰的头顶
chap4_para1118,1,,理查的左腿是王冠 ∧ 理查的左腿在约翰的头顶
chap4_para1119,1,,约翰的左腿是王冠 ∧ 约翰的左腿在约翰的头顶
chap4_para112,1,"When is a cyclic plan a solution? A minimum condition is that every leaf is a goal state and that a leaf is reachable from every point in the plan. In addition to that, we need to consider the cause of the nondeterminism. If it is really the case that the vacuum robot’s drive mechanism works some of the time, but randomly and independently slips on other occasions, then the agent can be confident that if the action is repeated enough times, eventually it will work and the plan will succeed. But if the nondeterminism is due to some unobserved fact about the robot or environment—perhaps a drive belt has snapped and the robot will never move—then repeating the action will not help.",为了便于理解，我们可以认为，它是将初始问题形式（完全可观测的，非确定性的）转化为另一种形式（部分可观测的，确定性的），其中循环规划的失败正是由于传动带的某个不可观测的特性。
chap4_para112,2,,在第12章中，我们将讨论如何判断几种不确定可能性中哪个可能性更大。
chap4_para1120,1,,王冠是王冠 ∧ 王冠在约翰的头顶
chap4_para1121,1,,第五个断言在模型中为真，因此先前的存在量化语句在模型中为真。
chap4_para1121,2,,注意，根据我们的定义，这条语句在约翰国王戴了两顶王冠的模型中也为真。
chap4_para1121,3,,这与原始语句“约翰国王的头顶有王冠”完全不矛盾。
chap4_para1121,4,,[7]
chap4_para1123,1,,[7]　存在量词有一个变种，通常写作∃1或∃!，意思是“恰好存在一个”。
chap4_para1123,2,,相同的含义可以用等词陈述表示。
chap4_para1124,1,,正如⇒是能自然地与∀合用的联结词一样，∧是与∃自然合用的联结词。
chap4_para1124,2,,使用∧作为∀的主要联结词会导致前面示例中的过强陈述，而使用⇒搭配∃则会导致过弱的陈述。
chap4_para1124,3,,考虑如下语句：
chap4_para1125,1,,表面来看，这似乎是对我们的语句的一种合理的表示。
chap4_para1125,2,,使用语义规则，我们发现该语句表达的是如下断言中至少一条为真：
chap4_para1126,1,,狮心理查是一顶王冠 ⇒ 狮心理查在约翰的头顶
chap4_para1127,1,,约翰国王是一顶王冠 ⇒ 约翰国王在约翰的头顶
chap4_para1128,1,,理查的左腿是一顶王冠 ⇒ 理查的左腿在约翰的头顶
chap4_para113,1,"One way to understand this decision is to say that the initial problem formulation (fully observable, nondeterministic) is abandoned in favor of a different formulation (partially observable, deterministic) where the failure of the cyclic plan is attributed to an unobserved property of the drive belt.",图4-12　光滑的真空吸尘器世界的部分搜索图，（一些）循环已经明确地标出。
chap4_para113,2,In Chapter 12 we discuss how to decide which of several uncertain possibilities is more likely.,这个问题的所有解都是循环规划，因为真空吸尘器无法稳定地移动
chap4_para1130,1,,蕴涵式为真的条件是其前提和结论都为真，或其前提为假。
chap4_para1130,2,,因此，如果狮心理查不是一顶王冠，则第一条断言为真，存在量化语句被满足。
chap4_para1130,3,,因此，只要任一对象不能满足前提，存在量化的蕴涵式语句就为真。
chap4_para1130,4,,因而这种语句其实基本上什么都没说。
chap4_para1132,1,,我们经常希望用多个量词表示更复杂的语句。
chap4_para1132,2,,最简单的情形是量词种类相同的情形。
chap4_para1132,3,,例如，“兄弟是同胞”可以写成
chap4_para1133,1,,连续的同类量词可以写成有多个变量的单个量词。
chap4_para1133,2,,例如，要表示同胞是对称关系，可以写成
chap4_para1134,1,,其他情况下，我们得混用量词。
chap4_para1134,2,,“每个人都喜爱一些人”意思是，对所有人都存在其喜爱的人：
chap4_para1135,1,,相反，要说“有人被所有人喜爱”，就写成
chap4_para1136,1,,因此，量词的顺序非常重要。
chap4_para1136,2,,添加括号会使语句看起来更清晰。
chap4_para1136,3,,表明每个人都有某种属性，也就是他们喜爱一些人的属性。
chap4_para1136,4,,反之，则表示世界上的一些人具有某种属性，即每个人都喜爱他们的属性。
chap4_para1137,1,,当两个量词与相同的变量名合用时会引起一些混淆。
chap4_para1137,2,,考虑语句
chap4_para1138,1,,"此处Brother(Richard, x)中的x是被存在量化的。"
chap4_para1138,2,,规则是，变量属于提及它的最内层量词，随后便不再受任何其他量词约束。
chap4_para1138,3,,"另一种考虑方式是，∃x Brother(Richard, x)是关于理查（有一个兄弟）的语句，不是关于x的语句；因此在外层放一个∀x并无效果。"
chap4_para1138,4,,"该语句一个等价的写法是∃z Brother (Richard, z)。"
chap4_para1138,5,,因为这可能是导致混淆的源头，所以我们会始终在嵌套量词中使用不同的变量名。
chap4_para114,1,4.,4.4　部分可观测环境中的搜索
chap4_para114,2,4Search in Partially Observable Environments,
chap4_para1140,1,,∀与∃两个量词实际上通过否定词紧密相关。
chap4_para1140,2,,断言每个人都讨厌欧洲萝卜与断言不存在喜欢欧洲萝卜的人是等价的，反之亦然：
chap4_para1142,1,,我们可以更进一步——“每个人都喜欢冰激凌”意思是没有人不喜欢冰激凌：
chap4_para1144,1,,由于∀实际上是对全体对象的合取而∃则是析取，因此它们遵循德摩根律就不足为奇了。
chap4_para1144,2,,量化语句和非量化语句的德摩根律如下：
chap4_para1145,1,,因此，我们实际上并不同时需要∀和∃，正如我们不同时需要∧和∨一样。
chap4_para1145,2,,不过，可读性比简洁性更重要，因此我们同时保留这两种量词。
chap4_para1147,1,,除了使用前述的谓词和项，一阶逻辑还有一种构成原子语句的方式。
chap4_para1147,2,,我们可以使用等词符号（equality symbol）来表示两个项指代相同的对象。
chap4_para1147,3,,例如：
chap4_para1148,1,,Father(John) = Henry
chap4_para1149,1,,表示Father(John)指代的对象与Henry指代的对象是相同的。
chap4_para1149,2,,由于解释会固定所有项的被指代物，确定等词语句的真值就只需要观察两项的被指代物是否为相同的对象即可。
chap4_para115,1,"We now turn to the problem of partial observability, where the agent’s percepts are not enough to pin down the exact state. That means that some of the agent’s actions will be aimed at reducing uncertainty about the current state.",现在我们考虑部分可观测性问题，即智能体的感知不足以确定准确的状态。
chap4_para115,2,,这意味着，智能体的一些动作将致力于减少当前状态的不确定性。
chap4_para1150,1,,等词符号可以用于陈述关于给定函数的事实，正如我们对Father符号所做的那样。
chap4_para1150,2,,它也可以与否定合用，表示两项不是相同的对象。
chap4_para1150,3,,要表示理查至少有两个兄弟，我们可以写成
chap4_para1152,1,,就不能表示我们所期望的含义。
chap4_para1152,2,,具体来说，这条语句在图8-2的模型中也为真，尽管其中理查只有一个兄弟。
chap4_para1152,3,,要弄清楚这一点，考虑x和y都被指定到约翰国王的扩展解释。
chap4_para1152,4,,附加的排除了这种模型。
chap4_para1152,5,,记法可以用作的简写。
chap4_para1153,1,,8.2.8　数据库语义
chap4_para1154,1,,继续8.2.7节中的例子，假设我们相信理查有2个兄弟——约翰和杰弗里[8]，我们可以写
chap4_para1156,1,,[8]　实际上理查有4个兄弟，另外两个是威廉和亨利。
chap4_para1158,1,,但这并不能完全反映我们要表示的状态。
chap4_para1158,2,,首先，这条断言在理查只有一个兄弟的模型中也为真——我们需要加上。
chap4_para1158,3,,其次，这条语句没有剔除理查除了约翰和杰弗里还有很多其他兄弟的模型。
chap4_para1158,4,,因此，对“理查的兄弟是约翰和杰弗里”的正确翻译如下：
chap4_para1159,1,,这条逻辑语句似乎比对应的自然语言表述烦琐很多。
chap4_para1159,2,,如果不能恰当地翻译自然语言，我们的逻辑推理系统就会犯错。
chap4_para1159,3,,我们能否构思一种语义，使逻辑语句更加直白呢？
chap4_para116,1,4.,4.4.1　无观测信息的搜索
chap4_para116,2,4.,
chap4_para116,3,1Searching with no observation,
chap4_para1160,1,,一种在数据库系统中非常流行的做法的工作方式如下。
chap4_para1160,2,,首先，我们确定每个常量符号都指代一个唯一的对象——唯一名称假设（unique-names assumption）。
chap4_para1160,3,,然后，我们假设未知其为真的原子语句事实上都为假——封闭世界假设（closed world assumption）。
chap4_para1160,4,,最后，我们调用域闭包（domain closure），意味着每个模型中的域元素不多于常量符号指代的那些。
chap4_para1161,1,,在由此产生的语义中，式（8-3）的确能表明理查仅有两个兄弟，约翰和杰弗里。
chap4_para1161,2,,我们称之为数据库语义（database semantics），以区别于标准的一阶逻辑语义。
chap4_para1161,3,,数据库语义也用于逻辑编程系统中，在9.4.4节我们对此进行解释。
chap4_para1162,1,,在数据库语义里考虑图8-4所示的情形中的所有可能的模型是很有指导性的。
chap4_para1162,2,,图8-5展示了其中一些模型，从没有元组满足关系的模型到所有元组都满足关系的模型。
chap4_para1162,3,,在有两个对象的情况下，有4种可能的二元素元组，存在24 = 16种不同的元组子集满足关系。
chap4_para1162,4,,因此，总共有16种可能模型——大大少于标准一阶逻辑语法下巨量的模型数量。
chap4_para1162,5,,不过，数据库语义需要世界中包含的东西的确定知识。
chap4_para1163,1,,图8-5　在数据库语义下，含有两个常量符号R和J以及一个二元关系符号的语言中的全部模型集的一部分成员。
chap4_para1163,2,,常量符号的解释是固定的，每个常量符号有唯一的对象
chap4_para1164,1,,这个例子引发了一个重要的观点：逻辑中不存在“正确的”语义。
chap4_para1164,2,,提出的语义的有用性取决于它对我们想要记录的知识的表示是否简洁和直观，以及相应的推断规则的生成是否容易和自然。
chap4_para1164,3,,当我们明确了知识库中描述的所有对象的身份，并且掌握了所有事实的时候，数据库语义最有用，而在其他情况下，数据库语义就很棘手。
chap4_para1164,4,,本章剩余部分，我们默认使用标准语义，并会在这种语义使表达变得非常繁琐的实例中另行标注。
chap4_para1165,1,,8.3　使用一阶逻辑
chap4_para1166,1,,现在我们已经定义了一种很有表达能力的逻辑语言，接下来我们学习如何使用它。
chap4_para1166,2,,本节，我们在一些简单的论域（domain）中给出范例语句。
chap4_para1166,3,,在知识表示中，论域是指我们要表示其知识的那部分世界。
chap4_para1167,1,,我们从简要地解释一阶知识库中的Tell/Ask推断开始。
chap4_para1167,2,,随后我们考察家庭关系、数、集合、列表以及wumpus世界论域。
chap4_para1167,3,,8.4.2节展示一个更大规模的示例（电子电路），而第10章则涵盖了宇宙万物。
chap4_para1168,1,,8.3.1　一阶逻辑的断言与查询
chap4_para1169,1,,语句是通过Tell添加到知识库的，与在命题逻辑中完全一样。
chap4_para1169,2,,这种语句被称为断言（assertion）。
chap4_para1169,3,,例如，我们可以断言约翰是国王、理查是人以及所有的国王都是人：
chap4_para117,1,"When the agent’s percepts provide no information at all, we have what is called a sensorless problem (or a conformant problem). At first, you might think the sensorless agent has no hope of solving a problem if it has no idea what state it starts in, but sensorless solutions are surprisingly common and useful, primarily because they don’t rely on sensors working properly. In manufacturing systems, for example, many ingenious methods have been developed for orienting parts correctly from an unknown initial position by using a sequence of actions with no sensing at all. Sometimes a sensorless plan is better even when a conditional plan with sensing is available. For example, doctors often prescribe a broad-spectrum antibiotic rather than using the conditional plan of doing a blood test, then waiting for the results to come back, and then prescribing a more specific antibiotic. The sensorless plan saves time and money, and avoids the risk of the infection worsening before the test results are available.",当智能体的感知根本不提供任何信息时，问题就变成了无传感器（sensorless）问题，或称一致性（conformant）问题。
chap4_para117,2,,起初，你可能会认为，如果无传感器智能体不知道起始状态，那它就无法求解问题，但出人意料的是，无传感器解非常普遍且有用，主要是因为它们不依赖于传感器是否正常工作。
chap4_para117,3,,例如，在制造系统中，已经开发出许多巧妙的方法，通过使用一系列行动而无须任何感知，从未知初始位置正确定位零件。
chap4_para117,4,,有时，即使存在可感知的条件规划，无传感器规划也会更好。
chap4_para117,5,,例如，医生通常会开一种广谱抗生素，而不是使用条件规划：先验血，接着等待结果，然后再开一种更具体的抗生素。
chap4_para117,6,,这种无传感器规划节省了时间和金钱，并且避免了在检测结果出来之前感染恶化的风险。
chap4_para1170,1,,我们可以使用Ask对知识库提问。
chap4_para1170,2,,例如：
chap4_para1171,1,,返回true。
chap4_para1171,2,,使用Ask提出的问题被称为查询或目标。
chap4_para1171,3,,一般来说，知识库中逻辑蕴含的所有查询都应该得到肯定的回答。
chap4_para1171,4,,例如，给定上述3条断言，查询
chap4_para1172,1,,应该也返回true。
chap4_para1172,2,,我们可以提出量化的问题，例如：
chap4_para1173,1,,答案为true，但它可能并不是我们想要的答案。
chap4_para1173,2,,它就像用“可以”回答“你能告我现在几点了吗？
chap4_para1173,3,,”一样。
chap4_para1173,4,,如果我们想了解使语句为真的x的值，我们就需要另一个函数AskVars：
chap4_para1174,1,,将返回一系列答案。
chap4_para1174,2,,在这个例子中有两个答案：以及。
chap4_para1174,3,,这种回答叫作置换（substitution）或绑定表（binding list）。
chap4_para1174,4,,AskVars通常与仅由霍恩子句构成的知识库合用，因为在这种知识库中，每种使查询为真的方式都将变量绑定到特定的值。
chap4_para1174,5,,而一阶逻辑中并不存在这种状况：在KB仅被告知King(John)的情况下，不存在使得查询∃x King(x)为真的x的单个绑定，即使这条查询实际上为真。
chap4_para1175,1,,8.3.2　亲属关系论域
chap4_para1176,1,,我们第一个考虑的范例是家庭关系（或称亲属关系）论域。
chap4_para1176,2,,这个论域包括类似“伊丽莎白是查尔斯的母亲”和“查尔斯是威廉的父亲”这样的事实，以及类似“一个人的祖母（外祖母）是他父母的母亲”这样的规则。
chap4_para1177,1,,显然，这个论域的对象是人。
chap4_para1177,2,,一元谓词包括Male和Female等。
chap4_para1177,3,,亲属关系（父母、兄弟、婚姻等）使用二元谓词表示：Parent、Sibling、Brother、Sister、Child、Daughter、Son、Spouse、Wife、Husband、Grandparent、Grandchild、Cousin、Aunt和Uncle。
chap4_para1177,4,,我们用函数表示Mother和Father，因为从生物学角度来说，每个人只有一对父母（尽管我们可以引入更多函数来处理养母、代孕妈妈等）。
chap4_para1178,1,,我们可以考察每个函数和谓词，并就我们知道的写下它们与其他符号的关系。
chap4_para1178,2,,例如， 一个人的母亲就是他父母中的女性成员：
chap4_para1179,1,,一个人的丈夫是她的男性配偶：
chap4_para118,1,"Consider a sensorless version of the (deterministic) vacuum world. Assume that the agent knows the geography of its world, but not its own location or the distribution of dirt. In that case, its initial belief state is {1, 2, 3, 4, 5, 6, 7, 8} (see Figure 4.9). Now, if the agent moves Right it will be in one of the states {2, 4, 6, 8}—the agent has gained information without perceiving anything! After [Right,Suck] the agent will always end up in one of the states {4, 8}. Finally, after [Right,Suck,Left,Suck] the agent is guaranteed to reach the goal state 7, no matter what the start state. We say that the agent can coerce the world into state 7.",考虑一个（确定性）真空吸尘器世界的无传感器版本。
chap4_para118,2,,假设智能体知道它所在世界的地理环境，但不知道它自己的位置和灰尘的分布。
chap4_para118,3,,"在这种情况下，它的初始信念状态为{1, 2, 3, 4, 5, 6, 7, 8}（见图4-9）。"
chap4_para118,4,,"现在，如果智能体执行Right动作，它将位于{2, 4, 6, 8}中的某个状态——智能体在没有感知的情况下获得了信息！"
chap4_para118,5,,"执行[Right, Suck]之后，智能体将总是位于{4, 8}中的某个状态。"
chap4_para118,6,,"最终，无论初始状态是什么，执行[Right, Suck, Left, Suck]之后，智能体必定会到达目标状态7。"
chap4_para118,7,,我们称，智能体可以强迫（coerce）世界到达状态7。
chap4_para1180,1,,父母与孩子是反关系：
chap4_para1181,1,,祖父母（外祖父母）是一个人父母的父母：
chap4_para1182,1,,兄弟姐妹是一个人父母的其他孩子：
chap4_para1183,1,,我们可以像这样写出很多页，这正是习题8.KINS的题目。
chap4_para1184,1,,所有这些语句都可以看作亲属关系论域中的公理，如7.1节所阐述。
chap4_para1184,2,,公理通常与纯数学论域相关（我们很快就能看到一些关于数字的公理），但它们在所有论域都有用。
chap4_para1184,3,,它们提供了用于推导有用结论的基本因子化信息。
chap4_para1184,4,,我们的亲属关系公理同时也是定义，它们具有形式。
chap4_para1184,5,,公理用其他谓词定义了Mother函数以及Husband、Male、Parent、Grandparent和Sibling谓词。
chap4_para1184,6,,我们的定义从基本的谓词集（Child、Female等）发展而来，并以此最终定义其他谓词。
chap4_para1185,1,,这是构建一个论域的表示的自然方式，类似于用基本的库函数定义子程序，再用子程序构建软件包。
chap4_para1185,2,,注意，基本谓词集并不一定是唯一的，我们可以使用Parent而非Child来得到同样的结果。
chap4_para1185,3,,像我们所展示的一样，在一些论域中并不存在清晰可辨的基本谓词集。
chap4_para1186,1,,并非所有关于论域的逻辑语句都是公理，其中一些是定理，也就是说，它们被公理所蕴含。
chap4_para1186,2,,例如，考虑如下关于兄弟姐妹关系对称性的断言：
chap4_para1187,1,,这条语句是公理还是定理？
chap4_para1187,2,,实际上，它是与定义兄弟姐妹的公理逻辑一致的定理。
chap4_para1187,3,,如果我们用这条语句Ask知识库，它应当返回true。
chap4_para1188,1,,从纯逻辑的观点来看，知识库应当只包含公理并且不含有定理，因为定理并不能增加从知识库导出的结论集。
chap4_para1188,2,,从实用的角度来看，定理对于降低推导新语句的计算开销是很有意义的。
chap4_para1188,3,,没有定理，推理系统就不得不每次都从基本原则出发，就像物理学家每次求解问题时都要重新推导微积分的法则一样。
chap4_para1189,1,,并非所有的公理都是定义。
chap4_para1189,2,,一些公理提供了关于某些谓词的更一般的信息，却不构成定义。
chap4_para1189,3,,实际上，一些谓词并没有完整的定义，因为我们不具有完全刻画它们的知识。
chap4_para1189,4,,例如，没有显而易见的定义方式能够完成语句
chap4_para119,1,"The solution to a sensorless problem is a sequence of actions, not a conditional plan (because there is no perceiving). But we search in the space of belief states rather than physical states.6 In belief-state space, the problem is fully observable because the agent always knows its own belief state. Furthermore, the solution (if any) for a sensorless problem is always a sequence of actions. This is because, as in the ordinary problems of Chapter 3, the percepts received after each action are completely predictable—they’re always empty! So there are no contingencies to plan for. This is true even if the environment is nondeterministic.",无传感器问题的解是一个动作序列，而不是条件规划（因为它没有感知）。
chap4_para119,2,,但是，我们是在信念状态空间而非物理状态空间中进行搜索。
chap4_para119,3,,[6]在信念状态空间中，问题是完全可观测的，因为智能体始终知道自己的信念状态。
chap4_para119,4,,此外，无传感器问题的解（如果有的话）始终是一个动作序列。
chap4_para119,5,,这是因为，正如第3章的原始问题一样，每个动作后接收到的感知是完全可预测的——它们总是空的！
chap4_para119,6,,所以不存在需要规划的偶发事件。
chap4_para119,7,,即使环境是非确定性的，这也是正确的。
chap4_para1190,1,,幸运的是，一阶逻辑允许我们使用Person谓词而无须对其进行完整定义。
chap4_para1190,2,,不过我们可以写出每个人具有的性质和使某物成为人的性质：
chap4_para1191,1,,"公理也可以是“直白的事实”，例如Male(Jim)和Spouse(Jim, Laura)。"
chap4_para1191,2,,这些来自特定问题实例描述的事实使特定的提问能够得到解答。
chap4_para1191,3,,如果一切顺利的话，这些问题的答案会成为与公理逻辑一致的定理。
chap4_para1192,1,,"我们常常会发现期望的答案不是现成的，例如，从Spouse(Jim, Laura)出发，我们期望（根据很多国家的法律）能推得，但这并不能由先前给出的公理推导得出，即便在我们像8.2.8节所述的那样添加也不行。"
chap4_para1192,2,,这表明缺失了一条公理。
chap4_para1192,3,,习题8.HILL要求读者提供这条公理。
chap4_para1193,1,,8.3.3　数、集合与列表
chap4_para1194,1,,数可能是展示从一小部分核心公理构建庞大理论的最生动的示例。
chap4_para1194,2,,我们在此阐述自然数或称非负整数的理论。
chap4_para1194,3,,我们需要谓词NatNum对于自然数为真，我们还需要常量符号0，以及一个函数符号S（后继）。
chap4_para1194,4,,皮亚诺公理（Peano axioms）定义了自然数和加法。
chap4_para1194,5,,[9]自然数是递归定义的：
chap4_para1196,1,,[9]　皮亚诺公理还包括归纳法则，但它是二阶逻辑的语句而非一阶逻辑。
chap4_para1196,2,,这种区别的重要性将在第9章中进行解释。
chap4_para1197,1,,也就是说，0是自然数，对于每一个对象n，如果n是自然数，则S(n)是自然数。
chap4_para1197,2,,"因此自然数是0, S(0), S(S(0)), …。"
chap4_para1197,3,,我们还需要约束后继函数的公理：
chap4_para1198,1,,现在我们就可以用后继函数定义加法：
chap4_para1199,1,,这些公理中，第一个公理表示对任何自然数m加0等于m本身。
chap4_para1199,2,,"注意，在+(m, 0)项中二元函数符号“+”的使用：在普通数学中，这一项会使用中缀（infix）记法写作m + 0。"
chap4_para1199,3,,［我们在一阶逻辑中使用的记法称为前缀（prefix）。
chap4_para1199,4,,］为使我们关于数的语句更容易阅读，我们允许使用中缀记法。
chap4_para1199,5,,我们可以将S(n)写成n + 1，因此第二个公理变为
chap4_para12,1,"The hill-climbing search algorithm is shown in Figure 4.2. It keeps track of one current state and on each iteration moves to the neighboring state with highest value—that is, it heads in the direction that provides the steepest ascent. It terminates when it reaches a “peak” where no neighbor has a higher value. Hill climbing does not look ahead beyond the immediate neighbors of the current state. This resembles trying to find the top of Mount Everest in a thick fog while suffering from amnesia. Note that one way to use hill-climbing search is to use the negative of a heuristic cost function as the objective function; that will climb locally to the state with smallest heuristic distance to the goal.",我们将使用8皇后问题（图4-3）进一步说明爬山法。
chap4_para12,2,,我们将使用一个完整状态形式化（complete-state formulation），即每个状态都包含解的所有组成部分，但它们可能并不都在正确的位置。
chap4_para12,3,,在这种情况下，每个状态都包括在棋盘上放置8个皇后，每列一个。
chap4_para12,4,,初始状态是随机选择的，状态后继是通过将一个皇后移动到同一列中的另一格所生成的所有可能状态（所以每个状态有8×7 = 56个后继）。
chap4_para12,5,,启发式代价函数h是可相互攻击的皇后对的数量；只有当该状态是一个解时，h值才是0。
chap4_para12,6,,（如果两个皇后在同一条线上，即使它们之间存在一个中间棋子，这两个皇后也会被视为形成相互攻击。
chap4_para12,7,,）图4-3b展示了一个h = 17的状态以及它所有后继的h值。
chap4_para120,1,We could introduce new algorithms for sensorless search problems.,
chap4_para120,2,"But instead, we can use the existing algorithms from Chapter 3 if we transform the underlying physical problem into a belief-state problem, in which we search over belief states rather than physical states.",
chap4_para120,3,"The original problem, P, has components ActionsP, ResultP etc.",
chap4_para120,4,", and the belief-state problem has the following components:",
chap4_para1200,1,,这条公理将加法简化为对后继函数的反复应用。
chap4_para1201,1,,使用中缀记法是一个语法糖（syntactic sugar）的示例。
chap4_para1201,2,,语法糖是一种对标准语法的扩展或缩略，但不改变语义。
chap4_para1201,3,,所有使用糖的语句都可以“脱糖”生成普通一阶逻辑中的等价语句。
chap4_para1201,4,,还有一个示例是使用方括号而非圆括号来使左右括号的对应关系更易读。
chap4_para1201,5,,而另一个示例是量词折叠：用代替。
chap4_para1202,1,,我们有了加法以后，将乘法定义为重复的加法、乘方定义为连续的乘法就是顺理成章的事情，同样我们可以定义整数除法和余数、质数等。
chap4_para1202,2,,这样，整个数论（包括密码学）就能从一个常量、一个函数、一个谓词和4条公理开始构建起来。
chap4_para1203,1,,集合的论域对数学和常识推理也是非常重要的。
chap4_para1203,2,,（实际上，可以用集合论来定义数论。
chap4_para1203,3,,）我们希望能够表示每个集合，包括空集。
chap4_para1203,4,,我们需要一种方法用其他集合的元素或对其他集合的操作构建集合。
chap4_para1203,5,,我们想知道一个元素是否是集合的成员，也需要区分一个对象是否是集合。
chap4_para1204,1,,我们将使用集合论中的一般词汇作为语法糖。
chap4_para1204,2,,空集是一个常量，写作{}。
chap4_para1204,3,,一元谓词Set对集合为真。
chap4_para1204,4,,二元谓词包括（x是集合s的成员）以及（集合s1是集合s2的子集，两个集合也可以相同）。
chap4_para1204,5,,"二元函数是（交集）、（并集）和Add(x, s)（将元素x添加到集合s生成的集合）。"
chap4_para1204,6,,下面是一个可能的公理集。
chap4_para1205,1,,（1）集合只能是空集和向集合中添加元素产生的集合：
chap4_para1206,1,,（2）空集没有被加入的元素。
chap4_para1206,2,,换言之，无法将空集分解为更小的集合和元素：
chap4_para1207,1,,（3）对集合添加已有元素没有作用：
chap4_para1208,1,,（4）集合中的成员只能是被添加到集合中的元素。
chap4_para1208,2,,我们用递归的形式表示它：声明x是s中的元素，当且仅当s等于某个将元素y添加到集合s2后的集合，其中y与x相同，或x是s2的成员：
chap4_para1209,1,,（5）一个集合是另一个集合的子集当且仅当第一个集合的所有成员都是第二个集合的成员：
chap4_para121,1,"•States: The belief-state space contains every possible subset of the physical states. If P has N states, then the belief-state problem has 2N belief states, although many of those may be unreachable from the initial state.",[6]　在完全可观测的环境中，每个信念状态只包含一个物理状态。
chap4_para121,2,,因此，我们可以将第3章的算法看作在信念状态为单元素的信念状态空间中搜索。
chap4_para1210,1,,（6）两个集合相等当且仅当它们互为对方的子集：
chap4_para1211,1,,（7）一个对象在两个集合的交集中，当且仅当它同时是这两个集合的成员：
chap4_para1212,1,,（8）一个对象在两个集合的并集中，当且仅当它同时是某个集合的成员：
chap4_para1213,1,,列表与集合类似。
chap4_para1213,2,,它们的区别是，列表是有序的，相同的元素在列表中可以出现多次。
chap4_para1213,3,,我们可以用Lisp语言的词汇表示列表：Nil是没有元素的常量列表；Cons、Append、First和Rest是函数；Find在列表中的作用与Member在集合中的作用相同。
chap4_para1213,4,,List是仅对列表为真的谓词。
chap4_para1213,5,,与集合一样，涉及列表的逻辑语句也常用到语法糖。
chap4_para1213,6,,空列表是[]。
chap4_para1213,7,,"Cons(x, Nil)项（即仅含有元素x，尾部没有其他元素的列表）写作[x]。"
chap4_para1213,8,,"含有若干元素的列表，如[A, B, C]，对应于嵌套项。"
chap4_para1213,9,,习题8.LIST要求你写出列表的公理。
chap4_para1214,1,,8.3.4　wumpus世界
chap4_para1215,1,,第7章给出了wumpus世界的一些命题逻辑公理。
chap4_para1215,2,,本节介绍的一阶公理简洁得多，自然、精确地刻画了我们的意图。
chap4_para1216,1,,如前所述，wumpus世界智能体接收一个含有5个元素的感知向量。
chap4_para1216,2,,知识库中存储的对应一阶语句必须包含感知和感知出现的时间，否则，智能体会搞不清何时接收到什么感知。
chap4_para1216,3,,我们使用整数表示时间步。
chap4_para1216,4,,一个典型的感知语句是
chap4_para1217,1,,此处，Percept是二元谓词，Stench等是列表中的常量。
chap4_para1217,2,,wumpus世界中的动作可以用逻辑项表示：
chap4_para1218,1,,要确定哪个动作最优，智能体程序执行查询
chap4_para122,1,"•Initial state: Typically the belief state consisting of all states in P, although in some cases the agent will have more knowledge than this.",我们可以为无传感器搜索问题介绍新的算法。
chap4_para122,2,,但是，如果我们将底层物理问题转化为信念状态问题，我们就可以使用第3章中现有的算法，即，对信念状态而非物理状态进行搜索。
chap4_para122,3,,原问题P，由ActionsP、ResultP等组成，信念状态问题则包括以下部分。
chap4_para1220,1,,将返回一个类似的绑定表。
chap4_para1220,2,,智能体程序将Grab作为要采取的动作。
chap4_para1220,3,,原始感知数据蕴涵了关于当前状态的某些事实。
chap4_para1220,4,,例如：
chap4_para1221,1,,这些规则展现了一个被称为感知的推理形式的细节，我们将在第25章进行深入研究。
chap4_para1221,2,,注意对时间t的量化。
chap4_para1221,3,,在命题逻辑中，我们需要每个时间步的每条语句的副本。
chap4_para1222,1,,简单的“反射”行为也可以用量化蕴涵式语句来实现。
chap4_para1222,2,,例如，我们有
chap4_para1223,1,,"给定感知和先前几段给出的规则，就能得出所需的结论BestAction(Grab, 5)，也就是说，Grab是要做的正确的事。"
chap4_para1224,1,,我们已经表示了智能体的输入和输出，现在可以表示环境本身了。
chap4_para1224,2,,我们从对象开始。
chap4_para1224,3,,显然，候选的对象有方格、无底洞和wumpus。
chap4_para1224,4,,"我们可以命名方格，如Square1,2等，但接下来Square1,2与Square1,3相邻的事实就必须是“额外”的事实，我们要为每一对方格列出一条这样的事实。"
chap4_para1224,5,,"使用行和列为整数的复合项是更好的做法，例如，我们可以简单地使用列表项[1, 2]。"
chap4_para1224,6,,任意相邻的方格可以定义为
chap4_para1225,1,,我们也可以为每个无底洞命名，但不宜这么做另有原因：没有必要去区分每个无底洞。
chap4_para1225,2,,[10]使用一元谓词Pit并使其在含有无底洞的方格中为真是更简单的做法。
chap4_para1225,3,,最后，由于只存在一个wumpus，用常量Wumpus与使用一元谓词并没什么区别（从wumpus的视角看，使用常量可能更威严）。
chap4_para1227,1,,[10]　同样，大多数人也不会为冬天迁徙到温暖地区的每一只鸟命名。
chap4_para1227,2,,但想研究迁徙模式、生存率等的鸟类学家要追踪每一只鸟，因此会为每只鸟命名，方法是为鸟安装腿环。
chap4_para1228,1,,"智能体的位置随时间变化，因此我们用At(Agent, s, t)来表示智能体在时间t位于方格s。"
chap4_para1228,2,,我们可以用将wumpus永远固定在一个位置。
chap4_para1228,3,,然后我们就可以说对象在一个时刻只能在一个位置：
chap4_para1229,1,,给定智能体的当前位置，它就可以用当前的感知来推断方格的属性。
chap4_para1229,2,,例如，如果智能体在一个方格中并感知到微风，则这个方格是有微风的：
chap4_para123,1,"•Actions: This is slightly tricky. Suppose the agent is in belief state b = {s1,s2}, but ACTIONSP(s1) ≠ ACTIONSP(s2); then the agent is unsure of which actions are legal. If we assume that illegal actions have no effect on the environment, then it is safe to take the union of all the actions in any of the physical states in the current belief state b:",● 状态：信念状态空间包含物理状态的每一个可能子集。
chap4_para123,2,,如果原问题P有N个状态，那么信念状态问题有2N个信念状态，尽管有很多状态都无法从初始状态到达。
chap4_para1230,1,,知道一个方格有微风很有用，因为我们知道无底洞是不能移动的。
chap4_para1230,2,,注意，Breezy没有时间参数。
chap4_para1231,1,,发现了哪些位置有微风（或有臭味）以及同样重要的哪些位置没有微风（或没有臭味），智能体就可以推导出无底洞的位置（以及wumpus的位置）。
chap4_para1231,2,,在命题逻辑中每个方格都需要一条公理（见7.4.3节的R2和R3），并且对每种世界的地形布局都需要一套不同的公理。
chap4_para1231,3,,而在一阶逻辑中我们只需要一条公理：
chap4_para1233,1,,类似地，一阶逻辑中我们可以量化所有时间，因此，对于每个谓词我们只需要一个后继状态公理，而非对每个时间步都保留副本。
chap4_para1233,2,,例如，箭的公理［式（7-2）］变为
chap4_para1234,1,,从这两个例子的语句可以看出，一阶逻辑的表达方式并不比第7章给出的自然语言描述更复杂。
chap4_para1234,2,,我们鼓励读者对智能体的位置和朝向构建类似的公理——在这些情况下，公理需要量化时间和空间。
chap4_para1234,3,,如命题状态估计一样，智能体可以对这样的公理使用逻辑推断来了解不能直接观测的那部分世界。
chap4_para1234,4,,第11章会更深入地研究一阶逻辑的后继状态公理以及它在构建规划中的用处。
chap4_para1235,1,,8.4　一阶逻辑中的知识工程
chap4_para1236,1,,8.3节展示了如何用一阶逻辑在3个简单的论域中表示知识。
chap4_para1236,2,,本节描述知识库构建的一般过程，这一过程称作知识工程（knowledge engineering）。
chap4_para1236,3,,知识工程师是研究一个特定论域，了解这个论域中哪些概念是重要的，并创建该论域中对象和关系的形式化表示的人。
chap4_para1236,4,,我们会阐述在电子电路论域中进行知识工程的过程。
chap4_para1236,5,,我们采用的方法适于构建专用知识库，这种知识库的论域是精心划定的，其查询的范围也是已知的。
chap4_para1236,6,,通用知识库则涵盖了较大范围的人类知识，用于支持像自然语言理解这样的任务，我们在第10章对其进行讨论。
chap4_para1237,1,,8.4.1　知识工程的过程
chap4_para1238,1,,知识工程项目的内容、范围和难度各不相同，但所有这样的项目都包括如下的步骤。
chap4_para1239,1,,（1）确定问题。
chap4_para1239,2,,知识工程必须描述知识库要支持的问题范围，以及对每个特定问题实例可获取的事实类型。
chap4_para1239,3,,例如，wumpus知识库是需要能够选择动作，还是只需要回答关于环境内容的问题？
chap4_para1239,4,,传感器事实是否需要包括当前位置？
chap4_para1239,5,,任务将决定为了将问题实例连接到回答必须表示哪些知识。
chap4_para1239,6,,这一步类似于第2章用于设计智能体的PEAS过程。
chap4_para124,1,"On the other hand, if an illegal action might lead to catastrophe, it is safer to allow only the intersection, that is, the set of actions legal in all the states.",● 初始状态：通常，初始信念状态包含P中的所有状态，尽管在某些情况下，智能体具有更多的先验知识。
chap4_para124,2,"For the vacuum world, every state has the same legal actions, so both methods give the same result.",
chap4_para1240,1,,（2）收集相关知识。
chap4_para1240,2,,知识工程师可能已经是领域专家，也可能需要与真正的专家合作来获得他们的知识——这个过程叫作知识获取（knowledge acquisition）。
chap4_para1240,3,,在这一阶段，知识并非形式化表示的，这一步的主要目的是了解任务所确定的知识库的范围，以及了解这一领域的运行方式。
chap4_para1241,1,,对由人工产生的规则集定义的wumpus世界来说，我们很容易找出相关知识。
chap4_para1241,2,,（但是要注意，相邻关系的定义并不是由wumpus世界规则明确给出。
chap4_para1241,3,,）对于真实世界的论域，相关性问题可能非常困难，例如，仿真VLSI设计的系统可能需要，也可能不需要考虑杂散电容和集肤效应问题。
chap4_para1242,1,,（3）确定谓词、函数和常量的词汇表。
chap4_para1242,2,,也就是说，将重要的论域级概念翻译为逻辑级名称。
chap4_para1242,3,,这就涉及知识工程风格的许多问题。
chap4_para1242,4,,类似于编程风格，知识工程风格可能对项目最终成功与否产生重要影响。
chap4_para1242,5,,例如，无底洞应当被表示为对象还是表示为方格的一元谓词？
chap4_para1242,6,,智能体的朝向应当是函数还是谓词？
chap4_para1242,7,,wumpus的位置是否与时间相关？
chap4_para1242,8,,一旦做出这些决定，就会形成被称为论域的本体论（ontology）的词汇表。
chap4_para1242,9,,“本体论”一词是指关于存在或实存的本质的理论。
chap4_para1242,10,,本体论决定哪些东西存在，但不能决定它们的具体性质和相互关系。
chap4_para1243,1,,（4）对论域的通用知识编码。
chap4_para1243,2,,知识工程师为词汇表中的所有项写出公理。
chap4_para1243,3,,这就（尽可能地）固定了项的含义，使专家能够检查其内容。
chap4_para1243,4,,这一步经常会发现词汇表的概念误解或理解偏差，这必须返回第3步进行修正并重复这个过程。
chap4_para1244,1,,（5）对问题实例的描述编码。
chap4_para1244,2,,如果本体论确定得很恰当，这一步就相当容易。
chap4_para1244,3,,它涉及写出本体论中的概念实例的简单原子语句。
chap4_para1244,4,,对逻辑智能体来说，问题实例是由传感器提供的，而“无形”的知识库获取语句的方式与传统程序获取输入数据的方式相同。
chap4_para1245,1,,（6）向推断过程提出查询并获得答案。
chap4_para1245,2,,这是获得回报的一步：我们可以让推断过程在公理和问题相关的事实上运行来推导我们有兴趣了解的事实。
chap4_para1245,3,,这样，我们就不需要编写应用相关的求解算法了。
chap4_para1246,1,,（7）调试并评估知识库。
chap4_para1246,2,,很遗憾，查询得到的答案一开始往往是错误的。
chap4_para1246,3,,更准确地说，答案对于现有的知识库是正确的（如果假设推断过程是可靠的），但它们不是用户期望的答案。
chap4_para1246,4,,例如，如果缺失了一条公理，一些查询就不能从知识库中得到答案。
chap4_para1246,5,,这就需要大量的调试过程。
chap4_para1246,6,,关注推理链意外停止的地方可以轻易找出缺失或过弱的公理。
chap4_para1246,7,,例如，如果知识库为找到wumpus而含有诊断规则（见习题8.WUMD）：
chap4_para1247,1,,而没有采用双向蕴涵，智能体就永远不能证明wumpus不存在。
chap4_para1247,2,,不正确的公理是关于世界的错误陈述，因此可以被找出。
chap4_para1247,3,,例如，语句
chap4_para1248,1,,对爬行动物、两栖动物和桌子都不成立。
chap4_para1248,2,,判断这条语句的错误性可以不依赖于知识库的其他部分。
chap4_para1248,3,,但是，程序中的一个典型错误则如下：
chap4_para1249,1,,在不理解上下文的情况下，不可能判断offset应当是position还是position+1。
chap4_para125,1,"•Transition model: For deterministic actions, the new belief state has one result state for each of the current possible states (although some result states may be the same):",● 动作：这部分有点棘手。
chap4_para125,2,,假设智能体位于信念状态，但是；那么智能体就无法确定哪些动作是合法的。
chap4_para125,3,,如果我们假定非法动作不会对环境产生影响，那么执行当前信念状态b下的任意物理状态的所有动作的并集都是安全的。
chap4_para1250,1,,当你的知识库中没有明显的错误时，似乎就要大功告成了。
chap4_para1250,2,,但最好还是通过在查询测试套件上运行系统并测量正确答案的数量来正式地评估系统，除非你的知识库明显没有错误。
chap4_para1250,3,,没有客观度量的话，你很容易就以为任务已经完成了。
chap4_para1250,4,,为了更好地理解这7个步骤，我们现在将其应用于一个扩展的示例——电子电路论域。
chap4_para1251,1,,8.4.2　电子电路论域
chap4_para1252,1,,我们将构建一个本体论和一个知识库，使我们能够进行关于图8-6所示的数字电路的推理。
chap4_para1252,2,,我们将遵循知识工程的7个步骤。
chap4_para1253,1,,图8-6　一位全加器的数字电路C1。
chap4_para1253,2,,前两个输入是要相加的两位，第三个输入是进位位。
chap4_para1253,3,,第一个输出是和，第二个输出是通往下一个加法器的进位位。
chap4_para1253,4,,电路包含两个异或门、两个与门和一个或门
chap4_para1255,1,,涉及数字电路的推理任务很多。
chap4_para1255,2,,最高层次的任务是分析电路的功能性。
chap4_para1255,3,,例如，图8-6的电路是否能够正确地做加法？
chap4_para1255,4,,如果所有输入都为高，A2门的输出是什么？
chap4_para1255,5,,关于电路结构的问题同样有趣。
chap4_para1255,6,,例如，连接到第一个输入端子的门有哪些？
chap4_para1255,7,,电路是否含有反馈回路？
chap4_para1255,8,,这都是这一步骤中的任务。
chap4_para1255,9,,还有更详细的分析层次，包括关于延迟、电路面积、功耗以及生产成本等的分析。
chap4_para1255,10,,所有这些层次的分析都需要额外的知识。
chap4_para1257,1,,我们对数字电路了解多少？
chap4_para1257,2,,根据我们的目的，这包括导线和门。
chap4_para1257,3,,信号沿着导线传输到门的输入端，每个门则在输出端产生一个信号沿着另一条导线传输。
chap4_para1257,4,,要确定这些信号是什么，我们需要了解门如何转换其输入信号。
chap4_para1257,5,,门有4种：具有两个输入端子的与门（AND）、或门（OR）和异或门（XOR），以及只有一个输入端子的非门（NOT）。
chap4_para1257,6,,所有门都只有一个输出端子。
chap4_para1257,7,,像门一样，电路本身也有输入端子和输出端子。
chap4_para1258,1,,要推理电路的功能性和连接性，我们不需要涉及导线本身、导线路径或导线连接点。
chap4_para1258,2,,重要的只有端子之间的连接——我们可以说某个输出端子连接到另一个输入端子，而不需要了解其实际的连接方式。
chap4_para1258,3,,其他因素，像元件的尺寸、形状、颜色或价格与我们的分析也不相关。
chap4_para1259,1,,如果我们的目的不是在门的层级验证设计，本体论就完全不同。
chap4_para1259,2,,例如，如果我们对于故障电路修复有兴趣，那么将导线纳入本体论就很可能是个好主意，因为导线的故障会妨碍在其中传输的信号。
chap4_para1259,3,,要解决时序故障，我们需要把门延迟加进本体论。
chap4_para1259,4,,如果我们要设计可盈利的产品，电路价格及其相对于市场上其他产品的速度就会很重要。
chap4_para126,1,"With nondeterminism, the new belief state consists of all the possible results of applying the action to any of the states in the current belief state:",但是，如果非法动作可能导致严重后果，那么只允许执行动作的交集（对所有状态都合法的动作的集合）更安全。
chap4_para126,2,,对于真空吸尘器世界，每个状态都具有相同的合法动作，所以两种方法将给出相同的结果。
chap4_para1261,1,,我们现在已经知道我们要涉及电路、端子、信号和门。
chap4_para1261,2,,下一步选择用于表示它们的函数、谓词和常量。
chap4_para1261,3,,我们需要先将不同的门与其他对象区分开。
chap4_para1261,4,,每个门由常量命名的对象表示，我们用Gate(X1)来断言X1是门。
chap4_para1261,5,,每个门的行为由其类型决定，即常量AND、OR、XOR和NOT中的一种。
chap4_para1261,6,,由于一个门只能有一种类型，我们可以使用函数Type(X1) = XOR。
chap4_para1261,7,,电路与门类似，使用一个谓词来表示——Circuit(C1)。
chap4_para1262,1,,接下来我们考虑端子，使用谓词Terminal(x)表示。
chap4_para1262,2,,一个电路可以有一个或多个输入端子和一个或多个输出端子。
chap4_para1262,3,,"我们使用函数In(1, X1)来表示电路X1的第1个输入端子。"
chap4_para1262,4,,"相似的函数Out(n, c)用于输出端子。"
chap4_para1262,5,,"谓词Arity(c, i, j)断言电路c有i个输入端子和j个输出端子。"
chap4_para1262,6,,门之间的连接性可以用谓词Connected表示，它需要两个端子作为参数，如。
chap4_para1263,1,,最后，我们需要知道一个信号是通还是断。
chap4_para1263,2,,一种可能是使用一元谓词On(t)，在某个端子的信号通时为真。
chap4_para1263,3,,但这会增加提出类似“电路C1输出端子的所有可能信号值有哪些？
chap4_para1263,4,,”的问题的难度。
chap4_para1263,5,,因此我们引入两个信号值1和0作为对象，分别表示“通”和“断”，而用函数Signal(t)表示端子t的信号值。
chap4_para1264,1,,4. 对论域的通用知识编码
chap4_para1265,1,,好的本体论仅需要少量通用规则，并且可以简明地声明这些规则。
chap4_para1265,2,,如下是我们需要的全部公理。
chap4_para1266,1,,（1）如果两个端子连通，则它们信号相同：
chap4_para1267,1,,（2）每个端子的信号只能是1或0：
chap4_para1268,1,,（3）Connected具有交换性：
chap4_para1269,1,,（4）门的类型有4种：
chap4_para127,1,"The size of bʹ will be the same or smaller than b for deterministic actions, but may be larger than b with nondeterministic actions (see Figure 4.13).",● 转移模型：对于确定性动作，对于每个当前可能状态，新的信念状态中都存在一个如下结果状态（尽管一些结果状态可能是相同的）。
chap4_para1270,1,,（5）与门的输出为0，当且仅当其任意输入为0：
chap4_para1271,1,,（6）或门的输出为1，当且仅当其任意输入为1：
chap4_para1272,1,,（7）异或门的输出为1，当且仅当其输入不相同：
chap4_para1273,1,,（8）非门的输出与其输入不同：
chap4_para1274,1,,（9）除了非门之外的所有门都有两个输入和一个输出：
chap4_para1275,1,,（10）电路有端子，数量不超过其输入和输出元数，不存在超出元数的任何东西：
chap4_para1276,1,,（11）门、端子和信号是不同的：
chap4_para1278,1,,5. 对特定问题实例编码
chap4_para1279,1,,图8-6所示的电路被编码为电路C1并有如下描述。
chap4_para1279,2,,首先我们对电路及其门元件进行分类：
chap4_para128,1,Description The belief states are depicted by circular sections enclosing the vacuum world states that are depicted by square blocks with corresponding states labeled on them.,
chap4_para128,2,"A bold arrow labeled suck from the first belief state, which includes vacuum world states 1 and 3, points to the first node.",
chap4_para128,3,"A bold arrow labeled open square bracket ""A"", clean close square bracket points to the second belief state, which has 5 and 7 vacuum world states.",
chap4_para128,4,An arrow labeled right from the first belief state points to a second node with an arc.,
chap4_para128,5,"An arrow labeled open square bracket B, Dirty close square bracket, from the second node points to a third belief state which has singleton vacuum world state 2.",
chap4_para128,6,"An arrow labeled open square bracket B, clean close square bracket, from the second node points to a third belief state which has singleton vacuum world state 4.",
chap4_para1280,1,,随后我们给出其连接情况：
chap4_para1281,1,,6. 向推断过程提出查询
chap4_para1282,1,,哪种输入组合会使C1的第一个输出（求和位）为0，第二个输出（进位位）为1？
chap4_para1283,1,,答案是变量i1、i2和i3的置换，以使得语句被知识库所蕴含。
chap4_para1283,2,,AskVars将给我们3种这样的置换：
chap4_para1284,1,,加法器电路中所有端子的可能值的集合有哪些？
chap4_para1285,1,,最后这个查询将返回设备的完整输入输出表，可以用于检验它是否能正确做加法。
chap4_para1285,2,,这是电路验证（circuit verification）的一个简单示例。
chap4_para1285,3,,我们也可以使用电路的定义来构建更大的数字系统，并使用相同的验证方式。
chap4_para1285,4,,（见习题8.ADDR）许多论域都支持这种结构化的知识库创建方式，但需要在简单概念的基础上定义更为复杂的概念。
chap4_para1287,1,,我们可以以各种方式查询知识库以了解它会出现哪些错误行为。
chap4_para1287,2,,例如，假设我们没有阅读8.2.8节，因而忘记断言10。
chap4_para1287,3,,假设我们发现系统除了输入000和110的情况，无法证明电路的任何输出，我们可以通过询问每个门的输出的方式来找到问题。
chap4_para1287,4,,我们可以询问：
chap4_para1288,1,,结果显示在X1处对于输入10和01没有输出。
chap4_para1288,2,,因此，我们查看应用于X1的异或门的公理：
chap4_para1289,1,,如果输入已知为1和0，则上式简化为
chap4_para129,1,Figure 4.,对于非确定性动作，新的信念状态则包含了将该动作应用于当前信念状态中的任一状态的所有可能结果。
chap4_para129,2,"13(a) Predicting the next belief state for the sensorless vacuum world with the deterministic action, Right.",
chap4_para129,3,(b) Prediction for the same belief state and action in the slippery version of the sensorless vacuum world.,
chap4_para1290,1,,现在，问题就很明显了：系统不能推断出，因此，我们需要告诉它10。
chap4_para1292,1,,本章介绍了一阶逻辑，一种命题逻辑更具表达能力的表示语言。
chap4_para1292,2,,本章要点如下。
chap4_para1293,1,,● 知识表示语言应当是说明性的、合成式的、有表达能力的、上下文无关的且无歧义的。
chap4_para1294,1,,● 逻辑之间的区别在于其本体论约定和认识论约定，命题逻辑仅约定事实的存在，一阶逻辑则约定对象和关系的存在，因而增加了表达能力，适用于像wumpus世界和电子电路这样的论域。
chap4_para1295,1,,● 命题逻辑和一阶逻辑在表示模糊命题上都有困难。
chap4_para1295,2,,这一困难限制了它们在需要个人判断的论域的应用性，如政治或烹饪。
chap4_para1296,1,,● 一阶逻辑的语法构建于命题逻辑之上。
chap4_para1296,2,,它增加了项来表示对象，并且有全称量词和存在量词来构建关于被量化的变量的全部或部分可能值的断言。
chap4_para1297,1,,● 一阶逻辑的一个可能世界或模型包括一个对象集和一种将常量符号映射到对象、将谓词符号映射到对象的关系、将函数符号映射到对象上的函数的解释。
chap4_para1298,1,,● 一条原子语句为真，仅当谓词命名的关系在项命名的对象之间成立。
chap4_para1298,2,,扩展解释将量词变量映射到模型中的对象，定义了量化语句的真值。
chap4_para1299,1,,● 在一阶逻辑中构建知识库需要严谨的过程来分析论域、选择词汇表、编码能支持所需推断的公理。
chap4_para13,1,"Description The chessboard positions are usually named in such a way that the columns are named from “a” to h, and the rows are named from 1 to 8. The queens are placed at the following positions. “a” 1, b 6, c 2, d 5, e 7, f 4, g 8, and h 3.",爬山法有时被称为贪心局部搜索（greedy local search），因为它只是选择最优的邻居状态，而不事先考虑下一步该如何走。
chap4_para13,2,,虽然贪婪被视为七宗罪之一，但事实证明，贪心算法往往相当有效。
chap4_para13,3,,爬山法可以在求解问题时取得快速进展，因为它通常可以很容易地改善一个差的状态。
chap4_para13,4,,例如，只需5步就可以从图4-3b的状态到达图4-3a的状态，该状态的h = 1，与解非常接近。
chap4_para13,5,,遗憾的是，爬山法可能会由于以下原因而陷入困境。
chap4_para130,1,"•Goal test: The agent possibly achieves the goal if any state s in the belief state satisfies the goal test of the underlying problem, IS-GOALP(s). The agent necessarily achieves the goal if every state satisfies IS-GOALP(s). We aim to necessarily achieve the goal.",对于确定性动作，b'不会大于b，而对于非确定性动作，b'可能会大于b（见图4-13）。
chap4_para1302,1,,第9章　一阶逻辑中的推断
chap4_para1303,1,,在本章中，我们定义有效的过程来回答用一阶逻辑提出的问题。
chap4_para1304,1,,在本章中，我们阐述能够回答所有可解的一阶逻辑问题的算法。
chap4_para1304,2,,9.1节介绍量词的推断规则，并展示如何将一阶逻辑推断约简为命题逻辑推断，尽管这样做代价巨大。
chap4_para1304,3,,9.2节描述了如何用合一来构建直接用于一阶逻辑的推断规则。
chap4_para1304,4,,随后我们讨论一阶逻辑推断的3类主要算法：前向链接（9.3节）、反向链接（9.4节）和基于归结的定理证明（9.5节）。
chap4_para1305,1,,9.1　命题推断与一阶推断
chap4_para1306,1,,进行一阶推断的方法之一是将一阶知识库转换为命题逻辑并使用我们已知的命题推断。
chap4_para1306,2,,第一步是消去全称量词。
chap4_para1306,3,,例如，假设我们的知识库含有典型的朴素道德公理，认为所有贪婪的国王都是邪恶的：
chap4_para1307,1,,由此我们可以推断出下列任一语句：
chap4_para1308,1,,一般来说，全称量词实例化（universal instantiation，UI）表明我们可以通过用基本项（没有变量的项）置换全称量化的变量来推断任意语句。
chap4_para1308,2,,[1]
chap4_para131,1,"•Action cost: This is also tricky. If the same action can have different costs in different states, then the cost of taking an action in a given belief state could be one of several values. (This gives rise to a new class of problems, which we explore in Exercise 4.MVAL.) For now we assume that the cost of an action is the same in all states and so can be transferred directly from the underlying physical problem.",图4-13　（a）预测在无传感器真空吸尘器世界执行确定性动作Right后的下一个信念状态；（b）在光滑的无传感器真空吸尘器世界中的同一状态下执行同一动作的预测
chap4_para1310,1,,[1]　不要把此处的置换与8.2.6节用于定义量词语义的扩展解释搞混了。
chap4_para1310,2,,置换用项（term，语法片段）代替变量来产生新的语句，而解释将变量映射到论域中的实例。
chap4_para1311,1,,我们使用8.3节介绍过的置换来形式化地写出推断规则。
chap4_para1311,2,,令表示对语句应用置换后的语句。
chap4_para1311,3,,则对于任意变量v和基本项g，规则写作
chap4_para1312,1,,前述的3条语句就是分别用置换、和得到的。
chap4_para1313,1,,类似地，存在量词实例化（existential instantiation）用一个新的常量符号替换存在量化的变量。
chap4_para1313,2,,其形式化描述如下：对于任意语句、变量v和未在知识库其他地方出现的常量符号k，
chap4_para1316,1,,只要C1未在知识库的其他地方出现。
chap4_para1316,2,,简单来说，存在语句表明存在满足某个条件的对象，运用存在实例化就是给这个对象命名。
chap4_para1316,3,,当然，这个名称不能已经属于其他对象。
chap4_para1316,4,,数学中有一个很好的例子：假设我们发现有一个数字比2.718 28稍大，并满足等式中的x。
chap4_para1316,5,,我们可以将这个数字命名为e，但不能将其命名为已经存在的对象名，如。
chap4_para1316,6,,在逻辑中，新的名称被称为斯科伦常量（Skolem constant）。
chap4_para1317,1,,全称量词实例化可以多次用于同一条公理来产出许多不同结果，而存在量词实例化只需要使用一次，随后就可以丢掉存在量化的语句。
chap4_para1317,2,,"例如，一旦我们添加了语句Kill(Murderer, Victim)的话，就不再需要。"
chap4_para1319,1,,我们现在展示如何将任意一阶知识库转换为命题知识库。
chap4_para1319,2,,第一个想法是，正如存在量化语句能够用一个实例代替一样，全称量化语句也可以用所有可能实例的集合代替。
chap4_para1319,3,,例如，假设我们的知识库仅含有语句
chap4_para132,1,Figure 4.,● 目标测试：如果信念状态中的任一状态s满足底层问题的目标测试，Is-GoalP(s)，则智能体有可能到达了目标。
chap4_para132,2,"14 shows the reachable belief-state space for the deterministic, sensorless vacuum world.",如果所有状态都满足Is-GoalP(s)，则智能体必定到达了目标。
chap4_para132,3,There are only 12 reachable belief states out of 28 = 256 possible belief states.,我们的目标是使得智能体必定到达了目标。
chap4_para1321,1,,且对象仅有John和Richard。
chap4_para1321,2,,我们用所有可能的置换，和，对第一条语句应用全称量词实例化。
chap4_para1321,3,,我们得到
chap4_para1322,1,,接下来用命题符号（如JohnIsKing）替换基本原子语句（如King(John)）。
chap4_para1322,2,,最后，用第7章的任意完备的命题算法得到如JohnIsEvil的结论，它等价于Evil(John)。
chap4_para1323,1,,正如我们将在9.5节中讨论的，这种命题化（propositionalization）技术可以被彻底一般化。
chap4_para1323,2,,然而，如果知识库中包含函数符号，可能的基本项置换集是无穷的！
chap4_para1323,3,,例如，如果知识库提到Father函数，就可以构建像Father(Father(Father(John)))这样的无穷多的嵌套项。
chap4_para1324,1,,"幸运的是，雅克·埃尔布朗（Jacques Herbrand）针对这一现象提出了著名的定理，即如果语句被原始的一阶知识库蕴含，则存在仅涉及命题化知识库的有限子集的证明（Herbrand, 1930）。"
chap4_para1324,2,,由于任意这样的子集都有其基本项的最大嵌套深度，我们可以通过先生成含有常量符号（Richard和John）的所有实例化，然后再生成深度为1的所有项（Father(Richard)和Father(John)），然后是深度为2的所有项，以此类推，直到我们能够构建所蕴含语句的命题证明。
chap4_para1325,1,,我们已经概述了通过命题化进行一阶逻辑推断的完备方法，也就是，所有蕴含的语句都可以被证明。
chap4_para1325,2,,这是一个重大的成就，特别是在可能模型的空间无限大的情况下。
chap4_para1325,3,,但是，在证明完成前我们并不知道语句是被蕴含的！
chap4_para1325,4,,如果语句并不被蕴含怎么办？
chap4_para1325,5,,我们能证明吗？
chap4_para1325,6,,实际上，对于一阶逻辑，答案是否定的。
chap4_para1325,7,,我们的证明程序会一直运行，生成越来越深的嵌套项，但我们不知道它是陷入绝望的循环，还是就快要得出证明结果。
chap4_para1325,8,,这非常类似于图灵机的停机问题。
chap4_para1325,9,,"艾伦·图灵（Turing, 1936）和阿朗佐·丘奇（Church, 1936）分别以不同方式证明了这种情况的不可避免性。"
chap4_para1325,10,,一阶逻辑的蕴含问题是半可判定的，也就是，存在能判定所有蕴含的语句的算法，却不存在能够判定所有不蕴含的语句的算法。
chap4_para1326,1,,9.2　合一与一阶推断
chap4_para1327,1,,眼尖的读者可能已经注意到命题化方法生成了许多不必要的全称量化语句的实例。
chap4_para1327,2,,我们希望有一个方法，仅使用一条规则，以如下方式推理出解答了查询：给定贪婪的国王都是邪恶的这条规则，找出某个x使得x为国王且x是贪婪的，进而推断出这个x是邪恶的。
chap4_para1327,3,,更一般地说，如果存在某个置换使得每个蕴涵式前提的合取子句与知识库中的语句完全相同，那么我们就在应用后，断言蕴涵式的结论。
chap4_para1327,4,,这种情况下，置换能达到这一目的。
chap4_para1327,5,,假设现在我们不知道Greedy(John)，但我们知道所有人都是贪婪的：
chap4_para1329,1,,则我们仍然能够断定Evil(John)，因为我们知道约翰是国王（已给定）且约翰是贪婪的（因为每个人都是贪婪的）。
chap4_para1329,2,,为了能采取这种做法，我们需要找出一个置换，来同时取代蕴涵语句中的变量和知识库中待匹配语句中的变量。
chap4_para1329,3,,这种情况下，对蕴涵式的前提King(x)和Greedy(x)使用置换就会使它们完全相同。
chap4_para1329,4,,这样我们可以推断出蕴涵式的后件。
chap4_para133,1,"Description The belief states are depicted by circular sections, and the vacuum world states are depicted by square blocks with corresponding states labeled in them.",● 路径代价：这部分也很棘手。
chap4_para133,2,Five belief states are shown.,如果同一动作在不同状态下代价不同，那么在给定信念状态下执行动作的代价是几种不同值中的一种。
chap4_para133,3,"The transmission from one belief state to the next is labeled in the order Suck, Open square bracket ""A"", clean close square bracket, Right, and Open square bracket B, Dirty close square bracket.",（这导致了一类新的问题，我们将在习题4.MVAL中讨论。
chap4_para133,4,An arrow from the vacuum world state 1 of the first belief state points to the vacuum world state 5 of the second belief state.,）现在我们假定同一动作在所有状态下具有相同代价，因此动作代价可以直接从底层物理问题中转换。
chap4_para133,5,Two arrows from the vacuum world state 3 of the first belief state point to the vacuum world states 5 and 7 of the second belief state.,
chap4_para133,6,Arrows from the vacuum world states 5 and 7 of the second belief state point to the vacuum world state 5 and 7 of the third belief state.,
chap4_para133,7,Two arrows from the vacuum world state 5 of the third belief state point to the vacuum world state 2 and 6 of the fourth belief state.,
chap4_para133,8,"Four arrows from the vacuum world state 7 of the third belief state point to the vacuum world states 2, 6, 4, and 8 of the fourth belief state.",
chap4_para133,9,Arrows from the vacuum world state 2 and 6 of the fourth belief state together point to the vacuum world state 2 of the fifth belief state.,
chap4_para1330,1,,这种推断过程可以表述为一条单独的推断规则被称为一般化肯定前件[2]（generalized Modus Ponens）。
chap4_para1330,2,,对于原子语句pi、和q，存在置换使得对所有i有，有
chap4_para1332,1,,[2]　一般化肯定前件比肯定前件（7.5.1节）更一般化，因为已知的事实和蕴涵式的前提只需要与一个置换匹配，而不需要完全一致。
chap4_para1332,2,,但肯定前件允许任意语句作为前提，而非仅是原子语句的合取。
chap4_para1333,1,,这条规则有n+1个前提：n个原子语句和一个蕴涵式。
chap4_para1333,2,,结论是对后件q运用置换的结果。
chap4_para1333,3,,对我们的例子来说：
chap4_para1334,1,,是King(John)　　　　　　　　　　 p1是King(x)
chap4_para1335,1,,是Greedy(y)　　　　　　　　　　　p2是Greedy(x)
chap4_para1336,1,,是　　　　　　　　q是Evil(x)
chap4_para1337,1,,是Evil(John)
chap4_para1338,1,,很容易证明一般化肯定前件是可靠的推断规则。
chap4_para1338,2,,首先，我们观察到，对于任意语句p（假设其变量是全称量化的）和任意置换，
chap4_para1339,1,,根据全称量词实例化为真。
chap4_para1339,2,,特别地，它对于满足一般化肯定前件规则条件的为真。
chap4_para1339,3,,因此，我们可以从推断
chap4_para134,1,Figure 4.,图4-14为确定性无传感器真空吸尘器世界的可达信念状态空间。
chap4_para134,2,"14The reachable portion of the belief-state space for the deterministic, sensorless vacuum world.",在28 = 256种可能信念状态中只有12种可以到达。
chap4_para134,3,Each rectangular box corresponds to a single belief state.,
chap4_para134,4,"At any given point, the agent has a belief state but does not know which physical state it is in.",
chap4_para134,5,The initial belief state (complete ignorance) is the top center box.,
chap4_para1340,1,,并且，从蕴涵式我们可以推断
chap4_para1341,1,,现在，一般化肯定前件规则中的已被定义为对所有i使得，因此这两条语句中，第一条语句正好匹配第二条语句的前提。
chap4_para1341,2,,根据肯定前件规则可得。
chap4_para1342,1,,一般化肯定前件是肯定前件的提升版——它将肯定前件从基本（无变量的）命题逻辑提升到一阶逻辑。
chap4_para1342,2,,我们将在本章其余部分看到第7章中的前向链接、反向链接和归结算法的提升版。
chap4_para1342,3,,提升版推断规则相比于命题化的重要优势在于，提升版推断规则只需必要的置换就可以进行特定的推断。
chap4_para1344,1,,提升版推断规则需要找出使不同的逻辑表达式看起来相同的置换。
chap4_para1344,2,,这一过程被称作合并（unification），是所有一阶逻辑推断算法的重要组成部分。
chap4_para1344,3,,合一算法Unify接收两条语句作为输入，如果存在置换，则为它们返回一个合一子（unifier）（即这个置换）：
chap4_para1345,1,,我们用一个例子来展示Unify的工作方式。
chap4_para1345,2,,"假设有查询AskVar(Knows(John, x))：约翰认识谁？"
chap4_para1345,3,,"这条查询的答案可以通过找出知识库中所有与Knows(John, x)合一的语句来找到。"
chap4_para1345,4,,此处有与4条不同语句合并而来的结果，它们可能在知识库中：
chap4_para1346,1,,最后一条合一失败了，因为x不能同时取值为John和Elizabeth。
chap4_para1346,2,,"但我们知道Knows(x, Elizabeth)的意思是“所有人都认识伊丽莎白”，因此我们应该可以推断出约翰认识伊丽莎白。"
chap4_para1346,3,,之所以出现问题是因为两条语句恰好使用了相同的变量名x。
chap4_para1346,4,,对要合一的两条语句中的一条进行标准化分离（standardizing apart），也就是对其变量进行重命名来避免名称冲突，就可以解决这一问题。
chap4_para1346,5,,"例如，我们可以将Knows(x, Elizabeth)中的x重命名为（新变量名）x17而不会改变其含义。"
chap4_para1346,6,,现在就可以进行合一了：
chap4_para1347,1,,习题9.STAN深入探讨了标准化分离的必要性。
chap4_para1348,1,,还有一个麻烦：我们说过Unify应当返回使两个参数看起来相同的置换。
chap4_para1348,2,,但这样的合一子可能不止一种。
chap4_para1348,3,,例如，可能返回或者。
chap4_para1348,4,,第一个合一子的结果是，而第二个合一子的结果是。
chap4_para1348,5,,第二个结果可以在第一个结果的基础上置换得出，因此我们说第一个合一子比第二个更一般化，因为它对变量的值的限制更少。
chap4_para1349,1,,每一对可合一的表达式都有一个最一般合一子（most general unifier，MGU），在不考虑变量的重命名和置换的情况下，它是唯一的。
chap4_para1349,2,,例如，和被看作是等价的，和也是等价的。
chap4_para135,1,The preceding definitions enable the automatic construction of the belief-state problem formulation from the definition of the underlying physical problem.,图4-14　确定性无传感器真空吸尘器世界的信念状态空间的可达部分。
chap4_para135,2,"Once this is done, we can solve sensorless problems with any of the ordinary search algorithms of Chapter 3.",每个矩形框对应一个信念状态。
chap4_para135,3,,在任何给定点，智能体都有一个信念状态，但它不知道自己位于哪个物理状态。
chap4_para135,4,,初始信念状态（完全未知）位于最上面的中间方框
chap4_para1350,1,,图9-1展示了一个用于计算最一般合一子的算法。
chap4_para1350,2,,这一过程很简单：同时递归地交替探索两个表达式，并在这个过程中创建合一子，如果结构中的两个对应点不匹配则返回失败。
chap4_para1350,3,,这个过程中存在一个高代价的步骤：当匹配某变量和一个复合项时，必须检查这个变量是否出现在这一复合项中；如果是，则匹配失败，因为无法构建一致的合一子。
chap4_para1350,4,,例如，S(x)无法与S(S(x))合一。
chap4_para1350,5,,这种出现检验（occur check）使得整个算法的复杂性是待合一的表达式规模的二次方。
chap4_para1350,6,,包括许多逻辑编程系统在内的一些系统干脆取消了出现检验，将避免不可靠推断的责任推给用户。
chap4_para1350,7,,其他系统则使用具有线性复杂性的更为复杂的合一算法。
chap4_para1351,1,,图9-1　合一算法。
chap4_para1351,2,,参数x和y可以是任意表达式：一个常量或者一个变量，或复合表达式（如复合的语句或项），或一系列表达式。
chap4_para1351,3,,参数是一个置换，初始值为空置换，但会随着我们在输入、逐个比较表达式元素的递归中加入。
chap4_para1351,4,,"在如F(A, B)的复合表达式中，Op(x)函数提取函数符号F而Args(x)函数提取参数表(A,B)"
chap4_para1352,1,,9.2.2　存储与检索
chap4_para1353,1,,用于告知和询问知识库的Tell、Ask和AskVar函数的底层是更基本的Store和Fetch函数。
chap4_para1353,2,,Store(s)将语句s存入知识库，而Fetch(q)返回所有使查询q与知识库中某个语句合一的合一子。
chap4_para1353,3,,"之前我们用于解释合一的例题（找出能与Knows(John, x)合一的所有事实）就是Fetch的一个实例。"
chap4_para1354,1,,实现Store和Fetch最简单的方式就是在一个长列表中列出所有事实，并将每个查询与列表中的每个元素合一。
chap4_para1354,2,,这种过程很低效，却可以正常工作。
chap4_para1354,3,,本节余下部分将概述使检索更为高效的方法。
chap4_para1355,1,,我们可以通过确保仅对有一定合一可能的语句进行合一来使Fetch更高效。
chap4_para1355,2,,"例如，合一Knows(John, x)和Brother(Richard, John)就没什么意义。"
chap4_para1355,3,,我们可以通过索引知识库中的事实来避免这种合一。
chap4_para1355,4,,一种叫作谓词索引的简单方法将所有Knows开头的事实放入一个存储桶内，而将所有Brother开头的事实放入另一个存储桶内。
chap4_para1355,5,,而这些存储桶可以用哈希表存储，以提高效率。
chap4_para1356,1,,谓词索引对于谓词符号很多而每个符号只有少量子句的情形非常有用。
chap4_para1356,2,,但有时，一个谓词有许多子句。
chap4_para1356,3,,"例如，假设税务部门想用谓词Employs(x, y)掌握雇佣关系情况。"
chap4_para1356,4,,这就会形成一个非常大的存储桶，其中很可能有几百万雇主和几千万雇员。
chap4_para1356,5,,"用谓词索引方法回答如Employs(x, Richard)这样的查询就需要搜索整个存储桶。"
chap4_para1357,1,,对于这类特殊的查询，如果除谓词外再使用第二个参数一起索引事实的话，就可能改善效率。
chap4_para1357,2,,这种方法也许要用到组合的哈希表键值。
chap4_para1357,3,,这样我们只要用查询构造键值，就能精确地检索到能与查询合一的事实。
chap4_para1357,4,,"对于其他查询，如Employs(IBM, y)，我们可能需要结合谓词和第一个参数来索引事实。"
chap4_para1357,5,,因此，事实可以存储在多个索引键值之下，以便各种可能与之合一的查询迅速地找到它们。
chap4_para1358,1,,给定要存储的语句，可以对所有可能与之合一的查询构建索引。
chap4_para1358,2,,"对于Employs(IBM, Richard)这样的事实，查询为"
chap4_para1359,1,,"Employs(IBM, Richard)（IBM是否雇佣了理查？"
chap4_para1359,2,,）
chap4_para136,1,"In ordinary graph search, newly reached states are tested to see if they were previously reached. This works for belief states, too; for example, in Figure 4.14, the action sequence [Suck,Left,Suck] starting at the initial state reaches the same belief state as [Right,Left,Suck], namely, {5, 7}. Now, consider the belief state reached by [Left], namely, {1, 3, 5, 7}. Obviously, this is not identical to {5, 7}, but it is a superset. We can discard (prune) any such superset belief state. Why? Because a solution from {1, 3, 5, 7} must be a solution for each of the individual states 1, 3, 5, and 7, and thus it is a solution for any combination of these individual states, such as {5, 7}; therefore we don’t need to try to solve {1, 3, 5, 7}, we can concentrate on trying to solve the strictly easier belief state {5, 7}.",上述定义确保信念状态问题的形式化能够从底层物理问题的定义自动构建。
chap4_para136,2,,一旦完成，就可以用第3章的任何普通搜索算法求解无传感器问题。
chap4_para1360,1,,"Employs(x, Richard)（谁雇佣了理查？"
chap4_para1360,2,,）
chap4_para1361,1,,"Employs(IBM, y)（IBM雇佣了谁？"
chap4_para1361,2,,）
chap4_para1362,1,,"Employs(x, y)（谁雇佣了谁？"
chap4_para1362,2,,）
chap4_para1363,1,,这些查询构成了一个包容格（subsumption lattice），如图9-2a所示。
chap4_para1363,2,,包容格具有一些有趣的性质。
chap4_para1363,3,,格中任意节点的子节点都是对父节点进行一次置换而来，而任意两个节点的 “最高” 共同后代则是应用最一般合一子的结果。
chap4_para1363,4,,具有重复常量的语句的格略有不同，如图9-2b所示。
chap4_para1363,5,,尽管函数符号并未在图中体现，但它们也可以被纳入这种格结构中。
chap4_para1364,1,,"图9-2　（a）最低节点为Employs(IBM, Richard)的包容格。"
chap4_para1364,2,,"（b）语句Employs(John, John)的包容格"
chap4_para1365,1,,对于只有少量参数的谓词符号，为包容格中每一个点创建一个索引是一种很好的权衡。
chap4_para1365,2,,这增加了一点点存储时间，但节省了检索时间。
chap4_para1365,3,,然而，对于有n个参数的谓词，其包容格含有O(2n)个节点。
chap4_para1365,4,,如果允许函数符号的话，节点的数量同样是要存储的语句中项的数量的指数级。
chap4_para1365,5,,这就会导致大量的索引。
chap4_para1366,1,,我们不得不采用一些方法将索引的范围限制为可能被查询频繁使用的节点，否则我们花在创建索引上的时间可能比使用索引而节省的时间还多。
chap4_para1366,2,,我们可以采取固定的策略，譬如只维护键值由一个谓词和单个参数构成的索引。
chap4_para1366,3,,我们还可以习得一种自适应的策略，它能够创建索引来满足各类查询的要求。
chap4_para1366,4,,对于事实数量以十亿计的商用数据库，一直有对这一课题的大量的研究、技术开发和持续改进。
chap4_para1368,1,,在7.5节中我们展示了用于命题确定子句知识库的前向链接算法。
chap4_para1368,2,,本节我们拓展这个概念以涵盖一阶确定子句。
chap4_para1369,1,,当然，有一些逻辑语句无法被表述为确定子句，因此也无法用这种方法处理。
chap4_para1369,2,,但形如Antecedent ⇒ Consequent的规则足以涵盖许多有趣的真实世界系统。
chap4_para137,1,"Conversely, if {1, 3, 5, 7} has already been generated and found to be solvable, then any subset, such as {5, 7}, is guaranteed to be solvable. (If I have a solution that works when I’m very confused about what state I’m in, it will still work when I’m less confused.) This extra level of pruning may dramatically improve the efficiency of sensorless problem solving.",在一般的图搜索中，需要检测新到达的状态之前是否已经到达过。
chap4_para137,2,,"这也适用于信念状态；例如，在图4-14中，动作序列[Suck, Left, Suck]从初始状态出发，到达与序列[Right, Left, Suck]相同的信念状态，即，{5, 7}。"
chap4_para137,3,,"现在，考虑[Left]到达的信念状态，{1, 3, 5, 7}。"
chap4_para137,4,,"显然，这与{5, 7}不同，但它是{5, 7}的超集。"
chap4_para137,5,,我们可以抛弃（剪枝）任何一个这样的信念状态超集。
chap4_para137,6,,为什么？
chap4_para137,7,,"因为从{1, 3, 5, 7}出发的解一定也是任何单一状态1、3、5和7的解，因此，它也是这些单一状态任意组合的解，例如{5, 7}；因此我们没有必要试着求解{1, 3, 5, 7}，可以专注于求解更严格简单的信念状态{5, 7}。"
chap4_para1370,1,,9.3.1　一阶确定子句
chap4_para1371,1,,一阶确定子句是文字的析取式，其中必须有且仅有一个正文字。
chap4_para1371,2,,这意味着确定子句要么是原子的，要么是前件为正文字的合取、后件为单个正文字的蕴涵式。
chap4_para1371,3,,存在量词在此处不能使用，而全称量词则被隐式地表示：如果你在确定子句中看到x，就意味着有隐含的∀x量词。
chap4_para1371,4,,典型的一阶逻辑确定子句如下：
chap4_para1372,1,,但文字King(x)和Greedy(y)也可以看作确定子句。
chap4_para1372,2,,一阶文字可以含有变量，因此Greedy(y)被解释为“每个人都是贪婪的”（全称量词是隐含的）。
chap4_para1373,1,,我们用确定子句表示如下问题：
chap4_para1374,1,,法律规定，美国人将武器出售给敌对国家是犯罪行为。
chap4_para1374,2,,诺诺（Nono）国是美国的敌人，它拥有一些导弹，所有导弹都是韦斯特（West）上校出售给它的，而韦斯特上校是美国人。
chap4_para1375,1,,首先，我们用一阶确定子句表示这些事实。
chap4_para1376,1,,“……美国人将武器出售给敌对国家是犯罪行为”：
chap4_para1378,1,,表示“诺诺国……拥有一些导弹”的语句被转换为两个存在量化的确定子句，其中引入了新的常量M1：
chap4_para138,1,"Even with this improvement, however, sensorless problem-solving as we have described it is seldom feasible in practice. One issue is the vastness of the belief-state space—we saw in the previous chapter that often a search space of size N is too large, and now we have search spaces of size 2N. Furthermore, each element of the search space is a set of up to N elements. For large N, we won’t be able to represent even a single belief state without running out of memory space.","反过来，如果已经生成{1, 3, 5, 7}，并且发现它是可解的，那么它的任何子集，如{5, 7}，可以确保也是可解的。"
chap4_para138,2,,（如果我有一个解，它在我对自己处于何种状态“非常困惑”时都是有效的，那么在我“不那么困惑”时它仍然是有效的。
chap4_para138,3,,）这种额外剪枝可能会显著提高无传感器问题的求解效率。
chap4_para1381,1,,“所有导弹都是韦斯特上校出售给它的”：
chap4_para1383,1,,我们还需要知道导弹是武器：
chap4_para1385,1,,且我们必须知道美国的敌人是“敌对的”：
chap4_para1387,1,,“而韦斯特上校是美国人……”：
chap4_para1389,1,,“诺诺国是美国的敌人……”：
chap4_para139,1,"One solution is to represent the belief state by some more compact description. In English, we could say the agent knows “Nothing” in the initial state; after moving Left, we could say, “Not in the rightmost column,” and so on. Chapter 7 explains how to do this in a formal representation scheme.",然而，即使有这样的改进，我们所介绍的无传感器问题求解方法在实践中也几乎是不可行的。
chap4_para139,2,,一个问题是信念状态空间非常庞大——我们在第3章中看到过，一个大小为N的搜索空间已经过于庞大，而现在我们搜索空间的大小为2N。
chap4_para139,3,,此外，搜索空间中的每个元素都是一个不超过N个元素的集合。
chap4_para139,4,,对于较大的N，内存空间甚至不足以表示单个的信念状态。
chap4_para1391,1,,这个知识库恰好是一个数据日志（datalog）知识库：数据日志是由不含函数符号的一阶确定子句组成的语言。
chap4_para1391,2,,它能够表示由关系数据库生成的陈述类型，故得名。
chap4_para1391,3,,没有了函数符号使推断更容易。
chap4_para1392,1,,9.3.2　简单的前向链接算法
chap4_para1393,1,,图9-3展示了简单的前向链接推断算法。
chap4_para1393,2,,它从已知事实开始，触发所有前提被满足的规则，将结论添加到已知事实中。
chap4_para1393,3,,这一过程不断重复，直到查询得到回答（假设只需要一个回答）或没有新的事实被添加。
chap4_para1393,4,,注意，如果一个事实只是某个已知事实的重命名，也就是只有变量名字不同的语句，那它就不是一个“新”事实。
chap4_para1393,5,,"例如，Likes(x, IceCream)与Likes(y, IceCream)互为重命名。"
chap4_para1393,6,,它们都意味着相同的事情：“每个人都喜欢冰激凌”。
chap4_para1394,1,,图9-3　一个概念上很直观，但低效的前向链接算法。
chap4_para1394,2,,每次迭代，它都将那些用一步就可以从已经在KB中的蕴涵语句和原子语句推断出的原子语句添加到KB中。
chap4_para1394,3,,函数Standardize-Variables用先前未使用过的变量替换其所有的参数
chap4_para1395,1,,下面我们使用前面的犯罪问题来解释FOL-FC-Ask。
chap4_para1395,2,,可用于链接的蕴涵语句为式（9-3）、式（9-6）、式（9-7）和式（9-8）。
chap4_para1395,3,,这里需要两次迭代。
chap4_para1396,1,,● 第一次迭代中，规则式（9-3）的前提未满足。
chap4_para1397,1,,满足规则式（9-6），添加。
chap4_para1398,1,,满足规则式（9-7），添加。
chap4_para1399,1,,满足规则式（9-8），添加。
chap4_para14,1,Figure 4.,● 局部极大值（local maxima）：局部极大值是一个比它每个相邻状态都高但比全局极大值低的峰顶。
chap4_para14,2,"2The hill-climbing search algorithm, which is the most basic local search technique.",爬山法到达局部极大值附近就会被向上拉向峰顶，但随后将困在局部极大值处无路可走。
chap4_para14,3,At each step the current node is replaced by the best neighbor.,图4-1示意性地说明了这一问题。
chap4_para14,4,,更具体地说，图4-3a中的状态是一个局部极大值（即代价h的局部极小值）；不管移动哪个皇后都会让情况变得更差。
chap4_para140,1,"Another approach is to avoid the standard search algorithms, which treat belief states as black boxes just like any other problem state.",一种解决方案是用更紧凑的描述来表示信念状态。
chap4_para140,2,"Instead, we can look inside the belief states and develop incremental belief-state search algorithms that build up the solution one physical state at a time.",例如，在英语中，我们可以用“Nothing”表示初始状态；我们可以用“Not in the rightmost column”表示执行Left动作后的信念状态，等等。
chap4_para140,3,"For example, in the sensorless vacuum world, the initial belief state is {1, 2, 3, 4, 5, 6, 7, 8}, and we have to find an action sequence that works in all 8 states.",第7章介绍了如何在形式化表示模式中实现上述表示。
chap4_para140,4,"We can do this by first finding a solution that works for state 1; then we check if it works for state 2; if not, go back and find a different solution for state 1, and so on.",
chap4_para1400,1,,● 第二次迭代中，规则式（9-3）被满足，添加推断。
chap4_para1401,1,,图9-4展示了所生成的证明树。
chap4_para1401,2,,注意，此时已不可能再产生新的推断，因为每个可以用前向链接得出的语句已经显式地被纳入知识库。
chap4_para1401,3,,这种知识库被称为推断过程的不动点。
chap4_para1401,4,,对一阶确定子句使用前向链接得到的不动点与命题前向链接中的类似（7.5.4节），主要的区别在于一阶逻辑不动点可以含有全称量化的原子语句。
chap4_para1402,1,,FOL-FC-Ask很容易分析。
chap4_para1402,2,,首先，它是可靠的，因为每个推断都是对一般化肯定前件的应用，而一般化肯定前件是可靠的。
chap4_para1402,3,,其次，它对于确定子句知识库是完备的，也就是说，它能够对所有答案蕴涵在确定子句知识库中的查询做出回答。
chap4_para1403,1,,对于不含有函数符号的数据日志知识库，完备性的证明相当简单。
chap4_para1403,2,,先对可能被添加的事实进行计数，这决定着迭代的次数。
chap4_para1403,3,,令k为最大元数（参数的数量），p为谓词数量，n为常量符号的数量。
chap4_para1403,4,,显然，基本事实的数量不可能超过pnk个，因此在这么多次迭代后，算法必然已经到达了不动点。
chap4_para1403,5,,然后我们就可以得出论据，它非常类似于命题前向链接完备性的证明。
chap4_para1403,6,,（见7.5.4节。
chap4_para1403,7,,）如何从命题逻辑完备性转进到一阶逻辑完备性的细节在9.5节介绍归结算法时给出。
chap4_para1404,1,,图9-4　前向链接算法为犯罪问题生成的证明树。
chap4_para1404,2,,最早的事实出现在最下层，第一次迭代推断得到的事实在中间层，而第二次迭代推断得出的事实在最顶层
chap4_para1405,1,,对于含有函数符号的一般确定子句，FOL-FC-Ask会生成无穷多的新事实，因此我们需要非常小心。
chap4_para1405,2,,在查询语句q的答案被蕴含的情形下，我们只能凭借埃尔布朗定理（9.1.1节）来证实算法将找到证明。
chap4_para1405,3,,（见9.5节的归结情形。
chap4_para1405,4,,）如果查询没有答案，算法在某些情况下就无法终止。
chap4_para1405,5,,例如，如果知识库含有皮亚诺公理
chap4_para1406,1,,则前向链接将添加NatNum(S(0))、NatNum(S(S(0)))、NatNum(S(S(S(0))))等。
chap4_para1406,2,,一般来说，这个问题是无法避免的。
chap4_para1406,3,,如我们在常规一阶逻辑中所见，确定子句的蕴含是半可判定的。
chap4_para1407,1,,9.3.3　高效前向链接
chap4_para1408,1,,图9-3所示的前向链接算法为了便于理解而牺牲了效率。
chap4_para1408,2,,低效的原因有3个。
chap4_para1408,3,,首先，算法的内层循环试图对知识库中的每一条规则和每一条事实进行匹配。
chap4_para1408,4,,其次，算法每次迭代都检查所有规则，尽管知识库只有少量更新。
chap4_para1408,5,,最后，算法会生成许多与目标无关的事实。
chap4_para1408,6,,我们依次解决这些问题。
chap4_para1409,1,,1. 将规则与已知事实进行匹配
chap4_para141,1,"Just as an AND–OR search has to find a solution for every branch at an AND node, this algorithm has to find a solution for every state in the belief state; the difference is that AND–OR search can find a different solution for each branch, whereas an incremental belief-state search has to find one solution that works for all the states.",另一种方法是避免使用标准搜索算法，它们将信念状态看作和任何其他问题状态一样的黑盒。
chap4_para141,2,,然而，我们可以选择查看信念状态内部，并设计增量信念状态搜索（incremental belief-state search）算法，即，每次只为一个物理状态建立解。
chap4_para141,3,,"例如，在无传感器真空吸尘器世界中，初始信念状态为{1, 2, 3, 4, 5, 6, 7, 8}，我们必须找到一个在所有8种状态下都有效的动作序列。"
chap4_para141,4,,我们可以先找到状态1的解；然后检查它对于状态2是否有效；如果无效，则回溯寻找状态1的另一个解，以此类推。
chap4_para1410,1,,将规则的前提与知识库中的事实进行匹配的问题似乎很简单。
chap4_para1410,2,,例如，假设我们要应用规则
chap4_para1411,1,,则我们需要找出所有与匹配的事实；被恰当索引的知识库可以在常量时间内对每个事实完成这项操作。
chap4_para1411,2,,现在考虑规则
chap4_para1412,1,,同样，我们可以在常量时间内找出诺诺国拥有的所有对象，然后对于每个对象，我们可以检查它是否是导弹。
chap4_para1412,2,,但如果知识库含有许多诺诺国拥有的对象而其中只有极少数是导弹，先找出所有的导弹然后再检查它们是否被诺诺国所拥有就是更好的操作。
chap4_para1412,3,,这就是合取子句排序（conjunct ordering）问题：求解规则前提的合取子句的排序，使总代价最小。
chap4_para1412,4,,实际上找出最优排序是NP困难问题，不过可以使用很好的启发式算法求解。
chap4_para1412,5,,例如，在第6章用于CSP的最小剩余值（MRV）启发式算法会建议，如果导弹的数量比诺诺国拥有的对象数量少，就对合取子句进行排序先查找导弹。
chap4_para1413,1,,实际上，模式匹配与约束满足的联系十分紧密。
chap4_para1413,2,,我们可以将每个合取子句看作一条对它所包含的变量的约束，例如，是x的一元约束。
chap4_para1413,3,,拓展这种想法，就能将所有有限域CSP表示为单个确定子句和相关的基本事实。
chap4_para1413,4,,考虑图6-1中的地图着色问题，这里显示于图9-5a。
chap4_para1413,5,,图9-5b给出了其等价的单个确定子句形式。
chap4_para1413,6,,很明显，只有CSP有解，才可以推断出结论Colorable()。
chap4_para1413,7,,因为3-SAT问题是一般CSP的一个特例，我们可以断定，将确定子句与事实集进行匹配的问题是NP困难问题。
chap4_para1414,1,,图9-5　（a）用于为澳大利亚地图着色的约束图。
chap4_para1414,2,,（b）用单个确定子句表示的地图着色CSP。
chap4_para1414,3,,每个地图区域都用变量表示，变量的值可以为常量red、green、blue（使用Diff声明）
chap4_para1415,1,,前向链接的内层循环含有NP困难的匹配问题看起来相当令人沮丧。
chap4_para1415,2,,但还是有3种方法能令我们振奋起来。
chap4_para1416,1,,● 我们可以发现，真实世界知识库的大部分规则是简洁的（如同犯罪例子中所示），而不是繁复的（如图9-5所示的CSP形式化）。
chap4_para1416,2,,在数据库世界中，很常用的假设是规则的长短和谓词的元数都限于一个常数，只需关心数据复杂性的问题，也就是，形式为知识库中基本事实数量的函数的推断复杂性。
chap4_para1416,3,,很容易证明前向链接的数据复杂性是多项式级别的，而非指数量级的。
chap4_para1417,1,,● 我们可以考虑使匹配变得高效的规则的子类别。
chap4_para1417,2,,本质上，所有数据日志子句都可以视作定义一个CSP，因此，如果对应的CSP容易求解，则匹配也容易求解。
chap4_para1417,3,,第6章描述了几种易解的CSP。
chap4_para1417,4,,例如，如果约束图（节点为变量，边为约束的图）构成一棵树，那么CSP就可以在线性时间内求解。
chap4_para1417,5,,完全相同的情况对匹配也成立。
chap4_para1417,6,,例如，如果我们从图9-5的地图中去掉南澳大利亚州SA，得到的子句就是：
chap4_para1418,1,,它对应于6.5.1节的图6-12所示的简化CSP。
chap4_para1418,2,,用于求解树状结构CSP的算法可以直接用来求解规则匹配问题。
chap4_para1419,1,,● 我们可以试着消除前向链接算法中冗余的规则匹配尝试，如下一部分内容所述。
chap4_para142,1,"The main advantage of the incremental approach is that it is typically able to detect failure quickly—when a belief state is unsolvable, it is usually the case that a small subset of the belief state, consisting of the first few states examined, is also unsolvable. In some cases, this leads to a speedup proportional to the size of the belief states, which may themselves be as large as the physical state space itself.",正如与或搜索必须为与节点上的每个分支找到解一样，这一算法也必须为信念状态下的每个物理状态找到解；区别在于与或搜索可以为每个分支找到不同的解，而增量信念状态搜索必须找到一个对所有状态都有效的解。
chap4_para1421,1,,我们先前在解释前向链接算法在犯罪问题示例中的工作方式时作弊了。
chap4_para1421,2,,具体而言，我们省略了由图9-3所示的算法完成的规则匹配。
chap4_para1421,3,,例如，在第二次迭代中，规则
chap4_para1422,1,,（第二次）匹配到了Missile(M1)，当然地，结论Weapon(M1)已知，因此什么都没发生。
chap4_para1422,2,,如果我们有如下的观察：所有在第t次迭代中推断出的新事实必然是从至少一个在第t−1次迭代中推断出的新事实推得的，就可以避免这种多余的规则匹配。
chap4_para1422,3,,这是正确的，因为所有不需要来自第t−1次迭代的新事实的推断，肯定在第t−1次迭代时就已经得出了。
chap4_para1423,1,,这一观察结果自然地引出增量前向链接算法，其中在第t次迭代时，我们仅检查前提含有合取子句pi的规则，pi能够与在第t−1次迭代新产生的事实p'i合一。
chap4_para1423,2,,规则匹配步骤随后固定pi来与p'i合一，但允许规则的其他合取子句与任意先前迭代产生的事实匹配。
chap4_para1423,3,,这个算法在每次迭代中生成的事实与图9-3所示的算法完全一致，但高效得多。
chap4_para1424,1,,如果有合适的索引，就很容易找到所有能够由任意已知事实触发的规则。
chap4_para1424,2,,很多真实系统在“更新”模式下运作，也就是每次收到Tell时都以前向链接作为回应。
chap4_para1424,3,,推断在规则集上逐级运行，直到达到不动点。
chap4_para1424,4,,这一过程对下一个新事实重复执行。
chap4_para1425,1,,一般来说，知识库中只有少部分规则是由新添加的已知事实而触发的。
chap4_para1425,2,,这就意味着在反复构建某些前提不满足的部分匹配时产生了大量冗余的工作。
chap4_para1425,3,,我们的犯罪问题示例由于太简单而无法很好地展示这种情形，但注意，第一次迭代中构建了一个规则
chap4_para1426,1,,和事实American(West)的部分匹配。
chap4_para1426,2,,这一部分匹配被丢弃，并在第二次迭代中重新构建（当规则匹配成功时）。
chap4_para1426,3,,比较好的做法是，保留部分匹配，并在新事实到来时逐步补全部分匹配而非直接丢弃它们。
chap4_para1427,1,,Rete算法（Rete algorithm）[3]首先求解了这一问题。
chap4_para1427,2,,算法对知识库中的规则集进行预处理来构建一个数据流网络，其中每个节点是规则前提中的一个文字。
chap4_para1427,3,,变量绑定在网络中流动，并在无法匹配某个文字时被过滤掉。
chap4_para1427,4,,如果一条规则中的两个文字共用一个变量，例如犯罪示例中的，则每个文字的绑定会被一个相等节点过滤。
chap4_para1427,5,,当变量绑定到达一个n元文字（如）的节点时，可能需要在过程继续运行前等待其他变量绑定的建立。
chap4_para1427,6,,在任意给定时刻，Rete网络的状态都会捕获所有规则的部分匹配，避免了大量的重新计算。
chap4_para1429,1,,[3]　Rete是拉丁语“网”的意思。
chap4_para1429,2,,它与“条约”（treaty）的英语发音押韵。
chap4_para143,1,4.,增量方法的主要优点是，它通常能够快速检测出失败——当一个信念状态无解时，通常情况下，它的子集（包含最先检测的几个状态）也是无解的。
chap4_para143,2,4.,在某些情况下，这将导致与信念状态规模成正比的加速，信念状态本身可能就和物理状态空间一样大。
chap4_para143,3,2Searching in partially observable environments,
chap4_para1430,1,,Rete网络和以它为基础的各种改进已经成为了所谓的产生式系统（production system）的关键组成部分。
chap4_para1430,2,,产生式系统是最早被大量使用的前向链接系统之一。
chap4_para1430,3,,"[4]Xcon系统（最初被称为R1；McDermott, 1982）就是用产生式系统的结构构建的。"
chap4_para1430,4,,Xcon含有用于为DEC公司的客户设计计算机部件规格的数千条规则。
chap4_para1430,5,,它是最早在专家系统这一新兴领域取得显著商业成功的系统之一。
chap4_para1430,6,,许多其他类似的系统都以相同的核心技术构建，这一技术已经在通用语言Ops-5中实现。
chap4_para1432,1,,[4]　“产生式系统”中的“产生式”表示一种条件-行动规则。
chap4_para1433,1,,产生式系统在认知架构（cognitive architecture）中也很流行。
chap4_para1433,2,,"认知架构也就是人类推理的模型，如ACT（Anderson, 1983）和Soar（Laird et al., 1987）。"
chap4_para1433,3,,在这些系统中，系统的“工作记忆”对人类的短期记忆进行建模，而产生式则是长期记忆的一部分。
chap4_para1433,4,,在每个操作周期中，产生式被匹配到事实的工作记忆。
chap4_para1433,5,,条件得到满足的产生式可以在工作记忆中添加或删除事实。
chap4_para1433,6,,相比于数据库中的典型情形，产生式系统往往有很多规则，却只有很少的事实。
chap4_para1433,7,,运用适当的优化匹配技术，系统可以在有几百万条规则的情况下实时运行。
chap4_para1435,1,,另一个低效的原因是前向链接允许所有基于已知事实的推断，即使它们与目标并不相关。
chap4_para1435,2,,在犯罪示例中，没有能够得出不相关结论的规则。
chap4_para1435,3,,但如果存在很多描述美国人饮食习惯，或导弹的部件及价格的规则，那么FOL-FC-Ask就会产生不相关结论。
chap4_para1436,1,,一种避免得到不相关结论的方法是使用反向链接，在9.4节中将进行讨论。
chap4_para1436,2,,另一种方法是将前向链接限制到特意挑选的规则子集上，如PL-FC-Entails?所示（7.5.4节）。
chap4_para1436,3,,第三种方法已经出现在演绎数据库（deductive database）中，这是一种大规模数据库，类似于关系数据库，但使用前向链接而非SQL查询作为标准推断工具。
chap4_para1436,4,,它的基本原理是使用目标信息重写规则集，以便在前向推理中只考虑相关的变量绑定，也就是那些属于所谓的魔法集（magic set）的绑定。
chap4_para1436,5,,例如，如果目标是Criminal(West)，能得出Criminal(x)的规则就会被重写，以便包含附加的、限制x的值的合取子句：
chap4_para1437,1,,事实Magic(West)也被加入知识库中。
chap4_para1437,2,,这样，即使知识库含有关于几百万美国人的事实，也只有韦斯特上校会在前向链接中被考虑到。
chap4_para1437,3,,定义魔法集、重写知识库的完整过程过于复杂，在此不详细描述，但其基本概念是从目标进行某种“通用”的反向推断，以此来找出哪些变量绑定需要被约束。
chap4_para1437,4,,因此，魔法集方法可以被认为是一种前向推断和反向预处理的混合。
chap4_para1439,1,,另一种主要的逻辑推断算法对确定子句使用反向链接。
chap4_para1439,2,,这些算法从目标开始反向运行，链接规则以找出支持证明的已知事实。
chap4_para144,1,Many problems cannot be solved without sensing.,4.4.2　部分可观测环境中的搜索
chap4_para144,2,"For example, the sensorless 8-puzzle is impossible.",
chap4_para144,3,"On the other hand, a little bit of sensing can go a long way: we can solve 8- puzzles if we can see just the upper-left corner square.",
chap4_para144,4,The solution involves moving each tile in turn into the observable square and keeping track of its location from then on.,
chap4_para1440,1,,9.4.1　反向链接算法
chap4_para1441,1,,图9-6展示了用于确定子句的反向链接算法。
chap4_para1441,2,,"如果知识库含有形如lhs ⇒ goal的规则，就能证得FOL-BC-Ask(KB, goal)，其中lhs（左手侧）是合取子句列表。"
chap4_para1441,3,,原子事实，如Americal(West)被视为lhs为空列表的子句。
chap4_para1441,4,,现在，含有变量的查询可以用多种方式证明。
chap4_para1441,5,,例如，查询Person(x)可以用置换和证明。
chap4_para1441,6,,因此，我们将FOL-BC-Ask实现为生成器，也就是能多次返回的函数，每次返回值给出一个可能的结果（见附录B）。
chap4_para1442,1,,反向链接是一种与或搜索——或的部分是由于目标查询可以用知识库中的任意规则证明，而与的部分是由于所有lhs中的合取子句都必须被证明。
chap4_para1442,2,,FOL-BC-Or的工作方式是抓取所有可能与目标合一的子句，将子句中的变量标准化为全新变量，如果子句的rhs确实能够与目标合一，就使用FOL-BC-And证明lhs中的所有合取子句。
chap4_para1442,3,,这个函数的工作方式是轮流证明合取子句，并记录运行中积累的所有置换。
chap4_para1442,4,,图9-7是从式（9-3）到式（9-10）推导Criminal(West)的证明树。
chap4_para1443,1,,如前所述，反向链接明显是深度优先搜索算法。
chap4_para1443,2,,这意味着其空间需求与证明规模呈线性关系，也意味着反向链接（不同于前向链接）受制于重复状态和不完备性。
chap4_para1443,3,,尽管有这些局限，事实表明反向链接在逻辑编程语言中仍然是非常流行且有效的。
chap4_para1444,1,,图9-6　用于一阶知识库的简单的反向链接算法
chap4_para1445,1,,图9-7　使用反向链接构建证明树来证明韦斯特是有罪的。
chap4_para1445,2,,树的阅读方式是深度优先，从左至右。
chap4_para1445,3,,要证明Criminal(West)，我们必须先证明其下方的4个合取子句。
chap4_para1445,4,,其中一些在知识库中，而另一些需要进一步反向链接。
chap4_para1445,5,,每次成功置换的绑定显示在对应的子目标旁边。
chap4_para1445,6,,注意，只要合取式中的一个子目标达成，其置换就被用于接下来的子目标。
chap4_para1445,7,,这样，当FOL-BC-Ask运行到最后一个合取子句，即最初为Hostile(z)的子句时，z就已经被绑定为Nono
chap4_para1446,1,,9.4.2　逻辑编程
chap4_para1447,1,,逻辑编程是一种接近第7章所述的陈述性理念的技术，即系统应当通过用形式语言表示的知识来构建，而问题应当通过在这些知识上运行推断过程来求解。
chap4_para1447,2,,这项理念在罗伯特·科瓦尔斯基（Robert Kowalski）的等式中得以总结：
chap4_para1449,1,,Prolog是最为广泛使用的逻辑编程语言。
chap4_para1449,2,,"它主要被用作快速原型语言，也用于像编写编译器（Van Roy, 1990）、自然语言分析（Pereira and Warren, 1980）这样的符号处理任务。"
chap4_para1449,3,,许多用于法律、医疗、财经和其他领域的专家系统都使用Prolog编写。
chap4_para145,1,"For a partially observable problem, the problem specification will specify a PERCEPT(s) function that returns the percept received by the agent in a given state.",对许多问题来说，没有感知就无法求解。
chap4_para145,2,"If sensing is nondeterministic, then we can use a PERCEPTS function that returns a set of possible percepts.",例如，求解无传感器8数码问题是不可能的。
chap4_para145,3,"For fully observable problems, PERCEPT(s) = s for every state s, and for sensorless problems PERCEPT(s) = null.",但是，一点点感知可能就有很大帮助：如果我们能够看到左上角的方格，就能求解8数码问题。
chap4_para145,4,,解包括依次将每个滑片移动到可观测的方格中，并从那时起记录该滑片的位置。
chap4_para1450,1,,Prolog程序是确定子句集，但记法与标准的一阶逻辑有所不同。
chap4_para1450,2,,Prolog使用大写字母表示变量，小写字母则表示常量——与逻辑中的约定相反。
chap4_para1450,3,,"确定子句中的合取子句用逗号区分，而确定子句的书写也与我们所习惯的“相反”：不同于写为，在Prolog中我们将其写作C :- A, B。"
chap4_para1450,4,,这里有一个典型的例子：
chap4_para1451,1,,"criminal(X) :- american(X), weapon(Y), sells(X,Y,Z), hostile(Z)"
chap4_para1452,1,,在Prolog中，记法[E|L]表示第一个元素为E其余部分为L的列表。
chap4_para1452,2,,"下面是append(X,Y,Z)的Prolog程序，如果列表Z是列表Y追加到X后的结果，则程序返回成功："
chap4_para1453,1,,"append([],Y,Y)"
chap4_para1454,1,,"append([A|X],Y,[A|Z]) :- append(X,Y,Z)"
chap4_para1455,1,,我们可以将这些子句用自然语言描述为：（1）将列表Y追加到空列表后得到相同的列表Y；（2）在给定Z是Y追加到X后的结果的情况下，[A|Z]是[Y]追加到[A|X]后的结果。
chap4_para1455,2,,在大多数高级语言中我们可以写出类似的递归函数来描述如何追加列表，但实际上Prolog的定义更为强大，因为它描述了3个参数间的关系，而非用两个参数算出的函数。
chap4_para1455,3,,"例如，我们可以提出查询append(X,Y,[1,2,3])：哪两个列表追加能产生[1,2,3]？"
chap4_para1455,4,,Prolog为我们返回的解是
chap4_para1456,1,,"X=[] 　Y=[1,2,3];"
chap4_para1457,1,,"X=[1] 　Y=[2,3];"
chap4_para1458,1,,"X=[1,2] 　Y=[3];"
chap4_para1459,1,,"X=[1,2,3]　Y=[];"
chap4_para146,1,"Consider a local-sensing vacuum world, in which the agent has a position sensor that yields the percept L in the left square, and R in the right square, and a dirt sensor that yields Dirty when the current square is dirty and Clean when it is clean.",对于部分可观测问题，问题形式化将定义一个Percept(s)函数，它返回智能体在给定状态下接收到的感知。
chap4_para146,2,"Thus, the PERCEPT in state 1 is [L, Dirty].",如果感知是非确定性的，那么我们可以使用Percepts函数返回可能感知的集合。
chap4_para146,3,"With partial observability, it will usually be the case that several states produce the same percept; state 3 will also produce [L, Dirty].",对于完全可观测问题，每个状态s下，Percept(s) = s，对于无传感器问题，Percept(s)= null。
chap4_para146,4,"Hence, given this initial percept, the initial belief state will be {1, 3}.",
chap4_para146,5,"We can think of the transition model between belief states for partially observable problems as occurring in three stages, as shown in Figure 4.",
chap4_para146,6,15:,
chap4_para1460,1,,Prolog程序的执行是通过深度优先的反向链接完成的，其中确定子句以其在知识库中的顺序进行尝试。
chap4_para1460,2,,Prolog的设计代表着陈述性与执行效率的妥协。
chap4_para1460,3,,Prolog的一些方面不属于标准的逻辑推断。
chap4_para1461,1,,● Prolog使用8.2.8节所述的数据库语义而非一阶语义，这可以明显地从它对等词和否定的处理看出（见9.4.4节）。
chap4_para1462,1,,● 有一系列用于算术的内置函数。
chap4_para1462,2,,使用这些函数符号的文字是通过执行代码而非进行深入推断“证得”的。
chap4_para1462,3,,例如，目标“X is 4+3”当X被绑定为7时达成。
chap4_para1462,4,,而目标“5 is X+Y”则无法达成，因为内置函数无法求解任意等式。
chap4_para1463,1,,● 存在执行时会产生副作用的内置谓词。
chap4_para1463,2,,这包括输入-输出谓词和用于修改知识库的assert/retract谓词。
chap4_para1463,3,,这类谓词在逻辑中没有对应物，会导致令人困惑的结果，例如，如果事实是在证明树的一个最终会失败的分支中断言的。
chap4_para1464,1,,● 出现检验在Prolog的合一算法中被略去。
chap4_para1464,2,,这就意味着会产生一些不可靠的推断。
chap4_para1464,3,,这在实际中几乎完全不会发生。
chap4_para1465,1,,● Prolog使用深度优先反向链接搜索，并且不检查无限递归。
chap4_para1465,2,,在恰当使用的情况下，这种做法使得编程语言可用且高效。
chap4_para1465,3,,但这也意味着某些看起来是有效逻辑的程序将无法终止。
chap4_para1466,1,,9.4.3　冗余推断和无限循环
chap4_para1467,1,,我们现在来看Prolog的致命弱点：深度优先搜索和包含了重复状态和无限路径的搜索树之间的错配。
chap4_para1467,2,,考虑如下的逻辑程序，这一程序判断有向图中的两点是否存在路径：
chap4_para1468,1,,"path(X,Z) :- link(X,Z)"
chap4_para1469,1,,"path(X,Z) :- path(X,Y), link(Y,Z)"
chap4_para147,1,"Description The robot is placed in a maze-like environment with dark shaded and white blocks. The path formed by the white block is where the robot has to move. The dark shaded blocks depict an obstacle. In the percept bit value, the 1s indicate the obstacles and 0s indicate the open path. The four bits depict the north, east, west, and south directions. The robot is depicted by two concentric bold circles. Part (“a”): Possible locations of the robot after E subscript 1 BaseLine equals 1011. The possible positions of the robot are shown at four blocks. Part (b): Possible locations of the robot after E subscript 1 BaseLine equals 1011, E subscript 2 BaseLine equals 1010. One possible position of the robot is depicted on the board.",考虑一个局部感知真空吸尘器世界，智能体拥有一个位置传感器（在左侧方格中生成感知L，右侧方格中生成感知R）和一个灰尘传感器（当前方格内有灰尘时生成感知Dirty，否则生成Clean）。
chap4_para147,2,,"因此，状态1的Percept为[L, Dirty]。"
chap4_para147,3,,"对于部分可观测的情况，通常会存在几个状态产生相同感知的情况；状态3也会产生[L, Dirty]。"
chap4_para147,4,,"因此，给定这一初始感知，初始信念状态将为{1,3}。"
chap4_para147,5,,我们可以将部分可观测问题信念状态之间的转移模型分为3个阶段，如图4-15所示。
chap4_para1470,1,,"事实link(a,b)和link(b,c)描述的一个简单的三节点图如图9-8a所示。"
chap4_para1470,2,,"在这个程序中，查询path(a,c)生成了图9-9a所示的证明树。"
chap4_para1470,3,,与此同时，如果我们按顺序写出如下子句：
chap4_para1473,1,,则Prolog会进入图9-9b所示的无限路径。
chap4_para1473,2,,因此，作为一个确定子句——甚至对于本例所示的数据日志程序——的定理证明器，Prolog是不完备的，因为对于某些知识库，它无法证明其所蕴含的语句。
chap4_para1473,3,,"注意，前向链接并没有这种问题：只要path(a,b)、path(b,c)和path(a,c)被推得，前向链接就会停止。"
chap4_para1474,1,,图9-8　（a）找出从A到C的路径会导致Prolog陷入死循环；（b）每个节点连接到下一层中两个随机后继的图。
chap4_para1474,2,,找到从A1到J4的路径需要877次推断
chap4_para1475,1,,图9-9　（a）证明从A到C存在一条路径。
chap4_para1475,2,,（b）子句顺序“错误”时生成的无限证明树
chap4_para1476,1,,深度优先反向链接也有冗余计算的问题。
chap4_para1476,2,,例如，当查找图9-8b中从A1到J4的路径时，Prolog进行了877次推断，大部分推断用于找出到达无法达成目标的节点的所有可能路径。
chap4_para1476,3,,这类似于第3章所述的重复状态问题。
chap4_para1476,4,,推断的总量随着生成的基本事实的数量增加而呈指数增长。
chap4_para1476,5,,"如果我们使用前向链接而非反向链接，连接到n个节点的path(X,Y)数量至多为n2个。"
chap4_para1476,6,,对于图9-8b所示的问题则仅需要62次推断。
chap4_para1477,1,,图搜索问题中的前向链接是动态规划（dynamic programming）的一个实例，其子问题的解是由更小的子问题的解递增构建的，通过缓存更小的子问题来避免重复计算。
chap4_para1477,2,,我们可以在反向链接中达到类似的效果，只需要将大目标分解为小目标而非从小目标构建大目标。
chap4_para1478,1,,不论如何，存储中间结果以避免重复计算是问题的关键。
chap4_para1478,2,,这是表格化逻辑编程（tabled logic programming）系统所采取的方法，它使用高效的存储和检索机制。
chap4_para1478,3,,表格化逻辑编程结合了反向链接的目标导向性以及前向链接动态规划的高效性。
chap4_para1478,4,,它对于数据日志知识库是完备的，这意味着程序员不太需要为死循环而担忧。
chap4_para1478,5,,"（使用类似father(X,Y)这种指代可能有无穷多对象的语句时，它仍然可能会进入死循环。"
chap4_para1478,6,,）
chap4_para1479,1,,9.4.4　Prolog的数据库语义
chap4_para148,1,Figure 4.,"● 预测（prediction）阶段与无传感器问题相同，计算由动作所导致的信念状态，Result(b, a)。"
chap4_para148,2,15Two examples of transitions in local-sensing vacuum worlds.,"为了强调这是一个预测，我们将其记为bˆ = Result(b, a)，其中b上方的“hat”表示“估计值”，我们还可以使用Predict(b, a)代替Result(b, a)。"
chap4_para148,3,"(a) In the deterministic world, Right is applied in the initial belief state, resulting in a new predicted belief state with two possible physical states; for those states, the possible percepts are [R, Dirty] and [R, Clean], leading to two belief states, each of which is a singleton.",
chap4_para148,4,"(b) In the slippery world, Right is applied in the initial belief state, giving a new belief state with four physical states; for those states, the possible percepts are [L, Dirty], [R, Dirty], and [R, Clean], leading to three belief states as shown.",
chap4_para1480,1,,Prolog使用8.2.8节讨论过的数据库语义。
chap4_para1480,2,,唯一名称假设表明每个Prolog常量和每个基本项都仅指代唯一的对象，而封闭世界假设表明为真的语句只能是知识库蕴含的语句。
chap4_para1480,3,,Prolog无法断言某条语句是假的。
chap4_para1480,4,,这使得Prolog的表达能力比一阶逻辑差，但这正是使Prolog更为高效简洁的原因之一。
chap4_para1480,5,,考虑如下关于一些课程的断言：
chap4_para1482,1,,在唯一名称假设下，CS和EE是不同的（101、102和106也不同），因此这表示有4门不同的课程。
chap4_para1482,2,,在封闭世界假设下，不存在其他课程，因此只有4门课程。
chap4_para1482,3,,但如果它是一阶逻辑（FOL）的断言，而非数据库语义的话，我们只能说课程的数量介于1到无穷之间。
chap4_para1482,4,,这是由于FOL中的断言并不否认存在未提及的课程的可能性，也不表明提到的课程各自不同。
chap4_para1482,5,,如果我们想将式（9-11）翻译成FOL，我们就会得到如下语句：
chap4_para1484,1,,这就是对式（9-11）的完备化（completion）。
chap4_para1484,2,,在FOL中它表示最多有4门课程。
chap4_para1484,3,,要用FOL表示最少有4门课程的概念，我们需要写出等词的完备化：
chap4_para1485,1,,完备化对于理解数据库语义是有益的，但为了实用，如果你的问题可以用数据库语义描述，则用Prolog和其他数据库语义系统进行推理会更加高效，而不是翻译为FOL后用完备的定理证明器推理。
chap4_para1486,1,,9.4.5　约束逻辑编程
chap4_para1487,1,,在对前向链接的讨论中（9.3节），我们展示了约束满足问题（CSP）是如何被编码为确定子句的。
chap4_para1487,2,,标准的Prolog求解此类问题的方法与图6.5所示的回溯算法完全一样。
chap4_para1488,1,,由于回溯算法枚举变量的域，因而只能用于有限域CSP。
chap4_para1488,2,,用Prolog的方式来说，如果目标含有未绑定变量的问题，其解的数量必须是有限的。
chap4_para1488,3,,（例如，在地图着色问题中，每个变量可以取4种不同的颜色中的一种。
chap4_para1488,4,,）无限域CSP（例如含有实数变量或整数变量的CSP）需要完全不同的算法，例如边界传播或线性规划。
chap4_para1489,1,,考虑如下的例子。
chap4_para1489,2,,"我们定义triangle(X,Y,Z)为其3个参数满足三角不等式时成立的谓词："
chap4_para149,1,"•The prediction stage computes the belief state resulting from the action, RESULT(b, a), exactly as we did with sensorless problems. To emphasize that this is a prediction, we use the notation = RESULT(b, a), where the “hat” over the b means “estimated,” and we also use PREDlCT(b, a) as a synonym for RESULT(b, a).",● 可能感知（possible percept）阶段计算在预测的信念状态下可以观测到的感知集合（用字母o表示观测到的感知）：
chap4_para1490,1,,"triangle(X,Y,Z) :-"
chap4_para1491,1,,"X0, Y0, Z0, X+YZ, Y+ZX, X+ZY."
chap4_para1492,1,,"如果我们向Prolog查询triangle(3,4,5)，它会返回成功；而如果我们询问triangle(3,4,Z)，它就无法找到解，因为Prolog无法处理子目标Z0。"
chap4_para1492,2,,我们不能将未绑定的值与0比较。
chap4_para1493,1,,约束逻辑编程（constraint logic programming）允许变量是被约束的而非被绑定的。
chap4_para1493,2,,CLP的解是从知识库中可以推得的、查询变量的最为具体的约束集。
chap4_para1493,3,,"例如，triangle(3,4,Z)的解是约束7Z1。"
chap4_para1493,4,,标准的逻辑程序只是CLP中约束必须为等式约束（也就是绑定）的特殊情形。
chap4_para1494,1,,CLP系统整合了各种约束求解算法用于该语言所支持的约束。
chap4_para1494,2,,例如，支持实值变量线性不等式的系统可能包含线性规划算法来求解这些约束。
chap4_para1494,3,,CLP系统也采用更为灵活的方法来求解标准的逻辑编程查询。
chap4_para1494,4,,例如，它可能使用第6章所述的任一高效算法，而非使用深度优先、从左到右回溯。
chap4_para1494,5,,因此，CLP系统结合了约束满足算法、逻辑编程和演绎数据库的要素。
chap4_para1495,1,,已经出现了一些允许程序员对用于推断的搜索顺序有更多控制的系统。
chap4_para1495,2,,"MRS语言（Genesereth and Smith, 1981; Russell, 1985）允许程序员编制元规则（metarule）来决定首先处理哪些合取式。"
chap4_para1495,3,,用户可以编制规则，说明要首先尝试变量最少的目标，或者也可以对某个谓词编制论域特定的规则。
chap4_para1497,1,,逻辑系统家族中的最后一个成员，也是唯一能够用于所有知识库而不仅是确定子句的成员，是归结。
chap4_para1497,2,,我们在7.5.2节了解了命题归结是命题逻辑的完备推断过程。
chap4_para1497,3,,在本节中，我们将其拓展到一阶逻辑。
chap4_para1498,1,,9.5.1　一阶逻辑的合取范式
chap4_para1499,1,,第一步是将语句转换为合取范式（CNF）——每个子句为文字析取的子句合取式。
chap4_para1499,2,,[5]在CNF中，文字可以包含变量，假定这些变量是全称量化的。
chap4_para1499,3,,例如，语句
chap4_para15,1,"To illustrate hill climbing, we will use the 8-queens problem (Figure 4.3). We will use a complete-state formulation, which means that every state has all the components of a solution, but they might not all be in the right place. In this case every state has 8 queens on the board, one per column. The initial state is chosen at random, and the successors of a state are all possible states generated by moving a single queen to another square in the same column (so each state has 8 × 7 = 56 successors). The heuristic cost function h is the number of pairs of queens that are attacking each other; this will be zero only for solutions. (It counts as an attack if two pieces are in the same line, even if there is an intervening piece between them.) Figure 4.3(b) shows a state that has h = 17. The figure also shows the h values of all its successors.",图4-3　（a）8皇后问题：在棋盘上放置8个皇后，使得它们不能互相攻击。
chap4_para15,2,,（皇后会攻击同一行、同一列或对角线上的任何棋子。
chap4_para15,3,,）当前状态非常接近于一个解，除了第4列和第7列的两个皇后会沿对角线互相攻击。
chap4_para15,4,,（b）一个8皇后状态，其启发式代价估计值h = 17。
chap4_para15,5,,棋盘显示了通过在同一列移动皇后而获得的每一个可能后继的h值。
chap4_para15,6,,有8个移动并列最优，其h = 12。
chap4_para15,7,,爬山法将选择它们中的一个
chap4_para150,1,•The possible percepts stage computes the set of percepts that could be observed in the predicted belief state (using the letter o for observation):,● 更新（update）阶段为每个可能感知计算其可能得到的信念状态。
chap4_para150,2,,更新后的信念状态bo是bˆ中可能产生这一感知的状态集合：
chap4_para1501,1,,[5]　子句也可以用原子语句合取式为前提，原子语句析取式为结论的蕴涵式表示（习题9.DISJ）。
chap4_para1501,2,,"这被称为蕴涵范式或科瓦尔斯基范式［特别是写成从右到左的蕴涵符号时（Kowalski, 1979）］，它通常比有许多否定文字的析取式更易读。"
chap4_para1503,1,,关键在于每条一阶逻辑语句都可以转换为推断上等价的CNF语句。
chap4_para1504,1,,转换成CNF的过程与命题逻辑中类似，我们已在7.5.2节中学习过。
chap4_para1504,2,,关键的差别在于对存在量词的消除。
chap4_para1504,3,,我们通过翻译语句“Everyone who loves all animals is loved by someone”（爱所有动物的每个人被一些人爱），即
chap4_para1505,1,,来描述转换过程，步骤如下。
chap4_para1506,1,,● 蕴涵消去：使用取代。
chap4_para1506,2,,在我们的例句中，需要操作两次。
chap4_para1507,1,,● 内移：除了针对否定联结词的一般规则，我们还需要针对否定量词的规则。
chap4_para1507,2,,因此，我们有
chap4_para1508,1,,我们的语句经过如下变换：
chap4_para1509,1,,注意，蕴涵式前提中的全称量词（∀y）已经变为存在量词。
chap4_para1509,2,,语句现在解读为“要么存在x不喜爱的动物，要么（如果事实并非如此的话）有人喜爱x”。
chap4_para1509,3,,显然，原始语句的含义被保留了下来。
chap4_para151,1,"•The update stage computes, for each possible percept, the belief state that would result from the percept. The updated belief state bo is the set of states in that could have produced the percept:",● 智能体需要在规划阶段处理可能的感知，因为在执行规划之前它不知道实际的感知。
chap4_para151,2,,注意，在预测阶段，物理环境中的非确定性会扩大信念状态，但每个更新后的信念状态bo不会大于预测的信念状态bˆ；观测到的感知只能帮助减少不确定性。
chap4_para151,3,,此外，对于确定性感知，不同感知的信念状态是不相交的，从而形成原始预测信念状态的一个划分。
chap4_para1510,1,,● 变量标准化：对于如这样两次使用相同变量名的语句，更改其中一个变量名。
chap4_para1510,2,,这可以避免在消除量词时产生歧义。
chap4_para1510,3,,因此，有
chap4_para1511,1,,● 斯科伦化：斯科伦化（Skolemization）就是通过消去移除存在量词的过程。
chap4_para1511,2,,在这个简单例子中，它就像9.1节所述的存在量词实例化，将翻译为P(A)，其中A是一个新变量。
chap4_para1511,3,,然而，我们无法对上述的语句应用存在量词实例化，因为它不符合的形式。
chap4_para1511,4,,语句中只有一部分满足这一形式。
chap4_para1511,5,,如果我们盲目地对两个符合的部分应用这一规则，得到
chap4_para1512,1,,其含义完全是错误的。
chap4_para1512,2,,它表明每个人要么无法爱上特定动物A，要么就被某个特定实体B所爱。
chap4_para1512,3,,而实际上，我们的原始语句允许每个人不爱不同的动物，或者被不同的人喜爱。
chap4_para1512,4,,我们希望斯科伦实体依赖于x：
chap4_para1513,1,,此处F和G为斯科伦函数（Skolem function）。
chap4_para1513,2,,总的规则是，斯科伦函数的参数全部是全称量化的变量，要消去的存在量词出现在这些变量的辖域内。
chap4_para1513,3,,与存在量词实例化一样，斯科伦化的语句的可满足性与原始语句完全一致。
chap4_para1514,1,,● 全称量词消除：此时，所有剩余变量必然是全称量化的。
chap4_para1514,2,,因此，我们消除全称量词不会损失任何信息：
chap4_para1516,1,,这一步可能还需要展开嵌套的合取式和析取式。
chap4_para1517,1,,语句现在成为了含有两个子句的CNF。
chap4_para1517,2,,它比原本含有蕴涵的语句难读多了。
chap4_para1517,3,,（将斯科伦函数F(x)解释为可能不被x所爱的动物，而将G(x)解释为可能爱着x的人，可能会对理解有所帮助。
chap4_para1517,4,,）幸运的是，人类很少需要考察CNF语句——翻译过程很容易自动化。
chap4_para1518,1,,9.5.2　归结推断规则
chap4_para1519,1,,一阶子句的归结规则就是7.5.2节命题归结规则的提升版。
chap4_para1519,2,,两条进行了标准化分离、没有共同变量的子句，如果它们含有互补文字则可以被归结。
chap4_para1519,3,,如果两个命题文字相互否定，则这两个命题文字是互补的；如果两个一阶逻辑文字中的一个能够与另一个的否定合一，则这两个一阶逻辑文字是互补的。
chap4_para1519,4,,因此，我们有
chap4_para152,1,"The agent needs to deal with possible percepts at planning time, because it won’t know the actual percepts until it executes the plan. Notice that nondeterminism in the physical environment can enlarge the belief state in the prediction stage, but each updated belief state bo can be no larger than the predicted belief state ; observations can only help reduce uncertainty. Moreover, for deterministic sensing, the belief states for the different possible percepts will be disjoint, forming a partition of the original predicted belief state.",图4-15　局部感知真空吸尘器世界中的两个转移实例。
chap4_para152,2,,"（a）确定性世界中，在初始信念状态下执行Right动作，所得到的新的预测信念状态有两个可能的物理状态；对于这些状态，可能的感知是[R, Dirty]和[R, Clean]，从而得到两种信念状态，每种都只包含一个物理状态。"
chap4_para152,3,,"（b）光滑世界中，在初始信念状态下执行Right动作，所得到的新的信念状态具有4个物理状态；对于这些状态，可能的感知是[L, Dirty]、[R, Dirty]和[R, Clean]，从而得到图中所示的3种信念状态"
chap4_para1520,1,,其中。
chap4_para1520,2,,例如，我们可以归结两个子句
chap4_para1522,1,,通过用合一子来消去互补文字和，生成归结式子句
chap4_para1523,1,,这个规则叫作二元归结（binary resolution）规则，因为它刚好归结两个文字。
chap4_para1523,2,,二元归结本身并不产生完备的推断过程。
chap4_para1523,3,,完备的归结规则能够归结每个子句的可合一文字子集。
chap4_para1523,4,,另一种方法是将因子提取（也就是对冗余文字的消除）拓展到一阶逻辑。
chap4_para1523,5,,命题逻辑因子提取将两个相同的文字约简为一个，一阶逻辑因子提取则约简两个可合一的文字。
chap4_para1523,6,,这种合一子必须应用于整个子句。
chap4_para1523,7,,二元归结和因子提取的组合是完备的。
chap4_para1524,1,,9.5.3　证明范例
chap4_para1525,1,,归结通过证明不可满足来证明，也就是说，通过推导空子句来证明。
chap4_para1525,2,,它的算法与命题逻辑情形相同，如图7-13所示，因此我们不在此重复。
chap4_para1525,3,,但我们会给出两个证明范例。
chap4_para1525,4,,第一个是9.3节的犯罪示例。
chap4_para1525,5,,CNF形式的语句为
chap4_para1526,1,,我们还包括了目标的否定。
chap4_para1526,2,,图9-10展示了归结证明。
chap4_para1526,3,,注意其结构：一条“主线”从目标子句开始，归结知识库中的子句，直到生成空子句。
chap4_para1526,4,,这是在霍恩子句知识库上进行归结的特点。
chap4_para1526,5,,实际上，沿着主线的子句严格对应于图9-6反向链接算法中目标变量的值。
chap4_para1526,6,,这是由于我们总是选择归结正文字能够与主线中“当前”子句最左边文字合一的子句；这与反向链接一模一样。
chap4_para1526,7,,因此，反向链接是归结的一个特例，它具有特定的控制策略来决定下一步要进行哪个归结。
chap4_para1527,1,,图9-10　归结证明韦斯特有罪。
chap4_para1527,2,,每个归结步骤中，合一文字用加粗字体表示，带有正文字的子句用蓝底表示
chap4_para1528,1,,我们的第二个范例使用斯科伦化，并涉及非确定子句。
chap4_para1528,2,,这会导致更为复杂的证明结构。
chap4_para1528,3,,其自然语言描述如下。
chap4_para1529,1,,Everyone who loves all animals is loved by someone.（每个爱所有动物的人都被一些人所爱。
chap4_para1529,2,,）
chap4_para153,1,"Putting these three stages together, we obtain the possible belief states resulting from a given action and the subsequent possible percepts:",综合这3个阶段，我们可以得到由给定动作及后续的可能感知所产生的可能信念状态：
chap4_para1530,1,,Anyone who kills an animal is loved by no one.（任何害死动物的人都不被人所爱。
chap4_para1530,2,,）
chap4_para1531,1,,Jack loves all animals.（杰克爱所有动物，）
chap4_para1532,1,,"Either Jack or Curiosity killed the cat, who is named Tuna.（要么是杰克要么是好奇心害死了那只猫，猫的名字叫Tuna。"
chap4_para1532,2,,）
chap4_para1533,1,,Did Curiosity kill the cat?（是好奇心害死了那只猫吗？
chap4_para1533,2,,）
chap4_para1534,1,,首先，我们将原始语句，也就是一些背景知识，以及目标G的否定表示为一阶逻辑：
chap4_para154,1,4.,
chap4_para154,2,4.,
chap4_para154,3,3Solving partially observable problems,
chap4_para1542,1,,然后，我们使用转换过程将每条语句转换为CNF：
chap4_para155,1,"The preceding section showed how to derive the RESULTS function for a nondeterministic belief-state problem from an underlying physical problem, given the PERCEPT function. With this formulation, the AND–OR search algorithm of Figure 4.11 can be applied directly to derive a solution. Figure 4.16 shows part of the search tree for the local-sensing vacuum world, assuming an initial percept [L, Dirty]. The solution is the conditional plan",4.4.3　求解部分可观测问题
chap4_para1551,1,,图9-11展示了“好奇心害死猫”的归结证明。
chap4_para1551,2,,在自然语言中，证明可以释义为：
chap4_para1552,1,,假设好奇心没有害死Tuna。
chap4_para1552,2,,我们知道要么是杰克要么是好奇心做了这件事，因此一定是杰克干的。
chap4_para1552,3,,现在，Tuna是一只猫，而猫是动物，因此Tuna是动物。
chap4_para1552,4,,因为任何害死动物的人都不被人所爱，我们就知道没人爱杰克。
chap4_para1552,5,,但是，杰克爱所有动物；至此有人爱他；至此我们得到了一个矛盾。
chap4_para1552,6,,因此，好奇心害死了那只猫。
chap4_para1553,1,,证明回答了问题“是好奇心害死了那只猫吗？
chap4_para1553,2,,”但我们常常希望提出更一般的问题，例如“谁害死了那只猫？
chap4_para1553,3,,”归结可以做到这一点，但需要稍微增加一些工作才能得到答案。
chap4_para1553,4,,"目标是∃w Kills(w, Tuna)，其CNF形式的否定为。"
chap4_para1553,5,,用新的否定的目标重复图9-11所示的证明，我们得到了类似的证明树，其中一步的置换为。
chap4_para1553,6,,因此，这种情况下，找出谁害死了那只猫就只是记录证明中查询变量的绑定的问题了。
chap4_para1553,7,,遗憾的是，归结有时会对存在量化目标产生非构造性证明（nonconstructive proof），我们知道一个查询为真，但却不知道这个变量的唯一绑定。
chap4_para1554,1,,图9-11　好奇心害死猫的归结证明。
chap4_para1554,2,,"注意，在推导子句Loves(G(Jack), Jack)时使用了因子分解。"
chap4_para1554,3,,"还要注意，在右上角，合一Loves(x, F(x))和Loves(Jack, x)只有在变量标准化分离后才可以进行"
chap4_para1555,1,,9.5.4　归结的完备性
chap4_para1556,1,,本节给出归结完备性证明。
chap4_para1556,2,,认为归结完备性是理所当然的读者可以略过本节。
chap4_para1557,1,,我们展示归结是反演完备的（refutation-complete），这意味着如果一个语句集是不可满足的，则归结总能推出矛盾。
chap4_para1557,2,,归结不能用于生成语句集的所有逻辑结果，但它可以用于证明给定语句是某个语句集所蕴含的。
chap4_para1557,3,,因此，它可以通过证明不可满足来找到给定问题Q(x)的所有答案。
chap4_para1558,1,,我们认定了一阶逻辑的所有语句（不含等词）都可以重写为CNF中的子句集。
chap4_para1558,2,,"它以原子语句为基础，在语句的形式上进行归纳来证明（Davis and Putnam, 1960）。"
chap4_para1558,3,,因此我们的目标是证明下面的陈述：如果S是不可满足的子句集，则对S应用有限次归结会产生矛盾。
chap4_para1559,1,,"我们的证明遵循鲁宾逊（Robinson）的原始证明，同时使用了（Genesereth and Nilsson, 1987）中的一些简化。"
chap4_para1559,2,,证明的基本结构（见图9-12）如下。
chap4_para156,1,Description A square block with three rows and three columns depicts the maze.,4.4.2节介绍了在给定Percept函数的情况下，如何从底层物理问题推导出非确定性信念状态问题的Results函数。
chap4_para156,2,"The rows are labeled 3, 2, and 1 from top to bottom.",使用这一形式化，可以直接应用图4-11的与或搜索算法得到问题的解。
chap4_para156,3,"The columns are labeled 1, 2, and 3 from left to right.","图4-16为局部感知真空吸尘器世界的部分搜索树，假定初始感知为[L, Dirty]。"
chap4_para156,4,S is positioned at Row 1 Column 1.,它的解是一个条件规划：
chap4_para156,5,G is positioned at Row 3 Column 3.,
chap4_para156,6,"Red bold lines are marked at the border lines of column 1 of rows 2 and 3, row 2 of columns 1 and 2, and columns 2 and 3 of rows 2 and 3.",
chap4_para1560,1,,（1）我们观察到如果S不可满足，则存在S中子句的某个基本实例集使得该集合同样无法满足（埃尔布朗定理）。
chap4_para1561,1,,（2）我们引入第7章给出的基本归结定理，它证明命题归结对于基本语句是完备的。
chap4_para1562,1,,（3）我们使用提升引理来证明，对于使用基本语句集的任意命题归结证明，都存在相应的一阶归结证明，它使用一阶语句，从中可以得到基本语句。
chap4_para1563,1,,图9-12　归结完备性证明的结构
chap4_para1565,1,,通过稍微拓展一阶逻辑语言来允许算术中的数学归纳法，库尔特·哥德尔的不完全性定理证明存在无法证明的真值算术语句。
chap4_para1566,1,,不完全性定理的证明有点超出本书的讨论范畴，要证明它至少需要30页纸，但我们在此可以给出一些思路。
chap4_para1566,2,,我们从逻辑数论开始。
chap4_para1566,3,,在该理论中，只存在单个常量0和单个函数S（后继函数）。
chap4_para1566,4,,在预期模型中，S(0)表示1，S(S(0))表示2，以此类推。
chap4_para1566,5,,因此语言中所有自然数都有名称。
chap4_para1566,6,,它的词汇表还包含函数符号+、×和Expt（幂运算）以及普通的逻辑联结词和量词。
chap4_para1567,1,,首先要注意的是，在这种语言中我们能够写出的语句集是可以枚举的。
chap4_para1567,2,,（想象给符号定义字母序，然后按字母顺序依次排列长度分别为1、2……的语句集。
chap4_para1567,3,,）我们就可以为每条语句编号一个唯一的自然数（即哥德尔数）。
chap4_para1567,4,,这很重要：数论包含了它的每个语句的名字。
chap4_para1567,5,,同样地，我们可以为每个证明P编号为哥德尔数G(P)，因为证明都是一个有限的语句序列。
chap4_para1568,1,,现在假设我们有递归可枚举的语句集A，它是对自然数的真命题。
chap4_para1568,2,,别忘了A可以由给定的整数集命名，我们可以想象用我们的语言写出如下类型的语句：
chap4_para1569,1,,不是哥德尔数为j的语句的证明的哥德尔数，其中证明只使用A中的前提。
chap4_para157,1,Figure 4.16The first level of the AND–OR search tree for a problem in the local-sensing vacuum world; Suck is the first action in the solution.,注意，因为我们是在信念状态问题中应用与或搜索算法，所以它返回的条件规划所测试的是信念状态，而非实际状态。
chap4_para157,2,,这是应该的：在部分可观测环境中，智能体并不知道实际状态。
chap4_para1570,1,,然后，令为语句，也就是表明其自身不可由A证明的语句。
chap4_para1570,2,,（也就是，这条语句恒为真，但并不明显。
chap4_para1570,3,,）
chap4_para1571,1,,现在我们提出如下的巧妙观点：假设是可由A证明的，则为假（因为说自己是不可证明的）。
chap4_para1571,2,,但这样我们就有一个可以从A证明的真值为假的语句，因此A不可能只包含真语句——这与我们的前提矛盾。
chap4_para1571,3,,因此是不可由A证明的。
chap4_para1571,4,,但这正如自己所述，因此是一个真语句。
chap4_para1572,1,,因此，我们证明了（略去了页）对于数论的所有真语句集，特别是所有基本公理集，存在由这些公理无法证明的真语句。
chap4_para1572,2,,这就明确了我们无法在任何给定公理系统内证明所有数学定理。
chap4_para1572,3,,显然，这是数学的重要发现。
chap4_para1572,4,,它对人工智能的重要性已经被广泛的争论，这种争论正始于哥德尔本人的猜想。
chap4_para1572,5,,我们在第27章探讨这些争论。
chap4_para1573,1,,要进行第一步，我们需要3个新概念。
chap4_para1574,1,,（1）埃尔布朗域（Herbrand universe）：如果S是子句集，则S的埃尔布朗域HS是可以由下面几项构建的基本项集合。
chap4_para1575,1,,a. S中的函数符号，如果存在的话。
chap4_para1576,1,,b. S中的常量符号，如果存在的话；如果不存在，则为默认常量符号S。
chap4_para1577,1,,例如，如果S仅含有子句 ，则HS为如下基本项的无限集：
chap4_para1578,1,,（2）饱和（saturation）：如果S为子句集，P是基本项集，则P(S)为S对于P的饱和，它是通过对S中的变量应用所有可能P中基本项的一致置换得到的所有基本子句的集合。
chap4_para1579,1,,（3）埃尔布朗基（Herbrand base）：子句集S关于其埃尔布朗域的饱和称为S的埃尔布朗基，写作HS(S)。
chap4_para1579,2,,例如，如果S仅含有上述的子句，则HS(S)是无限子句集
chap4_para158,1,"Notice that, because we supplied a belief-state problem to the AND–OR search algorithm, it returned a conditional plan that tests the belief state rather than the actual state. This is as it should be: in a partially observable environment the agent won’t know the actual state.",图4-16　局部感知真空吸尘器世界问题的第一层与或搜索树，Suck是解序列中的第一个动作
chap4_para1580,1,,"这些定义使我们可以陈述埃尔布朗定理（Herbrand, 1930）的一种形式："
chap4_para1581,1,,如果子句集S不可满足，则存在HS(S)的一个不可满足的有限子集。
chap4_para1582,1,,令S'为基本语句的有限子集。
chap4_para1582,2,,现在我们可以使用接地归结定理（7.5.2节）来证明归结闭包RC(S')含有空子句。
chap4_para1582,3,,也就是说，使用命题归结对S'进行完备化会推得矛盾。
chap4_para1583,1,,现在我们已经证明了必然存在涉及S的埃尔布朗基的有限子集的归结证明，下一步是证明存在使用S本身的子句的归结证明，它们不一定是基本子句。
chap4_para1583,2,,我们从考虑单次运用归结规则的情形开始。
chap4_para1583,3,,鲁宾逊阐述了如下引理：
chap4_para1584,1,,令C1和C2为两个不含相同变量的子句，C'1和C'2分别为C1和C2的基本实例。
chap4_para1584,2,,如果C'是C'1和C'2的归结式，则存在子句C使得：（1）C是C1和C2的归结式；（2）C'是C的基本实例。
chap4_para1585,1,,这就是提升引理（lifting lemma），因为它将基本子句的证明提升到一般一阶逻辑子句。
chap4_para1585,2,,鲁宾逊为了证明其基本提升引理而不得不发明了合一且推导了最一般合一子的所有性质。
chap4_para1585,3,,我们仅阐明该引理而不在此进行证明：
chap4_para1586,1,,我们看到C'实际上是C的基本实例。
chap4_para1586,2,,一般来说，要使C'1和C'2具有归结式，就必须通过先对C1和C2使用C1和C2中的互补文字的最一般合一子来构建它们。
chap4_para1586,3,,由提升引理，易得任意多次应用归结规则时的相似结论：
chap4_para1587,1,,对于归结闭包S'内的任意子句C'，有归结闭包S内的子句C使得C'为C的基本实例且对C的推导长度与对C'的推导长度相同。
chap4_para1588,1,,由此可得，如果归结闭包S'内有空子句，则它必然也在归结闭包S中。
chap4_para1588,2,,这是由于空子句不可能是任何其他子句的基本实例。
chap4_para1588,3,,概括来说：我们已经证明了如果S不可满足，则存在使用归结规则的对空子句的有限推导。
chap4_para1589,1,,定理证明从基本子句提升到一阶子句大大增加了其能力。
chap4_para1589,2,,这种能力的增加来源于以下事实：一阶逻辑证明只需要在证明确有必要时才实例化变量，而基本子句方法则需要检查大量的任意实例化。
chap4_para159,1,"As in the case of standard search algorithms applied to sensorless problems, the AND–OR search algorithm treats belief states as black boxes, just like any other states. One can improve on this by checking for previously generated belief states that are subsets or supersets of the current state, just as for sensorless problems. One can also derive incremental search algorithms, analogous to those described for sensorless problems, that provide substantial speedups over the black-box approach.",与标准搜索算法应用于无传感器问题的情况一样，与或搜索算法将信念状态看作和任何其他问题状态一样的黑盒。
chap4_para159,2,,可以通过检查先前生成的信念状态——它们是当前状态的子集或超集——来改进这一点，就像求解无传感器问题一样。
chap4_para159,3,,同样可以推导出与无传感器问题中描述的那些算法类似的增量搜索算法。
chap4_para159,4,,与黑盒方法相比，它们提供了显著的加速。
chap4_para1591,1,,本章到目前为止讲述过的所有推断方法都不能在不增加额外工作的情况下处理形如x = y的断言。
chap4_para1591,2,,为此可以采取3种不同的方法。
chap4_para1591,3,,第一种方法是公理化等词，也就是在知识库中写入相等关系的语句。
chap4_para1591,4,,我们需要说明相等是自反的、对称的和传递的，我们还需要说明我们可以在所有谓词或函数中用相等量置换相等量。
chap4_para1591,5,,因此我们需要3类基本公理，另外每个谓词和函数都需要一条公理：
chap4_para1592,1,,给定这些语句，标准的推断过程，如归结，就可以执行需要等词推理的任务，如求解数学方程。
chap4_para1592,2,,不过，这些公理会产生大量结论，其中大多数对证明没有帮助。
chap4_para1592,3,,因此第二种方法是添加推断规则而非公理。
chap4_para1592,4,,最简单的规则是解调，它取单元子句x = y和一个含有x项的子句，生成一个用y置换中的x得出的新子句。
chap4_para1592,5,,如果中的项能够与x合一，解调就可以使用，而不需要完全等于x。
chap4_para1592,6,,注意，解调是有方向性的，给定x = y，x总是会被y替换，而非相反。
chap4_para1592,7,,这意味着解调可以用形如z + 0 = z或z1 = z这样的解调器来简化表达式。
chap4_para1592,8,,下面的例子中，给定
chap4_para1593,1,,我们可以通过解调得出
chap4_para1594,1,,更为形式化地，我们有
chap4_para1595,1,,● 解调（demodulation）：对于任意项x、y和z，其中z出现在文字mi中的某处且 ，
chap4_para1596,1,,其中Subst是对绑定表的一般置换，而表示在m中的某处用y替换x。
chap4_para1597,1,,这个规则可以拓展到处理含有等词的非单元子句。
chap4_para1598,1,,● 超解调（paramodulation）：对于任意项x、y和z，其中z出现在文字mi中的某处且，
chap4_para16,1,Description The board shows the value of h for each possible successor obtained by moving a queen within its column.,● 岭（ridge）：如图4-4 所示。
chap4_para16,2,The values on each row are as follows.,岭的存在将导致一系列局部极大值，对于贪心算法，这是很难处理的。
chap4_para16,3,"Row 1: 14, 14, 13, 17, 12, 14, 12, 18.",
chap4_para16,4,"Row 2: 18, 14, queen, 15, 15, 14, queen, 16.",
chap4_para16,5,"Row 3: 17, queen, 16, 18, 15, queen, 15, queen.",
chap4_para16,6,"Row 4: queen, 14, 17, 15, queen, 14, 16, 16.",
chap4_para16,7,"Row 5: 15, 14, 14, queen, 13, 16, 13 16.",
chap4_para16,8,"Row 6: 14, 12, 18, 13, 15, 12, 14, 14.",
chap4_para16,9,"Row 7: 14, 16, 13, 15, 12, 14, 12, 16.",
chap4_para16,10,"Row 8: 18, 12, 14, 13, 13, 12, 14, 14.",
chap4_para160,1,4.,4.4.4　部分可观测环境中的智能体
chap4_para160,2,4.,
chap4_para160,3,4An agent for partially observable environments,
chap4_para1601,1,,我们有，通过超解调我们可以得到结论
chap4_para1602,1,,超解调产生含有等词的一阶逻辑的一个完备推断程序。
chap4_para1603,1,,第三种方法仅使用拓展的合一算法处理等词推理。
chap4_para1603,2,,也就是说，如果若干项在某种置换下可证明为相等，则它们是可合一的，其中“可证明”允许等词推理。
chap4_para1603,3,,例如，项1 + 2和2 + 1通常不可合一，但知道的合一算法可以用空置换合一它们。
chap4_para1603,4,,这种等词合一（equational unification）可以用针对特定公理（交换性、结合性等）设计的高效算法完成，而非通过直接用这些公理推断。
chap4_para1603,5,,使用这种技术的定理证明器与9.4节所述的CLP系统密切相关。
chap4_para1604,1,,9.5.6　归结策略
chap4_para1605,1,,我们知道只要证明存在，反复运用归结推断规则总会找到一个证明。
chap4_para1605,2,,在本节中我们考察有助于高效找出证明的策略。
chap4_para1606,1,,单元优先（unit preference）：这个策略优先处理其中一条语句为单文字（也就是单元子句）的归结。
chap4_para1606,2,,这一策略的思路是，我们试图产生空子句，因此先处理产生较短子句的推断可能是个好主意。
chap4_para1606,3,,归结单元语句（如P）与其他任意语句（如）总是生成比其他子句短的子句（本例中为）。
chap4_para1606,4,,当这种单元优先策略在1964年首次被用于命题推断时，它产生了巨大的加速作用，使得它能够证明许多先前无法处理的定理。
chap4_para1606,5,,单元归结是归结的一种受限形式，其中归结的每一步都含有单元子句。
chap4_para1606,6,,单元归结总体上是不完备的，但对霍恩子句是完备的。
chap4_para1606,7,,霍恩子句上的单元归结证明与前向链接类似。
chap4_para1607,1,,"Otter定理证明器（McCune, 1990）使用了最佳优先搜索。"
chap4_para1607,2,,其启发函数度量每个子句的“权重”，并偏好权重较轻的子句。
chap4_para1607,3,,启发式函数的选择取决于用户，但通常子句的权重应当与其规模或难度相关。
chap4_para1607,4,,它认为单元子句权重较轻，因此这种搜索可以被看作单元优先策略的一般化。
chap4_para1608,1,,支撑集（set of support）：优先尝试某些归结是有用的，但一般来说一起消除某些有潜力的归结是更为高效的做法。
chap4_para1608,2,,例如，我们可以使每个归结步都用到一个特殊子句集的至少一个元素，这个特殊子句集就是支撑集。
chap4_para1608,3,,归结式随后被加入支撑集中。
chap4_para1608,4,,如果支撑集远小于整个知识库，则搜索空间会大大简化。
chap4_para1609,1,,为确保这种策略的完备性，我们可以选择使得语句的剩余部分同时可满足的支撑集S。
chap4_para1609,2,,例如，假设原始知识库是一致的，我们就可以使用否定查询作为支撑集（毕竟，如果知识库不一致，则查询符合知识库也没什么意义了）。
chap4_para1609,3,,支撑集策略还有一个好处，它能够生成目标导向的证明树，利于人类理解。
chap4_para161,1,"An agent for partially observable environments formulates a problem, calls a search algorithm (such as AND-OR-SEARCH) to solve it, and executes the solution. There are two main differences between this agent and the one for fully observable deterministic environments. First, the solution will be a conditional plan rather than a sequence; to execute an if–then–else expression, the agent will need to test the condition and execute the appropriate branch of the conditional. Second, the agent will need to maintain its belief state as it performs actions and receives percepts. This process resembles the prediction–observation–update process in Equation (4.5) but is actually simpler because the percept is given by the environment rather than calculated by the agent. Given an initial belief state b, an action a, and a percept o, the new belief state is:",部分可观测环境中的智能体先对问题形式化，接着调用搜索算法（例如And-Or-Search）求解，然后执行解步骤。
chap4_para161,2,,这种智能体和完全可观测确定性环境中的智能体之间有两个主要区别。
chap4_para161,3,,首先，问题的解将是一个条件规划而不是一个序列；为了执行if-then-else表达式，智能体需要测试if语句中的条件并执行正确的条件分支。
chap4_para161,4,,其次，智能体需要在执行动作和接收感知时维护其信念状态。
chap4_para161,5,,这一过程类似于式（4-5）中的预测-观测-更新过程，但更加简单，因为感知是由环境给出的，而不是由智能体自己计算的。
chap4_para161,6,,给定初始信念状态b、动作a、感知o，则新的信念状态为
chap4_para1610,1,,输入归结（input resolution）：这种策略中，每个归结都是一个输入语句（来自知识库或查询）与其他一些语句的结合。
chap4_para1610,2,,图9-10所示的证明仅使用输入归结，因而具有单条“主线”且单条语句向主线结合的结构特征。
chap4_para1610,3,,显然，这种证明树的空间小于整个证明图的空间。
chap4_para1610,4,,在霍恩知识库中，肯定前件是一种输入归结策略，因为它将原知识库中的一个蕴涵式与其他语句结合。
chap4_para1610,5,,因此，我们知道输入归结对于霍恩形式的知识库是完备的，但一般情况下它是不完备的。
chap4_para1610,6,,如果P在原始知识库中或P在证明树上是Q的祖先的话，线性归结（linear resolution）策略允许P和Q一同归结。
chap4_para1610,7,,线性归结是完备的。
chap4_para1611,1,,包容（subsumption）：包容方法消除所有知识库中已有语句所包含的语句（也就是更为精确的语句）。
chap4_para1611,2,,例如，如果P(x)在知识库中，则添加语句P(A)就没有意义，添加P(A) ∨ Q(B)则更无意义。
chap4_para1611,3,,包容能够使知识库较小，进而有助于减小搜索空间。
chap4_para1612,1,,学习（learning）：我们可以通过从经验中学习改进定理证明器。
chap4_para1612,2,,给定先前证得的定理集，训练机器学习系统来回答问题：给定前提集和证明目标，哪些证明步骤与之前成功的证明步骤类似？
chap4_para1612,3,,"DeepHOL系统（Bansal et al., 2019）做到了这一点，它使用深度神经网络（见第21章）来构建目标和前提的模型（称为嵌入），并使用这些模型来选择步骤。"
chap4_para1612,4,,训练可以同时使用人类或计算机生成的证明作为样本，并至少需要10 000个证明。
chap4_para1613,1,,归结定理证明器的实际用途
chap4_para1614,1,,我们已经展示了一阶逻辑是如何表示简单的、涉及出售、武器、公民权等问题的真实世界场景的。
chap4_para1614,2,,但复杂的真实世界场景有太多未知和不确定性。
chap4_para1614,3,,逻辑已经被证明在涉及形式化、严格定义的概念的场景中表现出色，例如硬件和软件的合成（synthesis）与验证（verification）。
chap4_para1614,4,,定理证明研究还在硬件设计、编程语言和软件工程领域展开，而不仅限于人工智能领域。
chap4_para1615,1,,在硬件领域，公理描述了信号和电路元件之间的相互作用。
chap4_para1615,2,,（见8.4.2节的例子。
chap4_para1615,3,,"）专门用于验证的逻辑推理器已经能够验证整个CPU，包括验证其时序（Srivas and Bickford, 1990）。"
chap4_para1615,4,,"Aura定理证明器已经用于生成比所有已有设计更为紧凑的电路设计（Wojciechowski and Wojcik, 1983）。"
chap4_para1616,1,,在软件领域，对程序进行推理与动作推理非常相似，如在第7章中，公理描述每个命题的前提和效果。
chap4_para1616,2,,"算法的形式化合成是定理证明器最早的应用之一，如科德尔·格林（Green, 1969a）所述。"
chap4_para1616,3,,"科德尔·格林的论述基于更早由赫伯特·西蒙（Simon, 1963）提出的思路。"
chap4_para1616,4,,这种思路是对效果“存在满足特定规范的程序p”构造性地证明定理。
chap4_para1616,5,,尽管全自动演绎合成还不能用于通用编程，人工引导的演绎合成却已经成功用于设计一些新颖、精妙的算法。
chap4_para1616,6,,像科学计算代码这样的专用程序的合成也是研究的热门领域。
chap4_para1617,1,,"类似的技术现在已经被用于软件验证，对应的系统有Spin模型检查器（Holzmann, 1997）等。"
chap4_para1617,2,,"例如，Remote Agent空间飞行器控制程序在飞行前后都进行了验证（Havelund et al., 2000）。"
chap4_para1617,3,,"RSA公钥加密算法和BM（Boyer-Moore）字符串匹配算法也使用这种方式进行验证（Boyer and Moore, 1984）。"
chap4_para1619,1,,我们已经分析了一阶逻辑中的逻辑推断，以及一些相关的算法。
chap4_para162,1,"Consider a kindergarten vacuum world wherein agents sense only the state of their current square, and any square may become dirty at any time unless the agent is actively cleaning it at that moment.",
chap4_para162,2,7 Figure 4.,
chap4_para162,3,17 shows the belief state being maintained in this environment.,
chap4_para1620,1,,● 第一种方法使用推断规则（全称量词实例化和存在量词实例化）来命题化推断问题。
chap4_para1620,2,,通常，这种方法速度慢，除非论域非常小。
chap4_para1621,1,,● 使用合一来找出适当的变量置换消去一阶证明中的实例化步骤，在许多情况下提高了这一过程的效率。
chap4_para1622,1,,● 肯定前件的提升版使用了合一，产生了一般化肯定前件这种自然、强大的推断规则。
chap4_para1622,2,,前向链接算法和反向链接算法对确定子句集使用这条规则。
chap4_para1623,1,,● 一般化肯定前件对确定子句是完备的，但蕴含问题是半可判定的。
chap4_para1623,2,,对于不含函数的确定子句构成的数据日志知识库，蕴含是可判定的。
chap4_para1624,1,,● 前向链接用于演绎数据库，此时它可以与关系数据库的操作结合。
chap4_para1624,2,,它也用于对超大规则集进行高效更新的产生式系统。
chap4_para1624,3,,前向链接对于数据日志是完备的，并可以在多项式时间内运行。
chap4_para1625,1,,● 反向链接用于逻辑编程系统，它利用巧妙的编译器技术来实现超快速推断。
chap4_para1625,2,,反向链接受制于冗余推断和死循环，可以通过备忘来缓解这些问题。
chap4_para1626,1,,● Prolog与一阶逻辑不同，它使用了封闭世界中的名称唯一假设，并视否定为失败。
chap4_para1626,2,,这使Prolog成为很实用的编程语言，但也偏离了纯粹的逻辑。
chap4_para1627,1,,● 一般化的归结推断规则使用合取范式知识库为一阶逻辑提供了完备的推断系统。
chap4_para1628,1,,● 一些用于减小归结系统搜索空间的策略不牺牲其完备性。
chap4_para1628,2,,最重要的问题之一是处理等词，我们展示了如何使用解调和超解调。
chap4_para1629,1,,● 基于归结的高效定理证明器已经被用于证明有趣的数学定理和验证及合成软件和硬件。
chap4_para163,1,Description State space 1: An arrow from a node labeled S points to a node labeled “a”. Two arrows from the node labeled “a” point to two unlabeled nodes. An arrow from the first unlabeled node points to a node labeled G. An arrow from the second unlabeled node points to a third unlabeled node which has a self-loop. State space 2: An arrow from a node labeled S points to a node labeled “a”. Two arrows from the node labeled “a” point to two unlabeled nodes. An arrow from the first unlabeled node points to a third unlabeled node which has a self-loop. An arrow from the second unlabeled node points to a node labeled G.,考虑一个类幼儿园真空吸尘器世界，智能体只能感知当前方格的状态，任一方格在任一时刻都有可能变脏，除非智能体恰好在那一时刻主动清理该方格。
chap4_para163,2,,[7]图4-17为此环境中所维护的信念状态。
chap4_para1633,1,,在本章中，我们展示如何以一阶逻辑表示真实世界中的各种事实。
chap4_para1634,1,,前面的章节展示了具有知识库的智能体如何进行推断，以便能采取正确的行动。
chap4_para1634,2,,本章我们回答要把什么样的内容放进这种智能体的知识库中，也就是如何表示关于世界的事实。
chap4_para1634,3,,我们使用一阶逻辑作为表示语言，而后续章节将介绍其他表示的形式体系，例如用于规划推理的分层任务网络（第11章），用于不确定性推理的贝叶斯网络（第13章），用于进行时序推理的马尔可夫模型（第17章），以及用于推理图像、声音和其他数据的深度神经网络（第21章）。
chap4_para1634,4,,不论你使用什么表示，都始终需要处理关于世界的事实。
chap4_para1634,5,,本章将使你建立处理这些问题的直觉。
chap4_para1635,1,,10.1节介绍通用本体论的思想，将世界上所有的事物用层次类别组织起来；10.2节涵盖对象、物质和度量的基本类别；10.3节介绍事件；10.4节讨论关于信念的知识。
chap4_para1635,2,,然后，我们再考虑用这些内容进行推理的方法，10.5节讨论设计用于高效类别推断的推理系统，10.6节讨论具有缺省信息的推理。
chap4_para1636,1,,10.1　本体论工程
chap4_para1637,1,,在“玩具”领域，选择何种表示并不那么重要，很多表示都可以良好运作。
chap4_para1637,2,,但在复杂的领域，如网上购物或者在车流中驾驶，就需要更为通用和灵活的表示方法。
chap4_para1637,3,,本章将展示如何创建这些表示，主要关注于许多不同领域中都会出现的一般性的概念，如事件、时间、对象、信念等。
chap4_para1637,4,,有时，表示这些抽象概念被称为本体论工程（ontological engineering）。
chap4_para1638,1,,我们不能奢求表示世界中的一切事物，我们甚至无法表示1000页的教科书，但我们会留出一些位置，使所有领域的新知识都可以填入。
chap4_para1638,2,,例如，我们将定义对象是什么，而不同种类对象的细节——机器人、电视机、书或者无论什么——可以随后再进行填充补全。
chap4_para1638,3,,这类似于面向对象编程框架（如Java Swing图形化框架）的设计者定义窗口之类的一般性概念，并期待用户使用它们来定义更为具体的概念，如表单窗口。
chap4_para1638,4,,概念的一般性的框架被称为上层本体论（upper ontology），因为我们惯于将更一般性的概念绘制于更具体的概念之上，如图10-1所示。
chap4_para1639,1,,在进一步考虑本体论之前，我们要先说明一项重要的提醒。
chap4_para1639,2,,尽管真实世界的一些层面很难用一阶逻辑来刻画，我们仍选择使用FOL来讨论知识的内容和组织。
chap4_para1639,3,,主要的难点在于，大多数一般化都有其例外，或仅在某种程度上成立。
chap4_para1639,4,,例如，尽管“番茄是红色的”是一条有用的规则，但一些番茄是绿色的、黄色的或橙色的。
chap4_para1639,5,,本章的大多数规则都可以找到类似的例外。
chap4_para1639,6,,处理例外和不确定性的能力极其重要，但它却与理解一般性的本体论无关。
chap4_para1639,7,,因此，我们在10.5节之前都不讨论例外情形，而在第12章才讨论在不确定性下进行推理的更一般性的话题。
chap4_para164,1,Figure 4.17Two prediction–update cycles of belief-state maintenance in the kindergarten vacuum world with local sensing.,
chap4_para1640,1,,上层本体论的用处是什么？
chap4_para1640,2,,考虑8.4.2节的电路本体论。
chap4_para1640,3,,它进行了许多简化假设：时间被完全无视；信号是固定的且不需要传播；电路的结构保持不变。
chap4_para1640,4,,更一般性的本体论会考虑特定时间的信号，也会考虑导线的长度和传播延迟。
chap4_para1640,5,,这能使我们模拟电路的时序性质——实际上，电路设计师常常进行这种模拟。
chap4_para1641,1,,图10-1　世界的上层本体论，它展示了本章稍后要讲述的内容。
chap4_para1641,2,,每条线表示低层概念是高层概念的一种具体化。
chap4_para1641,3,,具体化不一定是排他的——人类既是动物，又是智能体。
chap4_para1641,4,,我们会在10.3.2节看到为何对象在一般化事件的下层
chap4_para1642,1,,我们还可以通过描述电路技术（TTL、COMS等）或输入输出规范等方法引入更为有趣的门电路类型。
chap4_para1642,2,,如果我们要讨论可靠性或进行诊断，我们就需要考虑电路的结构和门电路属性自发改变的可能性。
chap4_para1642,3,,要考察杂散电容，我们就需要表示导线在电路板上的位置。
chap4_para1643,1,,wumpus世界中也有类似的因素需要考虑。
chap4_para1643,2,,尽管我们表示了时间，但它的结构却过于简单：智能体在不行动时什么都不会发生，而所有变化都是瞬间发生的。
chap4_para1643,3,,更适于真实世界的、更为一般性的本体论能够允许变化随时间同时发生。
chap4_para1643,4,,我们还使用了Pit谓词来表示哪个方格有无底洞。
chap4_para1643,5,,我们其实可以通过在无底洞类别下增加不同属性的无底洞个体来允许出现不同种类的无底洞。
chap4_para1643,6,,类似地，我们可能还想允许wumpus之外的其他动物出现。
chap4_para1643,7,,从可用的感知可能无法确定动物的确切物种，因此我们可能需要构建生物分类学层级来帮助智能体从匮乏的线索中预测穴居者的行为。
chap4_para1644,1,,对所有专用本体论来说，做类似这样的修改来使其更为一般化是可行的。
chap4_para1644,2,,显然，这样做就产生了一个问题：这些本体论是否最终都会发展为通用本体论？
chap4_para1644,3,,在几个世纪的哲学和计算研究中，答案是“有可能”。
chap4_para1644,4,,本节我们展示一种通用本体论，它综合了这几百年的思想。
chap4_para1644,5,,通用本体论与专用本体论有两个主要的区别。
chap4_para1645,1,,● 通用本体论在所有专用论域都应当可以或多或少地适用（在增加论域特定的公理后）。
chap4_para1645,2,,这意味着它不能无视任何表示问题。
chap4_para1646,1,,● 在所有足够复杂的论域中，不同领域的知识必须是统一的，因为推理和问题求解会同时涉及多个领域。
chap4_para1646,2,,例如，一个机器人电路维修系统需要在电气连通性和物理布局方面推理电路，也需要出于电路时序分析和估计劳动力成本的目的而进行关于时间的推理。
chap4_para1646,3,,因此，描述时间的语句必须能够结合描述空间布局的语句，在处理纳秒或分钟、埃或米时也必须具有相同的性能。
chap4_para1647,1,,我们首先要说的是，目前为止，通用本体论工程的进展仍然相当有限。
chap4_para1647,2,,所有顶尖的人工智能应用（如第1章所列出的）都没有使用通用本体论——它们都使用专用知识工程和机器学习。
chap4_para1647,3,,对于争论各方，社会和政治考虑使得他们很难对某个本体论达成共识。
chap4_para1647,4,,"如汤姆·格鲁伯（Tom Gruber）（Gruber, 2004）所述：“每一种本体论都是一群有共同动机去分享的人之间的合约——社会共识。"
chap4_para1647,5,,”当竞争方面的考虑超过共享时，就不会有共同的本体论。
chap4_para1647,6,,"利益相关者的数量越少，就越容易构建本体论，因此构建通用本体论要难于构建用途有限的本体论，例如开放生物医学本体论（Smith et al., 2007）。"
chap4_para1647,7,,这些已有的本体论根据4条路径构建。
chap4_para1648,1,,（1）通过训练有素的本体论学家或逻辑学家团队来构建本体论并写出公理。
chap4_para1648,2,,"CYC系统基本上是用这种方法构建的（Lenat and Guha, 1990）。"
chap4_para1649,1,,（2）通过从现有数据库中引入类别、属性和值。
chap4_para1649,2,,"DBpedia通过从维基百科中引入结构化事实构建（Bizer et al., 2007）。"
chap4_para165,1,"In partially observable environments—which include the vast majority of real-world environments—maintaining one’s belief state is a core function of any intelligent system. This function goes under various names, including monitoring, filtering, and state estimation. Equation (4.6) is called a recursive state estimator because it computes the new belief state from the previous one rather than by examining the entire percept sequence. If the agent is not to “fall behind,” the computation has to happen as fast as percepts are coming in. As the environment becomes more complex, the agent will only have time to compute an approximate belief state, perhaps focusing on the implications of the percept for the aspects of the environment that are of current interest. Most work on this problem has been done for stochastic, continuous-state environments with the tools of probability theory, as explained in Chapter 14.",[7]　向那些不熟悉幼儿对环境影响的人表示歉意。
chap4_para1650,1,,（3）通过分析文本文件，从中提取信息。
chap4_para1650,2,,"TextRunner通过阅读大量网页语料库来构建（Banko and Etzioni, 2008）。"
chap4_para1651,1,,（4）通过诱导无技能的业余人士输入常识知识。
chap4_para1651,2,,"OpenMind系统通过用英语提出事实的志愿者构建（Singh et al., 2002; Chklovski and Gil, 2005）。"
chap4_para1652,1,,举例来说，谷歌知识图谱使用来自维基百科的半结构化内容，并结合了从大量网页中收集的、经过人类整合的内容。
chap4_para1652,2,,"它含有超过700亿条事实并为大约三分之一的谷歌搜索提供答案（Dong et al., 2014）。"
chap4_para1653,1,,10.2　类别与对象
chap4_para1654,1,,将对象组织为类别是知识表示的重要组成部分。
chap4_para1654,2,,尽管与世界的交互发生在单个对象的层面，但大多数推理发生在类别的层面。
chap4_para1654,3,,例如，购物者的目标通常是购买篮球，而非购买像BB9这样的某个特定的篮球。
chap4_para1654,4,,类别也能用于对已分类的对象进行预测。
chap4_para1654,5,,我们根据感知输入对某个对象是否存在进行推断，通过对对象属性的感知推断其类别，然后使用类别信息对该对象进行预测。
chap4_para1654,6,,例如，从黄色和绿色条纹的果皮、直径约30厘米、椭圆形的形状、红色的果肉、黑色的种子并位于超市水果区的特点来看，我们可以推断这个对象是一个西瓜；由此，我们推断它可以用于水果沙拉。
chap4_para1655,1,,用一阶逻辑表示类别有两种选择：谓词和对象。
chap4_para1655,2,,也就是说，我们可以使用谓词Basketballs(b)，也可以将类别物化[1]为对象Basketballs。
chap4_para1655,3,,"这样，我们就可以说Member(b, Basketballs)，我们将其缩写为，表示b是篮球类别中的成员。"
chap4_para1655,4,,"我们说Subset(Basketballs, Balls)，缩写为，表示篮球是球的子类别。"
chap4_para1655,5,,我们等价地使用子类别、子类和子集这3个词语。
chap4_para1657,1,,[1]　将命题转换对象称为物化（reification），来自拉丁语词语res，也就是物体。
chap4_para1657,2,,约翰•麦卡锡提出了术语“thingification”（物品化），但并未得以流行。
chap4_para1658,1,,类别通过继承组织知识。
chap4_para1658,2,,如果我们说食物类别下的所有实例都可以食用，且我们断言水果是食物的子类、苹果是水果的子类，则我们可以推得所有苹果都可以食用。
chap4_para1658,3,,我们可以说单个苹果继承了可食用性这个属性，这种继承在本例中源于其从属的食物类别。
chap4_para1659,1,,子类关系将类别组织为分类学层级（taxonomic hierarchy）或分类法（taxonomy）。
chap4_para1659,2,,分类法在技术领域已经被明确地使用了几百年。
chap4_para1659,3,,最大的这种分类法将大约一千万个现存或灭绝的物种组织为一个层次结构，其中包括许多种甲壳虫[2]；图书馆学为所有领域的知识开发了分类法，将其编码为杜威十进制系统；税务部门和其他政府部门也发展出了大量关于职业和商品的分类法。
chap4_para166,1,"In this section we will show an example in a discrete environment with deterministic sensors and nondeterministic actions. The example concerns a robot with a particular state estimation task called localization: working out where it is, given a map of the world and a sequence of percepts and actions. Our robot is placed in the maze-like environment of Figure 4.18. The robot is equipped with four sonar sensors that tell whether there is an obstacle—the outer wall or a dark shaded square in the figure—in each of the four compass directions. The percept is in the form of a bit vector, one bit for each of the directions north, east, south, and west in that order, so 1011 means there are obstacles to the north, south, and west, but not east.",在部分可观测环境中——涵盖绝大多数真实世界环境——维护自身的信念状态是任何智能系统的核心功能。
chap4_para166,2,,这一功能有很多不同的名称，包括监视（monitoring）、过滤（filtering）和状态评估（state estimation）。
chap4_para166,3,,式（4-6）称为递归状态评估器，因为它根据前一状态计算新的信念状态，而不是检查整个感知序列。
chap4_para166,4,,如果智能体不想“落后”，计算速度必须和感知进入的速度一样快。
chap4_para166,5,,随着环境越来越复杂，智能体将只有时间计算近似信念状态，它可能重点关注感知对当前感兴趣的环境方面的影响。
chap4_para166,6,,关于这一问题的大部分工作都是用概率论的工具处理随机的连续状态的环境，详见第14章。
chap4_para1661,1,,[2]　当被问及一个人通过研究自然能够对造物主有怎样的了解时，生物学家霍尔丹（J. B. S. Haldane）说：“他（造物主）是甲壳虫的超级爱好者。
chap4_para1661,2,,”
chap4_para1662,1,,一阶逻辑很易于陈述关于类别的事实，不论是通过把对象关联到类别还是对类别的成员进行量化。
chap4_para1662,2,,下面是一些事实的示例。
chap4_para1663,1,,● 一个对象是一个类别的成员。
chap4_para1664,1,,● 一个类别是另一个类别的子类。
chap4_para1665,1,,● 一个类别的所有成员都具有某种性质。
chap4_para1666,1,,● 一个类别的成员可以用某些性质来辨别。
chap4_para1667,1,,● 一个类别整体具有某些性质。
chap4_para1668,1,,注意，由于狗是一个类别，并且是驯化物种的一个成员，因此驯化物种必然是类别的类别。
chap4_para1668,2,,当然，上述的规则存在许多例外（瘪气的篮球不是圆的），我们稍后再处理这些例外。
chap4_para1669,1,,尽管子类和成员关系是类别中最重要的关系，我们也希望能够陈述类别之间的非从属关系。
chap4_para1669,2,,例如，如果我们只说了本科生和研究生是学生的子类，那么我们就没有表明一个本科生无法同时是研究生。
chap4_para1669,3,,如果两个或两个以上的类别没有共同的成员，则它们是不相交的（disjoint）。
chap4_para1669,4,,我们可能还想表明研究生和本科生类别构成了大学生的完全分解（exhaustive decomposition）。
chap4_para1669,5,,不相交集合的一种完全分解被称为一个划分（partition）。
chap4_para1669,6,,以下是上述概念的一些例子：
chap4_para167,1,"Description Seven long thin blocks are arranged at different levels, and the count of the block extends to n numbers.",图4-17　在局部感知的类幼儿园真空吸尘器世界中，信念状态维护的两个预测-更新周期
chap4_para167,2,A path is traced with alternate upper and lower parts of the blocks.,
chap4_para167,3,The path starts at S and ends at G.,
chap4_para1670,1,,（注意，NorthAmericans的完全分解不是一个划分，因为一些人具有双重国籍。
chap4_para1670,2,,）上述3个谓词定义如下：
chap4_para1671,1,,类别也可以通过给出成员的充要条件来定义。
chap4_para1671,2,,例如，单身汉是未婚的成年男性：
chap4_para1672,1,,正如我们在本章关于自然类的附页中所讨论的，类别的严格逻辑定义通常只能用于人造的形式化概念，而非一般事物。
chap4_para1672,2,,但定义并不总是必要的。
chap4_para1673,1,,10.2.1　物理组成
chap4_para1674,1,,“一个对象是另一个对象的一部分”这样的概念并不陌生。
chap4_para1674,2,,一个人的鼻子是他脑袋的一部分，罗马尼亚是欧洲的一部分，本章是本书的一部分。
chap4_para1674,3,,我们使用一般的PartOf关系来表明一个事物是另一个事物的一部分。
chap4_para1674,4,,对象可以分组为PartOf层次结构，类似于子集层次结构：
chap4_para1675,1,,PartOf关系是传递和自反的，也就是：
chap4_para1676,1,,"因此，我们可以得出结论PartOf (Bucharest, Earth)。"
chap4_para1676,2,,复合对象（composite object）类别常被特征化为部分之间的结构关系。
chap4_para1676,3,,例如，一个两足动物是身体上恰好有两条腿的对象：
chap4_para1677,1,,“恰好有两条”的符号有点棘手，我们不得不表明存在两条腿，它们不是同一条腿，如果有人提出了第三条腿，则这条腿必然是其他两条腿中的一条。
chap4_para1677,2,,在10.5.2节，我们描述了一个被称为描述逻辑的形式体系，它能够较容易地表示类似“恰好有两条”的约束。
chap4_para1678,1,,我们可以类比类别的Partition关系，定义一个PartPartition关系。
chap4_para1678,2,,（见习题10.DECM。
chap4_para1678,3,,）一个对象由其PartPartition中的部分组成，并且可以被看作从这些部分中获得了某些性质。
chap4_para1678,4,,例如，复合对象的质量是其各部分质量的总和。
chap4_para1678,5,,注意，类别并不会出现这种情形，即使类别中的元素可能有质量，类别也没有质量。
chap4_para1679,1,,使用无特定结构的确切部分定义复合对象也是有用的。
chap4_para1679,2,,例如，我们可能想表明“袋子里的苹果重两磅”。
chap4_para1679,3,,将这个重量归入袋中苹果的集合似乎是自然的做法，但这实际上是错误的，因为集合是抽象的数学概念，它只有元素而没有重量。
chap4_para1679,4,,因此，我们需要一个新概念，我们称之为束（bunch）。
chap4_para1679,5,,例如，如果苹果是Apple1、Apple2和Apple3，则
chap4_para168,1,"Figure 4.18Possible positions of the robot, ʘ, (a) after one observation, E1= 1011, and (b) after moving one square and making a second observation, E2 = 1010. When sensors are noiseless and the transition model is accurate, there is only one possible location for the robot consistent with this sequence of two observations.",在本节中，我们将展示一个离散环境中的实例，其传感器是确定性的，动作是非确定性的。
chap4_para168,2,,这个实例中涉及的机器人具有特定的状态评估任务，该任务称为定位（localization）：即在给定世界地图和一系列感知及行动的情况下，找到自己的位置。
chap4_para168,3,,机器人放置在图4-18所示的迷宫环境中。
chap4_para168,4,,它配备了4个声呐传感器，可以判断在4个罗盘方向上是否存在障碍物——外墙或者图中的深色阴影方格。
chap4_para168,5,,感知以位向量的形式出现，每一位依次代表北、东、南、西方向，所以1011表示北、南、西方向有障碍物。
chap4_para1680,1,,表示由3个苹果作为部分（而非元素）构成的对象。
chap4_para1680,2,,之后我们就可以将束作为普通的对象来使用了，尽管它是无结构的。
chap4_para1680,3,,注意。
chap4_para1680,4,,另外，BunchOf(Apples)是由所有苹果构成的复合对象，不要将它与所有苹果的集合或苹果类别搞混了。
chap4_para1681,1,,我们可以用PartOf关系来定义BunchOf。
chap4_para1681,2,,显然，s中的每个元素都是BunchOf (s)的部分：
chap4_para1682,1,,进一步地，BunchOf (s)是满足这个条件的最小对象。
chap4_para1682,2,,也就是说，BunchOf (s)必然是所有以s中全部元素为部分的对象的部分：
chap4_para1683,1,,这些公理属于一种叫作逻辑最小化的通用技术，意味着定义满足某些条件的最小对象。
chap4_para1685,1,,不论是在关于世界的科学理论中还是常识中，物体都有高度、质量、价格之类的性质。
chap4_para1685,2,,我们分配给这些性质的值叫作量度（measure）。
chap4_para1685,3,,普通的量化量度很容易表示。
chap4_para1685,4,,我们想象宇宙中有抽象的“量度对象”，例如这条线段的长度表示的长度。
chap4_para1685,5,,我们可以将这个长度称为1.5英寸或3.81厘米。
chap4_para1685,6,,也就是说，同样的长度在我们的语言中有不同的名字。
chap4_para1685,7,,我们使用以数字作为参数的单位函数（units function）表示长度。
chap4_para1685,8,,（习题10.ALTM探讨了另一种方法。
chap4_para1685,9,,）
chap4_para1686,1,,如果这条线段称为L1，我们可以写出
chap4_para1688,1,,使用从一种单位到另一种单位的等值倍数可以进行单位之间的转换：
chap4_para1689,1,,可以对磅和千克、秒和日、美元和美分写出类似的公理。
chap4_para1689,2,,量度可以以如下方式描述对象：
chap4_para169,1,"We assume that the sensors give perfectly correct data, and that the robot has a correct map of the environment. But unfortunately, the robot’s navigational system is broken, so when it executes a Right action, it moves randomly to one of the adjacent squares. The robot’s task is to determine its current location.",图4-18　机器人的可能位置，⊙，（a）一次观测E1 = 1011后。
chap4_para169,2,,（b）移动一个方格并进行第二次观测E2 = 1010后。
chap4_para169,3,,如果传感器没有噪声且转移模型是准确的，那么只有一个可能位置与这两个观测序列一致
chap4_para1690,1,,注意，$(1)不是一美元钞票，而是价格。
chap4_para1690,2,,我们可以有两张一美元钞票，但只有一个名为$(1)对象。
chap4_para1690,3,,还需要注意的是，即使Inches(0)和Centimeters(0)都指代相同的零长度，但却不同于其他零量度，如Seconds(0)。
chap4_para1691,1,,简单且量化的量度很容易表示。
chap4_para1691,2,,其他量度则更难一些，因为它们的值没有公认的尺度。
chap4_para1691,3,,习题具有难度，甜点具有美味程度，诗歌有优美程度，而我们无法为这些量赋以数值。
chap4_para1691,4,,有人可能会完全从计算的角度出发，忽略这些性质，因为它们对于逻辑推断并没什么用处；而更糟糕的做法，则是企图为优美程度强加一个数值尺度——这是严重的错误，因为这样做完全没有必要。
chap4_para1691,5,,对量度来说，最重要的不是其特定的数值，而是它是可以被排序的。
chap4_para1692,1,,尽管量度不是数字，但我们还是可以用诸如“”之类的定序符号来比较它们。
chap4_para1692,2,,例如，我们可能都认为诺维格（Norvig）出的习题比罗素（Russell）出的习题难，而且解答难题的人得分更少：
chap4_para1693,1,,这就足以使人们决定要做哪些题，尽管其中根本没有用到难度值。
chap4_para1693,2,,（但他们必须要弄清楚每道习题是谁出的。
chap4_para1693,3,,）这种量度之间的单调关系构成了定性物理（qualitative physics）的基本要素——定性物理是人工智能的一个子领域，它研究在不使用具体方程和数值模拟的情况下如何推理物理系统。
chap4_para1693,4,,在本章的参考文献与历史注释部分，我们会讨论到定性物理。
chap4_para1695,1,,一些类别有严格的定义：一个对象是三角形，当且仅当它是有三条边的多边形。
chap4_para1695,2,,而真实世界中的大部分类别没有边界清晰的定义，它们被称为自然类（natural kind）类别。
chap4_para1695,3,,例如，番茄接近于暗红色，大致是圆形的，顶部有个原本长着藤蔓的凹坑，直径5～10厘米，有薄而硬的果皮，内部有果肉、种子和汁水。
chap4_para1695,4,,但也有例外：一些番茄是黄色或橙色的，未成熟的番茄是绿色的，一些番茄小于或大于其平均大小，而圣女果都非常小。
chap4_para1695,5,,我们没有番茄的完备定义，而是有一系列特征，它们能够用于识别一个明显是番茄的物体，但却无法明确地识别其他物体。
chap4_para1695,6,,（有没有一种像桃子一样毛茸茸的番茄？
chap4_para1695,7,,）
chap4_para1696,1,,这对逻辑智能体来说是个问题。
chap4_para1696,2,,智能体无法确定它感知到的物体是番茄，而且，即使它确定这个物体就是番茄，它也无法确定这个番茄具有哪些番茄应有的典型性质。
chap4_para1696,3,,这个问题是在部分可观测环境中运作的不可避免的结果。
chap4_para1697,1,,一种有用的方法是区分对一个类别中所有实例都为真的性质和仅对典型实例为真的性质。
chap4_para1697,2,,因此除了Tomatoes类别，我们还会有Typical(Tomatoes)类别。
chap4_para1697,3,,此处，Typical函数将类别映射到仅含有典型实例的子类：
chap4_para1698,1,,关于自然类的大部分知识实际上是关于其典型实例的：
chap4_para1699,1,,这样，我们就可以写出关于类别的有用事实而无须精确的定义。
chap4_para1699,2,,"维特根斯坦（Wittgenstein, 1953）深入解释了为大部分自然类别提供精确定义的难点。"
chap4_para1699,3,,他使用了游戏的例子来表明一个类别的成员具有“家族相似性”而非充分必要的特征：什么样的严格定义可以囊括国际象棋、木头人、单人纸牌和躲避球？
chap4_para17,1,Figure 4.,图4-4　岭为爬山法带来困难的示意图。
chap4_para17,2,3(a) The 8-queens problem: place 8 queens on a chess board so that no queen attacks another.,状态网格（蓝色圆点）叠加在从左到右上升的岭上，形成了一个彼此不直接相连的局部极大值序列。
chap4_para17,3,"(A queen attacks any piece in the same row, column, or diagonal.",从每个局部极大值出发，所有可选动作都指向下坡。
chap4_para17,4,") This position is almost a solution, except for the two queens in the fourth and seventh columns that attack each other along the diagonal.",这样的拓扑在低维状态空间中很常见，例如二维平面中的点。
chap4_para17,5,(b) An 8-queens state with heuristic cost estimate h = 17.,但是在具有成百上千个维度的状态空间中，这种直观图并不成立，而且通常至少存在几个维度使得算法有可能漏掉岭和平台区
chap4_para17,6,The board shows the value of h for each possible successor obtained by moving a queen within its column.,
chap4_para17,7,"There are 8 moves that are tied for best, with h = 12.",
chap4_para17,8,The hill-climbing algorithm will pick one of these.,
chap4_para170,1,"Suppose the robot has just been switched on, and it does not know where it is—its initial belief state b consists of the set of all locations. The robot then receives the percept 1011 and does an update using the equation bo = UPDATE(1011), yielding the 4 locations shown in Figure 4.18(a). You can inspect the maze to see that those are the only four locations that yield the percept 1011.",我们假设传感器所提供的数据完全正确，而且机器人拥有正确的环境地图。
chap4_para170,2,,但遗憾的是，机器人的导航系统发生故障，所以当它执行Right动作时，会随机移动到一个相邻方格。
chap4_para170,3,,机器人的任务是确定它的当前位置。
chap4_para1700,1,,"奎因（Quine, 1953）也质疑了严格定义的概念的有用性。"
chap4_para1700,2,,他指出，就连将“单身汉”定义为未婚成年男性都是值得怀疑的。
chap4_para1700,3,,例如，一个人完全可以质疑诸如“教皇是单身汉”这样的陈述。
chap4_para1700,4,,尽管这种用法严格意义上并没有错，但这肯定是不妥当的，因为这会引起部分听众的无端猜忌。
chap4_para1700,5,,将用于内部知识表示的逻辑定义与更微妙的恰当措辞准则区分开来也许能够解决这种矛盾。
chap4_para1700,6,,后者可以通过“过滤”前者推得的断言得出。
chap4_para1700,7,,措辞的失误也可以用作修正内部定义的反馈，这样，过滤也就不再必要了。
chap4_para1701,1,,10.2.3　对象：事物和物质
chap4_para1702,1,,真实世界可以看作由基本对象（如原子粒子）和由其构建的复合对象组成的。
chap4_para1702,2,,通过在诸如苹果和汽车之类的大对象层面进行推理，我们可以避免逐个处理大量基本对象的麻烦。
chap4_para1702,3,,但现实中的很大一部分东西似乎不能被个体化（individuation），也就是将其细分为不同的组成对象。
chap4_para1702,4,,我们给这部分东西起名为物质。
chap4_para1702,5,,例如，假设我面前有一些黄油和一只食蚁兽。
chap4_para1702,6,,我们可以说这有一只食蚁兽，但却无法说出“黄油对象”的明确数量，因为一个黄油对象的任何一部分也是黄油对象——至少在我们将其分为极小的部分之前是这样。
chap4_para1702,7,,这是物质和事物的主要区别。
chap4_para1702,8,,如果我们将食蚁兽砍成两半，（很遗憾）我们并不能得到两只食蚁兽。
chap4_para1703,1,,英语能清晰地区分事物（thing）和物质（stuff）。
chap4_para1703,2,,我们说“一只食蚁兽”，但除了在加利福尼亚州那些故弄玄虚的餐馆里面，我们并不能说“一个黄油”。
chap4_para1703,3,,语言学家将食蚁兽、洞穴、定理之类的可数名词与黄油、水、能量之类的不可数名词区别开来。
chap4_para1703,4,,一些相互竞争的本体论都宣称它们能够处理这种区别。
chap4_para1703,5,,此处我们只描述其中一种，其他本体论则在本章的参考文献与历史注释部分讨论。
chap4_para1704,1,,要妥当地表示物质，我们从最浅显的情形开始。
chap4_para1704,2,,在我们的本体论中至少也要将“一块”物质作为对象，以便与之互动。
chap4_para1704,3,,例如，我们可能认得前一晚丢在桌上的那块黄油；我们可以把它捡起来，给它称重，或把它卖掉之类的。
chap4_para1704,4,,从这种意义上考虑，它就是与食蚁兽一样的对象。
chap4_para1704,5,,我们不妨称其为Butter3。
chap4_para1704,6,,我们还定义了Butter类别。
chap4_para1704,7,,非正式地，它的元素就是我们可能说“这是黄油”的东西，包括Butter3。
chap4_para1704,8,,在暂且忽略物质的极小部分的情况下，一个黄油对象的任何一部分也是黄油对象：
chap4_para1705,1,,现在我们就可以说黄油在大约30℃时融化：
chap4_para1706,1,,我们还可以说黄油是黄色的，密度比水小，在室温下是软的，含有很多脂肪，等等。
chap4_para1706,2,,另外，黄油没有特定的大小、形状或重量。
chap4_para1706,3,,我们可以为黄油定义更为专门的类别，如无盐黄油（UnsaltedButter），它也是一种物质。
chap4_para1706,4,,注意，一磅黄油（PoundOfButter）这个类别，它包含所有重量为一磅的黄油对象，却不是一种物质。
chap4_para1706,5,,很遗憾，我们将一磅黄油切成两半并不能得到两磅黄油。
chap4_para1707,1,,实际上，一些性质是固有的，它们属于对象的物质，而非对象这个整体。
chap4_para1707,2,,当你将一种具体的物质切成两半，这两半仍保留其固有性质，如其密度、沸点、味道、颜色、隶属关系等。
chap4_para1707,3,,而外在的性质，如重量、长度、形状之类的，在分割后并不能维持不变。
chap4_para1707,4,,因此，定义中只有固有性质的对象类别是物质，或不可数名词；而定义中含有任何外在性质的类别则是可数名词。
chap4_para1707,5,,物质和事物分别是最一般的物质类别和对象类别。
chap4_para1709,1,,在7.7.1节我们讨论了动作，它是可以发生的事情，如Shoott；我们还讨论了流，它是世界中变化的部分，如HaveArrowt。
chap4_para1709,2,,它们都用命题表示，我们使用了后继状态公理来表示如果时刻t的动作使一个流为真，或在时刻t这个流已经为真且此时的动作不使其为假的话，则这个流在时刻t+1为真。
chap4_para1709,3,,这是对动作是离散的、瞬时的、每个时刻只发生一次的，且只有一种实行方式（也就是说，只有一种射击动作，迅速射击、缓慢射击、紧张地射击之间没有区别）的世界而言的。
chap4_para171,1,"Next the robot executes a Right action, but the result is nondeterministic. The new belief state, ba = PREDICT(bo, Right), contains all the locations that are one step away from the locations in bo. When the second percept, 1010, arrives, the robot does UPDATE(ba, 1010) and finds that the belief state has collapsed down to the single location shown in Figure 4.18(b). That’s the only location that could be the result of",假设机器人刚刚启动，并不知道自己的位置——那么它的初始信念状态b为包含所有位置的集合。
chap4_para171,2,,接着机器人接收到感知1011，并使用公式bo = Update(1011)进行更新，得到如图4-18a所示的4个位置。
chap4_para171,3,,查看整个迷宫你会发现这是仅有的4个可以产生感知1011的位置。
chap4_para1710,1,,但当我们从简化的论域移步到真实世界中，要处理的动作和事件[3]范围就大得多了。
chap4_para1710,2,,考虑一个连续动作，如灌满浴缸。
chap4_para1710,3,,一条后继状态公理可以表明在动作前浴缸是空的，在动作完成后浴缸满了，但它无法讨论在动作进行中发生了什么。
chap4_para1710,4,,它也无法轻易地描述同时发生的两个动作——例如在等待浴缸灌满的时候刷牙。
chap4_para1710,5,,要处理这类情形，我们引入一种称为事件演算（event calculus）的方法。
chap4_para1712,1,,[3]　术语“事件”和“动作”可以互相代替——它们的意思都是 “可以发生的事情”。
chap4_para1713,1,,事件演算的对象是事件、流和时间点。
chap4_para1713,2,,"At(Shankar, Berkeley)是一个流，也就是指代Shankar在伯克利这个事实的对象。"
chap4_para1713,3,,Shankar从旧金山飞往华盛顿特区的事件E1描述为
chap4_para1714,1,,其中Flyings是所有飞行事件的类别。
chap4_para1714,2,,通过对事件进行物化，我们能够对事件添加任意数量的任意信息。
chap4_para1714,3,,例如，我们可以用Bumpy(E1)说明Shankar的航班很颠簸。
chap4_para1714,4,,在一个事件为n元谓词的本体论中，我们无法添加类似这样的额外信息——为此将本体论中的事件改为n+1元谓词并不是一个具有拓展性的解决方法。
chap4_para1715,1,,要断言在时刻t1某处开始延续到t2的流实际为真，我们使用谓词T，如 。
chap4_para1715,2,,类似地，我们使用来表明事件E1实际发生了，它从时刻t1开始，结束于t2。
chap4_para1715,3,,事件演算版本[4]的完整谓词集为
chap4_para1717,1,,"[4]　我们的版本基于（Shanahan, 1999），但做了一些改动。"
chap4_para1718,1,,我们可以将飞行事件的效果描述为
chap4_para1719,1,,我们假设一个特定事件Start，它通过表明在起始时刻时哪些流为真（用Initiates）哪些流为假（用Terminated）描述了初始状态。
chap4_para1719,2,,这样我们就可以用一对关于T和的、符合一般后继状态公理形式的公理描述哪个流在何时为真：假设一个事件在时刻t1和t3之间发生，而在该时段内的某时刻t2，该事件通过启动流（使其为真）或终止流（使其为假）改变了流f的值。
chap4_para1719,3,,则在未来的某个时刻t4，如果没有其他事件改变过流（不论是启动流还是终止流），流的值保持不变。
chap4_para1719,4,,形式上，这些公理是
chap4_para172,1,"With nondeterministic actions the PREDICT step grows the belief state, but the UPDATE step shrinks it back down—as long as the percepts provide some useful identifying information. Sometimes the percepts don’t help much for localization: If there were one or more long east-west corridors, then a robot could receive a long sequence of 1010 percepts, but never know where in the corridor(s) it was. But for environments with reasonable variation in geography, localization often converges quickly to a single point, even when actions are nondeterministic.",接下来，机器人执行Right动作，但结果是非确定性的。
chap4_para172,2,,"新的信念状态，ba = Predict(bo, Right)，包含了与bo中的位置相邻的所有位置。"
chap4_para172,3,,"当接收到第二个感知1010时，机器人执行Update(ba, 1010)，此时信念状态已经只剩图4-18b所示的一个位置。"
chap4_para172,4,,这是下式得到的唯一位置：
chap4_para1720,1,,其中Terminated和Initiates定义为
chap4_para1721,1,,我们可以拓展事件演算来表示同时发生的事件（例如玩跷跷板需要两人同时进行）、外因事件（例如风吹动物体）、连续事件（例如涨潮）、非确定性事件（例如抛硬币得到正面或反面）以及其他复杂事件。
chap4_para1723,1,,事件演算提供了表示时间点和时间间隔的可能性。
chap4_para1723,2,,我们考虑两种时间间隔：瞬间和延续间隔。
chap4_para1723,3,,它们的区别是，只有瞬间的持续时间为0：
chap4_para1724,1,,下面我们发明一种时间尺度，并将尺度上的点关联到瞬间，以确定绝对时间。
chap4_para1724,2,,时间尺度可以是任意的，我们选择用秒来度量，并指定格林尼治标准时1900年1月1日午夜瞬间为时间0。
chap4_para1724,3,,函数Begin和End输出一个间隔的最早瞬间和最晚瞬间，函数Time则将瞬间转换为时间尺度上的点。
chap4_para1724,4,,函数Duration给出开始时间和结束时间之间的差值。
chap4_para1725,1,,为利于读出数字，我们还引入了Date函数，它使用6个参数（小时、分钟、秒、日、月、年）并返回一个时间点：
chap4_para1726,1,,两个间隔中，如果第一个间隔的结束时间与第二个间隔的开始时间相等，则两个间隔相接（Meet）。
chap4_para1726,2,,"间隔关系的完整集合（Allen, 1983）如下（以及图10-2）："
chap4_para1727,1,,它们各自的含义都很直观，除了Overlap：我们倾向于认为重叠是对称的（如果i与j重叠，则j与i重叠），但根据其定义，仅在i早于j开始时为真。
chap4_para1727,2,,经验表明，这样定义对制定公理更加有用。
chap4_para1727,3,,要表明英国女王伊丽莎白二世（Elizabeth Ⅱ）的统治紧接着乔治六世（George Ⅵ）的统治，而猫王埃尔维斯（Elvis）主宰乐坛的时间与20世纪50年代重叠，我们可以将其写作
chap4_para1728,1,,图10-2　时间间隔的谓词
chap4_para1729,1,,10.3.2　流和对象
chap4_para173,1,What happens if the sensors are faulty?,对于非确定性动作，Predict阶段信念状态增加，但是Update阶段信念状态又减少回去——只要感知提供了有用的识别信息。
chap4_para173,2,"If we can reason only with Boolean logic, then we have to treat every sensor bit as being either correct or incorrect, which is the same as having no perceptual information at all.",有时感知对定位帮助不大：如果存在一个或多个很长的东西向走廊，那么机器人可能会接收到一个很长的1010感知序列，但它永远不会知道它在走廊的哪一位置。
chap4_para173,3,"But we will see that probabilistic reasoning (Chapter 12), allows us to extract useful information from a faulty sensor as long as it is wrong less than half the time.",但对于地理上存在合理差异的环境，定位往往会迅速收敛到单个点，即使动作是非确定性的。
chap4_para1730,1,,从对象是一部分时空的角度来看，对象可以被看作一般化的事件。
chap4_para1730,2,,例如，美国（USA）可以被当成是一个事件，它从1776年开始，由起初13个州的联合发展为50个州的联合，并仍在持续发展。
chap4_para1730,3,,我们可以将美国的变化性质描述为状态流，例如Population(USA)。
chap4_para1730,4,,美国的一个每4年或8年变化一次的性质——不出意外的话——是它的总统。
chap4_para1730,5,,有人可能提出，President(USA)是一个在不同时间表示不同对象的逻辑项。
chap4_para1731,1,,遗憾的是，这根本不可能。
chap4_para1731,2,,因为在给定的模型结构中，一个项只能表示一个对象。
chap4_para1731,3,,"（根据t的值，President(USA, t)项可以表示不同的对象，但我们的本体论中时间与流是分离的。"
chap4_para1731,4,,）唯一的可能是President(USA)表示单个对象，这个对象在不同的时间由不同的人组成。
chap4_para1731,5,,这个对象从1789年至1797年是乔治·华盛顿，从1797年至1801年是约翰·亚当斯，以此类推，如图10-3所示。
chap4_para1731,6,,要表示乔治·华盛顿是整个1790年的总统，我们可以写作
chap4_para1732,1,,我们用函数符号Equals而非标准逻辑谓词=，因为我们无法以谓词作为T的参数，还因为正确的解释并不是GeorgeWashington和President(USA)在1790年逻辑等价——逻辑等价并不能随时间改变。
chap4_para1732,2,,实际情况是，1790年这个时段所定义的对象President(USA)的子事件和GeorgeWashington的子事件具有等价关系。
chap4_para1733,1,,图10-3　早期President(USA)对象示意图
chap4_para1734,1,,10.4　精神对象和模态逻辑
chap4_para1735,1,,我们目前为止所构建的智能体具有信念，且能够推导新信念。
chap4_para1735,2,,但它们都不具有关于信念或推导的知识。
chap4_para1735,3,,关于自身所具有的知识和推导过程的知识对控制推断非常有用。
chap4_para1735,4,,例如，假设甲问道“1764的平方根是多少”，而乙回答“我不知道”。
chap4_para1735,5,,如果甲坚持道“再想一想”，乙应当意识到通过进一步思考其实可以回答这个问题。
chap4_para1735,6,,但是，如果甲提出的问题是“总统现在是坐着还是站着？
chap4_para1735,7,,”那么乙应当明白再怎么思考都不太会有作用。
chap4_para1735,8,,知道其他智能体所具有的知识也很重要，乙应当意识到总统自己肯定知道答案。
chap4_para1736,1,,我们需要的是智能体大脑中（或知识库中）的精神对象和操纵这些精神对象的精神过程的模型。
chap4_para1736,2,,这个模型不需要非常具体。
chap4_para1736,3,,我们并不需要预测某个智能体进行推断需要多少毫秒，我们只需要能够得出“妈妈知道她自己是不是坐着”的结论就可以。
chap4_para1737,1,,我们从智能体对精神对象所具有的命题态度（propositional attitude）开始：类似于相信（Believes）、知道（Knows）、想要（Wants）、通知（Informs）这样的态度。
chap4_para1737,2,,难处在于，这些态度的行为与“普通”谓词不同。
chap4_para1737,3,,例如，假设我们试图断言露易丝知道超人会飞：
chap4_para1738,1,,这种说法的一个小毛病是，我们通常将CanFly(Superman)当作语句，但这里它是一个项。
chap4_para1738,2,,我们可以通过物化CanFly(Superman)来修补这个问题，也就是将它变成流。
chap4_para1738,3,,但更严重的问题是，如果超人是克拉克·肯特为真，那么我们只能得出露易丝知道克拉克会飞，而这是错误的，因为（在大多数版本的故事中）露易丝不知道克拉克就是超人。
chap4_para1738,4,,[5]
chap4_para174,1,4.,如果传感器发生故障怎么办？
chap4_para174,2,5Online Search Agents and Unknown Environments,如果我们只能用布尔逻辑进行推理，那么我们就无法判断每个传感器位的正误，相当于没有任何感知信息。
chap4_para174,3,,但我们将看到，概率推理（第12章）允许我们从故障传感器中提取有用信息，只要它出错的时间不超过一半。
chap4_para1740,1,,[5]　超人（Superman）是美国漫画角色。
chap4_para1740,2,,根据漫画情节，超人出生于地外星球，具有超能力，在地球以记者克拉克•肯特（Clark Kent）的身份掩藏自己就是超人的事实。
chap4_para1740,3,,露易丝•莱恩（Lois Lane）是克拉克•肯特的记者同事，同时也是超人迷。
chap4_para1740,4,,在较早期的情节中，露易丝并不知道同事克拉克就是超人。
chap4_para1740,5,,——译者注
chap4_para1741,1,,这是构建在逻辑之中的等值推理的结论。
chap4_para1741,2,,通常这并不是一件坏事，如果我们的智能体知道2 + 2 = 4且4 5，我们就希望智能体知道2 + 2 5。
chap4_para1741,3,,这个性质称为指代透明性（referential transparency）——一种逻辑使用哪个项指代一个对象并不重要，重要的是这个项所指的对象。
chap4_para1741,4,,但对于像相信和知道这样的命题态度，我们需要指代不透明性——使用的项很重要，因为并非所有智能体都知道哪些项是指代同一个对象的。
chap4_para1742,1,,我们可以用进一步物化的方式修补这个问题：我们可以让一个对象表示作为超人的那个克拉克，另一个对象表示露易丝所认识的那个克拉克，我们还需要一个对象表示露易丝所认识的超人。
chap4_para1742,2,,但对象数量的激增意味着我们本来希望能快速写出的语句变得唠叨又笨拙。
chap4_para1743,1,,模态逻辑就是为解决这个问题而产生的。
chap4_para1743,2,,正规逻辑关注于单模态，真值模态使我们可以表示“P为真”或“P为假”。
chap4_para1743,3,,模态逻辑含有以语句（而非项）为参数的模态算子（modal operator）。
chap4_para1743,4,,例如，“A认识P”使用记法KAP表示，其中K是知识的模态算子。
chap4_para1743,5,,它使用两个参数，一个是智能体（以下标表示），另一个是语句。
chap4_para1743,6,,模态逻辑的语法与一阶逻辑基本相同，区别在于模态逻辑中的语句可以用模态算子构成。
chap4_para1744,1,,模态逻辑的语义更为复杂。
chap4_para1744,2,,在一阶逻辑中，一个模型含有一个对象集和将每个名称映射到正确的对象、关系或函数的解释。
chap4_para1744,3,,模态逻辑中，我们希望能够同时考虑到超人的秘密身份是克拉克的可能性和超人不是克拉克的可能性。
chap4_para1745,1,,因此，我们需要更为复杂的模型，它含有一系列可能世界（possible world），而非只有一个为真的世界。
chap4_para1745,2,,这些世界在一个图中以可达性关系（accessibility relation）连接，每个模态算子都对应一个这样的关系。
chap4_para1745,3,,如果w1中的一切都与A在w0中所知道的东西一致，我们就说从世界w0关于模态算子KA可达世界w1。
chap4_para1745,4,,举一个现实世界中的例子，布加勒斯特是罗马尼亚的首都，但对于不知道这一事实的智能体来说，罗马尼亚首都位于（例如）索非亚的世界就是可达的。
chap4_para1745,5,,但愿所有智能体都不可达2 + 2 = 5的世界。
chap4_para1746,1,,一般而言，一个知识原子KAP在世界w中为真，当且仅当在从w可达的所有世界中P都为真。
chap4_para1746,2,,更复杂的语句的真值是通过递归应用这条规则以及一阶逻辑的一般规则来推导的。
chap4_para1746,3,,这意味着模态逻辑可以用于推理嵌套知识语句：一个智能体对另一个智能体的知识知道多少。
chap4_para1746,4,,例如，我们可以说露易丝虽然不知道超人的秘密身份是否就是克拉克·肯特，但她知道克拉克本人知道超人的秘密身份是什么：
chap4_para1747,1,,模态逻辑解决了一些涉及量词和知识互相作用的麻烦问题。
chap4_para1747,2,,英语句子“Bond knows that someone is a spy”（邦德知道某个人是间谍）是有歧义的。
chap4_para1747,3,,第一种解读是邦德知道某个特定的人是间谍，我们可以将其写作
chap4_para1748,1,,这在模态逻辑中的意思是，存在一个x，在所有可达世界中邦德都知道这个x是间谍。
chap4_para1748,2,,第二种解读是，邦德只知道至少有一个间谍：
chap4_para1749,1,,它的模态逻辑解释是，在所有可达世界中，都有一个间谍x，但它在不同世界中未必是相同的x。
chap4_para175,1,"So far we have concentrated on agents that use offline search algorithms. They compute a complete solution before taking their first action. In contrast, an online search8 agent interleaves computation and action: first it takes an action, then it observes the environment and computes the next action. Online search is a good idea in dynamic or semi-dynamic environments, where there is a penalty for sitting around and computing too long. Online search is also helpful in nondeterministic domains because it allows the agent to focus its computational efforts on the contingencies that actually arise rather than those that might happen but probably won’t.",4.5　在线搜索智能体和未知环境
chap4_para1750,1,,我们现在有了知识的模态算子，就可以为其写出公理。
chap4_para1750,2,,首先，我们可以说智能体能够进行推论：如果一个智能体知道P且知道P蕴涵Q，则该智能体知道Q：
chap4_para1751,1,,由此（以及其他一些关于逻辑等价性的规则）我们可以得出是重言式：所有智能体都知道每个命题P要么为真要么为假。
chap4_para1751,2,,但是，不是重言式；一般而言，对于很多命题，智能体既不知其为真，也不知其为假。
chap4_para1752,1,,人们说（以柏拉图最先提出）知识是确证为真的信念。
chap4_para1752,2,,也就是说，如果一个事物为真，如果你相信它为真，而且如果你有无法反驳的好理由来说明它为真，那么你就知道这个事物。
chap4_para1752,3,,这意味着如果你知道某事，那么它必然为真。
chap4_para1752,4,,据此我们有公理：
chap4_para1753,1,,进一步地，逻辑智能体（但并非所有人）都能够内省自己的知识。
chap4_para1753,2,,如果它们知道某事，则它们知道“它们知道这事”：
chap4_para1754,1,,我们可以为信念（通常用B表示）和其他模态定义类似的公理。
chap4_para1754,2,,但模态逻辑方法的一个问题是它假设了智能体的逻辑全知（logical omniscience）。
chap4_para1754,3,,也就是说，如果智能体知道一个公理集，则它知道这些公理的所有结论。
chap4_para1754,4,,即使对于知识的较为抽象的概念这个前提都相当不牢靠，更别提对于信念了，因为信念更常涉及在智能体中被实际表示出来的东西，而非仅仅是可推导的东西。
chap4_para1755,1,,有人尝试过为智能体定义某种有限理性形式——让智能体只能相信那些不超过k个推理步骤或不超过s秒计算就能推导出来的断言。
chap4_para1755,2,,这些尝试基本都不能令人满意。
chap4_para1757,1,,除了针对知识的模态逻辑，还有许多其他针对不同模态的模态逻辑被提出。
chap4_para1757,2,,一种提法是为可能性和必然性添加模态运算符：本书的某个作者现在可能是坐着的，而2 + 2 = 4必然为真。
chap4_para1758,1,,如8.1.2节所述，一些逻辑学家青睐于关于时间的模态。
chap4_para1758,2,,在线性时态逻辑（linear temporal logic）中，我们添加如下模态算子：
chap4_para1759,1,,● X P：“P在下一个时刻将为真”
chap4_para176,1,"Of course, there is a tradeoff: the more an agent plans ahead, the less often it will find itself up the creek without a paddle.",到目前为止，我们主要关注使用离线搜索（offline search）算法的智能体。
chap4_para176,2,"In unknown environments, where the agent does not know what states exist or what its actions do, the agent must use its actions as experiments in order to learn about the environment.",它们在执行第一个动作之前就已经计算出一个完整的解。
chap4_para176,3,,相比之下，在线搜索（online search）[8]智能体则交替进行计算和动作：它首先执行一个动作，然后观测环境并计算下一个动作。
chap4_para176,4,,在线搜索适用于动态或半动态环境，因为在这些环境中停止不动或计算时间太长都要付出代价。
chap4_para176,5,,在线搜索在非确定性领域也很有用，因为它允许智能体将计算精力集中在实际发生的偶然事件上，而不是那些也许会发生但很可能不会发生的事件。
chap4_para1760,1,,● F P：“P最终（Finally）将在未来某个时刻为真”
chap4_para1761,1,,● G P：“P始终（Globally）为真”
chap4_para1762,1,,● P U Q：“在Q发生前P保持为真”
chap4_para1763,1,,有时可以从这些算子推导出其他算子。
chap4_para1763,2,,增加这些模态算子使逻辑自身变得更为复杂（也就使逻辑推断算法更难找出证明）。
chap4_para1763,3,,但这些算子使我们能够更简洁地陈述某些事实（这使得逻辑推断更快）。
chap4_para1763,4,,选择要用哪种逻辑类似于选择要用哪种编程语言：选择适合你任务的那一个，选择你和你的合作者更熟悉的那一个，选择对你的目的足够有效的那一个。
chap4_para1764,1,,10.5　类别的推理系统
chap4_para1765,1,,类别是大规模知识表示系统最重要的构造模块。
chap4_para1765,2,,本节描述为类别的组织和推理专门设计的系统。
chap4_para1765,3,,有两类密切相关的系统：语义网络（semantic network）从图的角度为知识库的可视化提供辅助，并基于对象的类别从属为推断对象的属性提供高效算法；描述逻辑（description logic）为构建和合一类别的定义提供形式化语言，并为确定类别间的子集和超集关系提供高效算法。
chap4_para1766,1,,10.5.1　语义网络
chap4_para1767,1,,1909年，查尔斯·皮尔斯（Charles S. Peirce）提出了一种称为存在图（existential graph）的、由边和节点构成的图表示，他称之为“未来的逻辑”。
chap4_para1767,2,,由此开启了一场提倡“逻辑”者和提倡“语义网络”者之间的长期争论。
chap4_para1767,3,,遗憾的是，争论掩盖了语义网络也是一种逻辑的事实。
chap4_para1767,4,,语义网络为某些语句提供的记法往往更方便，但如果我们排除了“人类界面”的因素，其底层概念（即对象、关系、量化等）是相同的。
chap4_para1768,1,,语义网络有很多变种，但它们都能表示单个对象、对象的类别和对象之间的关系。
chap4_para1768,2,,典型的记法将对象名称显示于椭圆或方框中，并以带标签的连线连接它们。
chap4_para1768,3,,"例如，图10-4在Mary和FemalePersons之间有MemberOf连线，对应于逻辑断言；类似地，Mary和John之间的SisterOf连线对应于断言SisterOf(Mary, John)。"
chap4_para1768,4,,我们可以使用SubsetOf连线连接类别，以此类推。
chap4_para1768,5,,画出气泡和箭头很有趣，但不要忘乎所以。
chap4_para1768,6,,例如，我们知道，人的母亲是女性，但我们可以从Persons画一条HasMother连线连到FemalesPersons上吗？
chap4_para1768,7,,答案是不行，因为HasMother是人和其母亲之间的关系，而类别并没有母亲。
chap4_para1768,8,,[6]
chap4_para177,1,"A canonical example of online search is the mapping problem: a robot is placed in an unknown building and must explore to build a map that can later be used for getting from A to B. Methods for escaping from labyrinths—required knowledge for aspiring heroes of antiquity—are also examples of online search algorithms. Spatial exploration is not the only form of online exploration, however. Consider a newborn baby: it has many possible actions but knows the outcomes of none of them, and it has experienced only a few of the possible states that it can reach.",
chap4_para1770,1,,[6]　一些早期的系统无法区分类别成员的属性和整个类别的属性。
chap4_para1770,2,,"这会直接引发不一致性，如德鲁•麦克德莫特（Drew McDermott）（McDermott, 1976）在文章“Artificial Intelligence Meets Natural Stupidity”所指出。"
chap4_para1770,3,,另一个常见的问题是对子集和成员关系都使用了IsA（是）连线，对应于英语用法“猫是哺乳动物”和“菲菲是猫”。
chap4_para1770,4,,见习题10.NATS了解更多关于这一主题的知识。
chap4_para1771,1,,因此，我们在图10-4中使用了双方框这样的特殊记法。
chap4_para1771,2,,这个连线断言了
chap4_para1772,1,,我们可能还想断言人有两条腿，也就是
chap4_para1773,1,,如前所述，我们需要当心，以免断言某个类别有两条腿；图10-4中的单方框用于断言一个类别中每个成员都具有的属性。
chap4_para1774,1,,语义网络的记法很便于进行10.2节介绍的继承推理。
chap4_para1774,2,,例如，作为一个人，玛丽继承了具有两条腿的属性。
chap4_para1774,3,,因此，要搞清楚玛丽有几条腿，继承算法追溯从Mary到其所属类别的MemberOf连线，然后跟着SubsetOf连线向上层移动，直到它找到连线是带方框的Legs的类别——本例中为Persons类别。
chap4_para1774,4,,对比于半可判定的逻辑定理证明，这种推断机制的简洁性和高效性是语义网络具有吸引力的主要原因之一。
chap4_para1775,1,,图10-4　具有4个对象（John、Mary、1和2）和4个类别的语义网络。
chap4_para1775,2,,关系使用带标签的连线表示
chap4_para1776,1,,当对象可以属于不止一个类别，或当类别可以是不止一个类别的子类时，继承就会变得较为复杂，这被称为多重继承（multiple inheritance）。
chap4_para1776,2,,这种情况下，继承算法可能会为查询找到两个甚至更多个互相冲突的值。
chap4_para1776,3,,因此，一些在类的层次结构中使用继承的面向对象编程（object-oriented programming，OOP）禁止多重继承，如Java。
chap4_para1776,4,,在语义网络中通常允许多重继承，但我们在10.6节再对其进行讨论。
chap4_para1777,1,,读者可能已经注意到了语义网络表示相比于一阶逻辑的一个明显的缺点：气泡之间的连线只能表示二元关系。
chap4_para1777,2,,"例如，语句Fly(Shankar, NewYork, NewDelhi, Yesterday)无法直接从语义网络中断言。"
chap4_para1777,3,,不过我们可以通过将命题自身物化为属于合适的事件类别的事件来得到n元断言的效果。
chap4_para1777,4,,图10-5展示了这个事件的语义网络结构。
chap4_para1777,5,,注意，二元关系的限制条件迫使网络创造出大量物化概念的本体论。
chap4_para1778,1,,"图10-5　一个语义网络的一部分，展示了对逻辑断言Fly(Shankar, NewYork, NewDelhi, Yesterday)的表示"
chap4_para1779,1,,命题的物化使得在语义网络记法中表示所有基本的、无函数的一阶逻辑原子语句成为可能。
chap4_para1779,2,,某些全称量化的语句可以使用反向连线并对类别使用单框或双框的箭头来断言，但这仍然远不及完整的一阶逻辑。
chap4_para1779,3,,否定、析取、嵌套函数符号和存在量词都无法表示。
chap4_para1779,4,,扩展记法使语义网络等价于一阶逻辑是可能的（如皮尔斯的存在图），但这样会损失语义网络的一个重要优点，也就是推断过程的简洁性和透明性。
chap4_para1779,5,,设计者可以构建很大的网络，同时仍然能够很好地了解哪些查询是高效的，因为（a）将推断过程行进的步骤可视化相当简单，（b）某些情况下查询语言非常简单，以至于无法提出高难度的查询。
chap4_para178,1,4.,[8]　这里的“在线”指的是必须在接收到输入时立即进行处理的算法，而不是等待整个输入数据集都可用时再进行处理。
chap4_para178,2,5.,“在线”的这种用法与“因特网连接”的概念无关。
chap4_para178,3,1Online search problems,
chap4_para1780,1,,当表达能力确实太有限时，许多语义网络系统提供了过程式附件（procedural attachment）来弥补。
chap4_para1780,2,,过程式附件是一种技术，它使得涉及某些关系的查询（有时是断言）能够调用专用于处理这种关系的过程，而非一般的推断算法。
chap4_para1781,1,,语义网络很重要的一个方面是它具有表示类别的缺省值（default value）的能力。
chap4_para1781,2,,仔细考察图10-4，我们注意到约翰有一条腿，尽管他是一个人，而人都有两条腿。
chap4_para1781,3,,在严格的逻辑知识库中，这会导致矛盾，但在语义网络中，这种“人都有两条腿”的断言只是具有缺省状态，也就是说，我们预设人有两条腿，除非有与之矛盾的、更为确切的信息。
chap4_para1781,4,,很自然地，缺省语义由继承算法执行，因为它从对象自身（本例中为John）沿着连线向上运行，一旦找出一个值就停止运行。
chap4_para1781,5,,我们说缺省值被更确切的值覆盖（overridden）了。
chap4_para1781,6,,注意，我们也可以通过创建John所在的Persons类别的子类OneLeggedPerson（一条腿的人）来覆盖缺省的腿数量。
chap4_para1782,1,,如果我们表明了对Person的Legs断言在John这里有例外，就可以维持网络的严格逻辑语义：
chap4_para1783,1,,对于固定的网络，这样做在语义上没有问题，但如果例外太多的话，其简洁性就远不如网络记法。
chap4_para1783,2,,但对于需要用新断言更新的网络，这样做就不可行——我们实际想表明的是目前还不知道是谁的那些只有一条腿的人也是例外。
chap4_para1783,3,,10.6节更深入地探讨了这个话题，还探讨了一般的缺省推理。
chap4_para1784,1,,10.5.2　描述逻辑
chap4_para1785,1,,一阶逻辑的语法旨在简化对对象的描述。
chap4_para1785,2,,描述逻辑则是旨在简化对类别的定义和性质的描述的记法。
chap4_para1785,3,,描述逻辑系统是从语义网络演化而来的，目的是在维持分类结构作为组织原则的同时形式化网络的含义。
chap4_para1786,1,,描述逻辑的主要推断任务是包容（subsumption）（通过比较定义来检查一个类别是否是另一个类别的子集）和分类（classification）（检查一个对象是否属于某个类别）。
chap4_para1786,2,,一些系统还纳入了类别定义的一致性（consistency）——成为该类别成员的条件是否是逻辑可满足的。
chap4_para1787,1,,"Classic语言（Borgida et al., 1989）是典型的描述逻辑。"
chap4_para1787,2,,Classic描述的语法展示在图10-6中。
chap4_para1787,3,,[7]例如，要说单身汉是未婚成年男性，可以写作
chap4_para1789,1,,[7]　注意，这个语言不允许我们直接陈述一个概念或类别是另一个概念或类别的子集。
chap4_para1789,2,,这是刻意为之的：类别之间的包容关系必须可以由类别描述的某些方面推导得来。
chap4_para1789,3,,如果无法推导，说明描述不完整。
chap4_para179,1,"An online search problem is solved by interleaving computation, sensing, and acting. We’ll start by assuming a deterministic and fully observable environment (Chapter 16 relaxes these assumptions) and stipulate that the agent knows only the following:",当然，这里需要权衡：智能体提前规划得越多，发现自己陷入困境的频率越低。
chap4_para179,2,,在未知环境中，智能体不清楚存在什么状态或者动作会产生什么结果，必须使用自身的动作作为实验来了解环境。
chap4_para1790,1,,一阶逻辑中的等价形式为
chap4_para1791,1,,图10-6　Classic语言的一个子集中的描述语法
chap4_para1792,1,,注意，描述逻辑具有对谓词的代数运算，一阶逻辑中显然没有这种东西。
chap4_para1792,2,,Classic中的任何描述都可以翻译为等价的一阶逻辑语句，但一些描述在Classic中更为直接。
chap4_para1792,3,,例如，要描述这样一个男人的集合，其中每个男人至少有3个儿子，至多有2个女儿，这些儿子都无业且都娶了医生，这些女儿都是物理或数学系教授，我们可以将其写作
chap4_para1793,1,,将其翻译为一阶逻辑是我们的一道习题。
chap4_para1794,1,,也许描述逻辑最重要的一点是它对推断易处理性的强调。
chap4_para1794,2,,一个问题实例可以通过对其进行描述并查看它是否被几个可能的解类别所包容来求解。
chap4_para1794,3,,在标准的一阶逻辑中，往往不可能预测求解时长。
chap4_para1794,4,,用户经常需要修改表示方法，以避免那些可能导致系统花几个星期求解问题的语句集。
chap4_para1794,5,,而描述逻辑很棒的地方是它保证包容检测可以在描述规模的多项式时间内求解。
chap4_para1794,6,,[8]
chap4_para1796,1,,[8]　实际中，Classic提供了高效的包容检测，但其最坏情况运行时间是指数级的。
chap4_para1797,1,,这乍听起来不错，直到我们发觉它只会导致两个后果之一：要么完全无法陈述困难的问题，要么需要指数级的大规模描述！
chap4_para1797,2,,不过，易处理的结果指明了哪些构件引发了问题，也有助于使用者理解不同表示的行为。
chap4_para1797,3,,例如，描述逻辑通常缺乏否定和析取。
chap4_para1797,4,,它们都使一阶逻辑系统不得不进行潜在的指数级的情况分析来确保完备性。
chap4_para1797,5,,Classic仅在Fills和OneOf构件中使用有限的析取，它允许对显式枚举出的个体使用析取，而不能析取描述。
chap4_para1797,6,,如果有描述的析取的话，嵌套定义能轻易导致指数量级的、表示一个类别包容另一个类别的分支路径。
chap4_para1798,1,,10.6　用缺省信息推理
chap4_para1799,1,,在前一节中，我们见过一个使用缺省状态进行断言的简单例子：人有两条腿。
chap4_para1799,2,,这个缺省信息可以被更确切的信息覆盖，例如Long John Silver[9]只有一条腿。
chap4_para1799,3,,我们看到，语义网络的继承机制用简单自然的方式实现了对缺省信息的覆盖。
chap4_para1799,4,,本节我们用更一般化的方式研究缺省信息，以期理解缺省信息的语义，而非仅给出其过程性机制。
chap4_para18,1,Hill climbing is sometimes called greedy local search because it grabs a good neighbor state without thinking ahead about where to go next.,● 平台区（plateau）：平台区是指状态空间地形图中的平坦区域。
chap4_para18,2,"Although greed is considered one of the seven deadly sins, it turns out that greedy algorithms often perform quite well.",它可能是一块平坦的局部极大值，不存在上坡的出口；也可能是一个山肩（shoulder），从山肩出发还有可能继续前进（参见图4-1）。
chap4_para18,3,Hill climbing can make rapid progress toward a solution because it is usually quite easy to improve a bad state.,爬山搜索可能会迷失在平台区上。
chap4_para18,4,"For example, from the state in Figure 4.",
chap4_para18,5,"3(b), it takes just five steps to reach the state in Figure 4.",
chap4_para18,6,"3(a), which has h = 1 and is very nearly a solution.",
chap4_para18,7,"Unfortunately, hill climbing can get stuck for any of the following reasons:",
chap4_para180,1,"•ACTIONS(s), the legal actions in state s;",在线搜索的一个典型实例是地图构建问题（mapping problem）：机器人放置在一个未知建筑中，它必须进行探索以绘制一个从A到B的地图。
chap4_para180,2,,逃离迷宫的方法——有抱负的古代英雄所需的知识——也是在线搜索算法的实例。
chap4_para180,3,,然而，空间探索并不是在线探索的唯一形式。
chap4_para180,4,,以一个新生儿为例：它可能可以做许多举动，却不知道这些动作的后果，而且它只体验过少数几个它能达到的可能状态。
chap4_para1801,1,,[9]　Long John Silver一般译作约翰•西尔弗，是英国小说家史蒂文森创作的著名小说《金银岛》中的海盗，他只有一条腿，在另一条腿处安装了木制假腿。
chap4_para1801,2,,——译者注
chap4_para1802,1,,10.6.1　限定与缺省逻辑
chap4_para1803,1,,我们已经见过两个违反了第7章证明的逻辑的单调性（Monotonicity）性质的推理程序。
chap4_para1803,2,,[10]本章我们看到，语义网络中一个类别所有成员都继承的性质可以被子类别更确切的信息覆盖。
chap4_para1803,3,,在9.4.4节，我们看到在封闭世界假设下，如果一个命题没有在KB中被提及，则，但。
chap4_para1805,1,,[10]　回想一下，单调性要求知识库中所有蕴含的语句在新语句被添加到知识库后仍然蕴含。
chap4_para1805,2,,也就是说，如果，则。
chap4_para1806,1,,简单的内省表明，常识推理往往不符合单调性。
chap4_para1806,2,,人类似乎总是“跳到结论”。
chap4_para1806,3,,例如，当有人看到停在路边的车，他往往愿意相信这辆车有4个轮子，尽管他只能看到3个轮子。
chap4_para1806,4,,概率论当然可以提供车大概率有4个轮子的结论，但对多数人来说，只有在新证据自动出现的情况下才会想到这辆车并非有4个轮子的可能性。
chap4_para1806,5,,这样看来，在没有理由怀疑的情况下，4个轮子的结论似乎是缺省地达成的。
chap4_para1806,6,,如果有了新的证据——例如，如果我们看到车主搬着一只轮胎，而且车被千斤顶顶起来了——则先前的结论可以被收回。
chap4_para1806,7,,可以说这种推理展示出了非单调性（nonmonotonicity），因为信念集在新证据到来时并不随之单调增长。
chap4_para1806,8,,非单调逻辑（nonmonotonic logic）修改了真值和蕴含的概念以刻画这种行为。
chap4_para1806,9,,我们将考察两种这样的逻辑，限定和缺省逻辑，它们都被大量研究过。
chap4_para1807,1,,限定（circumscription）可以被看作更为强大且精确的封闭世界假设。
chap4_para1807,2,,其思想是确定一个被假设为“尽可能假”的谓词，也就是，对所有对象都为假，除了那些我们已知为真的对象。
chap4_para1807,3,,例如，假设我们要断言缺省规则，鸟会飞。
chap4_para1807,4,,我们引入一个谓词，譬如，写出
chap4_para1808,1,,如果我们说被限定了，则限定推理器就有权假设，除非已知为真。
chap4_para1808,2,,这就使结论Flies(Tweety)可以从前提Bird(Tweety)中得出，但如果被断言，结论便不再成立。
chap4_para1809,1,,限定可以被看作一种模型偏好（model preference）逻辑。
chap4_para1809,2,,在这种逻辑中，如果语句在知识库的所有被偏好的模型中都为真，则语句（在缺省情况下）被蕴含，而无须像经典逻辑中要求在所有模型中都为真。
chap4_para1809,3,,对限定来说，如果一个模型的异常对象更少，则它比另一个模型更受偏好。
chap4_para1809,4,,[11]我们来看这种思想在语义网络的多重继承上下文中是如何运作的。
chap4_para1809,5,,多重继承问题的一个标准范例是“尼克松菱形”。
chap4_para1809,6,,我们观察到，理查德·尼克松既是基督教贵格会教徒（故而缺省为和平主义者），又是共和党党员（故而缺省为非和平主义者）。
chap4_para1809,7,,我们可以将其写作
chap4_para181,1,"•c(s, a, s'), the cost of applying action a in state s to arrive at state s'. Note that this cannot be used until the agent knows that s' is the outcome.",4.5.1　在线搜索问题
chap4_para1811,1,,[11]　对于封闭世界假设，一个模型只要真原子比另一个模型少就受偏好，也就是说，偏好模型是最小模型。
chap4_para1811,2,,封闭世界假设和确定子句知识库密切相关，因为前向链接在确定子句知识库上到达的不动点是唯一的最小模型。
chap4_para1811,3,,见7.5.4节了解更多相关内容。
chap4_para1812,1,,如果我们限定Abnormal2和Abnormal3，就会有两个偏好模型，其中一个模型中Abnormal2(Nixon)和Pacifist(Nixon)为真，另一个模型中Abnormal3(Nixon)与为真。
chap4_para1812,2,,这样的话，限定推理器在尼克松到底是不是和平主义者这一问题上就完全是不可知论者。
chap4_para1812,3,,如果我们想另外断言宗教信仰优先于政治信仰，我们可以使用称为优先限定（prioritized circumscription）的形式体系来对Abnormal3最小化的模型增加偏好。
chap4_para1813,1,,缺省逻辑是可以用缺省规则生成逻辑偶然的非单调结论的形式体系。
chap4_para1813,2,,缺省规则类似下式：
chap4_para1814,1,,这条规则的意思是，如果Bird(x)为真，且如果Flies(x)与知识库一致，则可以得出缺省结论Flies(x)。
chap4_para1814,2,,一般而言，缺省规则的形式为
chap4_para1815,1,,其中，P称为先决条件，C是结论，Ji是论证——如果其中任何一条可以被证明为假，则无法得出结论。
chap4_para1815,2,,Ji或C中的所有变量都必须同时在P中。
chap4_para1815,3,,在缺省逻辑中，尼克松菱形的例子可以用一条事实和两条缺省规则表示：
chap4_para1816,1,,要翻译缺省规则的含义，我们将缺省理论的拓展定义为该理论结果的最大集合。
chap4_para1816,2,,也就是，一个拓展S含有原始已知事实和缺省规则得出的结论集，使得S中不再能得出其他结论，且S中的每个缺省结论的论证都与S一致。
chap4_para1816,3,,与限定中的偏好模型一样，对于尼克松菱形，我们有两种可能的拓展：在其中一种当中尼克松是和平主义者，在另一种当中他不是和平主义者。
chap4_para1816,4,,优先方法可以使某些缺省规则比另一些规则优先，以便解决某些歧义性问题。
chap4_para1817,1,,从1980年首次提出非单调性逻辑开始，对其数学性质的理解已经有了大量进展。
chap4_para1817,2,,但仍然有尚未解决的问题。
chap4_para1817,3,,例如，如果“汽车有4个轮子”为假，那么它在一个智能体的知识库中意味着什么？
chap4_para1817,4,,什么样的缺省规则集是好的规则集？
chap4_para1817,5,,如果我们无法确定每条规则是否属于我们的知识库，那么我们就要面临严重的非模块性问题。
chap4_para1817,6,,最后，具有缺省状态的信念如何用于决策？
chap4_para1817,7,,这很可能是缺省推理中最难的问题。
chap4_para1818,1,,决策往往需要权衡，因此我们需要比较对不同动作的结果的信念的强度，以及决策错误的代价。
chap4_para1818,2,,当重复进行相同决策时，或许可以将缺省规则解释为“阈值概率”。
chap4_para1818,3,,例如，缺省规则“我的刹车一直都很好”的实际含义是“在没有其他信息的前提下，我的刹车很好的概率足够高，因此我的最优决策是不用检查刹车就直接开车”。
chap4_para1818,4,,当决策上下文改变时——例如，当我们开着一辆重载卡车下陡坡时——缺省规则突然就变得不适宜了，即使并没有新证据表明刹车存在故障。
chap4_para1818,5,,这些思考促使研究者考虑如何将缺省推理嵌入概率论或效用理论当中。
chap4_para1819,1,,10.6.2　真值维护系统
chap4_para182,1,"•IS-GOAL(s), the goal test.",求解在线搜索问题需要交替进行计算、感知和动作。
chap4_para182,2,,我们首先假设环境是确定性的和完全可观测的（第17章放宽了这些假设），并规定智能体只知道以下内容。
chap4_para1820,1,,我们已经见过许多知识表示系统得出的推断只是具有缺省状态，而非完全确定。
chap4_para1820,2,,不可避免地，在有新信息的情况下，许多推断出的事实最终将被证明是错误的，必须被收回。
chap4_para1820,3,,这个过程被称为信念修正（belief revision）。
chap4_para1820,4,,"[12]假设知识库KB含有语句P（可能是前向链接算法记录的缺省结论，也可能只是不正确的断言）且我们想执行Tell(KB, )。"
chap4_para1820,5,,"为避免导致矛盾，我们必须先执行Retract(KB, P)。"
chap4_para1820,6,,这听起来很简单。
chap4_para1820,7,,但如果其他语句是从P推断得出的，且在KB中断言了该语句，就会产生问题。
chap4_para1820,8,,例如，蕴涵式可能已经用于添加Q。
chap4_para1820,9,,显然的“解决方法”——收回由P得出的所有语句——无法使用，因为这种语句还有除P之外的其他论证。
chap4_para1820,10,,例如，如果R和也在KB中，则Q就根本不需要被移除。
chap4_para1820,11,,真值维护系统（truth maintenance system），或TMS，就是用于解决这类难题的。
chap4_para1822,1,,[12]　信念修正常与信念更新进行对比。
chap4_para1822,2,,当为了反映世界的变化而非固定世界的新信息而修改知识库时会出现信念更新。
chap4_para1822,3,,信念更新将信念修正与对时间和变化的推理进行结合，它还涉及第14章介绍的滤波。
chap4_para1823,1,,真值维护的一个简单方法是将语句编号为P1到Pn来记录它们被告知知识库的顺序。
chap4_para1823,2,,"当调用Retract(KB, Pi)时，系统恢复到Pi刚刚被添加前的状态，因而删除Pi和由Pi得出的所有推断。"
chap4_para1823,3,,语句Pi+1到Pn就可以被重新加入。
chap4_para1823,4,,这很简单，且确保了知识库的一致性，但收回Pi需要收回并重新断言n−1条语句，还要撤销并重做由这些语句得出的所有推断。
chap4_para1823,5,,对于添加了许多事实的系统（例如大型商业数据库）这不切实际。
chap4_para1824,1,,一个更为高效的方法是基于论证的真值维护系统，简称JTMS。
chap4_para1824,2,,在JTMS中，知识库中的每条语句都用一条论证（justification）标记，它含有推断出该语句的语句集。
chap4_para1824,3,,例如，如果一个知识库已经含有，则Tell(P)会使Q和附带的论证被加入。
chap4_para1824,4,,一般而言，一条语句的论证数量是无限制的。
chap4_para1824,5,,论证使收回语句变得高效。
chap4_para1824,6,,调用Retract(P)时，JTMS将删除每条论证都有P的所有语句。
chap4_para1824,7,,因此，如果语句Q的唯一论证为，它就会被删除；而如果Q有其他论证，则它会被保留。
chap4_para1824,8,,这样，收回P所需的时间就仅依赖于由P推得的语句数量，而非在P之后添加的语句数量。
chap4_para1825,1,,JTMS假设被考虑过一次的语句很可能会再次被考虑，因此当语句失去所有论证时，JTMS并不从知识库中完全删除该语句，而仅将语句标记为在知识库外。
chap4_para1825,2,,如果后续的断言重建了语句的某个论证，则语句被标记为在知识库内。
chap4_para1825,3,,如此，JTMS保留了它用到的所有推断链，当一个论证重新生效时便无须重新推导语句。
chap4_para1826,1,,除了收回错误信息，TMS还可以用于加速多重假设情形的分析。
chap4_para1826,2,,例如，假设罗马尼亚奥委会正在为2048年将在罗马尼亚举办的奥运会挑选游泳（swimming）、田径（athletics）和马术（equestrian）比赛的地点。
chap4_para1826,3,,"例如，令第一个假设为Site(Swimming, Pitesti)、Site(Athletics, Bucharest)和Site(Equestrian, Arad)。"
chap4_para1827,1,,我们随后必须进行大量推断来算出这种假设的后勤保障需要，也就是其合意程度。
chap4_para1827,2,,"如果我们想转而考虑Site(Athletics, Sibiu)，TMS会避免从头开始重新计算。"
chap4_para1827,3,,"相反，我们只需收回Site(Athletics, Bucharest)并断言Site(Athletics, Sibiu)，TMS就会进行必要的修正。"
chap4_para1827,4,,选择布加勒斯特（Bucharest）生成的推断链可以重新用在锡比乌（Sibiu）上——如果二者的结论相同的话。
chap4_para1828,1,,基于假设的真值维护系统简称ATMS，它能使这种在假设世界之间进行的转换特别高效。
chap4_para1828,2,,在JTMS中，维护论证使你可以用少量收回和断言就能从一个状态快速转换到另一个状态，但在任意时刻，它只能表示一种状态。
chap4_para1828,3,,ATMS则同时表示所有被考虑过的状态。
chap4_para1828,4,,JTMS只是将每条语句标记为在内或在外，而ATMS则记录每条语句在哪个假设中为真。
chap4_para1828,5,,也就是说，每条语句都有一个包含假设集的标签。
chap4_para1828,6,,语句仅在一个语句集的所有假设为真时为真。
chap4_para1829,1,,真值维护系统还提供了生成解释的机制。
chap4_para1829,2,,理论上，语句P的解释是语句集E，使得E蕴含P。
chap4_para1829,3,,如果E中的语句已知为真，则E只是提供了证明P的充分根据。
chap4_para1829,4,,但解释还可以包括假设——未知其为真，但如果为真的话就足以证明P的语句。
chap4_para1829,5,,例如，如果你的汽车无法启动，你很可能没有足够的信息来确定性地证明造成这个问题的原因。
chap4_para1829,6,,但一个合理的解释可能含有电瓶没电的假设。
chap4_para1829,7,,结合汽车工作原理的知识，这就能解释观测到的故障。
chap4_para1829,8,,在大多数情况下，我们倾向于最小的解释E，这意味着E不存在同样是解释的真子集。
chap4_para1829,9,,ATMS可以通过不分先后顺序的假设（如“汽车没油”或“电瓶没电”）来生成“汽车不启动”问题的解释，即使有些假设互相矛盾。
chap4_para1829,10,,然后我们查看语句“汽车不启动”的标签来读出可能能够论证该语句的假设集。
chap4_para183,1,"Note in particular that the agent cannot determine RESULT(s, a) except by actually being in s and doing a. For example, in the maze problem shown in Figure 4.19, the agent does not know that going Up from (1,1) leads to (1,2); nor, having done that, does it know that going Down will take it back to (1,1). This degree of ignorance can be reduced in some applications—for example, a robot explorer might know how its movement actions work and be ignorant only of the locations of obstacles.",● Actions(s)，状态s下的合法动作。
chap4_para1830,1,,真值维护系统的确切实现算法有些复杂，我们不在此赘述。
chap4_para1830,2,,真值维护系统的计算复杂度至少与命题推断一样大，也就是NP困难的。
chap4_para1830,3,,因此，你不能将真值维护当作灵丹妙药。
chap4_para1830,4,,但如果恰当使用的话，TMS能够极大增加逻辑系统处理复杂环境和假设的能力。
chap4_para1832,1,,我们希望通过研究如何表示各种知识，我们希望读者已经了解了如何构建真实的知识库，并体会到其中有趣的哲学问题。
chap4_para1832,2,,本章要点如下。
chap4_para1833,1,,● 大规模知识表示需要通用本体论来组织和结合各种特定论域的知识。
chap4_para1834,1,,● 通用本体论需要包含非常多样化的知识，且原则上应当能够处理所有论域。
chap4_para1835,1,,● 构建大型通用本体论是一项尚未被完全了解的重大挑战，尽管现有的框架似乎相当健壮。
chap4_para1836,1,,● 我们呈现了一个基于类别和事件演算的上层本体论。
chap4_para1836,2,,它包括类别、子类别、部分、结构化对象、量度、物质、事件、时间与空间、变化和信念等。
chap4_para1837,1,,● 自然类无法用逻辑来完全定义，但自然类的性质可以被表示。
chap4_para1838,1,,● 动作、事件和时间可以用事件演算来表示。
chap4_para1838,2,,这种表示使智能体能够构建动作序列并推断这些动作产生的结果。
chap4_para1839,1,,● 类似语义网络和描述逻辑的专用表示系统已经被设计用于组织类别层次结构。
chap4_para1839,2,,继承是重要的推断形式，它使得对象的性质可以从其类别从属关系中被推导出来。
chap4_para184,1,"Description The first and the last nodes are labeled S and G, respectively.","● c(s, a, s')，在状态s下执行动作a到达状态s'的代价。"
chap4_para184,2,All the other nodes are unlabeled.,注意，前提是智能体知道s'是结果。
chap4_para184,3,"For every two adjacent nodes, a third node is aligned below the mid of the two.",
chap4_para184,4,To and from arrows connect the adjacent nodes.,
chap4_para184,5,An arrow from node G points to the last node on the bottom row.,
chap4_para184,6,"An arrow from this node points to the node just above this, and then the flow progresses until the first node.",
chap4_para1840,1,,● 逻辑程序中实现的封闭世界假设提供了简便的方法来免于被迫表明大量否定信息。
chap4_para1840,2,,将其翻译为能够被附加信息覆盖的缺省则是最优的。
chap4_para1841,1,,● 如限定和缺省逻辑这样的非单调逻辑旨在总体上刻画缺省推理。
chap4_para1842,1,,● 真值维护系统能高效处理知识更新和修正。
chap4_para1843,1,,● 人工构建大规模本体论很难，从文本中提取知识则能简化这项任务。
chap4_para1847,1,,在本章中，我们将看到智能体如何利用问题的结构来高效地构建复杂的动作计划。
chap4_para1848,1,,规划一系列动作是智能体的关键需求。
chap4_para1848,2,,正确表示的动作和状态以及正确的算法可以使规划变得更容易。
chap4_para1848,3,,在11.1节中，我们为规划问题引入一种通用的因子化表示语言，它可以自然而简洁地表示各种领域，可以高效地扩展到大型问题，并且无须对新领域特定的启发式。
chap4_para1848,4,,我们在11.2节介绍高效规划算法，在11.3节介绍启发式方法。
chap4_para1848,5,,11.4节拓展表示语言使其允许分层次动作，以使我们能够处理更复杂的问题。
chap4_para1848,6,,在11.5节中，我们考虑部分可观测和非确定性域。
chap4_para1848,7,,在11.6节中，我们再次扩展该语言，以解决资源约束下的调度问题。
chap4_para1848,8,,这让我们更接近于真实世界中用于规划和调度航天器、工厂以及军事战役运行的规划器。
chap4_para1848,9,,11.7节分析这些技术的有效性。
chap4_para1849,1,,11.1　经典规划的定义
chap4_para185,1,Figure 4.,● Is-Goal(s)，目标测试。
chap4_para185,2,19A simple maze problem.,
chap4_para185,3,The agent starts at S and must reach G but knows nothing of the environment.,
chap4_para1850,1,,经典规划（classical planning）定义为在一个离散的、确定性的、静态的、完全可观测的环境中，找到完成目标的一系列动作的任务。
chap4_para1850,2,,我们已经见过两种完成这个任务的方法：第3章的问题求解智能体和第7章的混合命题逻辑智能体。
chap4_para1850,3,,它们都受到两个限制。
chap4_para1850,4,,首先，对于每个新领域，它们都需要特定的启发式方法：用于搜索的启发式评价函数和用于混合wumpus智能体的人工代码。
chap4_para1850,5,,其次，它们都需要明确地表示指数量级的状态空间。
chap4_para1850,6,,例如，在wumpus世界的命题逻辑模型中，向前移动一步的公理不得不在所有4个智能体朝向、T个时间步和n2个当前位置重复。
chap4_para1851,1,,针对这些限制，规划研究者使用PDDL语言研究出了因子化表示。
chap4_para1851,2,,"PDDL语言全称是规划领域定义语言（Planning Domain Definition Language）（Ghallab et al., 1998），它利用单个动作模式可以表示4Tn2个动作，且不需要特定的领域知识。"
chap4_para1851,3,,基本的PDDL可以处理经典规划领域，而扩展的PDDL则可以处理连续的、部分可观测的、并发的和多智能体的非经典领域。
chap4_para1851,4,,PDDL的语法基于Lisp，但是我们会将它转换成与本书中使用的表示法相符的形式。
chap4_para1852,1,,在PDDL中，一个状态表示为基本原子流的合取。
chap4_para1852,2,,回想一下，“基本”表示不含变量，“流”表示世界的一个方面随时间而变化，“基本原子”表示它只有一个谓词，而如果它含有参数，则这些参数必然是常量。
chap4_para1852,3,,例如，可能表示一个倒霉的智能体的状态，可能表示包裹投递问题中的一个状态。
chap4_para1852,4,,PDDL使用数据库语义：封闭世界假设意味着没有提到的任何流都是假的，唯一名称假设意味着Truck1和Truck2是不同的。
chap4_para1853,1,,"在状态中不允许使用下列流：At(x, y)（因为它含有变量）、（因为它是否定的），At(Spouse(Ali), Sydney)（因为它使用了一个函数符号Spouse）。"
chap4_para1853,2,,方便的时候，我们可以把流的合取看作流的集合。
chap4_para1854,1,,一个动作模式（action schema）表示一组基本动作。
chap4_para1854,2,,例如，下面是一个使飞机从一个位置飞到另一个位置的动作模式：
chap4_para1855,1,,模式由动作名称、模式中使用的所有变量的列表、前提（precondition）和效果（effect）组成。
chap4_para1855,2,,前提和效果都是文字的合取（肯定或否定的原子句）。
chap4_para1855,3,,我们可以选择常量来实例化变量，产生一个基本（无变量）动作：
chap4_para1856,1,,如果状态s蕴含基本动作a的前提，也就是说，前提中的每一个正文字都在s中，且每一个负文字都不在s中，则动作a适用于状态s。
chap4_para1857,1,,在状态s中执行适用动作a的结果被定义为状态s'，状态s'的形成方式是从s出发，移除动作效果中以负文字形式出现的流，［我们称之为删除列表（delete list）或Del(a)］，并添加在动作效果中以正文字形式出现的流［我们称之为添加列表（add list）或Add(a)］：
chap4_para1859,1,,"例如，采取动作Fly(P1, SFO, JFK)，我们移除流At(P1, SFO)并且添加流At(P1, JFK)。"
chap4_para186,1,"Finally, the agent might have access to an admissible heuristic function h(s) that estimates the distance from the current state to a goal state.","特别要注意的是，智能体不能确定Result(s, a)的值，除非它确实在s中执行了a。"
chap4_para186,2,"For example, in Figure 4.","例如，在图4-19所示的迷宫问题中，智能体并不知道从(1, 1)执行Up动作会到达(1, 2)；也不知道再执行Down动作会回到(1, 1)。"
chap4_para186,3,"19, the agent might know the location of the goal and be able to use the Manhattan-distance heuristic (page 116).",在某些应用中可以减少这种无知——例如，机器人探测器可能知道它是如何移动的，只是不知道障碍物的位置。
chap4_para1860,1,,一组动作模式是规划领域的一个定义。
chap4_para1860,2,,领域中的特定问题是通过添加初始状态和目标来定义的。
chap4_para1860,3,,初始状态是基本流的合取（在图11-1中使用关键字Init引入）。
chap4_para1860,4,,由于对所有状态都使用了封闭世界假设，这意味着任何没有被提及的原子都是假的。
chap4_para1860,5,,目标（使用Goal引入）和前提类似，它是可以含有变量的文字（正文字或负文字）合取式。
chap4_para1860,6,,例如，目标指的是满足货物C1位于SFO而货物C2不位于此地，且SFO有一架飞机的所有状态。
chap4_para1861,1,,11.1.1　范例领域：航空货物运输
chap4_para1862,1,,图11-1展示了一个航空货物运输问题，它涉及货物的装载、卸载和从一个地点飞到另一个地点。
chap4_para1862,2,,这个问题可以用3个动作定义：Load（装载）、Unload（卸载）、和Fly（飞行）。
chap4_para1862,3,,"这些动作影响到两个谓词：In(c, p)表示货物c在飞机p里，At(x, a)表示对象x（飞机或货物）在机场a。"
chap4_para1862,4,,注意，必须仔细确保对At谓词的正确维护。
chap4_para1862,5,,当一架飞机从一个机场飞到另一个机场时，飞机内的所有货物都会跟着它一起飞过去。
chap4_para1862,6,,在一阶逻辑中，很容易对飞机内的所有对象进行量化。
chap4_para1862,7,,但是PDDL没有全称量词，所以我们需要用到其他方法。
chap4_para1862,8,,我们使用的方法是，当一件货物在飞机里（In）时，它就不会在（At）其他地方；货物只有在被卸载后才会在（At）新机场。
chap4_para1862,9,,所以At的真正含义是“在（At）给定地点才可以使用”。
chap4_para1862,10,,下面的规划是这个问题的一个解：
chap4_para1863,1,,图11-1　航空货物运输规划问题的PDDL描述
chap4_para1864,1,,11.1.2　范例领域：备用轮胎问题
chap4_para1865,1,,考虑更换瘪气轮胎的问题（图11-2）。
chap4_para1865,2,,其目标是在车轴上正确安装一只备用轮胎，而初始状态是车轴上有一只瘪气轮胎，后备箱里有一只备用轮胎。
chap4_para1865,3,,为简单起见，我们对这个问题的描述是抽象的，不考虑难拧的螺母之类的复杂问题。
chap4_para1865,4,,问题只有4种动作：从后备箱取出备用轮胎、从车轴上卸下瘪气轮胎、把备用轮胎装在车轴上、把汽车留下整夜无人看管。
chap4_para1865,5,,我们假设汽车停在一个特别糟糕的街区，因此把汽车留下整夜无人看管的效果是轮胎不见了。
chap4_para1865,6,,是问题的一个解。
chap4_para1866,1,,图11-2　简单的备用轮胎问题
chap4_para1867,1,,11.1.3　范例领域：积木世界
chap4_para1868,1,,最著名的规划领域之一是积木世界。
chap4_para1868,2,,这个领域由一组立方体形状的积木组成，积木放在一张任意大的桌子上。
chap4_para1868,3,,[1]积木可以堆叠，但只有一块积木可以直接放在另一个上面。
chap4_para1868,4,,机械臂可以拿起一块积木并将其放到到另一个位置，可以是放在桌子上，也可以放在另一块积木上。
chap4_para1868,5,,机械臂一次只能拿一块积木，因此它无法拿起上面有另一块积木的积木。
chap4_para1868,6,,一个典型的目标是使积木A在积木B上，并且积木B在积木C上（见图11-3）。
chap4_para187,1,"Typically, the agent’s objective is to reach a goal state while minimizing cost. (Another possible objective is simply to explore the entire environment.) The cost is the total path cost that the agent incurs as it travels. It is common to compare this cost with the path cost the agent would incur if it knew the search space in advance—that is, the optimal path in the known environment. In the language of online algorithms, this comparison is called the competitive ratio; we would like it to be as small as possible.",最后，智能体可能可以访问一个可容许的启发式函数h(s)，该函数对从当前状态到目标状态的距离进行估计。
chap4_para187,2,,例如，在图4-19中，智能体可能知道目标的位置，从而可以使用曼哈顿距离启发式函数（3.6节）。
chap4_para1870,1,,[1]　规划研究中使用的积木世界通常比Shrdlu的版本（1.2.3节）简单得多。
chap4_para1871,1,,图11-3　图11-4的积木世界问题的示意图
chap4_para1872,1,,"我们用On(b, x)表示积木b在x上，其中x要么是另一块积木，要么是桌子。"
chap4_para1872,2,,"将积木b从x上移动到y上的动作是Move(b, x, y)。"
chap4_para1872,3,,现在，移动b的前提之一是它上面没有其他积木。
chap4_para1872,4,,在一阶逻辑中，这可以表示为或。
chap4_para1872,5,,基本版PDDL中没有量词，因此我们引入一个谓词Clear(x)，当x上没有任何东西时其为真。
chap4_para1872,6,,（完整的问题描述如图11-4所示。
chap4_para1872,7,,）
chap4_para1873,1,,图11-4　积木世界中的一个规划问题：建造一个3块积木构成的塔。
chap4_para1873,2,,一个解是序列
chap4_para1874,1,,如果b和y的上面都没有东西，动作Move可以将积木b从x移动到y。
chap4_para1874,2,,移动后，Clear(b)为真，而Clear(y)为假。
chap4_para1874,3,,第一次写出的Move模式是
chap4_para1875,1,,遗憾的是，当x或y是桌子时，这种模式无法正确维持Clear。
chap4_para1875,2,,当x=Table时，该动作的效果是Clear(Table)，但桌子上并非没有东西；当y=Table时，它的前提变为Clear(Table)，但桌子上有东西并不妨碍我们把积木放在桌子上。
chap4_para1875,3,,我们做如下两件事来解决这个问题。
chap4_para1875,4,,首先，我们引入另一个动作来将积木b从x移动到桌子上：
chap4_para1876,1,,其次，我们将Clear(x)解释为“在x上有一个容纳积木的空间”。
chap4_para1876,2,,在这种解释下，Clear(Table)会始终为真。
chap4_para1876,3,,"唯一的问题是我们无法阻止规划器用Move(b, x, Table)而非MoveToTable(b, x)。"
chap4_para1876,4,,我们可以不管这个问题——这会导致搜索空间的非必要增大，但不会导致错误的答案——或者，我们可以引入谓词Block并在Move的前提中添加Block(b) ∧ Block(y)，如图11-4所示。
chap4_para1877,1,,11.2　经典规划的算法
chap4_para1878,1,,规划问题的描述显然提供了一种从初始状态出发，在状态空间中搜索目标的方法。
chap4_para1878,2,,动作模式的陈述式表示的一个突出的优点是，我们还可以从目标反向搜索，寻找初始状态（图11-5比较了前向搜索和反向搜索）。
chap4_para1878,3,,此外，还有一种可能性是将问题描述转化为一组逻辑语句，我们可以应用逻辑推断算法寻找解。
chap4_para1879,1,,图11-5　搜索规划的两种方法。
chap4_para1879,2,,（a）在基本状态空间中前向（递进）搜索，从初始状态开始，利用问题的动作向前搜索目标状态集合中的一个成员。
chap4_para1879,3,,（b）通过状态描述进行反向（回归）搜索，从目标开始，用逆动作反向搜索初始状态
chap4_para188,1,"Online explorers are vulnerable to dead ends: states from which no goal state is reachable. If the agent doesn’t know what each action does, it might execute the “jump into bottomless pit” action, and thus never reach the goal. In general, no algorithm can avoid dead ends in all state spaces. Consider the two dead-end state spaces in Figure 4.20(a). An online search algorithm that has visited states S and A cannot tell if it is in the top state space or the bottom one; the two look identical based on what the agent has seen. Therefore, there is no way it could know how to choose the correct action in both state spaces. This is an example of an adversary argument—we can imagine an adversary constructing the state space while the agent explores it and putting the goals and dead ends wherever it chooses, as in Figure 4.20(b).",图4-19　一个简单的迷宫问题。
chap4_para188,2,,智能体必须从S出发到达G，但它对环境一无所知
chap4_para1880,1,,11.2.1　规划的前向状态空间搜索
chap4_para1881,1,,我们可以使用第3章或第4章中的任意启发式搜索算法来求解规划问题。
chap4_para1881,2,,搜索状态空间中的状态是基本状态，其中每个流要么为真要么为假。
chap4_para1881,3,,目标是一个状态，它含有该问题的目标中的所有正流而不含负流。
chap4_para1881,4,,一个状态中的适用动作Action(s)是动作模式的基本实例，也就是所有变量都被常量代替的动作。
chap4_para1882,1,,为了确定适用的动作，我们将当前状态与当每个动作模式的前提合一。
chap4_para1882,2,,对于每个成功产生置换的合一，我们将该置换应用于动作模式来产生不含变量的基本动作。
chap4_para1882,3,,（动作模式的要求是，效果中的所有变量必须也出现在前提中，这样，我们可以保证在置换后没有遗漏任何变量。
chap4_para1882,4,,）
chap4_para1883,1,,每个模式可能有多种合一方式。
chap4_para1883,2,,"在备用轮胎范例（11.1.2节）中，Remove动作有一个前提At(obj, loc)，它匹配初始状态的方式有两种，进而产生两个置换和；应用这些置换会产生两个基本状态。"
chap4_para1883,3,,如果一个动作的前提中有多个文字，那么每个文字都可能以多种方式与当前状态进行匹配。
chap4_para1884,1,,乍看起来，对许多问题来说，状态空间似乎都太大了。
chap4_para1884,2,,考虑一个有10个机场的航空货物运输问题，其中每个机场有5架飞机和20件货物。
chap4_para1884,3,,目标是将所有在A机场的货物运送到B机场。
chap4_para1884,4,,这个问题的一个解有41步：将20件货物装入A机场的一架飞机上，飞到B机场，然后卸载这20件货物。
chap4_para1885,1,,找到这种显然且直接的解可能很困难，因为平均分支因子非常大：50架飞机中的每一架都可以飞到9个其他机场，200件包裹中每一件都可以被卸载（如果已被装载）或装载（如果它已被卸载）到机场的任意飞机上。
chap4_para1885,2,,所以在任何状态中，都至少有450种动作（当所有包裹所在的机场都没有飞机时），最多则有10 450种动作（当所有包裹和飞机都在同一个机场时）。
chap4_para1885,3,,平均而言，假设每个状态大约有2000种可能的动作，深度最多为41步的搜索图就会有大约200041个节点。
chap4_para1886,1,,显然，如果没有精确的启发式方法，即使是求解这种规模很小的问题案例都令人非常绝望。
chap4_para1886,2,,尽管规划的许多真实世界的应用都依赖于领域特定的启发式，但实际上（正如我们将在11.3节中看到的），强大的领域无关的启发式方法可以由自动推导得来，使得前向搜索成为一种可行的方法。
chap4_para1887,1,,11.2.2　规划的反向状态空间搜索
chap4_para1888,1,,在反向搜索［也称为回归搜索（regression search）］中，我们从目标开始反向应用动作，直到找出到达初始状态的步骤序列。
chap4_para1888,2,,在每一步中，我们考虑相关动作（relevant action）（与前向搜索不同，前向搜索考虑的是适用动作）。
chap4_para1888,3,,这极大地减少了分支因子，特别是在有许多可能动作的领域。
chap4_para1889,1,,相关动作是其效果能够与目标中的一个文字合一的动作，但这个效果不否定目标的任何部分的行动。
chap4_para1889,2,,例如，对目标，效果仅为Famous的动作是相关动作，而效果为的动作则不相关：尽管这个动作可能在规划过程中的某处用到（来构建Famous），它却不能在规划的这个地方出现，因为这样会使Poor出现在最终状态中。
chap4_para189,1,"Description Part (“a”): Six nodes labeled 8, 9, 2, 2, 4, and 3 are connected using double-headed arrows labeled 1. Node 2 is shaded in red. Part (b): Six nodes labeled 8, 9, 3, 2, 4, and 3 are connected using double-headed arrows labeled 1. Note: Digit 3 in the third node is encircled. Node 2 is shaded in red. Part (c): Six nodes labeled 8, 9, 3, 4, 4, and 3 are connected using double-headed arrows labeled 1. Note: The digit 4 in the fourth node is encircled. Node 3 is shaded in red. Part (d): Six nodes labeled 8, 9, 5, 4, 4, and 3 are connected using double-headed arrows labeled 1. Note: The digit 5 in the third node is encircled. Node 4 is shaded in red. Part (e): Six nodes labeled 8, 9, 5, 5, 4, and 3 are connected using double-headed arrows labeled 1. Note: The digit 5 in the fourth node is encircled. Node 4 is shaded in red.",通常，智能体的目标是以最小代价到达目标状态。
chap4_para189,2,,（另一个可能目标是简单地探索整个环境。
chap4_para189,3,,）代价是智能体在移动过程中产生的总的路径代价。
chap4_para189,4,,通常将它与智能体事先知道搜索空间时所产生的路径代价（即已知环境中的最优路径）进行比较。
chap4_para189,5,,在在线算法的术语中，这种比较被称为竞争比（competitive ratio），我们希望它尽可能地小。
chap4_para1890,1,,在反方向应用一个动作是什么意思？
chap4_para1890,2,,给定一个目标g和一个动作a，从g通过a的回归（regression）会给出一个状态描述g'，其正负文字由下式给出：
chap4_para1891,1,,也就是说，前提在之前必须成立，否则动作就无法被执行，但由该动作添加或删除的正负文字在之前不必为真。
chap4_para1892,1,,这些等式对基本文字来说很简单直接，但当在g和a中存在变量时，就需要小心了。
chap4_para1892,2,,例如，假设目标是向SFO投递一件特定的货物：。
chap4_para1892,3,,"Unload动作模式的效果是At(c, a)。"
chap4_para1892,4,,当我们把它与目标进行合一，得到置换；将这个置换应用到模式中，我们就得到了一个新的模式，它刻画了使用位于SFO的任意一架飞机的概念：
chap4_para1893,1,,这里我们用一个名为p'的新变量来取代p。
chap4_para1893,2,,这是变量名的标准化分离的实例，以防不同变量因具有相同名称而发生冲突（见9.2.1节）。
chap4_para1893,3,,回归后的状态描述给出了一个新目标：
chap4_para1894,1,,再举一个例子，考虑目标为拥有一本特定ISBN号的书：Own(9780134610993)。
chap4_para1894,2,,给定1万亿个13位数字的ISBN号和单个动作模式A：
chap4_para1895,1,,不含启发式的前向搜索将不得不开始枚举那1万亿[2]个基本的Buy动作。
chap4_para1895,2,,但如果采用反向搜索，我们可以将目标Own(9780134610993)与效果Own(i')合一，产生置换。
chap4_para1895,3,,然后，我们在动作上回归，产生前驱状态描述ISBN(9780134610993)。
chap4_para1895,4,,这是初始状态的一部分，因而我们得到一个解并完成了任务，其中只考虑了一个动作而不是1万亿个动作。
chap4_para1897,1,,[2]　此处原书为“10 billion”（100亿），但根据上下文，此处应为1万亿。
chap4_para1897,2,,——译者注
chap4_para1898,1,,更形式化地说，假设一个目标描述g包含一个目标文字gi和一个动作模式A。
chap4_para1898,2,,如果A有一个效果文字，其中，并且我们定义，如果A'的效果不含对g中文字的否定，则A'是对g的一个相关动作。
chap4_para1899,1,,对大多数问题域而言，反向搜索的分支因子小于前向搜索。
chap4_para1899,2,,但由于反向搜索使用了含有变量的状态而非基本状态，因此难以找到好的启发式方法。
chap4_para1899,3,,这是目前大多数系统倾向于使用前向搜索的主要原因。
chap4_para19,1,"•Local maxima: A local maximum is a peak that is higher than each of its neighboring states but lower than the global maximum. Hill-climbing algorithms that reach the vicinity of a local maximum will be drawn upward toward the peak but will then be stuck with nowhere else to go. Figure 4.1 illustrates the problem schematically. More concretely, the state in Figure 4.3(a) is a local maximum (i.e., a local minimum for the cost h); every move of a single queen makes the situation worse.",在每种情况下，算法都会到达一个无法再取得进展的点。
chap4_para19,2,,从一个随机生成的8皇后状态开始，在86%的情况下，最陡上升爬山法会被卡住，它只能解决14%的问题实例。
chap4_para19,3,,但是，它求解速度很快，成功找到解时平均步数为4，被卡住时平均步数为3，这对一个具有万个状态的状态空间来说不算糟糕。
chap4_para190,1,Figure 4.,在线探索器很容易陷入死胡同（dead-end）：无法到达任何目标状态的状态。
chap4_para190,2,20(a) Two state spaces that might lead an online search agent into a dead end.,如果智能体不知道每个动作的后果，它可能会“跳进陷阱”，因此永远无法到达目标。
chap4_para190,3,Any given agent will fail in at least one of these spaces.,一般来说，没有一种算法能在所有状态空间中都避免进入死胡同。
chap4_para190,4,(b) A two-dimensional environment that can cause an online search agent to follow an arbitrarily inefficient route to the goal.,以图4-20a中的两个死胡同状态空间为例。
chap4_para190,5,"Whichever choice the agent makes, the adversary blocks that route with another long, thin wall, so that the path followed is much longer than the best possible path.",对已经访问过状态S和A的在线搜索算法来说，它无法分辨自己是处于顶部的状态还是底部的状态；根据智能体观测到的感知信息，这两个状态看起来是相同的。
chap4_para190,6,,因此，它不可能知道如何在两个状态空间中选择正确的动作。
chap4_para190,7,,这是一个对手论证（adversary argument）的实例——想象对手在智能体探索状态空间时构建状态空间，并将目标和死胡同放在它所选择的任何地方，如图4-20b所示。
chap4_para1900,1,,11.2.3　使用布尔可满足性规划
chap4_para1901,1,,在7.7.4节中，我们展示了一些巧妙的公理重写如何将wumpus世界问题转换为可以由高效可满足性求解器求解的命题逻辑可满足性问题。
chap4_para1901,2,,基于SAT的规划器SATPlan通过将PDDL问题描述翻译为命题形式来工作。
chap4_para1901,3,,这种翻译含有下面一系列步骤。
chap4_para1902,1,,● 将动作命题化：对于每个动作模式，用常量置换每个变量形成基本命题。
chap4_para1902,2,,"因此我们不能仅用模式Unload(c, p, a)，而是必须将动作命题分为每个货物、飞机和机场的组合（此处用下标表示），以及每个时间步（此处用上标表示）。"
chap4_para1903,1,,● 添加动作排除公理来表明两个动作不能同时发生，例如。
chap4_para1904,1,,● 添加前提公理：对于每个基本动作At，添加公理，也就是说，如果在时刻t采取动作，那么前提必须已经为真，例如。
chap4_para1905,1,,● 定义初始状态：在问题初始状态中对每个流F断言F0，并对每个初始状态中未提及的流断言。
chap4_para1906,1,,● 将目标命题化：目标变为它的所有基本实例的析取式，其中变量被常量替代。
chap4_para1906,2,,例如，目标是在一个具有对象A、B和C的世界中，使积木A位于另一块积木之上，也就是，它将被以下目标替换：
chap4_para1907,1,,● 添加后继状态公理：对于每个流F，添加一个形式如下的公理：
chap4_para1908,1,,其中ActionCausesF代表所有添加F的基本动作的析取式，而ActionCausesNotF代表所有删除F的基本动作的析取式。
chap4_para1909,1,,翻译的结果通常比原始的PDDL大得多，但现代SAT求解器的效率通常足以弥补这一点。
chap4_para191,1,"Dead ends are a real difficulty for robot exploration—staircases, ramps, cliffs, one-way streets, and even natural terrain all present states from which some actions are irreversible—there is no way to return to the previous state. The exploration algorithm we will present is only guaranteed to work in state spaces that are safely explorable—that is, some goal state is reachable from every reachable state. State spaces with only reversible actions, such as mazes and 8-puzzles, are clearly safely explorable (if they have any solution at all). We will cover the subject of safe exploration in more depth in Section 23.3.2.",图4-20　（a）两个可能将在线搜索智能体引入死胡同的状态空间。
chap4_para191,2,,任何给定智能体都会在至少一个空间中失败。
chap4_para191,3,,（b）二维环境实例，将导致在线搜索智能体沿着一条任意低效的路线到达目标。
chap4_para191,4,,无论智能体做出何种选择，对手都会用另一堵很长很薄的墙来阻挡这条路线，这样智能体所走的路径就会比最优可能路径长得多
chap4_para1910,1,,11.2.4　其他经典规划方法
chap4_para1911,1,,在自动规划50年的历史上，并非只存在上述3种方法。
chap4_para1911,2,,我们在这里简要介绍一些其他方法。
chap4_para1912,1,,一种称为Graphplan的方法使用一种专门的数据结构——规划图（planning graph）来编码约束以规定动作与其前提和效果的关系以及哪些事物互相排斥。
chap4_para1913,1,,情景演算（situation calculus）是一种用一阶逻辑描述规划问题的方法。
chap4_para1913,2,,这种方法像SATPlan一样使用后继状态公理，但一阶逻辑允许更灵活简洁的公理形式。
chap4_para1913,3,,总的来说，该方法有助于我们对规划的理论理解，却没有在实际应用中产生重大影响，可能是因为一阶证明器不如命题可满足性程序发展得好。
chap4_para1914,1,,我们可以将有界规划问题（也就是寻找长度为k的规划）编码为约束满足问题（constraint satisfaction problem，CSP）。
chap4_para1914,2,,这种编码方式类似于编码为SAT问题（11.2.3节），但它有一个重要的简化：在每个时间步，我们只需要一个变量Actiont，它的定义域是可能的动作集。
chap4_para1914,3,,我们不再需要为每个动作分配变量，也不需要动作排除公理。
chap4_para1915,1,,到目前为止，我们看到的所有方法都构建了由严格的线性动作序列组成的全序规划。
chap4_para1915,2,,但如果一个航空货物运输问题有30个包裹被装载到一架飞机上，50个包裹被装载到另一架飞机上，那么对这80个装载动作制定一个特定的线性顺序似乎毫无意义。
chap4_para1916,1,,还有一种称为偏序规划（partial-order planning）的方法用图而不是用线性序列来表示规划：每个动作是图中的一个节点，每个动作的前提都有一条来自另一个动作的边（或来自初始状态），表明形成这一前提的前驱动作。
chap4_para1916,2,,"因此，我们可以用偏序规划表示动作Remove(Spare, Trunk)和Remove(Flat, Axle)必须在PutOn(Spare, Axle)之前进行，而无须说明应该先执行这两个Remove动作中的哪一个。"
chap4_para1916,3,,我们在规划空间而非世界状态空间中搜索，通过插入动作来满足条件。
chap4_para1917,1,,在20世纪80和90年代，偏序规划被认为是处理具有独立子问题的规划问题的最佳方法。
chap4_para1917,2,,到2000年，前向搜索规划器发展出了优秀的启发式方法，这使得它们能够有效地发现偏序规划所擅长处理的独立子问题。
chap4_para1917,3,,此外，SATPlan能够利用摩尔定律：在1980年还大得吓人的命题化问题现在看起来微不足道，因为现在计算机的内存增加了1万倍。
chap4_para1917,4,,因此，在完全自动化的经典规划问题上，偏序规划没什么竞争力。
chap4_para1918,1,,尽管如此，偏序规划仍然是该领域的重要组成部分。
chap4_para1918,2,,对于某些特定的任务，如作业调度，采用领域特定的启发式方法的偏序规划依然是可以选用的技术。
chap4_para1918,3,,许多这种系统使用高层规划库，如11.4节所述。
chap4_para1919,1,,偏序规划也常用于那些需要人类理解其规划的领域。
chap4_para1919,2,,例如，用于航天器和火星车的作业规划通过偏序规划器生成，在将规划上传到这些装备并执行前会经过人类操作员的检查。
chap4_para1919,3,,规划精细化方法使得人类易于理解规划算法做了什么事情，并在规划被执行前验证其正确性。
chap4_para192,1,"Even in safely explorable environments, no bounded competitive ratio can be guaranteed if there are paths of unbounded cost.",死胡同是机器人探索中的一个真正的难点——楼梯、斜坡、悬崖、单行道甚至自然地形中都存在从它出发某些动作不可逆（irreversible）的状态——没有办法回到之前的状态。
chap4_para192,2,"This is easy to show in environments with irreversible actions, but in fact it remains true for the reversible case as well, as Figure 4.",我们提出的探索算法只保证在可安全探索（safely explorable）的状态空间中是有效的，也就是说，从每个可达状态出发都存在可以到达的目标状态。
chap4_para192,3,20(b) shows.,所有动作都可逆的状态空间，如迷宫和8数码，显然是可安全探索的（如果它们有解的话）。
chap4_para192,4,"For this reason, it is common to characterize the performance of online search algorithms in terms of the size of the entire state space rather than just the depth of the shallowest goal.",我们将在22.3.2节中更深入地讨论安全探索的话题。
chap4_para1920,1,,11.3　规划的启发式方法
chap4_para1921,1,,如果没有好的启发式函数，前向搜索和反向搜索都是低效的。
chap4_para1921,2,,回想在第3章中，一个启发式函数h(s)估计了从状态s到目标的距离，如果我们能推导出这个距离的可容许的启发式方法，也就是不会高估的方法，那么我们就可以使用A*搜索来找到最优解。
chap4_para1922,1,,根据定义，能够分析原子状态的方法是不存在的。
chap4_para1922,2,,因此，为含有原子状态的搜索问题定义良好的领域特定启发式方法需要分析师（通常是人）的聪明才智。
chap4_para1922,3,,但是规划使用状态和动作的因子化表示，就使得找出良好的、领域无关的启发式方法成为可能。
chap4_para1923,1,,回想一下，可以通过定义一个更容易求解的松弛问题推导出一个可容许的启发式方法。
chap4_para1923,2,,求解这个简单问题的确切代价就变为寻找原问题的启发式。
chap4_para1923,3,,搜索问题是一个节点为状态、边为动作的图。
chap4_para1923,4,,问题是找到一条连接初始状态和目标状态的路径。
chap4_para1923,5,,我们有两种主要的方法来松弛这个问题，使它变得更容易：通过在图中添加更多的边，使找到一条路径更容易，或者通过将多个节点分为一组，形成一个具有更少状态的状态空间的抽象，因而更容易搜索。
chap4_para1924,1,,我们首先看看向图中添加边的启发式方法。
chap4_para1924,2,,最简单的方法大概是忽略前提启发式方法（ignore-preconditions heuristic），它从动作中去掉所有的前提。
chap4_para1924,3,,每一个动作都适用于所有状态，任何单个目标流都可以在一步之内完成（如果存在适用动作的话。
chap4_para1924,4,,如果没有适用动作，这个问题就是无解的）。
chap4_para1924,5,,这几乎意味着，求解松弛问题所需的步骤数量等于未满足的目标数量——几乎但不完全等于，因为（1）一些动作可能实现多个目标，（2）一些动作可能抵消了其他动作的效果。
chap4_para1925,1,,对于许多问题，精确的启发式是通过考虑（1）且忽略（2）得到的。
chap4_para1925,2,,首先，我们通过移除所有前提和效果（含有目标中的文字的效果除外）来松弛动作。
chap4_para1925,3,,然后我们计算为了满足目标所要求的效果而需要合一的动作的最小数量。
chap4_para1925,4,,这是一个集合覆盖问题（set-cover problem）。
chap4_para1925,5,,有一个小麻烦：集合覆盖问题是NP困难的。
chap4_para1925,6,,幸运的是，有一种简单的贪心算法能够确保返回一个集合的覆盖，其大小不超过实际最小覆盖的logn倍，其中n是目标中的文字的数量。
chap4_para1925,7,,遗憾的是，这种贪心算法无法保证可容许性。
chap4_para1926,1,,只忽略被选定的动作的前提也是可以的。
chap4_para1926,2,,考虑3.2节中的滑块问题(8数码问题或15数码问题）。
chap4_para1926,3,,我们可以将其编码为一个规划问题，其滑块只有Slide一个模式：
chap4_para1927,1,,正如我们在3.6节中所看到的，如果我们移除前提，那么在一次动作中，所有滑块都可以移动到任意位置，我们就得到了错放的滑块数量的启发式。
chap4_para1927,2,,如果只移除前提Blank(s2)，我们就得到了曼哈顿距离启发式。
chap4_para1927,3,,很容易看出这些启发式是如何从动作模式的描述中自动推导出来的。
chap4_para1927,4,,与搜索问题的原子表示相比，规划问题的因子化表示的最大优点是易于操作动作模式。
chap4_para1928,1,,另一种可能性是忽略删除列表启发式方法（ignore-delete-lists heuristic）。
chap4_para1928,2,,暂且假设所有目标和前提只包含正文字。
chap4_para1928,3,,[3]我们想要创建一个原问题的更容易求解的松弛版本，并且将其解的长度用作很好的启发式函数。
chap4_para1928,4,,我们可以通过从所有动作中移除删除列表（例如，从效果中移除所有负文字）来实现。
chap4_para1928,5,,这使得向着目标单调前进成为可能——任何动作都不会抵消另一个动作所取得的进展。
chap4_para1928,6,,虽然找到松弛问题的最优解仍然是NP困难的，但可以通过爬山搜索算法在多项式时间内找到近似解。
chap4_para193,1,4.,即使在可安全探索的环境中，如果存在代价无界的路径，也不能保证竞争比有界。
chap4_para193,2,5.,在动作不可逆的环境中，很容易发现上述结论，但事实上，可逆情况下也是如此，如图4-20b所示。
chap4_para193,3,2Online search agents,因此，通常会根据整个状态空间的大小来描述在线搜索算法的性能，而不是仅仅根据最浅层目标的深度。
chap4_para1930,1,,[3]　许多问题都采用这种惯例记法。
chap4_para1930,2,,对于没有使用这种记法的问题，将所有目标或前提中的负文字用新的正文字P'替换，并相应地修改初始状态和动作效果即可。
chap4_para1931,1,,图11-6画出了使用忽略删除列表启发式方法的两个规划问题的部分状态空间，其中点代表状态，边代表动作，每个点离底面的高度代表启发式函数的值。
chap4_para1931,2,,在底部平面上的状态就是解。
chap4_para1931,3,,两个问题都有通往目标的宽阔路径。
chap4_para1931,4,,因为没有死路，也就没有回溯的必要，简单的爬山搜索就可以轻松求解这些问题（尽管它可能不是最优解）。
chap4_para1932,1,,图11-6　使用忽略删除列表启发式方法的规划问题的两个状态空间。
chap4_para1932,2,,底部平面以上的高度是一个状态的启发式得分；底部平面的状态是目标。
chap4_para1932,3,,由于不存在局部极小值，所以搜索目标很简单直接。
chap4_para1932,4,,"图片来自（Hoffmann, 2005）"
chap4_para1933,1,,11.3.1　领域无关剪枝
chap4_para1934,1,,因子化表示中很容易就能看出许多状态只是其他状态的变体。
chap4_para1934,2,,例如，假设桌子上有12块积木，我们的目标是让积木A位于3块积木的积木塔的顶部。
chap4_para1934,3,,一个解的第一步就是将某块积木x放到积木y的上面（其中x、y和A都是不同的）。
chap4_para1934,4,,然后，我们把A放在x上面就可以了。
chap4_para1934,5,,x有11种选择，而给定x的话，y有10种选择，因此有110种状态需要考虑。
chap4_para1934,6,,但所有这些状态都是对称的：选择这一个而非那一个并没有什么区别，因此规划器应当只考虑其中一种。
chap4_para1934,7,,这就是对称约简（symmetry reduction）的原理：我们修剪掉搜索树中的所有对称分支而不予考虑，只保留其中一个。
chap4_para1934,8,,对许多领域来说，这会使问题从难以求解变为高效求解。
chap4_para1935,1,,另一种做法是进行前向剪枝，为了将搜索集中于有希望的分支，我们需要承担可能会剪掉最优解的风险。
chap4_para1935,2,,可以定义一个如下的优先动作（preferred action）：首先，定义问题的一个松弛版本，然后求解它，得到一个松弛规划。
chap4_para1935,3,,如此，优先动作要么是松弛规划中的一步，要么能够满足松弛规划的某个前提。
chap4_para1936,1,,有时通过找出可以被剔除的负相互作用也可以高效求解问题。
chap4_para1936,2,,如果问题中存在子目标的某种顺序，使得规划器按照这个顺序完成子目标时不会撤销已完成的子目标，则这个问题具有可序列化子目标（serializable subgoal）。
chap4_para1936,3,,例如，在积木世界里，如果我们的目标是建造一座塔（例如，积木A在B上，B在C上，C在桌子上，如图11-3所示），则子目标是自底向上可序列化的：如果我们先让积木C在桌子上，则当完成其他的子目标时我们就不需要撤销它。
chap4_para1936,4,,一个使用自底向上技术的规划器可以无须回溯地求解积木世界中的任何问题（尽管它并不总能找到最短的规划）。
chap4_para1936,5,,再举个例子，如果一个房间有n个电灯开关，每个开关控制一盏灯，而我们的目标是让这些灯都亮着，那么就不需要考虑开灯的顺序，可以任意指定规划的开灯顺序，如使用升序。
chap4_para1937,1,,对控制美国国家航空航天局“深空一号”航天器的“远程智能体”规划器来说，控制航天器所涉及的命题被设定为是可序列化的。
chap4_para1937,2,,这也许并不是很奇怪，因为航天器是被工程师设计为尽量容易操纵的（同时也受到其他因素限制）。
chap4_para1937,3,,利用目标的序列化顺序，“远程智能体”规划器能够消除大部分搜索。
chap4_para1937,4,,这意味着它的速度快到足以实时控制航天器，这在以前被认为是不可能做到的。
chap4_para1938,1,,11.3.2　规划中的状态抽象
chap4_para1939,1,,松弛化问题给出一个仅用于计算启发式函数的值的简化规划问题。
chap4_para1939,2,,许多规划问题有10100个或更多的状态，松弛这些动作并不能减少状态的数量，这意味着计算启发式的代价仍然很高。
chap4_para1939,3,,因此，我们现在来看通过构造状态抽象（state abstraction）以减少状态数量的松弛化方法——从问题的基本表示到抽象表示的多对一映射。
chap4_para194,1,"After each action, an online agent in an observable environment receives a percept telling it what state it has reached; from this information, it can augment its map of the environment.",4.5.2　在线搜索智能体
chap4_para194,2,The updated map is then used to plan where to go next.,
chap4_para194,3,"This interleaving of planning and action means that online search algorithms are quite different from the offline search algorithms we have seen previously: offline algorithms explore their model of the state space, while online algorithms explore the real world.",
chap4_para194,4,"For example, A* can expand a node in one part of the space and then immediately expand a node in a distant part of the space, because node expansion involves simulated rather than real actions.",
chap4_para1940,1,,状态抽象最简单的形式是忽略一些流。
chap4_para1940,2,,例如，考虑一个有10个机场、50架飞机和200件货物的航空货物运输问题。
chap4_para1940,3,,每架飞机可以位于10个机场中的一个，每件包裹可以在其中一架飞机上，或已卸载到其中一个机场。
chap4_para1940,4,,所以有个状态。
chap4_para1940,5,,现在考虑该领域中的一个特定问题，在这个问题中，所有的包裹刚好只在5个机场中，且在给定机场中的所有包裹的目的地都相同。
chap4_para1940,6,,这样，对这个问题的一个有用的抽象是去掉所有At流，除了那些涉及在这5个机场中的包裹和飞机的流。
chap4_para1940,7,,现在只有个状态。
chap4_para1940,8,,在这个抽象状态空间中的解要比原始空间中的解短（因此它是一个可容许的启发式），而且抽象解可以轻易扩展为原问题的解（通过添加额外的Load和Unload动作）。
chap4_para1941,1,,定义启发式的一个关键思想是分解（decomposition）：将问题分解为多个部分，独立求解各个部分，然后将这些部分组合起来。
chap4_para1941,2,,子目标独立（subgoal independence）假设是，求解一系列子目标的代价近似于独立求解每个子目标的成本之和。
chap4_para1941,3,,子目标独立性假设可以是乐观的，也可以是悲观的。
chap4_para1941,4,,当每个子目标的子规划之间存在负相互作用时，它就是乐观的——例如，当一个子规划中的动作删除了了另一个子规划完成的目标时。
chap4_para1941,5,,当子规划包含冗余的动作时，它是悲观的、不可容许的，例如，两个动作在合一后的规划中被替换为一个动作。
chap4_para1942,1,,"假设目标是一组流的集合G，我们将其分成不相交的子集G1, …, Gn。"
chap4_para1942,2,,"随后找到各个子目标的最优解P1, …, Pn。"
chap4_para1942,3,,实现整个G的规划的代价大概是多少？
chap4_para1942,4,,我们可以把每个Cost(Pi)想作一个启发式估计，而且如果我们通过取它们当中的最大值的来进行总体估计，我们就能得到一个可容许的启发式。
chap4_para1942,5,,因此，maxiCost(Pi)是可容许的，而且有时它是完全准确的，例如当P1偶然地实现了所有Gi。
chap4_para1942,6,,但通常这个估计是过低的。
chap4_para1942,7,,我们可以把代价加起来吗？
chap4_para1942,8,,对许多问题来说这是一个合理的估计，但它是不可容许的。
chap4_para1942,9,,最好的情况是Gi和Gj是独立的，也就是对其中一个目标的规划不能减少另一个规划的代价。
chap4_para1942,10,,这种情况下，估计Cost(Pi) + Cost(Pj)是可容许的，并且比最大估计更准确。
chap4_para1943,1,,很明显，通过抽象来减少搜索空间有很大的潜力。
chap4_para1943,2,,诀窍在于选择适当的抽象，并使其总代价——定义抽象、进行抽象搜索、将抽象映射回原问题——小于求解原问题的代价。
chap4_para1943,3,,在3.6.3节中的模式数据库技术可以派上用场，因为创建模式数据库的代价可以分摊到多种问题案例上。
chap4_para1944,1,,"利用了高效启发式的系统有FF，或称FastForward（Hoffmann, 2005），这是一个使用了忽略删除列表启发式方法的前向状态空间搜索器，它使用规划图估计启发式。"
chap4_para1944,2,,FF随后使用该启发式进行爬山搜索（修改版，以便于记录规划）来寻找解。
chap4_para1944,3,,FF的爬山算法是非标准的：它通过在当前状态运行广度优先搜索来避免局部极大值，直到找到更好的状态。
chap4_para1944,4,,如果没有找到结果，FF就会切换到贪心最佳优先搜索。
chap4_para1946,1,,前几章的问题求解和规划方法都只使用固定的原子动作集。
chap4_para1946,2,,动作可以连在一起，而最新的算法可以生成包含数千个动作的解。
chap4_para1946,3,,如果我们正在规划假期，而动作仅仅是在“从旧金山飞到火奴鲁鲁”的层次，这样做没什么问题；但在“左膝弯曲5度”的电动机控制层次，我们需要连接几百万到几十亿个动作，而不止是几千个。
chap4_para1947,1,,弥合这一差距需要在更高的抽象层次上进行规划。
chap4_para1947,2,,一个高层级的夏威夷度假规划可能是“前往旧金山机场；乘坐飞往火奴鲁鲁的HA 11号航班；游玩两个星期；乘坐HA 12飞机回旧金山；回家”。
chap4_para1947,3,,给定这样的规划，“前往旧金山机场”这一动作本身就可以被视为一项规划任务，它的解包括“选择送机服务；预订一辆车；乘车前往机场”。
chap4_para1947,4,,每个动作都可以被进一步分解，直到我们达到低层级的电动机控制动作，就像钉扣机一样。
chap4_para1948,1,,在这个例子中，规划和行动是交替的。
chap4_para1948,2,,例如，我们可以把从路边到大门的步行规划问题推迟到下车之后再说。
chap4_para1948,3,,因此，在执行阶段之前，该动作仍然处于抽象层级。
chap4_para1948,4,,我们在11.5节再讨论这个话题。
chap4_para1948,5,,此处，我们专注于层次分解（hierarchical decomposition）的概念，几乎在控制复杂性的所有尝试中都可以见到这种概念。
chap4_para1948,6,,例如，复杂软件是基于子程序和类的层次性而创建的，军队、政府和企业都有层次化的组织结构。
chap4_para1948,7,,分层结构的主要益处是，分层的每一层级都将一个计算任务、军事行动或行政职能减少为下一层次的少量活动，因此找出为当前问题安排这些活动的正确方法的计算代价很小。
chap4_para1949,1,,11.4.1　高层动作
chap4_para195,1,"An online algorithm, on the other hand, can discover successors only for a state that it physically occupies.",可观测环境中的在线智能体在每个动作之后都会接收到一个感知，告诉它目前到达了哪一状态，通过这些信息，智能体可以更新它的环境地图。
chap4_para195,2,"To avoid traveling all the way to a distant state to expand the next node, it seems better to expand nodes in a local order.",更新后的地图将用于规划下一步。
chap4_para195,3,Depth-first search has exactly this property because (except when the algorithm is backtracking) the next node expanded is a child of the previous node expanded.,规划和动作交替进行意味着在线搜索算法与之前介绍的离线搜索算法有很大不同：离线算法探索其状态空间模型，而在线算法探索真实世界。
chap4_para195,4,,例如，A*可以在空间的某部分扩展一个节点，然后马上在空间的另一相距很远的部分扩展另一个节点，因为节点扩展设计的是模拟动作而非真实动作。
chap4_para1950,1,,用于理解层次分解的基本形式体系来自分层任务网络（hierarchical task network，HTN）领域规划。
chap4_para1950,2,,目前，我们假设完全可观测性和确定性，以及一组动作，称为基元动作（primitive action），它具有标准的前提-效果模式。
chap4_para1950,3,,另外一个重要的概念是高层动作（high-level action）或称HLA——例如，“前往旧金山机场”动作。
chap4_para1950,4,,每个HLA都有一个或多个可能的细化（refinement）来形成一个动作序列，其中的每个动作可能是一个HLA或一个基元动作。
chap4_para1950,5,,"例如，动作“前往旧金山机场”，其形式化表示为Go(Home, SFO)，它可以有两个可能的细化，如图11-7所示。"
chap4_para1950,6,,图11-7还展示了在真空吸尘器世界中导航的递归细化：要到达目的地，我们先走一步，然后再前往目的地。
chap4_para1951,1,,图11-7　两个高层动作——前往旧金山机场和在真空吸尘器世界中导航——的可能细化的定义。
chap4_para1951,2,,注意真空吸尘器世界中细化的递归特性和对前提的使用
chap4_para1952,1,,这些例子表明，高层动作及其细化体现了关于如何做事的知识。
chap4_para1952,2,,"例如，Go(Home, SFO)的细化表明你可以开车或叫车去机场；买牛奶、坐下来、将马移动到e4方格等动作是无须考虑的。"
chap4_para1953,1,,只包含基元动作的HLA细化称为这个HLA的一个实现（implementation）。
chap4_para1953,2,,"在网格世界中，序列[Right, Right, Down]和[Down, Right, Right]都实现了HLA Navigate([1, 3], [3, 2])。"
chap4_para1953,3,,一个高层规划（HLA序列）的实现就是连接序列中每个HLA的实现。
chap4_para1953,4,,给定每个基元动作的前提-效果的定义，很容易确定高层规划的任意给定实现是否达成了目标。
chap4_para1954,1,,因此，我们可以说，如果一个高层规划至少有一个实现从给定状态达成了目标，则该高层规划从该给定状态达成了目标。
chap4_para1954,2,,这个定义中，“至少有一个”是至关重要的，并非所有实现都需要达成目标，因为智能体会想办法决定它要执行哪个实现。
chap4_para1954,3,,因此，HTN规划中的可能实现的集合——其中各个实现的结果可能不同——与非确定性规划中可能结果的集合不同。
chap4_para1954,4,,在非确定性规划中，我们需要一个对所有结果都有效的规划，因为智能体不能选择结果，产生何种结果是自然因素导致的。
chap4_para1955,1,,最简单的情况是只有一个实现的HLA。
chap4_para1955,2,,在这种情况下，我们可以从实现的前提和效果中计算HLA的前提和效果（见习题11.HLAU），然后将HLA本身完全视为一个基元动作。
chap4_para1955,3,,可以证明，一组正确的HLA可以将盲目搜索的时间复杂性从解深度的指数量级降到解深度的线性量级，虽然设计出这样的一组HLA并非易事。
chap4_para1955,4,,当HLA有多个可能的实现时，有两种选择：一种是在所有实现中搜索出一个有效的实现，如11.4.2节所述；另一种是直接对HLA进行推理——不管存在多少种实现，如11.4.3节所述。
chap4_para1955,5,,后一种方法可以导出可证明为正确的抽象规划，而无须考虑它们的实现。
chap4_para1956,1,,11.4.2　搜索基元解
chap4_para1957,1,,HTN规划通常是由一个称为Act的“顶层”动作制定的，其目标是找到能达成目标的Act的实现。
chap4_para1957,2,,这种方法是完全通用的。
chap4_para1957,3,,"例如，经典的规划问题可以定义为：对于每个基元动作ai，给出一个带有步骤[ai, Act]的Act的细化。"
chap4_para1957,4,,这就创建了一个让我们添加动作的Act的递归定义。
chap4_para1957,5,,但我们需要某种方法来停止递归。
chap4_para1957,6,,为此，我们为Act提供了另一条细化，其中包含一个空步骤列表，并且前提等于问题的目标。
chap4_para1957,7,,这就是说，如果目标已经实现了，那么正确的实现就是什么也不做。
chap4_para1958,1,,该方法引出了一个简单的算法：在当前规划中反复选择一个HLA，并将其替换为它的一个细化，直到规划达成目标。
chap4_para1958,2,,图11-8展示了一种基于广度优先树搜索的实现。
chap4_para1958,3,,规划的考虑顺序是细化嵌套的深度，而非基元步骤的数量。
chap4_para1958,4,,设计该算法的图搜索版本、深度优先版本或迭代加深版本很简单。
chap4_para1959,1,,本质上，这种分层搜索的形式探索了一个序列空间，它符合HLA库中关于如何做事的知识。
chap4_para1959,2,,每个细化确定的动作序列和细化的前提都可以编码大量知识。
chap4_para1959,3,,对于一些领域，HTN规划器已经能够用少量搜索生成大型规划。
chap4_para1959,4,,"例如，O-Plan（Bell and Tate, 1985）将HTN规划与调度结合起来，已经被用于为日立制定生产规划。"
chap4_para1959,5,,一个典型的问题中包含一条制造350种产品、有35台装配机和2000多种不同操作的生产线。
chap4_para1959,6,,这个规划器生成了一个30天的进度计划，每天进行3次8小时换班，涉及数千万个步骤。
chap4_para1959,7,,另一个重要方面是，根据定义，HTN规划是分层结构的，这通常更利于人类理解。
chap4_para196,1,An online depth-first exploration agent (for deterministic but unknown actions) is shown in Figure 4.,另外，在线算法只能找到其实际占据的状态的后继。
chap4_para196,2,21.,为了避免长途跋涉到一个相距较远的状态来扩展下一个节点，按照局部顺序扩展节点似乎更好。
chap4_para196,3,"This agent stores its map in a table, result[s, a], that records the state resulting from executing action a in state s.",深度优先搜索恰好具有这一性质，因为（如果算法不用回溯）下一个扩展节点是前一个扩展节点的子节点。
chap4_para196,4,"(For nondeterministic actions, the agent could record a set of states under results[s, a].",
chap4_para196,5,") Whenever the current state has unexplored actions, the agent tries one of those actions.",
chap4_para196,6,The difficulty comes when the agent has tried all the actions in a state.,
chap4_para196,7,"In offline depth-first search, the state is simply dropped from the queue; in an online search, the agent has to backtrack in the physical world.",
chap4_para196,8,"In depth-first search, this means going back to the state from which the agent most recently entered the current state.",
chap4_para196,9,"To achieve that, the algorithm keeps another table that lists, for each state, the predecessor states to which the agent has not yet backtracked.",
chap4_para196,10,"If the agent has run out of states to which it can backtrack, then its search is complete.",
chap4_para1960,1,,图11-8　分层前向规划搜索的广度优先实现。
chap4_para1960,2,,最初提供给算法的规划是[Act]。
chap4_para1960,3,,Refinements函数返回一个动作序列集， HLA的每个由状态outcome满足其前提的细化都对应其中一个动作序列
chap4_para1961,1,,分层搜索的计算优势可以从一个理想化的案例中看出。
chap4_para1961,2,,假设一个规划问题的解有d个基元动作。
chap4_para1961,3,,对于一个每个状态有b个可用动作的非分层前向状态空间规划器，其代价是O(bd)，如第3章所述。
chap4_para1961,4,,对于一个HTN规划，我们假设一个非常规则的细化结构：每个非基元动作有r个可能的细化，每个细化到在下一层次有k个动作。
chap4_para1961,5,,我们想知道这个结构有多少种不同的细化树。
chap4_para1961,6,,现在，如果在基元层有d个动作，根节点下面的层次数量是logk d，所以内部细化节点的数量是。
chap4_para1961,7,,每个内部节点有r个可能的细化，因此能构造个可能的分解树。
chap4_para1962,1,,仔细查看这个公式，我们可以看到使r较小而k较大会减少大量开销：如果b和r是可比较的，我们取非分层代价的k次方根。
chap4_para1962,2,,较小的r和较大的k意味着一个HLA的库只有少量的细化，每个细化都产生一个较长的动作序列。
chap4_para1962,3,,但这并不总是可能的：可用于广泛问题的长动作序列极为少见。
chap4_para197,1,Figure 4.21An online search agent that uses depth-first exploration. The agent can safely explore only in state spaces in which every action can be “undone” by some other action.,图4-21为在线深度优先探索智能体（动作是确定性但未知的）。
chap4_para197,2,,"智能体将它的地图存储在一个result[s, a]表中，记录了在状态s下执行动作a所产生的状态。"
chap4_para197,3,,"（对于非确定性动作，智能体可以在results[s, a]中记录状态集合。"
chap4_para197,4,,）只要当前状态存在未探索过的动作，智能体就会尝试其中一个动作。
chap4_para197,5,,当智能体尝试完某个状态下的所有动作时，问题就来了。
chap4_para197,6,,在离线深度优先搜索中，我们只是将状态从队列中删除；而在线搜索中，智能体必须在物理世界中回溯。
chap4_para197,7,,在深度优先搜索中，这意味着回溯到智能体进入当前状态前的最近状态。
chap4_para197,8,,为了实现这一点，算法需要维护另一个表，表中列出了每个状态尚未回溯到的前驱状态。
chap4_para197,9,,如果智能体已经没有可回溯的状态，那么搜索就完成了。
chap4_para198,1,"We recommend that the reader trace through the progress of ONLINE-DFS-AGENT when applied to the maze given in Figure 4.19. It is fairly easy to see that the agent will, in the worst case, end up traversing every link in the state space exactly twice. For exploration, this is optimal; for finding a goal, on the other hand, the agent’s competitive ratio could be arbitrarily bad if it goes off on a long excursion when there is a goal right next to the initial state. An online variant of iterative deepening solves this problem; for an environment that is a uniform tree, the competitive ratio of such an agent is a small constant.",图4-21　使用深度优先探索的在线搜索智能体。
chap4_para198,2,,智能体只有在每个动作都可以被其他动作“撤消”的状态空间中才能安全地探索
chap4_para199,1,"Because of its method of backtracking, ONLINE-DFS-AGENT works only in state spaces where the actions are reversible.",我们建议读者在求解图4-19中的迷宫问题时跟踪Online-DFS-Agent的进度。
chap4_para199,2,"There are slightly more complex algorithms that work in general state spaces, but no such algorithm has a bounded competitive ratio.",很容易看到，最坏情况下，智能体最终恰好要遍历状态空间中的每个连接两次。
chap4_para199,3,,对探索来说，这是最优的；但是，对寻找目标来说，如果在初始状态旁边恰好有一个目标状态，智能体的竞争比将变得无限差。
chap4_para199,4,,在线迭代加深算法可以解决这一问题；对于均衡树环境，这样一个智能体的竞争比是一个很小的常数。
chap4_para2,1,"In which we relax the simplifying assumptions of the previous chapter, to get closer to the real world.",第3章讨论了完全可观测的、确定性的、静态的、已知的环境中的问题，问题的解是一个动作序列。
chap4_para2,2,,在本章中，我们将放宽这些限制。
chap4_para2,3,,首先，我们考虑这样一个问题，即寻找一个好的状态而不考虑到达该状态的路径，状态包括离散状态（4.1节）和连续状态（4.2节）。
chap4_para2,4,,然后，我们放宽了确定性假设（4.3节）和可观测性假设（4.4节）。
chap4_para2,5,,在一个非确定性的世界中，智能体将需要一个条件规划，并根据它所观测到的情况执行不同的动作——例如，红灯停，绿灯行。
chap4_para2,6,,对于部分可观测性环境，智能体还需要记录它的可能状态。
chap4_para2,7,,最后，4.5节将指导智能体使用在线搜索（online search）通过一个未知空间，在未知空间中一边前进一边学习。
chap4_para20,1,•Ridges: A ridge is shown in Figure 4.4. Ridges result in a sequence of local maxima that is very difficult for greedy algorithms to navigate.,我们怎么才能求解更多问题？
chap4_para20,2,,一个答案是当我们到达一个平台区时继续前进——允许横向移动（sideways move），希望这个平台区真的是一个山肩，如图4-1所示。
chap4_para20,3,,但如果我们实际上位于一块平坦的局部极大值上，那么算法就会陷入死循环。
chap4_para20,4,,因此，我们可以限制连续横向移动的次数，如在100次连续横向移动之后停止。
chap4_para20,5,,这种方法将爬山法成功求解问题实例的百分比从14%提高到了94%。
chap4_para20,6,,成功是有代价的：平均下来，对每个成功实例算法需要运行约21步，失败实例约64步。
chap4_para200,1,4.,由于其回溯方法，Online-DFS-Agent只在动作可逆的状态空间中有效。
chap4_para200,2,5.,在一般的状态空间中，有一些更复杂的算法，但是这类算法的竞争比都不是有界的。
chap4_para200,3,3Online local search,
chap4_para201,1,"Like depth-first search, hill-climbing search has the property of locality in its node expansions.",4.5.3　在线局部搜索
chap4_para201,2,"In fact, because it keeps just one current state in memory, hill-climbing search is already an online search algorithm!",
chap4_para201,3,"Unfortunately, the basic algorithm is not very good for exploration because it leaves the agent sitting at local maxima with nowhere to go.",
chap4_para201,4,"Moreover, random restarts cannot be used, because the agent cannot teleport itself to a new start state.",
chap4_para202,1,"Instead of random restarts, one might consider using a random walk to explore the environment. A random walk simply selects at random one of the available actions from the current state; preference can be given to actions that have not yet been tried. It is easy to prove that a random walk will eventually find a goal or complete its exploration, provided that the space is finite and safely explorable.9 On the other hand, the process can be very slow. Figure 4.22 shows an environment in which a random walk will take exponentially many steps to find the goal, because, for each state in the top row except S, backward progress is twice as likely as forward progress. The example is contrived, of course, but there are many real-world state spaces whose topology causes these kinds of “traps” for random walks.",与深度优先搜索一样，爬山搜索在节点扩展上也有局部性。
chap4_para202,2,,事实上，因为爬山搜索在内存中只保存一个当前状态，它已经是在线搜索算法！
chap4_para202,3,,遗憾的是，基础算法并不适用于探索，因为智能体会陷入局部极大值而无路可走。
chap4_para202,4,,此外，不能使用随机重启，因为智能体无法将自己瞬移到一个新的初始状态。
chap4_para203,1,Figure 4.,相比于随机重启，我们可以考虑使用随机游走（random walk）来探索环境。
chap4_para203,2,22An environment in which a random walk will take exponentially many steps to find the goal.,随机游走只是从当前状态中随机选择一个可用动作，可以优先考虑尚未尝试的动作。
chap4_para203,3,,容易证明，当空间有限且可安全探索时，随机游走最终会找到一个目标或完成探索。
chap4_para203,4,,[9]但是，这一过程可能非常慢。
chap4_para203,5,,图4-22为一个环境实例，在这个环境中，随机游走将耗费指数级的步骤来寻找目标，因为对于第一行除S之外的每个状态，后退的可能性是前进的两倍。
chap4_para203,6,,当然，这个例子是人为设计的，但是真实世界中许多状态空间的拓扑结构都会导致这类随机游走“陷阱”。
chap4_para204,1,Augmenting hill climbing with memory rather than randomness turns out to be a more effective approach. The basic idea is to store a “current best estimate” H(s) of the cost to reach the goal from each state that has been visited. H(s) starts out being just the heuristic estimate h(s) and is updated as the agent gains experience in the state space.,
chap4_para205,1,"Figure 4.23 shows a simple example in a one-dimensional state space. In (a), the agent seems to be stuck in a flat local minimum at the red state. Rather than staying where it is, the agent should follow what seems to be the best path to the goal given the current cost estimates for its neighbors. The estimated cost to reach the goal through a neighbor s' is the cost to get to s' plus the estimated cost to get to a goal from there—that is, c(s, a, s') + H(s'). In the example, there are two actions, with estimated costs 1 + 9 to the left and 1 + 2 to the right, so it seems best to move right.",[9]　随机游走在无限的一维和二维网格上是完备的。
chap4_para205,2,,"在三维网格上，游走返回起点的概率只有大约0.3405（Hughes, 1995）。"
chap4_para206,1,Figure 4.,图4-22　环境实例，随机游走需要耗费指数级的步骤来寻找目标
chap4_para206,2,23Five iterations of LRTA* on a one-dimensional state space.,
chap4_para206,3,"Each state is labeled with H(s), the current cost estimate to reach a goal, and every link has an action cost of 1.",
chap4_para206,4,"The red state marks the location of the agent, and the updated cost estimates at each iteration have a double circle.",
chap4_para207,1,"In (b) it is clear that the cost estimate of 2 for the red state in (a) was overly optimistic. Since the best move cost 1 and led to a state that is at least 2 steps from a goal, the red state must be at least 3 steps from a goal, so its H should be updated accordingly, as shown in Figure 4.23(b). Continuing this process, the agent will move back and forth twice more, updating H each time and “flattening out” the local minimum until it escapes to the right.",事实证明，增加爬山法的内存而非随机性是一种更有效的方法。
chap4_para207,2,,基本思想是，存储从已访问的每个状态出发到达目标所需代价的“当前最佳估计”H(s)。
chap4_para207,3,,H(s)开始时只是启发式估计，然后根据智能体在状态空间中获得的经验不断更新。
chap4_para208,1,"An agent implementing this scheme, which is called learning real-time A* (LRTA*), is shown in Figure 4.24. Like ONLINE-DFS-AGENT, it builds a map of the environment in the result table. It updates the cost estimate for the state it has just left and then chooses the “apparently best” move according to its current cost estimates. One important detail is that actions that have not yet been tried in a state s are always assumed to lead immediately to the goal with the least possible cost, namely h(s). This optimism under uncertainty encourages the agent to explore new, possibly promising paths.",图4-23为一维状态空间中的一个简单示例。
chap4_para208,2,,在图4-23a中，智能体似乎陷入了位于红色状态的局部极小值。
chap4_para208,3,,智能体不应该停留在原地，而应该根据其邻居节点的当前代价估计值选择到达目标的最优路径。
chap4_para208,4,,"经由邻居节点s'到达目标的估计代价等于到达s'的代价加上从s'到达目标的估计代价，即c(s, a, s') + H(s')。"
chap4_para208,5,,在这个示例中，有2个动作，估计代价分别为向左1 + 9，向右1 + 2，因此最好向右移动。
chap4_para209,1,Figure 4.,在图4-23b中，显然，将图4-23a中红色状态的代价估计为2是过于乐观的。
chap4_para209,2,"24LRTA*-AGENT selects an action according to the values of neighboring states, which are updated as the agent moves about the state space.",因为最佳移动的代价为1，而且其结果状态离目标状态至少还有2步，所以红色状态离目标一定至少还有3步，所以应该相应地更新红色状态的H，如图4-23b所示。
chap4_para209,3,,继续上述过程，智能体将再来回移动两次，每次都会更新H并“拉平”局部极小值，直到它逃逸到右侧。
chap4_para21,1,"•Plateaus: A plateau is a flat area of the state-space landscape. It can be a flat local maximum, from which no uphill exit exists, or a shoulder, from which progress is possible. (See Figure 4.1.) A hill-climbing search can get lost wandering on the plateau.",爬山法存在很多变体。
chap4_para21,2,,随机爬山法（stochastic hill climbing）在上坡行动中随机选择一个；被选中的概率随着上坡陡度的变化而变化。
chap4_para21,3,,这种方法通常比最陡上升法收敛得更慢，但在某些状态地形图中，它能找到更好的解。
chap4_para21,4,,首选爬山法（first-choice hill climbing）通过不断随机地生成后继直到生成一个比当前状态更好的后继为止来实现随机爬山。
chap4_para21,5,,当一个状态存在众多（如数千个）后继时，这是一个很好的策略。
chap4_para210,1,"An LRTA* agent is guaranteed to find a goal in any finite, safely explorable environment. Unlike A*, however, it is not complete for infinite state spaces—there are cases where it can be led infinitely astray. It can explore an environment of n states in O(n2) steps in the worst case, but often does much better. The LRTA* agent is just one of a large family of online agents that one can define by specifying the action selection rule and the update rule in different ways. We discuss this family, developed originally for stochastic environments, in Chapter 23.",能够实现上述方案的智能体称为实时学习A*（learning real-time A*，LRTA*）智能体，如图4-24所示。
chap4_para210,2,,同Online-DFS-Agent一样，它用result表构建环境地图。
chap4_para210,3,,它首先更新刚刚离开的状态的代价估计值，然后根据当前的代价估计值选择“显然最佳”移动。
chap4_para210,4,,一个重要的细节是，在状态s下尚未尝试的动作总是被假定为以最少的可能代价，即h(s)直接到达目标。
chap4_para210,5,,这种不确定性下的乐观主义（optimism under uncertainty）鼓励智能体去探索新的、可能更有希望的路径。
chap4_para211,1,4.,图4-23　一维状态空间上LRTA*的5次迭代。
chap4_para211,2,5.,每个状态都标有H(s)，即到达目标的当前代价估计值，每个连接的动作代价为1。
chap4_para211,3,4Learning in online search,红色状态表示智能体的位置，每次迭代所更新的代价估计值以双圈标记
chap4_para212,1,"The initial ignorance of online search agents provides several opportunities for learning. First, the agents learn a “map” of the environment—more precisely, the outcome of each action in each state—simply by recording each of their experiences. Second, the local search agents acquire more accurate estimates of the cost of each state by using local updating rules, as in LRTA*. In Chapter 23, we show that these updates eventually converge to exact values for every state, provided that the agent explores the state space in the right way. Once exact values are known, optimal decisions can be taken simply by moving to the lowest-cost successor—that is, pure hill climbing is then an optimal strategy.",图4-24　LRTA*-Agent根据相邻状态的值选择动作，智能体在状态空间中移动时更新状态值
chap4_para213,1,If you followed our suggestion to trace the behavior of ONLINE-DFS-AGENT in the environment of Figure 4.,LRTA* 智能体保证在任何有限的、可安全探索的环境中都能找到目标。
chap4_para213,2,"19, you will have noticed that the agent is not very bright.",然而，不同于A*，LRTA*在无限状态空间中是不完备的——在某些情况下，它可能被无限地引入歧途。
chap4_para213,3,"For example, after it has seen that the Up action goes from (1,1) to (1,2), the agent still has no idea that the Down action goes back to (1,1) or that the Up action also goes from (2,1) to (2,2), from (2,2) to (2,3), and so on.",在最坏情况下，探索状态数为n的环境可能需要O(n2)步，但通常情况下会比这种情况好得多。
chap4_para213,4,"In general, we would like the agent to learn that Up increases the y-coordinate unless there is a wall in the way, that Down reduces it, and so on.",LRTA* 智能体只是一个庞大的在线智能体家族中的一员，可以通过以不同方式指定动作选择规则和更新规则来定义。
chap4_para213,5,,我们将在第22章中详细讨论这一发源于随机环境的在线智能体家族。
chap4_para214,1,"For this to happen, we need two things.",4.5.4　在线搜索中的学习
chap4_para214,2,"First, we need a formal and explicitly manipulable representation for these kinds of general rules; so far, we have hidden the information inside the black box called the RESULT function.",
chap4_para214,3,Chapters 8 to 11 are devoted to this issue.,
chap4_para214,4,"Second, we need algorithms that can construct suitable general rules from the specific observations made by the agent.",
chap4_para214,5,These are covered in Chapter 19.,
chap4_para215,1,"If we anticipate that we will be called upon to solve multiple similar problems in the future then it makes sense to invest time (and memory) to make those future searches easier. There are several ways to do this, all falling under the heading of incremental search. We could keep the search tree in memory and reuse the parts of it that are unchanged in the new problem. We could keep the heuristic h values and update them as we gain new information—either because the world has changed or because we have computed a better estimate. Or we could keep the best-path g values, using them to piece together a new solution, and updating them when the world changes.",在线搜索智能体初始时对环境的无知为我们提供了一些学习的机会。
chap4_para215,2,,首先，智能体通过记录它们的每一次经验来学习环境“地图”——更准确地说，学习每种状态下每个动作的结果。
chap4_para215,3,,其次，当智能体以正确的方式探索状态空间时，局部搜索智能体可以利用局部更新规则获得每个状态代价更准确的估计值。
chap4_para215,4,,一旦知道代价的准确值，只需移动到代价最低的后继状态就能实现最优决策，也就是说，纯粹的爬山法就是一个最优策略。
chap4_para216,1,"This chapter has examined search algorithms for problems in partially observable, nondeterministic, unknown, and continuous environments.",如果按照我们的建议在图4-19的环境中跟踪Online-DFS-Agent的行为，你会注意到智能体不是非常聪明。
chap4_para216,2,,"例如，在它已经知道Up动作能够从(1, 1)到达(1, 2)后，它仍然不知道Down动作能回到(1, 1)，或者Up动作还能从(2, 1)到(2, 2)，从(2, 2)到(2, 3)，等等。"
chap4_para216,3,,一般来说，我们希望智能体能够学到，Up在不遇到墙的情况下使得y坐标值增加，Down则使得y坐标值降低，等等。
chap4_para217,1,"•Local search methods such as hill climbing keep only a small number of states in memory. They have been applied to optimization problems, where the idea is to find a high-scoring state, without worrying about the path to the state. Several stochastic local search algorithms have been developed, including simulated annealing, which returns optimal solutions when given an appropriate cooling schedule.",要实现这一点，我们需要做两件事。
chap4_para217,2,,首先，需要对这类一般规则有一个形式的、可显式操纵的表示；到目前为止，信息都被隐藏在名为Result函数的黑盒中。
chap4_para217,3,,第8～11章将专门讨论这个问题。
chap4_para217,4,,其次，需要能够根据智能体所得到的具体观测信息构造合适的一般规则的算法。
chap4_para217,5,,这些内容将在第19章中讨论。
chap4_para218,1,"•Many local search methods apply also to problems in continuous spaces. Linear programming and convex optimization problems obey certain restrictions on the shape of the state space and the nature of the objective function, and admit polynomial-time algorithms that are often extremely efficient in practice. For some mathematically well-formed problems, we can find the maximum using calculus to find where the gradient is zero; for other problems we have to make do with the empirical gradient, which measures the difference in fitness between two nearby points.",如果我们预计将来会被要求求解多个类似问题，那么投入时间（和内存）使得这些未来搜索更容易是有意义的。
chap4_para218,2,,有几种方法可以做到这一点，它们都属于增量搜索（incremental search）的范畴。
chap4_para218,3,,我们可以将搜索树保留在内存中，并复用在新问题中未发生改变的部分。
chap4_para218,4,,我们可以保留启发式代价函数h的值，并在获得新信息时更新它们——要么是因为世界发生改变，要么是因为我们计算出了更好的估计值。
chap4_para218,5,,或者我们可以保留最优路径的g值，用它们拼凑出一个新的解，并在世界发生改变时对它们进行更新。
chap4_para219,1,"•An evolutionary algorithm is a stochastic hill-climbing search in which a population of states is maintained. New states are generated by mutation and by crossover, which combines pairs of states.",
chap4_para22,1,"Description From each of the local maxima, arrows point downward in either direction.",另一种变体是随机重启爬山法（random-restart hill climbing），它来自于一句格言：“如果一开始没有成功，那么尝试，再尝试。
chap4_para22,2,The intersecting points are depicted by dark circles.,”它从随机生成的初始状态开始，执行一系列爬山搜索，直到找到目标。
chap4_para22,3,,算法完备的概率为1，因为它最终会生成一个目标状态作为初始状态。
chap4_para22,4,,如果每一次爬山搜索成功的概率为p，那么需要重启的期望次数为1 / p。
chap4_para22,5,,对于不允许横向移动的8皇后实例，，所以大概需要7次迭代才能找到一个目标（6次失败，1次成功）。
chap4_para22,6,,所需步数的期望为一次成功迭代的代价加上(1−p)/p倍的失败代价，总共约为22步。
chap4_para22,7,,当允许横向移动时，平均需要次迭代，步。
chap4_para22,8,,因此，对于8皇后问题，随机重启爬山法是非常有效的。
chap4_para22,9,,即使有300万个皇后，这种方法也能在很短的时间内找到解。
chap4_para22,10,,[1]
chap4_para220,1,"•In nondeterministic environments, agents can apply AND–OR search to generate contingent plans that reach the goal regardless of which outcomes occur during execution.",本章讨论了部分可观测的、非确定性的、未知的和连续的环境中问题的搜索算法。
chap4_para221,1,"•When the environment is partially observable, the belief state represents the set of possible states that the agent might be in.",● 局部搜索算法，如爬山法，在内存中只保留少量状态。
chap4_para221,2,,这些方法已被应用于优化问题，其思想是找到一个高分值的状态，而不考虑进入该状态的路径。
chap4_para221,3,,研究人员已经开发了一些随机局部搜索算法，包括模拟退火，当给定适当的冷却方案时它能返回最优解。
chap4_para222,1,"•Standard search algorithms can be applied directly to belief-state space to solve sensorless problems, and belief-state AND–OR search can solve general partially observable problems. Incremental algorithms that construct solutions state by state within a belief state are often more efficient.",● 许多局部搜索方法同样适用于连续空间中的问题。
chap4_para222,2,,线性规划和凸优化问题服从状态空间形状和目标函数性质上的某些限制，并且允许多项式时间算法，这些算法在实践中往往非常高效。
chap4_para222,3,,对于一些数学上合式的问题，我们可以使用微积分找到梯度为零的最大值；对于其他问题，我们必须使用经验梯度，即测量两个邻近点间的适应度差值。
chap4_para223,1,"• Exploration problems arise when the agent has no idea about the states and actions of its environment. For safely explorable environments, online search agents can build a map and find a goal if one exists. Updating heuristic estimates from experience provides an effective method to escape from local minima.",● 进化算法是一种维护状态种群的随机爬山搜索。
chap4_para223,2,,通过突变和杂交（结合状态对）产生新状态。
chap4_para224,1,Bibliographical and Historical Notes,● 在非确定性环境中，智能体可以应用与或搜索算法生成应变规划，无论执行过程中出现何种结果，它都能实现目标。
chap4_para225,1,"Local search techniques have a long history in mathematics and computer science. Indeed, the Newton–Raphson method (Newton, 1671; Raphson, 1690) can be seen as a very efficient local search method for continuous spaces in which gradient information is available. Brent (1973) is a classic reference for optimization algorithms that do not require such information. Beam search, which we have presented as a local search algorithm, originated as a bounded-width variant of dynamic programming for speech recognition in the HARPY system (Lowerre, 1976). A related algorithm is analyzed in depth by Pearl (1984, Ch. 5).",● 如果环境是部分可观测的，信念状态表示智能体可能位于的可能状态的集合。
chap4_para226,1,"The topic of local search was reinvigorated in the early 1990s by surprisingly good results for large constraint-satisfaction problems such as n-queens (Minton et al., 1992) and Boolean satisfiability (Selman et al., 1992) and by the incorporation of randomness, multiple simultaneous searches, and other improvements. This renaissance of what Christos Papadimitriou has called “New Age” algorithms also sparked increased interest among theoretical computer scientists (Koutsoupias and Papadimitriou, 1992; Aldous and Vazirani, 1994).",● 标准搜索算法可以直接应用于信念状态空间求解无传感器问题，而信念状态与或搜索算法可以求解一般的部分可观测问题。
chap4_para226,2,,在一个信念状态中逐状态构造解的增量算法通常效率更高。
chap4_para227,1,"In the field of operations research, a variant of hill climbing called tabu search has gained popularity (Glover and Laguna, 1997).",● 探索问题发生在智能体对环境的状态和动作一无所知时。
chap4_para227,2,"This algorithm maintains a tabu list of k previously visited states that cannot be revisited; as well as improving efficiency when searching graphs, this list can allow the algorithm to escape from some local minima.",对于可安全探索的环境，在线搜索智能体能够构建地图并找到目标（如果存在的话）。
chap4_para227,3,,根据经验来更新启发式估计值提供了一种避免局部极小值的有效方法。
chap4_para228,1,"Another useful improvement on hill climbing is the STAGE algorithm (Boyan and Moore, 1998). The idea is to use the local maxima found by random-restart hill climbing to get an idea of the overall shape of the landscape. The algorithm fits a smooth quadratic surface to the set of local maxima and then calculates the global maximum of that surface analytically. This becomes the new restart point. Gomes et al. (1998) showed that the run times of systematic backtracking algorithms often have a heavy-tailed distribution, which means that the probability of a very long run time is more than would be predicted if the run times were exponentially distributed. When the run time distribution is heavy-tailed, random restarts find a solution faster, on average, than a single run to completion. Hoos and Stützle (2004) provide a book-length coverage of the topic.",
chap4_para229,1,Simulated annealing was first described by Kirkpatrick et al.,微信扫码关注【异步社区】微信公众号，回复“e59810”获取本书配套资源以及异步社区15天VIP会员卡，近千本电子书免费畅读。
chap4_para229,2,"(1983), who borrowed directly from the Metropolis algorithm (which is used to simulate complex systems in physics (Metropolis et al.",
chap4_para229,3,",1953) and was supposedly invented at a Los Alamos dinner party).",
chap4_para229,4,"Simulated annealing is now a field in itself, with hundreds of papers published every year.",
chap4_para23,1,Figure 4.,
chap4_para23,2,4Illustration of why ridges cause difficulties for hill climbing.,
chap4_para23,3,"The grid of states (dark circles) is superimposed on a ridge rising from left to right, creating a sequence of local maxima that are not directly connected to each other.",
chap4_para23,4,"From each local maximum, all the available actions point downhill.",
chap4_para23,5,"Topologies like this are common in low-dimensional state spaces, such as points in a two-dimensional plane.",
chap4_para23,6,"But in state spaces with hundreds or thousands of dimensions, this intuitive picture does not hold, and there are usually at least a few dimensions that make it possible to escape from ridges and plateaus.",
chap4_para230,1,"Finding optimal solutions in continuous spaces is the subject matter of several fields, including optimization theory, optimal control theory, and the calculus of variations.",第5章　对抗搜索和博弈
chap4_para230,2,The basic techniques are explained well by Bishop (1995); Press et al.,
chap4_para230,3,(2007) cover a wide range of algorithms and provide working software.,
chap4_para231,1,"Researchers have taken inspiration for search and optimization algorithms from a wide variety of fields of study: metallurgy (simulated annealing); biology (genetic algorithms); neuroscience (neural networks); mountaineering (hill climbing); economics (market-based algorithms (Dias et al., 2006)); physics (particle swarms (Li and Yao, 2012) and spin glasses (Mézard et al., 1987)); animal behavior (reinforcement learning, grey wolf optimizers (Mirjalili and Lewis, 2014)); ornithology (Cuckoo search (Yang and Deb, 2014)); entomology (ant colony (Dorigo et al., 2008), bee colony (Karaboga and Basturk, 2007), firefly (Yang, 2009) and glowworm (Krishnanand and Ghose, 2009) optimization); and others.",在本章中，我们将探索有其他智能体计划与我们对抗时的环境。
chap4_para232,1,Linear programming (LP) was first studied systematically by the mathematician Leonid Kantorovich (1939).,在本章中，我们将讨论竞争环境（competitive environment），在这种环境中，两个或两个以上的智能体具有互相冲突的目标，这引出了对抗搜索（adversarial search）问题。
chap4_para232,2,"It was one of the first applications of computers; the simplex algorithm (Dantzig, 1949) is still used despite worst-case exponential complexity.",我们将专注于讨论博弈[1]，如国际象棋、围棋和扑克，而不是处理真实世界中的混乱冲突。
chap4_para232,3,"Karmarkar (1984) developed the far more efficient family of interior-point methods, which was shown to have polynomial complexity for the more general class of convex optimization problems by Nesterov and Nemirovski (1994).",对人工智能研究人员来说，这些博弈的简化特性是一个优势：博弈状态很容易表示，智能体通常仅能执行少数几个动作，而且动作的效果由明确的规则定义。
chap4_para232,4,Excellent introductions to convex optimization are provided by Ben-Tal and Nemirovski (2001) and Boyd and Vandenberghe (2004).,对于体育比赛（如槌球和冰球），描述更加复杂，可能动作的范围更大，而且定义动作合法性的规则也不够明确。
chap4_para232,5,,除足球机器人外，体育比赛并没有引起人工智能社区的很大兴趣。
chap4_para233,1,"Work by Sewall Wright (1931) on the concept of a fitness landscape was an important precursor to the development of genetic algorithms. In the 1950s, several statisticians, including Box (1957) and Friedman (1959), used evolutionary techniques for optimization problems, but it wasn’t until Rechenberg (1965) introduced evolution strategies to solve optimization problems for airfoils that the approach gained popularity. In the 1960s and 1970s, John Holland (1975) championed genetic algorithms, both as a useful optimization tool and as a method to expand our understanding of adaptation (Holland, 1995).",
chap4_para234,1,"The artificial life movement (Langton, 1995) took this idea one step further, viewing the products of genetic algorithms as organisms rather than solutions to problems. The Baldwin effect discussed in the chapter was proposed roughly simultaneously by Conwy Lloyd Morgan (1896) and James (Baldwin, 1896). Computer simulations have helped to clarify its implications (Hinton and Nowlan, 1987; Ackley and Littman, 1991; Morgan and Griffiths, 2015). Smith and Szathmáry (1999), Ridley (2004), and Carroll (2007) provide general background on evolution.",[1]　对应英文game在博弈论中译为“博弈”，但在本书中不同语境下会根据具体情况使用博弈、游戏、比赛等。
chap4_para234,2,,——译者注
chap4_para235,1,"Most comparisons of genetic algorithms to other approaches (especially stochastic hill climbing) have found that the genetic algorithms are slower to converge (O’Reilly and Oppacher, 1994; Mitchell et al., 1996; Juels and Wattenberg, 1996; Baluja, 1997). Such findings are not universally popular within the GA community, but recent attempts within that community to understand population-based search as an approximate form of Bayesian learning (see Chapter 21) might help close the gap between the field and its critics (Pelikan et al.,1999). The theory of quadratic dynamical systems may also explain the performance of GAs (Rabani et al., 1998). There are some impressive practical applications of GAs, in areas as diverse as antenna design (Lohn et al., 2001), computer-aided design (Renner and Ekart, 2003), climate models (Stanislawska et al., 2015), medicine (Ghaheri et al., 2015), and designing deep neural networks (Miikkulainen et al., 2019).",
chap4_para236,1,The field of genetic programming is a subfield of genetic algorithms in which the representations are programs rather than bit strings.,对于多智能体环境，我们至少可以有3种观点。
chap4_para236,2,"The programs are represented in the form of syntax trees, either in a standard programming language or in specially designed formats to represent electronic circuits, robot controllers, and so on.",第一种观点适用于智能体数量非常大的情况，即把它们看作一个经济（economy）整体来考虑，这让我们可以做出例如“需求增长会导致价格上涨”这样的预测，而不需要预测任何个体智能体的动作。
chap4_para236,3,Crossover involves splicing together subtrees in such a way that the offspring are guaranteed to be well-formed expressions.,
chap4_para237,1,"Interest in genetic programming was spurred by the work of John Koza (1992, 1994), but it goes back at least to early experiments with machine code by Friedberg (1958) and with finite-state automata by Fogel et al.",第二种观点是，我们可以认为对抗智能体只是环境的一部分——这一部分让环境变成非确定性的。
chap4_para237,2,(1966).,但如果我们以对雨建模一样的方式（例如，雨有时下，有时不下）对对手进行建模，我们就会忽略对手正在积极地尝试击败我们这一事实，而雨没有这样的意图。
chap4_para237,3,"As with genetic algorithms, there is debate about the effectiveness of the technique.",
chap4_para237,4,Koza et al.,
chap4_para237,5,(1999) describe experiments in the use of genetic programming to design circuit devices.,
chap4_para238,1,"The journals Evolutionary Computation and IEEE Transactions on Evolutionary Computation cover evolutionary algorithms; articles are also found in Complex Systems, Adaptive Behavior, and Artificial Life.",第三种观点是用对抗博弈树搜索技术显式地对对抗智能体建模。
chap4_para238,2,The main conference is the Genetic and Evolutionary Computation Conference (GECCO).,这就是本章所涵盖的内容。
chap4_para238,3,"Good overview texts on genetic algorithms include those by Mitchell (1996), Fogel (2000), Langdon and Poli (2002), and Poli et al.",我们从一类受限的博弈开始，定义最优移动并寻找最优移动的算法——极小化极大搜索（minimax search），它是与或搜索的一种推广（见图4-11）。
chap4_para238,4,(2008).,我们指出，剪枝（pruning）通过忽略搜索树中对最优移动没有影响的部分来提高搜索效率。
chap4_para238,5,,对于非平凡博弈，我们通常没有足够的时间以确保找到最优移动（即使使用剪枝），我们不得不在某个时刻停止搜索。
chap4_para239,1,"The unpredictability and partial observability of real environments were recognized early on in robotics projects that used planning techniques, including Shakey (Fikes et al., 1972) and FREDDY (Michie, 1972). The problems received more attention after the publication of McDermott’s (1978a) influential article Planning and Acting.",对于每一个我们选择在那里停止搜索的状态，我们都需要知道谁是获胜者。
chap4_para239,2,,要回答这个问题，有一个选择：可以基于状态特征应用启发式评价函数来估计谁是获胜者（5.3节），或者可以从该状态开始快速模拟至博弈结束，再取多次模拟结果的平均值（5.4节）。
chap4_para24,1,"In each case, the algorithm reaches a point at which no progress is being made. Starting from a randomly generated 8-queens state, steepest-ascent hill climbing gets stuck 86% of the time, solving only 14% of problem instances. On the other hand, it works quickly, taking just 4 steps on average when it succeeds and 3 when it gets stuck—not bad for a state space with 88 ≈ 17 million states.","[1]　卢比等人（Luby et al., 1993）建议在搜索固定次数之后重启，并表明这比让每次搜索都无限期地继续下去要有效得多。"
chap4_para240,1,"The first work to make explicit use of AND–OR trees seems to have been Slagle’s SAINT program for symbolic integration, mentioned in Chapter 1. Amarel (1967) applied the idea to propositional theorem proving, a topic discussed in Chapter 7, and introduced a search algorithm similar to AND-OR-GRAPH-SEARCH. The algorithm was further developed by Nilsson (1971), who also described AO*—which, as its name suggests, finds optimal solutions. AO* was further improved by Martelli and Montanari (1973).",5.5节讨论了包含机会因素（通过掷骰子或洗牌）的博弈，5.6节讨论了不完美信息（imperfect information）博弈（如扑克和桥牌，即并非所有牌对所有玩家都可见）。
chap4_para241,1,"AO* is a top-down algorithm; a bottom-up generalization of A* is A*LD, for A* Lightest Derivation (Felzenszwalb and McAllester, 2007). Interest in AND–OR search underwent a revival in the early 2000s, with new algorithms for finding cyclic solutions (Jimenez and Torras, 2000; Hansen and Zilberstein, 2001) and new techniques inspired by dynamic programming (Bonet and Geffner, 2005).",
chap4_para242,1,The idea of transforming partially observable problems into belief-state problems originated with Astrom (1965) for the much more complex case of probabilistic uncertainty (see Chapter 16).,人工智能领域中最常研究的博弈（例如国际象棋和围棋）是博弈论学者所称的确定性、双人、轮流、完美信息（perfect information）的零和博弈（zero-sum game）。
chap4_para242,2,"Erdmann and Mason (1988) studied the problem of robotic manipulation without sensors, using a continuous form of belief-state search.",“完美信息”是“完全可观测”的同义词[2]，“零和”意味着对一方有利的东西将对另一方同等程度有害：不存在“双赢”结果。
chap4_para242,3,They showed that it was possible to orient a part on a table from an arbitrary initial position by a well-designed sequence of tilting actions.,在博弈论中，我们通常用移动（move）作为“动作”（action）的同义词，用局面（position）作为“状态”（state）的同义词。
chap4_para242,4,"More practical methods, based on a series of precisely oriented diagonal barriers across a conveyor belt, use the same algorithmic insights (Wiegley et al.",
chap4_para242,5,", 1996).",
chap4_para243,1,The belief-state approach was reinvented in the context of sensorless and partially observable search problems by Genesereth and Nourbakhsh (1993).,
chap4_para243,2,"Additional work was done on sensorless problems in the logic-based planning community (Goldman and Boddy, 1996; Smith and Weld, 1998).",
chap4_para243,3,"This work has emphasized concise representations for belief states, as explained in Chapter 11.",
chap4_para243,4,Bonet and Geffner (2000) introduced the first effective heuristics for belief-state search; these were refined by Bryce et al.,
chap4_para243,5,(2006).,
chap4_para243,6,"The incremental approach to belief-state search, in which solutions are constructed incrementally for subsets of states within each belief state, was studied in the planning literature by Kurien et al.",
chap4_para243,7,"(2002); several new incremental algorithms were introduced for nondeterministic, partially observable problems by Russell and Wolfe (2005).",
chap4_para243,8,"Additional references for planning in stochastic, partially observable environments appear in Chapter 16.",
chap4_para244,1,"Algorithms for exploring unknown state spaces have been of interest for many centuries. Depth-first search in a reversible maze can be implemented by keeping one’s left hand on the wall; loops can be avoided by marking each junction. The more general problem of exploring Eulerian graphs (i.e., graphs in which each node has equal numbers of incoming and outgoing edges) was solved by an algorithm due to Hierholzer (1873).",[2]　对应英文player在博弈论中为“参与者”，但在本书中不同语境下会根据具体情况使用参与者、玩家、选手等。
chap4_para244,2,,——译者注
chap4_para245,1,"The first thorough algorithmic study of the exploration problem for arbitrary graphs was carried out by Deng and Papadimitriou (1990), who developed a completely general algorithm but showed that no bounded competitive ratio is possible for exploring a general graph.",我们将两个参与者[3]分别称为max和min，这么命名的原因稍后解释。
chap4_para245,2,Papadimitriou and Yannakakis (1991) examined the question of finding paths to a goal in geometric path-planning environments (where all actions are reversible).,max先移动，然后两个参与者轮流移动，直到博弈结束。
chap4_para245,3,"They showed that a small competitive ratio is achievable with square obstacles, but with general rectangular obstacles no bounded ratio can be achieved.",博弈结束时，获胜者得分，而失败者受到惩罚。
chap4_para245,4,(See Figure 4.,可以使用以下元素对博弈进行形式化定义。
chap4_para245,5,20.,
chap4_para245,6,),
chap4_para246,1,"In a dynamic environment, the state of the world can spontaneously change without any action by the agent.",
chap4_para246,2,"For example, the agent can plan an optimal driving route from A to B, but an accident or unusually bad rush hour traffic can spoil the plan.",
chap4_para246,3,Incremental search algorithms such as Lifelong Planning A* (Koenig et al.,
chap4_para246,4,", 2004) and D* Lite (Koenig and Likhachev, 2002) deal with this situation.",
chap4_para247,1,"The LRTA* algorithm was developed by Korf (1990) as part of an investigation into realtime search for environments in which the agent must act after searching for only a fixed amount of time (a common situation in two-player games). LRTA* is in fact a special case of reinforcement learning algorithms for stochastic environments (Barto et al., 1995). Its policy of optimism under uncertainty—always head for the closest unvisited state—can result in an exploration pattern that is less efficient in the uninformed case than simple depth-first search (Koenig, 2000). Dasgupta et al. (1994) show that online iterative deepening search is optimally efficient for finding a goal in a uniform tree with no heuristic information.",[3]　一些作者对此进行了区分，用“不完美信息博弈”指扑克之类的游戏，其中玩家将获得其他玩家没有的关于自己手牌的私人信息，而用“部分可观测博弈”指《星际争霸II》之类的游戏，其中每个玩家可以看到其附近的环境，但看不到远处的环境。
chap4_para248,1,"Several informed variants on the LRTA* theme have been developed with different methods for searching and updating within the known portion of the graph (Pemberton and Korf, 1992).",● S0：初始状态，指定博弈开始时如何设置。
chap4_para248,2,"As yet, there is no good theoretical understanding of how to find goals with optimal efficiency when using heuristic information.",
chap4_para248,3,Sturtevant and Bulitko (2016) provide an analysis of some pitfalls that occur in practice.,
chap4_para249,1,1Luby et al.,● To-Move(s)：在状态s下，轮到其移动的参与者。
chap4_para249,2,(1993) suggest restarting after a fixed number of steps and show that this can be much more efficient than letting each search continue indefinitely.,
chap4_para25,1,"How could we solve more problems? One answer is to keep going when we reach a plateau—to allow a sideways move in the hope that the plateau is really a shoulder, as shown in Figure 4.1. But if we are actually on a flat local maximum, then this approach will wander on the plateau forever. Therefore, we can limit the number of consecutive sideways moves, stopping after, say, 100 consecutive sideways moves. This raises the percentage of problem instances solved by hill climbing from 14% to 94%. Success comes at a cost: the algorithm averages roughly 21 steps for each successful instance and 64 for each failure.",爬山法是否能成功在很大程度上取决于状态空间地形图的形状：如果几乎不存在局部极大值和平台区，那么随机重启爬山法可以很快找到一个好的解。
chap4_para25,2,,但是，许多实际问题的地形图看起来更像是平地上散布着一群秃顶豪猪，每个豪猪的刺上还住着微型豪猪。
chap4_para25,3,,NP困难问题（参见附录 A）通常存在指数级数量的局部极大值。
chap4_para25,4,,尽管如此，在几次重启后，通常也可以找到相当好的局部极大值。
chap4_para250,1,"2Knowledge of vectors, matrices, and derivatives is useful for this section (see Appendix A).",● Actions(s)：在状态s下，全体合法移动的集合
chap4_para251,1,"3In general, the Newton–Raphson update can be seen as fitting a quadratic surface to f at x and then moving directly to the minimum of that surface—which is also the minimum of f if f is quadratic.","● Result(s, a)：转移模型，定义状态s下执行动作a所产生的结果状态。"
chap4_para252,1,"4A set of points S is convex if the line joining any two points in S is also contained in S. A convex function is one for which the space “above” it forms a convex set; by definition, convex functions have no local (as opposed to global) minima.",● Is-Terminal(s)：终止测试（terminal test），博弈结束时返回真，否则返回假。
chap4_para252,2,,博弈结束时的状态称为终止状态（terminal state）。
chap4_para253,1,5We assume that most readers face similar problems and can sympathize with our agent.,"● Utility(s, p)：效用函数（也称为目标函数或收益函数），定义博弈结束时终止状态s下参与者p得到的最终的数值收益。"
chap4_para253,2,"We apologize to owners of modern, efficient cleaning appliances who cannot take advantage of this pedagogical device.",在国际象棋中，结果为赢、输或平局，收益分别为1、0或1/2。
chap4_para253,3,,[4]一些博弈存在更大范围的可能结果，例如，西洋双陆棋的收益范围为0～192。
chap4_para254,1,"6In a fully observable environment, each belief state contains one physical state.",
chap4_para254,2,"Thus, we can view the algorithms in Chapter 3 as searching in a belief-state space of singleton belief states.",
chap4_para255,1,7The usual apologies to those who are unfamiliar with the effect of small children on the environment.,[4]　国际象棋被认为是一种“零和”游戏，尽管两个选手每局游戏的结果之和为+1，而不是0。
chap4_para255,2,,“常量和”是一个更准确的术语，但“零和”更传统，你可以将其看作每个选手被收取了1/2的入场费。
chap4_para256,1,8The term “online” here refers to algorithms that must process input as it is received rather than waiting for the entire input data set to become available. This usage of “online” is unrelated to the concept of “having an Internet connection.”,同第3章一样，初始状态、Actions函数和Result函数定义了状态空间图（state space graph）——在图中，顶点表示状态，边表示移动，一个状态可以通过多条路径到达。
chap4_para256,2,,如第3章所述，我们可以在图的一部分上叠加搜索树（search tree）以确定下一步移动。
chap4_para256,3,,我们将完整的博弈树（game tree）定义为搜索树，它会记录每个一直到终止状态的移动序列。
chap4_para256,4,,如果状态空间本身是无界的，或者博弈规则允许局面可以无限次重复，那么博弈树可能是无限的。
chap4_para257,1,9Random walks are complete on infinite one-dimensional and two-dimensional grids.,图5-1为井字棋（圈叉游戏tic-tac-toe）的部分博弈树。
chap4_para257,2,"On a three-dimensional grid, the probability that the walk ever returns to the starting point is only about 0.",从初始状态开始，max有9种可能的移动。
chap4_para257,3,"3405 (Hughes, 1995).",游戏交替进行，max放x，min放o，直到到达对应于终止状态的叶节点，即一个玩家占据某一行，或者所有方格都被填满。
chap4_para257,4,,每个叶节点上的数字是对max来说该终止状态的效用值，值越高对max越有利，对min越不利（这也是玩家名字的由来）。
chap4_para258,1,,对井字棋来说，博弈树相对较小——不超过9!= 362 880个终止节点（只有5478个不同状态）。
chap4_para258,2,,但是对国际象棋来说，节点数超过1040，所以博弈树被认为是一个在物理世界中无法实现的理论结构。
chap4_para259,1,,图5-1　井字棋的（部分）博弈树。
chap4_para259,2,,最上面的节点是初始状态，max先移动，在某个空位上放一个x。
chap4_para259,3,,我们展示了树的一部分，给出min(o)和max(x)的交替移动，直到最终到达终止状态，根据博弈规则为终止状态分配效用值
chap4_para26,1,Many variants of hill climbing have been invented.,4.1.2　模拟退火
chap4_para26,2,Stochastic hill climbing chooses at random from among the uphill moves; the probability of selection can vary with the steepness of the uphill move.,
chap4_para26,3,"This usually converges more slowly than steepest ascent, but in some state landscapes, it finds better solutions.",
chap4_para26,4,First-choice hill climbing implements stochastic hill climbing by generating successors randomly until one is generated that is better than the current state.,
chap4_para26,5,This is a good strategy when a state has many (e.,
chap4_para26,6,g.,
chap4_para26,7,", thousands) of successors.",
chap4_para260,1,,5.2　博弈中的优化决策
chap4_para261,1,,max想要找到通往胜利的动作序列，但min不希望max获胜。
chap4_para261,2,,这意味着max的策略必须是一个条件规划——一个随机应变策略，指定对min的每个可能移动的响应。
chap4_para261,3,,在具有二元结果（赢或输）的博弈中，我们可以使用与或搜索（4.3.2节）生成条件规划。
chap4_para261,4,,事实上，对于这类博弈，博弈的获胜策略的定义与非确定性规划问题的解的定义相同：在这两种情况下，无论“另一方”做什么，都必须保证己方能获得理想结果。
chap4_para261,5,,对于具有多个结果分数的博弈，我们需要一种更一般的算法，即极小化极大搜索。
chap4_para262,1,,考虑图5-2中的简单博弈。
chap4_para262,2,,根节点上max的可能移动被标记为a1、a2和a3。
chap4_para262,3,,min对a1的可能响应为b1、b2、b3等。
chap4_para262,4,,这个特殊游戏在max和min各移动一次后结束。
chap4_para262,5,,（注意，在某些游戏中，“move”一词意味着双方都执行了一次移动，因此，ply一词被用来明确表示一个玩家的一次移动，即我们在博弈树中又深入了一层。
chap4_para262,6,,）博弈中终止状态的效用值范围为2～14。
chap4_para263,1,,图5-2　二层博弈树。
chap4_para263,2,,△节点为“max节点”，即轮到max移动，节点为“min节点”。
chap4_para263,3,,终止节点显示max的效用值，其他节点标记有它们的极小化极大值。
chap4_para263,4,,max在根节点的最佳移动是a1，因为它指向极小化极大值最高的状态，而min的最佳响应是b1，因为它指向极小化极大值最低的状态
chap4_para264,1,,给定博弈树，可以通过计算树中每个状态的极小化极大值（minimax value）确定最优策略，记为Minimax(s)。
chap4_para264,2,,某一状态的极小化极大值是指，假设从该状态到博弈结束两个参与者都以最优策略行动，到达的终止状态对于max的效用值。
chap4_para264,3,,终止状态的极小化极大值就是它的效用值。
chap4_para264,4,,在非终止状态下，轮到max移动时，max倾向于移动到极小化极大值最大的状态，而min倾向于移动到极小化极大值最小的状态（对max来说值最小，因此对min来说值最大）。
chap4_para264,5,,所以有：
chap4_para265,1,,让我们将上述定义应用于图5-2中的博弈树。
chap4_para265,2,,底层的终止节点从Utility函数中获取它们的效用值。
chap4_para265,3,,第一个min节点，标记为B，存在3个后继状态，值分别为3、12和8，因此它的极小化极大值为3。
chap4_para265,4,,类似地，另外两个min节点的极小化极大值都为2。
chap4_para265,5,,根节点为max节点，它的后继状态的极小化极大值分别为3、2和2，因此，它的极小化极大值为3。
chap4_para265,6,,我们还可以在根节点处确定极小化极大决策（minimax decision）：动作a1是max的最优选择，因为它指向极小化极大值最大的状态。
chap4_para266,1,,max的最优策略假设min也是按照最优策略动作。
chap4_para266,2,,如果min不按照最优策略动作呢？
chap4_para266,3,,那么max至少会表现得与它面对最优对手时一样好，甚至可能更好。
chap4_para266,4,,然而，这并不意味着，面对次优对手时选择极小化极大最优移动总是最好的。
chap4_para266,5,,考虑这样一种情况，双方均按照最优策略行动，结果为平局，但max有一种冒险的走法，在这种走法导致的状态下，min有10种可能的响应，这些响应似乎都是合理的，但其中9种都会使min输掉游戏，只有1种会使max输掉游戏。
chap4_para266,6,,如果max认为min没有足够的计算能力找到最优移动，那么max可能会尝试这种冒险的走法，因为9/10的获胜机会要比一个确定的平局好。
chap4_para267,1,,5.2.1　极小化极大搜索算法
chap4_para268,1,,现在我们来计算Minimax(s)，我们可以将其转化为一个搜索算法，即尝试所有动作然后选择其结果状态的Minimax值最大的动作作为max的最佳移动。
chap4_para268,2,,算法如图5-3所示。
chap4_para268,3,,这是一种递归算法，它一直向下进行到叶节点，然后随着递归的展开通过搜索树倒推极小化极大值。
chap4_para268,4,,例如，图5-2中的算法，首先递归到左下角的3个节点，并对它们调用Utility函数，发现它们的值分别为3、12和8。
chap4_para268,5,,然后选择其中的最小值，3，并将其返回，作为节点B的倒推值。
chap4_para268,6,,同理可得，C和D的倒推值都为2。
chap4_para268,7,,最后，我们选择3、2和2中的最大值3作为根节点的倒推值。
chap4_para269,1,,极小化极大算法对博弈树进行完整的深度优先探索。
chap4_para269,2,,如果树的最大深度为m，并且在每个点都有b种合法移动，那么极小化极大算法的时间复杂度为O(bm)。
chap4_para269,3,,对于一次生成所有动作的算法，空间复杂度为O(bm)，对于一次只生成一个动作的算法，空间复杂度为O(m)（见3.4.3节）。
chap4_para269,4,,指数级的复杂度使得Minimax无法应用于复杂博弈。
chap4_para269,5,,例如，国际象棋的分支因子约为35，平均深度约为80层，搜索个状态显然是不可行的。
chap4_para269,6,,然而，Minimax确实是对博弈进行数学分析的基础。
chap4_para269,7,,通过以各种方式近似极小化极大分析，我们可以推导出更实用的算法。
chap4_para27,1,"Another variant is random-restart hill climbing, which adopts the adage, “If at first you don’t succeed, try, try again.” It conducts a series of hill-climbing searches from randomly generated initial states, until a goal is found. It is complete with probability 1, because it will eventually generate a goal state as the initial state. If each hill-climbing search has a probability p of success, then the expected number of restarts required is 1/p. For 8-queens instances with no sideways moves allowed, p ≈ 0.14, so we need roughly 7 iterations to find a goal (6 failures and 1 success). The expected number of steps is the cost of one successful iteration plus (1 – p)/p times the cost of failure, or roughly 22 steps in all. When we allow sideways moves, 1/0.94 ≈ 1.06 iterations are needed on average and (1 × 21) + (0.06/0.94) × 64 ≈ 25 steps. For 8-queens, then, random-restart hill climbing is very effective indeed. Even for three million queens, the approach can find solutions in seconds.1",从不“下坡”，即从不向值较低（或代价较高）的状态移动的爬山算法总是很容易陷入局部极大值。
chap4_para27,2,,相比之下，纯粹的随机游走算法不考虑状态值，而是随机移动到一个后继状态，它最终能够找到全局极大值，但它的效率非常低。
chap4_para27,3,,因此，尝试将爬山法和随机游走结合起来以同时获得高效性和完备性，似乎是合理的。
chap4_para270,1,,图5-3　使用极小化极大计算最优移动的算法。
chap4_para270,2,,最优移动是指，在假定对手移动是为了使效用值最小的前提下，使终止状态效用值最大的移动。
chap4_para270,3,,函数Max-Value和Min-Value遍历整个博弈树直到叶节点，以确定每个状态的倒推值以及如何移动以到达该状态
chap4_para271,1,,5.2.2　多人博弈中的最优决策
chap4_para272,1,,许多流行游戏都允许多个玩家参与。
chap4_para272,2,,让我们来看看如何将极小化极大思想推广到多人博弈中。
chap4_para272,3,,从技术角度来看，这很自然，但是也产生了一些有趣的新的概念上的问题。
chap4_para273,1,,首先，我们需要将每个节点的单一值替换为值向量。
chap4_para273,2,,例如，在玩家A、B和C参与的3人博弈中，每个节点都与一个向量相关联。
chap4_para273,3,,对于终止状态，这一向量表示每个玩家各自在该状态得到的效用值。
chap4_para273,4,,（在双人零和博弈中，二元向量可以简化为一个值，因为两个值总是互为相反数。
chap4_para273,5,,）最简单的实现方法是让Utility函数返回效用值向量。
chap4_para274,1,,现在我们要考虑非终止状态。
chap4_para274,2,,考虑图5-4的博弈树中标为X的节点。
chap4_para274,3,,此时，轮到玩家C选择如何移动。
chap4_para274,4,,两种选择产生了效用值向量分别为和的两种终止状态，因为6大于3，所以C应该选择第一种移动。
chap4_para274,5,,这意味着，如果到达状态X，后续的博弈将产生效用值为的终止状态。
chap4_para274,6,,因此，这个向量就是X的倒推值。
chap4_para274,7,,一般地，节点n的倒推值是对在该点进行选择的玩家来说效用值最大的后继状态的效用值向量。
chap4_para275,1,,任何参与多人博弈（如Diplomacy或Settlers of Catan游戏）的参与者都会很快意识到，比起双人博弈，多人博弈要复杂得多。
chap4_para275,2,,多人博弈通常涉及参与者之间的正式或非正式联盟（alliance）。
chap4_para275,3,,联盟会随着博弈的发展建立和瓦解。
chap4_para275,4,,我们如何理解这种行为？
chap4_para275,5,,联盟是多人博弈中每个参与者都按照最优策略行动的自然结果吗？
chap4_para275,6,,事实证明的确如此。
chap4_para276,1,,例如，假设现在A和B处于弱势，而C处于强势。
chap4_para276,2,,那么，对A和B来说，最理想的做法往往是一起攻击C，而不是彼此攻击，以免C对它们逐个消灭。
chap4_para276,3,,这样的话，合作其实产生于纯粹的自私行为。
chap4_para276,4,,当然，一旦C在联合攻击下被削弱，联盟就失去了价值，A或B都有可能违反协议。
chap4_para277,1,,图5-4　三人博弈的博弈树的前三层，3个玩家为A、B、C。
chap4_para277,2,,每个节点都标有3个玩家各自的效用值。
chap4_para277,3,,最佳移动标示在根节点上
chap4_para278,1,,在某些情况下，显式联盟只是将无论如何都会发生的事情具体化。
chap4_para278,2,,而在其他情况下，破坏联盟会被记录为社会污点，所以参与者必须权衡破坏联盟所带来的即时优势和失去信任所造成的长期劣势。
chap4_para278,3,,有关这些复杂问题的更多讨论，详见18.2节。
chap4_para279,1,,如果博弈不是零和博弈，那么在只有两个参与者时，合作也可能发生。
chap4_para279,2,,例如，假设存在一个效用值为的终止状态，并且每个参与者最高的可能效用值也是1000。
chap4_para279,3,,那么最优策略是双方都尽一切可能到达该状态，也就是说，参与者会自动合作以实现共同的期望目标。
chap4_para28,1,"The success of hill climbing depends very much on the shape of the state-space landscape: if there are few local maxima and plateaus, random-restart hill climbing will find a good solution very quickly.",模拟退火（simulated annealing）就是这样一种算法。
chap4_para28,2,"On the other hand, many real problems have a landscape that looks more like a widely scattered family of balding porcupines on a flat floor, with miniature porcupines living on the tip of each porcupine needle.",在冶金学中，退火（annealing）是一种通过将金属或玻璃加热到高温然后逐渐冷却的方法使材料达到低能量结晶态以进行回火或硬化的过程。
chap4_para28,3,NP-hard problems (see Appendix A) typically have an exponential number of local maxima to get stuck on.,为了更好地解释模拟退火，我们将关注点从爬山转换为梯度下降（gradient descent）（即，最小化代价），想象这样一项任务，把一个乒乓球放入一个崎岖表面的最深的裂缝中。
chap4_para28,4,"Despite this, a reasonably good local maximum can often be found after a small number of restarts.",如果只是让球滚动，它会停在一个局部极小值。
chap4_para28,5,,如果晃动平面，乒乓球会从局部极小值中弹出来——也许会弹到更深的局部极小值中，在那里它将耗费更多的时间。
chap4_para28,6,,诀窍是晃动幅度要足够大，以使球从局部极小值中弹出，但又不能太大，以至于从全局极小值中弹出。
chap4_para28,7,,模拟退火就是开始时用力晃动（即高温），然后逐渐降低晃动强度（即降低温度）。
chap4_para281,1,,博弈的状态数关于树的深度是指数量级的。
chap4_para281,2,,没有一种算法可以完全消除指数项，但有时可以将它减半，即通过剪枝（见3.5.3节）消除对结果没有影响的树的大部分，从而不需要检查所有状态就能计算出正确的极小化极大决策。
chap4_para281,3,,这种技术称为剪枝（alpha-beta pruning）。
chap4_para282,1,,再次考虑图5-2中的双层博弈树。
chap4_para282,2,,让我们再进行一次最优决策的计算，这一次要仔细观察在这个过程中的每个点上都获得了什么信息。
chap4_para282,3,,步骤如图5-5所示。
chap4_para282,4,,结果是，我们可以在无须评估其中两个叶节点的情况下就能确定极小化极大决策。
chap4_para283,1,,另一种考虑这一问题的方式是将Minimax公式简化。
chap4_para283,2,,假设图5-5中节点C的两个未评估的后继节点的值分别为x和y，则根节点的值为
chap4_para284,1,,也就是说，根节点的值以及极小化极大决策与叶节点x和y的值无关，因此可以将它们剪枝。
chap4_para285,1,,剪枝可以应用于任何深度的树，而且通常可以将整个子树而不只是叶节点剪枝。
chap4_para285,2,,一般原则是：考虑树中某个位置的节点n（见图5-6），玩家可以选择移动到n。
chap4_para285,3,,如果玩家在树中同一层（如图5-6中的m'）或更上层的任何位置（如图5-6中的m）有更好的选择，那么玩家永远都不愿移动到n。
chap4_para285,4,,所以，一旦我们对n有了足够的了解（通过检查它的某些后继）来得出上述结论，就可以将它剪枝。
chap4_para286,1,,图5-5　图5-2中博弈树的最优决策计算过程。
chap4_para286,2,,每一步都标有每个节点可能的值的范围。
chap4_para286,3,,（a）B下面的第一个叶节点值为3。
chap4_para286,4,,因此，作为min节点，B的值最多为3。
chap4_para286,5,,（b）B下面的第二个叶节点值为12，min将避免移动到该节点，所以B的值仍然最多为3。
chap4_para286,6,,（c）B下面的第三个叶节点值为8，此时我们已经检查完了B的所有后继状态，所以B的值就是3。
chap4_para286,7,,现在我们可以推断根节点的值至少是3，因为max在根节点处有值为3的选择。
chap4_para286,8,,（d）C下面的第一个叶节点值为2。
chap4_para286,9,,因此，作为min节点，C的值最多为2。
chap4_para286,10,,但是我们知道B的值为3，所以max永远不会选择C。
chap4_para286,11,,因此，没有必要再去检查C的其他后继状态。
chap4_para286,12,,这是剪枝的一个实例。
chap4_para286,13,,（e）D下面的第一个叶节点值为14，所以D的值最多为14。
chap4_para286,14,,这仍然高于max的最佳选择（即3），所以我们需要继续探索D的后继状态。
chap4_para286,15,,注意，此时根节点的所有后继都有界，所以根节点的值也最多为14。
chap4_para286,16,,（f）D的第二个后继值为5，所以我们又需要继续探索。
chap4_para286,17,,第三个后继值为2，所以D的值就是2。
chap4_para286,18,,最终，max在根节点处的决策是移动到值为3的节点B
chap4_para287,1,,图5-6　剪枝的一般情况。
chap4_para287,2,,如果对玩家来说m或m'要好于n，那么我们永远都不会在博弈中到达n
chap4_para288,1,,记住，极小化极大搜索是深度优先的，所以在任何时候我们只需考虑树中单个路径上的节点。
chap4_para288,2,,"剪枝得名于Max-Value(state, , )（见图5-7）中的两个额外参数，它们分别是路径上任何位置的倒推值的下界和上界。"
chap4_para289,1,,= 到目前为止，路径上发现的max的任一选择点中最佳（即最大值）选择的值。
chap4_para289,2,,也就是 说， = “至少”。
chap4_para29,1,4.,模拟退火算法的总体结构（图4-5）与爬山法类似。
chap4_para29,2,1.,然而，它不是选择最佳移动，而是选择随机移动。
chap4_para29,3,2Simulated annealing,如果该移动使得情况改善，那么它总是会被接受。
chap4_para29,4,,否则，算法以小于1的概率接受该移动。
chap4_para29,5,,概率随着该移动的“坏的程度”——评估值变差的量——呈指数级下降。
chap4_para29,6,,概率也会随“温度”T的降低而减小：开始时T较高，“坏”的移动更有可能被接受，当T降低时，可能性也逐渐降低。
chap4_para29,7,,如果schedule所设置的T降到0的速度足够慢，那么玻尔兹曼分布的一个性质是所有概率都集中在全局极大值上，即算法将以接近1的概率找到全局极大值。
chap4_para290,1,,= 到目前为止，路径上发现的min的任一选择点中最佳（即最小值）选择的值。
chap4_para290,2,,也就是 说， = “至多”。
chap4_para291,1,,搜索不断更新和的值，并且一旦当前节点的值比此时的（对于max）或（对于min）值更差，就剪掉该节点的剩余分支（即终止递归调用）。
chap4_para291,2,,完整算法如图5-7所示。
chap4_para291,3,,图5-5跟踪了博弈树上的算法进程。
chap4_para292,1,,图5-7　搜索算法。
chap4_para292,2,,注意，这些函数与图5-3中的Minimax-Search函数相同，除了需要维护变量和，以及在值超出边界时截断搜索
chap4_para293,1,,5.2.4　移动顺序
chap4_para294,1,,剪枝的有效性很大程度上依赖于状态的检查顺序。
chap4_para294,2,,例如，在图5-5e和图5-5f中，根本不能剪掉D的任何后继，因为最差的后继（从min的角度来看）是最先生成的。
chap4_para294,3,,如果最先生成D的第三个后继，它的值为2，那么我们就可以剪掉另外两个后继。
chap4_para294,4,,这表明，应该先检查有可能是最佳选择的后继节点。
chap4_para295,1,,如果能够完美地实现这一点，搜索算法只需要检查个节点就能选出最佳移动，而极小化极大算法需要O(bm)。
chap4_para295,2,,这意味着有效分支因子从b变为了，对国际象棋来说，大约从35变为了6。
chap4_para295,3,,换句话说，在相同时间内，拥有完美移动顺序的剪枝可以求解的树的深度大约是极小化极大算法的两倍。
chap4_para295,4,,如果移动顺序随机，对于适当大小的b，需要检查的节点总数约为。
chap4_para295,5,,显然我们现在无法实现完美移动顺序，否则，在这种情况下，可以用排序函数玩一个完美的游戏！
chap4_para295,6,,但通常我们可以非常接近完美。
chap4_para295,7,,对国际象棋来说，一个非常简单的排序函数（例如，先尝试吃子，然后是威胁，再后是前进和后退）就能让检查的节点数减少到不超过最好情况的大约2倍。
chap4_para296,1,,增加动态的移动排序方案，例如先尝试之前发现的最佳移动，能让我们非常接近理论极限。
chap4_para296,2,,“之前”可能指上一次移动（通常面临同样的威胁），也可能来自之前通过迭代加深（见3.4.4节）过程对当前移动的探索。
chap4_para296,3,,首先，搜索一层并根据它们的评估结果记录这些移动的排名。
chap4_para296,4,,然后再深入搜索一层，利用之前的排名指导移动顺序，以此类推。
chap4_para296,5,,由于迭代加深过程而增加的搜索时间可以通过更好的移动顺序来弥补。
chap4_para296,6,,这些最佳移动称为绝招（killer move），首先尝试绝招称为绝招启发式评价函数。
chap4_para297,1,,在3.3.3节中，我们指出通往重复状态的冗余路径会导致搜索代价呈指数级增长，而维护一个先前到达状态的表可以解决这个问题。
chap4_para297,2,,在博弈树搜索中，重复状态的产生是由于换位（transposition）——移动序列的不同排列最终导致相同的局面，这个问题可以通过换位表（transposition table）解决，它将缓存状态的启发式值。
chap4_para298,1,,"例如，假设白方进行了移动w1，而黑方用b1应对，在棋盘的另一边有一个不相关的移动w2，黑方可以用b2应对，我们搜索移动序列[w1, b1, w2, b2]，将其结果状态记为s。"
chap4_para298,2,,在探索了s下面一棵较大的子树之后，我们找到了它的倒推值，并将其存储在换位表中。
chap4_para298,3,,"当我们之后搜索移动序列[w2, b2, w1, b1]时，我们再次到达s，这时我们可以在表中查找它的值而无须重复搜索。"
chap4_para298,4,,在国际象棋中，换位表非常有效，在相同时间内能到达的搜索深度将扩大一倍。
chap4_para299,1,,即使采用剪枝和精巧的移动顺序，极小化极大算法也不适用于国际象棋和围棋这样的游戏，因为在可用时间内仍然有太多状态需要探索。
chap4_para299,2,,"在关于计算机博弈的第一篇论文“Programming a Computer for Playing Chess”（Shannon, 1950）中，克劳德·香农意识到这一问题，并提出了两种策略。"
chap4_para299,3,,A型策略（Type A strategy）考虑搜索树中某一深度的所有可能的移动，然后使用启发式评价函数估计该深度下状态的效用值。
chap4_para299,4,,它探索了树的宽但浅的部分。
chap4_para299,5,,B型策略（Type B strategy）舍弃了那些看起来就很差的移动，“尽可能”走那些更有可能的路线。
chap4_para299,6,,它探索了树的深但窄的部分。
chap4_para3,1,"Chapter 3 addressed problems in fully observable, deterministic, static, known environments where the solution is a sequence of actions. In this chapter, we relax those constraints. We begin with the problem of finding a good state without worrying about the path to get there, covering both discrete (Section 4.1) and continuous (Section 4.2) states. Then we relax the assumptions of determinism (Section 4.3) and observability (Section 4.4). In a nondeterministic world, the agent will need a conditional plan and carry out different actions depending on what it observes—for example, stopping if the light is red and going if it is green. With partial observability, the agent will also need to keep track of the possible states it might be in. Finally, Section 4.5 guides the agent through an unknown space that it must learn as it goes, using online search.",4.1　局部搜索和最优化问题
chap4_para30,1,"A hill-climbing algorithm that never makes “downhill” moves toward states with lower value (or higher cost) is always vulnerable to getting stuck in a local maximum. In contrast, a purely random walk that moves to a successor state without concern for the value will eventually stumble upon the global maximum, but will be extremely inefficient. Therefore, it seems reasonable to try to combine hill climbing with a random walk in a way that yields both efficiency and completeness.",图4-5　模拟退火算法，一种允许某些下坡移动的随机爬山法。
chap4_para30,2,,输入的schedule是关于时间的函数，它决定了“温度”T的值
chap4_para300,1,,历史上，大多数国际象棋程序都是A型策略（我们将在5.3节讨论），而围棋程序通常是B型策略（将在5.4节讨论），因为围棋的分支因子要高得多。
chap4_para300,2,,"最近，B型程序在各种游戏中都达到了世界冠军级水平，包括国际象棋（Silver et al., 2018）。"
chap4_para301,1,,5.3　启发式树搜索
chap4_para302,1,,为了充分利用有限的计算时间，我们可以提前截断搜索，并对状态应用启发式评价函数，从而有效地将非终止节点转变为终止节点。
chap4_para302,2,,换句话说，我们用Eval函数代替Utility函数，Eval对状态效用值进行估计。
chap4_para302,3,,用截断测试（cutoff test）代替终止测试，对于终止状态，截断测试必定返回真，但是它可以根据搜索深度和当前状态的任意属性自由决定何时终止搜索。
chap4_para302,4,,"这样我们得到了搜索深度d处状态s的启发式极小化极大值的计算公式H-Minimax(s, d)："
chap4_para303,1,,5.3.1　评价函数
chap4_para304,1,,"就像第3章的启发式函数返回到目标距离的估计值一样，启发式评价函数Eval(s, p)向参与者p返回状态s的期望效用的估计值。"
chap4_para304,2,,"对于终止状态，一定是Eval(s, p) = Utility(s, p)，而对于非终止状态，估计值必须介于输和赢之间：。"
chap4_para305,1,,除了满足这些需求之外，一个好的评价函数是由什么组成的？
chap4_para305,2,,首先，计算时间不能太长！
chap4_para305,3,,（重点是加快搜索速度。
chap4_para305,4,,）其次，评价函数应与实际的获胜机会密切相关。
chap4_para305,5,,你可能会对“获胜机会”一词感到疑惑。
chap4_para305,6,,毕竟，国际象棋并不是一种碰运气的游戏：我们确定地知道当前的状态，博弈没有任何随机性；如果双方都没有犯错，结果是预先确定的。
chap4_para305,7,,但是，如果搜索必须在非终止状态截断，那么算法对这些状态的最终结果必然是不确定的（即使这种不确定性可以通过提供无限的计算资源来解决）。
chap4_para306,1,,让我们把这一思想进一步具体化。
chap4_para306,2,,大多数评价函数需要计算状态的各种特征（feature），例如，在国际象棋中，我们将拥有白兵数目、黑兵数目、白后数目、黑后数目等特征。
chap4_para306,3,,这些特征合在一起，定义了状态的各种类别或等价类：同一类别中的状态，对所有特征都具有相同值。
chap4_para306,4,,例如，某一类别包含所有的“两兵对一兵”残局。
chap4_para306,5,,任何给定类别都可能包含一些通往（以完美玩法）胜利的状态，一些通往平局的状态和一些通往失败的状态。
chap4_para307,1,,评价函数不知道到底是处于哪种状态，但它可以返回一个值来估计每个结果的状态比例。
chap4_para307,2,,例如，假设我们的经验表明，在“两兵对一兵”类中，82%的状态通向胜利（效用值+1），2%导致失败（效用值0），16%为平局（效用值1/2）。
chap4_para307,3,,那么，该类别中状态的合理评估为期望值（expected value）：(0.82×+1) + (0.02×0) + (0.16×1/2) = 0.90。
chap4_para307,4,,原则上，可以为每一个状态类确定一个期望值，这样我们就得到了适用于任何状态的评价函数。
chap4_para308,1,,在实践中，这种方法需要分析太多类别，因此需要非常多的经验去估计所有的可能性。
chap4_para308,2,,与上述方法不同，大多数评价函数会分别计算每个特征的数值贡献，将它们结合起来得到总数值。
chap4_para308,3,,几个世纪以来，国际象棋棋手们已经提出了一些使用这一思想评估局面价值的方法。
chap4_para308,4,,例如，国际象棋入门书籍给出了各个棋子的子力价值（material value）估计：兵值1分，马或象值3分，车值5分，后值9分。
chap4_para308,5,,其他特征，如“好的兵阵”和“王的安全”可能值半个兵。
chap4_para308,6,,这些特征值简单地相加即可得到局面的评估值。
chap4_para309,1,,数学上，这种评价函数称为加权线性函数（weighted linear function），因为它可以表示为如下形式：
chap4_para31,1,"Simulated annealing is such an algorithm. In metallurgy, annealing is the process used to temper or harden metals and glass by heating them to a high temperature and then gradually cooling them, thus allowing the material to reach a low-energy crystalline state. To explain simulated annealing, we switch our point of view from hill climbing to gradient descent (i.e., minimizing cost) and imagine the task of getting a ping-pong ball into the deepest crevice in a very bumpy surface. If we just let the ball roll, it will come to rest at a local minimum. If we shake the surface, we can bounce the ball out of the local minimum—perhaps into a deeper local minimum, where it will spend more time. The trick is to shake just hard enough to bounce the ball out of local minima but not hard enough to dislodge it from the global minimum. The simulated-annealing solution is to start by shaking hard (i.e., at a high temperature) and then gradually reduce the intensity of the shaking (i.e., lower the temperature).",从20世纪80年代开始，模拟退火就被用于求解VLSI布图问题。
chap4_para31,2,,它已广泛应用于工厂调度和其他大规模优化任务。
chap4_para310,1,,其中fi是局面的某一特征（例如“白象数目”），wi是其权重（表明该特征的重要性）。
chap4_para310,2,,权重需要归一化，使总和始终保持在输（0）到赢（+1）的范围内。
chap4_para310,3,,如图5-8a所示，一个兵的确定优势提供了很大的获胜可能性，而3个兵的确定优势则几乎必胜。
chap4_para310,4,,之前提到，评价函数应与实际的获胜机会密切相关，但并不需要线性相关：如果状态s获胜的可能性是状态s'的两倍，并不意味着Eval(s)必须是Eval(s')的两倍，只需要Eval(s) Eval(s')。
chap4_para311,1,,将特征的值相加似乎是合理的，但实际上它涉及一个很强的假设：每个特征的贡献独立于其他特征的值。
chap4_para311,2,,因此，目前的国际象棋和其他游戏程序也会使用特征的非线性组合。
chap4_para311,3,,例如，一对象的价值可能比单个象价值的两倍还要大，并且在残局时，象比之前价值更大，即当移动数这一特征很大或剩余棋子数这一特征很小时。
chap4_para312,1,,如何得到特征和权重？
chap4_para312,2,,它们不属于国际象棋规则，而是来自人类下棋的经验。
chap4_para312,3,,在没有这种经验的游戏中，评价函数的权重可以通过第22章的机器学习技术来估计。
chap4_para312,4,,将这些技术应用到国际象棋中，结果表明一个象确实相当于大约3个兵，而且似乎几个世纪的人类经验都可以在短短几小时的机器学习中被复制。
chap4_para313,1,,图5-8　两个国际象棋局面，只有右下角车的位置不同。
chap4_para313,2,,在（a）中，黑方有一个马两个兵的优势，这足以取胜。
chap4_para313,3,,在（b）中，白方将吃掉对方的皇后，这几乎是必胜的优势
chap4_para314,1,,5.3.2　截断搜索
chap4_para315,1,,下一步是修改Alpha-Beta-Search，让它在合适的时候调用启发式Eval函数截断搜索。
chap4_para315,2,,我们把图5-7中提到Is-Terminal的两行代码替换为下面这行代码：
chap4_para316,1,,我们还必须记录一些信息，这样在每一次递归调用时可以逐渐增加当前的depth。
chap4_para316,2,,"控制搜索量最直接的方法是设置一个固定的深度限制，这样的话，对所有大于固定深度d的depth（以及所有终止状态），Is-Cutoff(state, depth)都返回true。"
chap4_para316,3,,深度d的选择取决于分配时间内所选择的移动。
chap4_para316,4,,更稳健的方法是使用迭代加深（见第3章）。
chap4_para316,5,,当时间耗尽时，程序将返回最深的已完成搜索所选择的移动。
chap4_para316,6,,如果在每一轮迭代加深中，我们都维护换位表中的条目，那么作为奖励，后续轮次的速度将加快，我们可以使用评估值改进移动顺序。
chap4_para317,1,,由于评价函数只是一种近似，这些简单方法可能导致误差。
chap4_para317,2,,重新考虑象棋中基于子力优势的简单评价函数。
chap4_para317,3,,假设程序搜索到达了深度限制，例如到达图5-8b中的局面，即黑方多了一个马、两个兵。
chap4_para317,4,,程序会将其报告为该状态的启发式值，从而认为该状态很可能导致黑方获胜。
chap4_para317,5,,但其实白方下一步就可以不留退路地吃掉黑方的皇后。
chap4_para317,6,,因此，这个局面实际上对白方有利，但这只有通过向前看才能知道。
chap4_para318,1,,评价函数只能应用于静态（quiescent）局面，也就是说，在这些局面中不存在会使评估值大幅度摇摆变化的待定移动（例如吃掉皇后）。
chap4_para318,2,,对于非静态局面，Is-Cutoff将返回false，并继续搜索直到到达静态局面。
chap4_para318,3,,这种额外的静态搜索（quiescence search）有时会被进一步限制为只考虑特定类型的移动（例如吃子），它能快速消除当前局面的不确定性。
chap4_para319,1,,视野效应（horizon effect）则更难消除。
chap4_para319,2,,它是指程序面临一个将给我方造成严重损失而且基本无法避免的对方移动，但可以使用拖延战术暂时避开。
chap4_para319,3,,考虑图5-9中的国际象棋局面。
chap4_para319,4,,很明显，黑象已经无路可逃。
chap4_para319,5,,例如，白车可以通过依次移动到h1、a1、a2吃掉黑象，在第6步完成吃子。
chap4_para32,1,"The overall structure of the simulated-annealing algorithm (Figure 4.5) is similar to hill climbing. Instead of picking the best move, however, it picks a random move. If the move improves the situation, it is always accepted. Otherwise, the algorithm accepts the move with some probability less than 1. The probability decreases exponentially with the “badness” of the move—the amount ∆E by which the evaluation is worsened. The probability also decreases as the “temperature” T goes down: “bad” moves are more likely to be allowed at the start when T is high, and they become more unlikely as T decreases. If the schedule lowers T to 0 slowly enough, then a property of the Boltzmann distribution, e∆E/T, is that all the probability is concentrated on the global maxima, which the algorithm will find with probability approaching 1.",4.1.3　局部束搜索
chap4_para320,1,,但黑方确实可以采取一系列移动，将象被吃掉这一结果推向“视野”以外。
chap4_para320,2,,假设黑方搜索深度为8层。
chap4_para320,3,,黑方的大多数出招都会导致象最终被吃掉，因此被标记为“坏招”。
chap4_para320,4,,但黑棋也会考虑这样的移动序列，即先用兵来阻挡王，引诱王去吃兵。
chap4_para320,5,,然后黑方可以同样地处理第二个兵。
chap4_para320,6,,上述过程占用了太多步，在剩余的搜索步数内，象不会被吃掉。
chap4_para320,7,,黑方自认为这一策略用两个兵保住了象，但实际上它所做的只是白白浪费了兵，象被吃掉是不可避免的，只是被推到了黑方能搜索到的视野之外。
chap4_para321,1,,缓解视野效应的一种策略是允许单步延伸（singular extension），该策略是说，即使搜索本应在此状态截断，但是，如果在给定局面中有比其他所有移动都“明显更好”的一种移动，我们就允许算法继续沿着这个移动延伸搜索。
chap4_para321,2,,在我们的例子中，搜索将发现白车的3次移动——h2到h1，h1到a1，从a1吃掉a2处的象——依次都是明显更好的移动，因此，即使兵的某个移动序列将搜索推到视野之外，这些明显更好的移动将有机会被延伸搜索。
chap4_para321,3,,这会使树变得更深，但由于单步延伸通常很少，这一策略并不会增加很多节点，在实践中，它已被证明是有效的。
chap4_para322,1,,图5-9　视野效应。
chap4_para322,2,,黑方移动后，黑象注定难逃厄运。
chap4_para322,3,,但是黑方可以用兵来阻挡白方的王，引诱王去吃掉兵。
chap4_para322,4,,这会将不可避免的象的损失推到视野之外，因此，搜索算法将牺牲兵的这一步看作“好招”
chap4_para323,1,,5.3.3　前向剪枝
chap4_para324,1,,剪枝将剪掉对最终评估没有影响的树的分支，但前向剪枝（forward pruning）将剪掉那些看上去很糟糕但也可能实际很好的移动。
chap4_para324,2,,因此，这一策略以出错风险增大的代价节省了计算时间。
chap4_para324,3,,用香农的话说，这是B型策略。
chap4_para324,4,,显然，大多数人类棋手都会这么做，仅考虑每个局面的几步移动（至少是潜意识地）。
chap4_para325,1,,前向剪枝的一种方法是束搜索（见4.1.3节）：在每一层，只考虑一“束”n个最佳移动（根据评价函数），而不是所有可能的移动。
chap4_para325,2,,遗憾的是，这种方法相当危险，因为无法保证最佳移动不被剪枝。
chap4_para326,1,,"ProbCut（概率截断，probabilistic cut）算法（Buro, 1995）是搜索的前向剪枝版本，它使用从先前经验中获得的统计数据来减少最佳移动被剪除的概率。"
chap4_para326,2,,搜索将剪除所有可证明位于当前窗口之外的节点。
chap4_para326,3,,ProbCut算法则剪除有可能位于窗口之外的节点。
chap4_para326,4,,它通过执行浅层搜索计算某个节点的倒推值v，然后利用过去的经验估计树中深度为d的节点的值v位于范围之外的可能性。
chap4_para326,5,,布罗（Buro）将这种技术应用到了他的黑白棋程序Logistello，发现即使常规版本的黑白棋程序拥有两倍的可用时间，ProbCut版本依然以64%的获胜率击败了常规版本。
chap4_para327,1,,另一种技术，即后期移动缩减（late move reduction）技术，假设移动顺序已经调整好，因此在可能的移动的列表中后期才出现的移动不太可能是好的移动。
chap4_para327,2,,这一技术没有将后期的移动完全删除，只是减少了搜索这些移动的深度，从而节省了时间。
chap4_para327,3,,如果缩减后的搜索返回的值高于当前值，我们可以重新运行全深度搜索。
chap4_para328,1,,结合本章介绍的所有技术，可以得到一个国际象棋（或其他游戏）程序。
chap4_para328,2,,我们假设，已经实现了一个国际象棋评价函数——一个使用静态搜索的合理截断测试。
chap4_para328,3,,我们还假设，经过几个月的努力，可以在最新的个人计算机上每秒生成并评估大约100万个节点。
chap4_para328,4,,国际象棋的分支因子平均约为35，而355约等于5000万，因此，如果我们使用极小化极大搜索，在大约1分钟的计算时间内只能向前搜索5层。
chap4_para328,5,,按照比赛规则，我们没有足够的时间去搜索第6层。
chap4_para328,6,,平均水平的人类棋手就可以击败这样的程序，因为他们偶尔会向前规划6～8步。
chap4_para329,1,,通过搜索和大型换位表，我们可以向前搜索大约14层，已经到达了专家级水平。
chap4_para329,2,,我们可以将个人计算机换成一台拥有8个GPU的工作站，每秒可以计算超过10亿个节点，但如果要达到大师级水平，还需要一个经过精心调整的评价函数和一个存储残局招式的大型数据库。
chap4_para329,3,,像Stockfish这样的顶级国际象棋程序拥有所有这些功能，它在搜索树中通常能达到超过30的深度，远远超过任何一个人类棋手的能力。
chap4_para33,1,"Description The genetic algorithm is represented by four sets of blocks, each having four rows of blocks. Each block consists of a real number. Part (“a”) to Part (d) is labeled Initial population, Fitness function, Selection, Cross over, and Mutation. The four 8-digit strings on the initial population blocks are as follows. 24748552, 32752411, 24415124, and 32543213. Selection. The numbers labeled on the selection blocks are as follows, 32752411, 24748552, 32752411, and 24415124. blocks 32752411 and 32752411 are shaded in brown, and the others in blue. Each block is divided into two pairs as follows. First block: 327 and 52411. Second block: 247 and 48552. Third block: 32752 and 411. Fourth block: 24415 and 124. Arrows labeled with a real number and the corresponding percentage depict the ranking by a fitness function. An arrow labeled 24, 31 percent from 24748552 in the initial population set points to a block labeled 24748552 in the selection set. An arrow labeled 23, 29 percent from 32752411 in the initial population set points to 32752411 in the selection set. An arrow labeled 20, 26 percent from 32752411 in the initial population set points to 32752411 in the selection set. An arrow labeled 11, 14 percent from 24415124 in the initial population set points to 24415124 in the selection set. The next section is labeled crossover. The numbers labeled on the cross over section blocks are as follows. 32748552, 24752411, 32752124, and 24415411. Arrows from blocks 32752411 and 24748552 in the selection set point to blocks 32748552, and 24752411 in the crossover set. Arrows from blocks 32752411 and 24415124 in the selection set point to blocks 32752124, and 24415411 in the crossover set. Each block is divided into two pairs as follows. First block: 327 and 48552. Second block: 247 and 52411. Third block: 32752 and 124. Fourth block: 24415 and 411. The numbers labeled on the mutation set blocks are as follows. 32748152 (1 highlighted), 24752411, 32752124 (2 highlighted), and 24415417 (7 highlighted). An arrow from block 32748552 in the crossover set points to the block labeled 32748152 in the mutation set. An arrow from block 24752411 in the crossover set points to the block labeled 24752411 in the mutation set. An arrow from block 32752124 in the crossover set points to the block labeled 32252124 in the mutation set. An arrow from block 24415411 in the crossover set points to the block labeled 24415417 in the mutation set.",对于内存限制问题，在内存中只保存一个节点似乎有些极端。
chap4_para33,2,,局部束搜索（local beam search）算法记录k个状态而不是只记录一个。
chap4_para33,3,,它从k个随机生成的状态开始。
chap4_para33,4,,在每一步中，生成全部k个状态的所有后继状态。
chap4_para33,5,,如果其中任意一个是目标状态，那么算法停止。
chap4_para33,6,,否则，它将从完整列表中选择k个最佳后继并重复上述操作。
chap4_para330,1,,5.3.4　搜索和查表
chap4_para331,1,,对一个国际象棋程序来说，开局就考虑一个包含10亿个博弈状态的树似乎有些过犹不及：漫长的搜索得出的结论仅仅是将兵放到e4（最常见的第一步）。
chap4_para331,2,,"一个世纪以来，许多国际象棋书籍都介绍了如何下好开局和残局（Tattersall, 1911）。"
chap4_para331,3,,因此，许多游戏程序使用查表而非搜索来处理开局和残局也就不足为奇了
chap4_para332,1,,对于开局，计算机主要依靠人类的专业知识。
chap4_para332,2,,可以从书中复制人类专家关于如何打好每个开局的最佳建议并将其输入表中供计算机使用。
chap4_para332,3,,此外，计算机还可以从以前玩过的游戏的数据库中收集统计数据，以判断哪种开局最容易取胜。
chap4_para332,4,,最开始的几步可能的局面很少，大多数局面都能存储在表中。
chap4_para332,5,,通常，移动10～15步后，我们会到达一个很少见到的局面，程序必须从查表切换到搜索。
chap4_para333,1,,在游戏接近结束时，可能的局面又变少，因此更容易查表。
chap4_para333,2,,这是计算机的专长：计算机对残局的分析能力远远超过了人类。
chap4_para333,3,,新手玩家按照一些简单的规则就能在王、车对王（KRK）残局中获胜。
chap4_para333,4,,而其他残局，例如王、象、马对王（KBNK），则很难掌握，也不存在简明的策略。
chap4_para334,1,,另外，计算机可以通过生成一种策略完全解决残局问题，这一策略是从每种可能状态到该状态下最佳移动的映射。
chap4_para334,2,,这样计算机就可以在这个表中查到正确移动从而完美完成棋局。
chap4_para334,3,,这个表由逆向（retrograde）极小化极大搜索构建：首先考虑在棋盘上放置KBNK的所有方法。
chap4_para334,4,,有些局面是白方获胜，将它们标为“赢”。
chap4_para334,5,,然后反转国际象棋规则，做逆向移动。
chap4_para334,6,,无论黑方的应对是什么，白方的任何一步最终位于“赢”局面的移动，都标为“赢”。
chap4_para334,7,,继续上述搜索，直到所有可能局面都被解析为赢、输或平局，这样就得到了一个包含所有KBNK残局的准确无误的查询表。
chap4_para334,8,,这种做法不仅适用于KBNK残局，也适用于所有棋子数不超过7的残局，这样的表格包含400万亿个状态。
chap4_para334,9,,棋子数为8的表则包含40 000万亿个状态。
chap4_para335,1,,5.4　蒙特卡罗树搜索
chap4_para336,1,,对围棋来说，启发式树搜索有两个主要缺点：首先，围棋的分支因子开始时为361，这意味着搜索被限制在4～5层。
chap4_para336,2,,其次，很难为围棋定义一个好的评价函数，因为子力价值并不是一个强有力的指标，而且大多数状态直到最后阶段都在不断变化。
chap4_para336,3,,为了应对这两个挑战，现代围棋程序已经放弃了搜索，而是使用一种称为蒙特卡罗树搜索（Monte Carlo tree search，MCTS）的策略。
chap4_para336,4,,[5]
chap4_para338,1,,[5]　“蒙特卡罗”算法是以摩纳哥蒙特卡罗赌场命名的随机算法。
chap4_para339,1,,基本的MCTS策略不使用启发式评价函数。
chap4_para339,2,,相反，状态值是根据从该状态开始的多次完整博奕模拟（simulation）的平均效用值估算的。
chap4_para339,3,,一次模拟（也被称为一个playout或rollout）先为一个参与者选择移动，接着为另一个参与者选择，重复上述操作直到到达某个终止局面。
chap4_para339,4,,这时，博弈规则（而非不可靠的启发式）决定输赢以及比分。
chap4_para339,5,,对于那些只有输赢两种结果的博弈，“平均效用值”为“获胜百分比”。
chap4_para34,1,"Figure 4.5The simulated annealing algorithm, a version of stochastic hill climbing where some downhill moves are allowed. The schedule input determines the value of the “temperature” T as a function of time.",从第一印象来看，具有k个状态的局部束搜索似乎只不过是并行（而非串行）地运行k次随机重启。
chap4_para34,2,,事实上，这两种算法是完全不同的。
chap4_para34,3,,在随机重启搜索中，每个搜索进程独立运行。
chap4_para34,4,,而在局部束搜索中，有用信息将在并行的搜索线程之间传递。
chap4_para34,5,,实际上，生成最佳后继的那些状态会对其他状态说：“过来，这里的草更绿！
chap4_para34,6,,”算法将很快放弃那些没有效果的搜索并把资源转移到取得最大进展的路径上。
chap4_para340,1,,在模拟中我们如何选择要采取的移动？
chap4_para340,2,,如果只是随机选择，那么多次模拟之后，我们仅能得到“如果两个参与者都随机选择，那么最佳移动是什么？
chap4_para340,3,,”这一问题的答案。
chap4_para340,4,,对于一些简单游戏，这恰好与“如果两名参与者都玩得很好，那么最佳移动是什么？
chap4_para340,5,,”的答案相同，但对大多数游戏却并非如此。
chap4_para340,6,,为了从模拟中获得有用信息，我们需要一个模拟策略（playout policy），使其偏向于好的行动。
chap4_para340,7,,对围棋和其他游戏来说，人们已经使用神经网络成功地从自我对弈中学习到了模拟策略。
chap4_para340,8,,有时还会根据游戏的不同，使用不同的启发式方法，如国际象棋中的“考虑吃子”，或黑白棋中的“占据角落”。
chap4_para341,1,,给定了模拟策略，我们接下来需要决定两件事：从什么局面开始模拟，以及分配给每个局面多少次模拟？
chap4_para341,2,,最简单的答案是纯蒙特卡罗搜索（pure Monte Carlo search），即从博弈当前状态开始做N次模拟，并记录从当前局面开始哪一种可能移动胜率最高。
chap4_para342,1,,对于一些随机游戏，随着N的增加，这一策略会收敛到最优策略，但对大多数博弈来说，这还不够——我们需要一个选择策略（selection policy），有选择地将计算资源集中在博弈树的重要部分上。
chap4_para342,2,,选择策略需要平衡两个因素以做出更准确的估计：对那些模拟次数很少的状态的探索（exploration），以及对那些在过去的模拟中表现良好的状态的利用（exploitation）。
chap4_para342,3,,（有关探索/利用权衡的更多信息，请参阅17.3节。
chap4_para342,4,,）蒙特卡罗树搜索维护一个搜索树，它在每次迭代（包含以下4个步骤）中不断增长，如图5-10所示。
chap4_para343,1,,图5-10　使用蒙特卡罗树搜索（MCTS）选择移动的算法的一次迭代，该算法使用“应用于树搜索的置信上界”法（UCT）作为选择度量，此时已完成了100次迭代。
chap4_para343,2,,（a）选择移动，沿着树一直向下，到标记为27/35（35次模拟中黑方赢了27次）的叶节点结束。
chap4_para343,3,,（b）扩展所选节点并进行模拟，最终黑方获胜。
chap4_para343,4,,（c）将模拟结果沿树反向传播
chap4_para344,1,,● 选择：从搜索树的根节点开始，选择一个移动（在选择策略的指导下），到达一个后继节点，然后重复该过程，沿着树向下移动到叶节点。
chap4_para344,2,,图5-10a为一棵搜索树，根表示白方刚刚移动的状态，到目前为止，白方已经在100次模拟中赢了37次。
chap4_para344,3,,粗箭头表示黑方选择的移动，在它指向的节点上黑方赢了60/79次。
chap4_para344,4,,这是3种移动中最高的胜率，所以选择它是一次利用。
chap4_para344,5,,但为了探索，选择2/11节点也是合理的——只有11次模拟，该节点的估值仍有很高的不确定性，如果我们获得更多相关信息，它最终可能是最好的。
chap4_para344,6,,继续选择直到到达标有27/35的叶节点。
chap4_para345,1,,● 扩展：我们通过为所选节点生成一个新的子节点的方式增长搜索树，图5-10b中展示了标记为0/0的新节点。
chap4_para345,2,,（一些版本在这一步中会生成多个子节点。
chap4_para345,3,,）
chap4_para346,1,,● 模拟：我们从新生成的子节点开始执行一次模拟，根据模拟策略为两个参与者选择移动。
chap4_para346,2,,这些移动不会记录在搜索树中。
chap4_para346,3,,在图中，模拟结果为黑方获胜。
chap4_para347,1,,● 反向传播：我们现在使用模拟结果自底向上地更新所有搜索树节点。
chap4_para347,2,,因为这次模拟的结果是黑方获胜，所以黑方节点的获胜次数和模拟次数都会增加，27/35变为28/36，60/79变为61/80。
chap4_para347,3,,因为白方失败，其节点只增加模拟次数，所以16/53变为16/54，根节点的37/100变为37/101。
chap4_para348,1,,我们在固定次数的迭代中重复这4个步骤，或者迭代到所分配的时间耗尽，然后返回模拟次数最多的移动。
chap4_para349,1,,一种非常有效的选择策略称为“应用于树搜索的置信上界”，即UCT。
chap4_para349,2,,它根据称为UCB1的置信上界公式对每个可能的移动排序。
chap4_para349,3,,（详见17.3.3节。
chap4_para349,4,,）对节点n来说，公式为
chap4_para35,1,Simulated annealing was used to solve VLSI layout problems beginning in the 1980s.,如果k个状态之间缺乏多样性，局部束搜索可能会受到影响——k个状态可能聚集在状态空间的一块小区域内，导致搜索只不过是k倍慢版本的爬山法。
chap4_para35,2,It has been applied widely to factory scheduling and other large-scale optimization tasks.,一种被称作随机束搜索（stochastic beam search）的变体可以帮助缓解这个问题，它类似于随机爬山法。
chap4_para35,3,,随机束搜索不是选择最佳的k个后继状态，而是选择概率与它对应的目标函数值成正比的后继状态，从而增加了多样性。
chap4_para350,1,,其中U(n)为经过节点n的所有模拟的总效用值，N(n)是经过节点n的模拟次数，Parent(n)是树中n的父节点。
chap4_para350,2,,因此为利用项，即节点n的平均效用值。
chap4_para350,3,,带有平方根的项是探索项：分母为N(n)，这意味着对只探索过几次的节点来说，这一项的值比较高；分子记录了我们对n的父节点的探索次数，这意味着，如果我们选择n的概率不是0，那么随着计数的增加，探索项会趋于零，最终模拟次数将被分配给平均效用值最高的节点。
chap4_para351,1,,C是一个平衡利用和探索的常数。
chap4_para351,2,,有一种理论认为C应该是，但在实践中，程序员会尝试多个C值，从中选择一个表现最好的。
chap4_para351,3,,（有些程序则使用一些稍微不同的公式。
chap4_para351,4,,例如，AlphaZero增加了一个行动概率项，由根据之前的自我对弈训练得到的神经网络计算。
chap4_para351,5,,）当C = 1.4时，图5-10中60/79节点的UCB1值最高，而当C = 1.5时，2/11节点分值最高。
chap4_para352,1,,图5-11给出了完整的UCT MCTS算法。
chap4_para352,2,,当迭代终止时，算法返回模拟次数最多的移动。
chap4_para352,3,,你可能认为应该返回平均效用值最高的节点，但算法的思想是获胜65/100次的节点优于获胜2/3次的节点，因为后者有很多不确定性。
chap4_para352,4,,在任何情况下，UCB1公式确保模拟次数最多的节点几乎总是拥有最高的获胜概率，因为随着模拟次数的增加，选择过程将越来越偏向获胜概率。
chap4_para353,1,,图5-11　蒙特卡罗树搜索算法。
chap4_para353,2,,首先，初始化博弈树tree，然后重复Select/Expand/Simulate/Back-Propagate的循环，直到时间耗尽，最后返回指向模拟次数最多的节点的移动
chap4_para354,1,,计算一次模拟结果的时间对博弈树的深度来说是线性的，而不是指数级的，因为在每个选择点上只采用一个移动。
chap4_para354,2,,这样我们就有足够的时间进行多次模拟。
chap4_para354,3,,例如，假设有一个分支因子为32的博弈，博弈平均持续100步。
chap4_para354,4,,如果我们有足够的计算能力可以在执行移动前考虑10亿个博弈状态，那么极小化极大算法可以搜索6层深度，具有完美行动顺序的算法可以搜索12层深度，蒙特卡罗搜索算法可以搜索1000万次模拟。
chap4_para354,5,,哪种方法更好呢？
chap4_para354,6,,这取决于所用的启发式函数与选择策略、模拟策略的准确性的高下。
chap4_para355,1,,传统观点认为，对于围棋这种分支因子非常高（因此搜索不够深）或者很难定义一个好的评价函数的游戏，蒙特卡罗搜索要优于搜索。
chap4_para355,2,,考虑到对手的目标是最小化得分，搜索将选择指向可实现评价函数得分最高的节点的路径。
chap4_para355,3,,因此，如果评价函数不准确，搜索也会不准确。
chap4_para355,4,,对单个节点的错误计算可能导致搜索错误地选择（或避开）指向该节点的路径。
chap4_para355,5,,而蒙特卡罗搜索依赖于多次模拟的聚合，因此不容易受到单次错误的影响。
chap4_para355,6,,我们也可以将MCTS和评价函数结合起来：对一定数量的移动进行模拟，然后截断模拟，并在截断的节点上应用评价函数。
chap4_para356,1,,也可以将搜索和蒙特卡罗搜索结合。
chap4_para356,2,,例如，在可以持续很多步的博弈中，我们可能希望提前终止模拟（early playout termination），即终止持续太多步的模拟，并使用启发式评价函数对其进行评估，或者干脆宣布平局。
chap4_para357,1,,蒙特卡罗搜索可以应用于没有任何经验可以用来定义评价函数的全新博弈。
chap4_para357,2,,只要我们知道博弈规则，蒙特卡罗搜索不需要任何附加信息。
chap4_para357,3,,选择和模拟策略可以充分利用人工制定的专家知识，也可以通过仅仅使用自我对弈训练得到的神经网络来学习好的策略。
chap4_para358,1,,当单步移动可以改变游戏进程时，蒙特卡罗搜索存在缺陷，因为蒙特卡罗搜索的随机性意味着它可能不会考虑这一移动。
chap4_para358,2,,换句话说，蒙特卡罗搜索中的B型剪枝意味着它可能根本没有探索关键路线。
chap4_para358,3,,当博弈状态“明显”是一方或另一方获胜时（根据人类的知识和评价函数），蒙特卡罗搜索也存在缺陷，它仍然需要模拟很多步来验证获胜者。
chap4_para358,4,,长期以来，人们一直认为，在国际象棋等具有较低分支因子和较好评价函数的游戏中，搜索更好。
chap4_para358,5,,但最近，蒙特卡罗方法在国际象棋及其他游戏中也取得了成功。
chap4_para359,1,,模拟未来的行动，观测结果，并根据结果来确定哪些行动是好的，这样的一般思想其实就是一种强化学习思想，我们将在第22章中介绍。
chap4_para36,1,4.,4.1.4　进化算法
chap4_para36,2,1.,
chap4_para36,3,3Local beam search,
chap4_para361,1,,包含随机因素（例如掷骰子）的随机博弈（stochastic game）使我们更接近现实生活的不可预测性。
chap4_para361,2,,西洋双陆棋是一种典型的运气和技巧相结合的随机游戏。
chap4_para361,3,,在图5-12的西洋双陆棋局面中，黑方掷出“6-5”，有4种可能走法［每种走法将一个棋子向前（顺时针）移动5步，另一个棋子向前移动6步］。
chap4_para362,1,,图5-12　一个典型的西洋双陆棋局面。
chap4_para362,2,,游戏的目标是把自己的所有棋子移出棋盘。
chap4_para362,3,,黑方向25顺时针移动，白方向0逆时针移动。
chap4_para362,4,,一个棋子可以移动到任何位置，除非那里有多个对方棋子；如果只有一个对方棋子，对方棋子就会被吃掉，然后必须从起点重新开始。
chap4_para362,5,,"图中所示的局面，黑棋已经掷出了6-5，必须从(5−11, 5−10)、(5−11, 19−24)、(5−10, 10−16)和(5−11, 11−16)这4种合法移动中选择，其中符号(5−11, 11−16)表示将一个棋子从位置5移动到位置11，另一个棋子从位置11移动到位置16"
chap4_para363,1,,此时，黑方知道可以走什么棋，但不知道白方会掷出什么，因此也不知道白方的合法移动会是什么。
chap4_para363,2,,这意味着黑方无法构建我们在国际象棋和井字棋中看到的那种标准博弈树。
chap4_para363,3,,西洋双陆棋的博弈树除了max和min节点外，还必须包括机会节点（chance node）。
chap4_para363,4,,机会节点如图5-13中的圆圈所示。
chap4_para363,5,,从每个机会节点引出的分支表示可能掷出的骰子点数，每个分支都标有掷出的点数及其概率。
chap4_para363,6,,两个骰子有36种组合，每一种都是等可能的，但是，因为6-5和5-6是一样的，所以只有21种不同的点数组合。
chap4_para363,7,,6个点数相同的组合（1-1到6-6）的概率都是1/36，即P(1−1) = 1/36。
chap4_para363,8,,其他15种不同组合的概率都是1/18。
chap4_para364,1,,图5-13　西洋双陆棋局面的博弈树图解
chap4_para365,1,,下一步是了解如何做出正确决策。
chap4_para365,2,,显然，我们仍然想选择能够到达最佳局面的那一步棋。
chap4_para365,3,,然而，局面没有明确的极小化极大值。
chap4_para365,4,,我们只能计算局面的期望值（expected value）：机会节点所有可能结果的平均值。
chap4_para366,1,,可以将确定性博弈的极小化极大值推广为包含机会节点的博弈的期望极小化极大值（expectiminimax value）。
chap4_para366,2,,终止节点、max节点和min节点的工作方式与之前完全相同（注意，max和min的合法移动取决于前一个机会节点的掷骰子结果）。
chap4_para366,3,,对于机会节点，我们则计算期望值，即用每个机会动作的概率加权的所有结果的值之和：
chap4_para367,1,,"其中，r表示可能的掷骰子结果（或其他概率事件），而Result(s, r)仍表示状态s，附加了掷骰子结果r。"
chap4_para369,1,,和极小化极大算法一样，可以通过在某点截断搜索并对每个叶节点应用评价函数来近似估计期望极小化极大值。
chap4_para369,2,,有人可能会认为，西洋双陆棋等游戏的评价函数应该与国际象棋的评价函数类似——更好的局面得分更高。
chap4_para369,3,,但事实上，机会节点的存在意味着我们必须更加仔细地定义这些值。
chap4_para37,1,Keeping just one node in memory might seem to be an extreme reaction to the problem of memory limitations.,进化算法（evolutionary algorithm）可以看作随机束搜索的变体，算法的动机明显来自生物学中自然选择的隐喻：一个由个体（状态）组成的种群，其中最适应环境（值最高）的个体可以生成后代（后继状态）来繁衍下一代，这个过程被称为重组（recombination）。
chap4_para37,2,The local beam search algorithm keeps track of k states rather than just one.,进化算法存在无数种形式，它们按照以下方式变化。
chap4_para37,3,It begins with k randomly generated states.,
chap4_para37,4,"At each step, all the successors of all k states are generated.",
chap4_para37,5,"If any one is a goal, the algorithm halts.",
chap4_para37,6,"Otherwise, it selects the k best successors from the complete list and repeats.",
chap4_para370,1,,"图5-14表明：如果评价函数给叶节点分配的值为[1, 2, 3, 4]，那么移动a1是最佳的；如果值为[1, 20, 30, 400]，移动a2是最佳的。"
chap4_para370,2,,因此，如果我们更改一些评估值，即使优先顺序保持不变，程序的选择也会完全不同。
chap4_para371,1,,图5-14　在保持叶节点值排序不变的情况下，不同的叶节点赋值改变了最佳移动
chap4_para372,1,,为了避免这一问题，评价函数应该返回获胜概率（对于结果非输或赢的博弈返回的是期望效用值）的正线性变换值。
chap4_para372,2,,这是在不确定性下非常重要和普遍的性质，将在第16章进一步讨论。
chap4_para373,1,,如果程序事先知道游戏接下来的所有掷骰子结果，那么求解有骰子的游戏和求解没有骰子的游戏是一样的，即极小化极大算法的时间复杂度为O(bm)，其中b为分支因子，m为博弈树的最大深度。
chap4_para373,2,,因为期望极小化极大值还要考虑所有可能的掷骰子序列，它的时间复杂度为O(bmnm)，其中n是掷骰子的不同结果的数目。
chap4_para374,1,,即使将搜索深度限制在某个很小的值d内，与极小化极大算法相比，额外代价的存在也使得在大多数机会博弈中向前看很远是不现实的。
chap4_para374,2,,在西洋双陆棋中，n是21，b通常是20左右，但在某些情况下，骰子数翻倍，b可能高达4000。
chap4_para374,3,,我们大概只能搜索3层。
chap4_para375,1,,换一种方式考虑这一问题：搜索的优势在于，在采取最佳玩法的情况下它忽略了那些未来不可能发生的情况。
chap4_para375,2,,因此，它将精力集中于可能发生的情况。
chap4_para375,3,,但在一个每次移动前都要掷两个骰子的游戏中，没有可能的移动序列，即使是最有可能的移动也只在2/36的情况下出现，因为执行移动的前提是，骰子点数是正确的组合从而使该移动合法。
chap4_para375,4,,这是不确定性下的一个普遍问题：可能性急剧增多，制定详细的动作规划变得毫无意义，因为世界可能不会朝你规划的方向发展。
chap4_para376,1,,你可能会想到像剪枝这样的方法也可以应用于包含机会节点的博弈树。
chap4_para376,2,,事实证明的确可以。
chap4_para376,3,,对min和max节点的分析不变，但可以用一点聪明才智对机会节点剪枝。
chap4_para376,4,,考虑图5-13中的机会节点C，以及在计算其子节点时它的值发生了什么变化。
chap4_para376,5,,在我们检查完C的所有子节点之前是否有可能找到C的上界？
chap4_para376,6,,（回想一下，这是剪枝剪除某个节点及其子树时需要的。
chap4_para376,7,,）
chap4_para377,1,,乍一看，这似乎是不可能的，因为C的值是它子节点值的平均，为了计算一组数字的平均值，我们必须查看所有的数字。
chap4_para377,2,,但如果限制效用函数的可能值的范围，那么就可以得到平均值的范围而不需要查看每一个数字。
chap4_para377,3,,例如，假设所有效用值都在−2和+2之间，那么叶节点的值是有界的，反过来，我们就可以在不检查所有子节点的情况下为机会节点的值设置上界。
chap4_para378,1,,在机会节点分支因子较高的博弈中——考虑Yahtzee这样的游戏，即每回合掷5个骰子——你可能要考虑前向剪枝，即采样少数几个可能的机会分支。
chap4_para378,2,,或者，你可能想要完全避免使用评价函数，而选择蒙特卡罗树搜索，其中每次模拟都包含随机掷骰子。
chap4_para379,1,,5.6　部分可观测博弈
chap4_para38,1,"At first sight, a local beam search with k states might seem to be nothing more than running k random restarts in parallel instead of in sequence. In fact, the two algorithms are quite different. In a random-restart search, each search process runs independently of the others. In a local beam search, useful information is passed among the parallel search threads. In effect, the states that generate the best successors say to the others, “Come over here, the grass is greener!” The algorithm quickly abandons unfruitful searches and moves its resources to where the most progress is being made.",
chap4_para380,1,,博比·费希尔（Bobby Fischer）认为“国际象棋就是战争”，但国际象棋缺少真实战争的一个主要特征——部分可观测性。
chap4_para380,2,,在《战争之雾》（Fog of War）游戏中，敌人的行踪往往是未知的，除非与他直接接触。
chap4_para380,3,,因此，战争中常常使用侦察兵和间谍来收集信息，用隐匿处和虚张声势来迷惑敌人。
chap4_para381,1,,部分可观测游戏也具有这些特征，因此与前文提到的游戏有本质不同。
chap4_para381,2,,像《星际争霸》这样的电子游戏尤其具有挑战性，因为它是部分可观测、多智能体、非确定性、动态且未知的。
chap4_para382,1,,在确定性部分可观测博弈中，关于棋盘状态的不确定性完全来自无法获知对手做出的选择。
chap4_para382,2,,这类博弈包括Battleship（每个玩家战舰的放置位置都对敌人隐藏）和Stratego（棋子的位置已知，但种类隐藏）这样的儿童游戏。
chap4_para382,3,,我们考虑四国军棋（Kriegspiel）游戏，它是国际象棋的部分可观测变体，即完全看不到对方的棋子。
chap4_para382,4,,其他游戏也有部分可观测版本：幻影围棋、幻影井字棋和Screen Shogi。
chap4_para383,1,,5.6.1　四国军棋：部分可观测的国际象棋
chap4_para384,1,,四国军棋的规则如下：白方和黑方各自只能看到自己一方的棋子。
chap4_para384,2,,裁判可以看到所有棋子，他对比赛进行判定并定期向双方宣布。
chap4_para384,3,,首先，白方向裁判提出合法移动（只要位置上没有黑方）。
chap4_para384,4,,如果该位置有黑方占位，裁判会宣布移动“非法”，白方不断向裁判提出下一步的走法，直到找到一个合法移动——在这个过程中也了解到了黑方的位置。
chap4_para385,1,,一旦提出了一个合法移动，裁判会宣布以下一项或多项内容：如果在X处有吃子则宣布“在X上吃子”，如果黑王被将军，则宣布“被D将军”，其中D是将军的方向，可以是“马”“行”“列”“长对角线”或“短对角线”。
chap4_para385,2,,如果黑方被将死或陷入僵局，裁判也会宣布；否则，轮到黑方行棋。
chap4_para386,1,,四国军棋看起来非常难处理，但人类可以很好地掌握它，计算机程序也开始迎头赶上。
chap4_para386,2,,回顾4.4节和图4-14中介绍的信念状态的概念——在给定目前为止所有历史感知的情况下，所有逻辑可能的棋盘状态的集合。
chap4_para386,3,,初始时，白方的信念状态只有一个元素，因为黑方还没有移动。
chap4_para386,4,,白方下了一步且黑方做出应对后，白方的信念状态就包含了20种局面，因为黑方对白方的任意一种开局都存在20种回应。
chap4_para387,1,,在游戏过程中跟踪信念状态正是状态评估问题，4.4.4节中的式（4-6）给出了更新步骤。
chap4_para387,2,,如果我们把对手看作不确定性的来源，那么可以把四国军棋的状态评估直接映射到4.4节的部分可观测的、非确定性的框架中；也就是说，白方所选移动的Results由白方自身移动带来的（可预测）结果和黑方回应给出的不可预测结果组成。
chap4_para387,3,,[6]
chap4_para389,1,,[6]　有时，信念状态会变得非常大以至于无法仅用棋盘状态列表表示，但我们将暂时忽略这个问题，第7章和第8章将介绍大型信念状态的紧凑表示方法。
chap4_para39,1,"Local beam search can suffer from a lack of diversity among the k states—they can become clustered in a small region of the state space, making the search little more than a k-times-slower version of hill climbing. A variant called stochastic beam search, analogous to stochastic hill climbing, helps alleviate this problem. Instead of choosing the top k successors, stochastic beam search chooses successors with probability proportional to the successor’s value, thus increasing diversity.",● 每个个体的表示。
chap4_para39,2,,在遗传算法（genetic algorithm）中，每个个体都是有限字母表上的一个字符串（通常是一个布尔字符串），就像DNA是字母表ACGT上的一个字符串一样。
chap4_para39,3,,在进化策略（evolution strategy）中，个体是实数序列，而在遗传编程（genetic programming）中，个体是计算机程序。
chap4_para390,1,,给定当前的信念状态，白方可能会问：“我能赢吗？
chap4_para390,2,,”对于部分可观测游戏，策略的概念会发生改变，我们不需要规定如何回应对手的每个可能移动，而是需要规定如何回应玩家可能接收到的每种可能感知序列。
chap4_para391,1,,对四国军棋来说，必胜策略或确保将死（guaranteed checkmate）是指，对于每种可能感知序列和当前信念状态中的每种可能棋盘状态，不管对手如何移动，该策略都会取胜。
chap4_para391,2,,在这种定义下，对手的信念状态无关紧要——即使对手能看到所有棋子，这一策略也必须奏效。
chap4_para391,3,,这大大简化了计算。
chap4_para391,4,,图5-15为KRK（王车对王）残局必胜策略的一部分。
chap4_para391,5,,在这种情况下，黑方只有一个棋子（王），所以可以通过在单个棋盘上标记黑王的所有可能位置来表示白方的信念状态。
chap4_para392,1,,如4.4节中所述，可以将一般的与或搜索算法应用于信念状态空间来寻找必胜策略。
chap4_para392,2,,4.4.2节提到的增量信念状态算法通常能在中盘找到深度高达9的必胜策略——这远远超过了大多数人类棋手的能力。
chap4_para393,1,,除确保将死之外，四国军棋还存在一个在完全可观测游戏中毫无意义的全新概念：概率将死（probabilistic checkmate）。
chap4_para393,2,,在信念状态中的每一种棋盘状态下，这种将死都要奏效，而概率一词则来源于获胜玩家移动的随机性。
chap4_para393,3,,要了解它的基本思想，可以考虑只用白王来捉住黑王的问题。
chap4_para393,4,,通过简单地随机移动，白王最终一定会吃掉黑王，这是因为，即使黑王总是设法逃跑，它也不可能永远都猜对正确的逃跑方向。
chap4_para393,5,,在概率论的术语中，这一事件以概率1发生。
chap4_para394,1,,在这种意义上，KBNK残局——王、象、马对王——一定会赢，白方为黑方提供一个无限的随机选择序列，黑方总是会猜错其中一个，因此暴露自己的位置，然后被将死。
chap4_para394,2,,另外，KBBK残局的获胜概率是。
chap4_para394,3,,白方要想获胜，只能移动象（此时这个象不受保护）。
chap4_para394,4,,如果黑方碰巧在正确的位置上并吃掉了象（如果象是受保护的，那么这步棋就是非法的），游戏就会变成平局。
chap4_para394,5,,白方可以在一段很长的序列中随机选择一点来走这步险棋，这样会使减小到一个任意小的常数，但无法将减小到零。
chap4_para395,1,,有时将死策略只对当前信念状态中的某些棋盘状态有效，而对其他状态无效。
chap4_para395,2,,尝试这种策略可能会成功，导致意外将死（accidental checkmate）。
chap4_para395,3,,这里的意外是指，如果黑方刚好在特定的位置，白方不会知道自己将会将死对方。
chap4_para395,4,,（在人类博弈中，大多数将死都是偶然的。
chap4_para395,5,,）这个想法自然引出了一个问题，给定策略有多大可能获胜，这又引出了一个问题，当前信念状态中的每种棋盘状态有多大可能是真正的棋盘状态。
chap4_para396,1,,图5-15　KRK残局必胜策略的一部分，图中为缩减后的棋盘。
chap4_para396,2,,在初始信念状态中，黑王位于3种可能位置之一。
chap4_para396,3,,通过一系列探索移动，该策略将黑王的范围缩小到其中一种。
chap4_para396,4,,将死策略的剩余部分留作习题
chap4_para397,1,,人们的第一倾向可能认为当前信念状态中的所有棋盘状态都是等可能的——但这是错误的。
chap4_para397,2,,例如，考虑黑方走第一步棋后白方的信念状态。
chap4_para397,3,,根据定义（假设黑方遵循最优策略），黑方一定采取了最优移动，所以由次优移动产生的所有棋盘状态的概率应该为零。
chap4_para398,1,,这一论点也不完全正确，因为每个玩家的目标不仅仅是将棋子移动到正确的方格中，还需要最小化对手能掌握的关于自己位置的信息。
chap4_para398,2,,遵循任何可预测的“最优”策略都能为对手提供信息。
chap4_para398,3,,因此，在部分可观测博弈中，最佳玩法需要一定随机性。
chap4_para398,4,,（这也是餐厅卫生检查员进行随机检查的原因。
chap4_para398,5,,）这意味着他们偶尔要选择一些“本质上”较差的移动——但他们能从不可预测性上获益，因为对手不大可能为防御这些移动做好准备。
chap4_para399,1,,从这些考虑来看，似乎只有在给定最优随机策略的情况下，才能计算出当前信念状态中各种棋盘状态的概率；反过来，计算这一策略似乎需要知道棋盘可能处于的各种状态的概率。
chap4_para399,2,,这个难题可以利用博弈论中均衡解的概念解决，我们将在第17章中进一步探讨。
chap4_para399,3,,均衡为每个玩家指定了一个最优随机策略。
chap4_para399,4,,对四国军棋来说，计算均衡的代价太昂贵了。
chap4_para399,5,,目前，一般四国军棋游戏的有效算法设计是一个开放的研究课题。
chap4_para399,6,,大多数系统在自己的信念状态空间中执行有限深度的前瞻搜索，而不考虑对手的信念状态。
chap4_para399,7,,评价函数与完全可观测博弈的评价函数类似，但包含一个新的组成部分，信念状态大小——越小越好！
chap4_para399,8,,我们将在18.2节的博弈论主题下重新讨论部分可观测博弈。
chap4_para4,1,4.,在第3章的搜索问题中，我们希望找到一条通过搜索空间的路径，如一条从Arad到Bucharest的路径。
chap4_para4,2,1Local Search and Optimization Problems,但有时我们只关心最终状态，而不是到达状态的路径。
chap4_para4,3,,例如，在8皇后问题中（图4-3），我们只关心如何找到8个皇后的有效最终配置（因为如果知道配置，重构它的创建步骤就非常简单）。
chap4_para4,4,,这也适用于许多重要应用，例如集成电路设计、工厂车间布局、作业车间调度、自动编程、电信网络优化、农作物种植规划和投资组合管理。
chap4_para40,1,4.,● 混合数，，是一起形成后代的亲本的数量。
chap4_para40,2,1.,最常见的情况是：双亲结合它们的“基因”（它们表示的一部分）来形成后代。
chap4_para40,3,4Evolutionary algorithms,当时，为随机束搜索（可以看作无性繁殖）。
chap4_para40,4,,也是可能的，这在自然界中很少发生，但很容易在计算机上进行模拟。
chap4_para400,1,,5.6.2　纸牌游戏
chap4_para401,1,,桥牌、惠斯特牌、红心大战和扑克等纸牌游戏都具有随机的部分可观测性，即无法观测的信息是由随机发牌产生的。
chap4_para402,1,,乍一看，这些纸牌游戏似乎很像掷骰子：纸牌是随机分配的，并且决定了每个玩家的可能移动，但所有的“掷骰子”都发生在游戏的开始！
chap4_para402,2,,尽管将纸牌游戏类比为掷骰子是错误的，但它提出了一种算法：将游戏的开始视为一个机会节点，每一种可能的发牌视为一个结果，然后使用Expectiminimax公式选择最佳移动。
chap4_para402,3,,注意，在这种方法中，唯一的机会节点是根节点；在那之后，游戏则是完全可观测的。
chap4_para402,4,,这种方法有时被称为观测力平均，因为它假设，一旦发牌实际发生，游戏对双方都是完全可观测的。
chap4_para402,5,,尽管这种策略在直观上具有吸引力，但有可能让人误入歧途。
chap4_para402,6,,考虑下面这个故事。
chap4_para403,1,,第一天：道路A通向一桶金子，道路B通向一个岔路口。
chap4_para403,2,,你可以看到，岔路口左转是两桶金子，右转则会撞上一辆公共汽车。
chap4_para404,1,,第二天：道路A通向一桶金子，道路B通向一个岔路口。
chap4_para404,2,,你可以看到，岔路口右转是两桶金子，左转则会撞上一辆公共汽车。
chap4_para405,1,,第三天：道路A通向一桶金子，道路B通向一个岔路口。
chap4_para405,2,,你知道岔路口的一个分支通向两桶金子，另一个分支会撞上一辆公共汽车。
chap4_para405,3,,遗憾地是，你不知道哪个分支通向金子。
chap4_para406,1,,观测力平均会得出以下推论：第一天，B是正确选择；第二天，B也是正确选择；第三天，情况和第一天或第二天一样，所以B仍然是正确选择。
chap4_para407,1,,现在我们可以看出观测力平均为什么会失败：它没有考虑智能体执行行动后所处的信念状态。
chap4_para407,2,,完全忽略信念状态是不可取的，特别是当其中一种可能性是必死时。
chap4_para407,3,,因为它假设每种未来状态都自动成为一个完美知识，观测力方法从不选择那些收集信息的行动（例如图5-15中的第一个移动），也不会选择那些向对手隐藏信息或向同伴提供信息的行动，因为它假定对方已经知道这些信息。
chap4_para407,4,,在扑克游戏中，它永远不会虚张声势（bluff）[7]，因为它假设对手知道自己的牌。
chap4_para407,5,,在第17章中，我们将介绍如何构造算法解决真正的部分可观测决策问题，得到最优均衡策略（见18.2节）。
chap4_para409,1,,[7]　虚张声势——即使自己的手牌很差，也要装作很好——是扑克策略的核心部分。
chap4_para41,1,"Evolutionary algorithms can be seen as variants of stochastic beam search that are explicitly motivated by the metaphor of natural selection in biology: there is a population of individuals (states), in which the fittest (highest value) individuals produce offspring (successor states) that populate the next generation, a process called recombination.",● 选择（selection）过程。
chap4_para41,2,"There are endless forms of evolutionary algorithms, varying in the following ways:",选择将成为下一代亲本的个体：一种可能是从所有个体中选择，被选中的概率与其适应度得分成正比。
chap4_para41,3,,另一种可能是随机选择n个个体（），然后选择最适合的个个体作为亲本。
chap4_para410,1,,尽管存在上述缺陷，观测力平均仍是一个有效策略，通过一些技巧可以使其更好地发挥作用。
chap4_para410,2,,在大多数纸牌游戏中，可能的发牌结果数量都相当大。
chap4_para410,3,,例如，在桥牌中，每个玩家只能看到四手牌中的两手，剩余两手各包含13张牌，所以可能的发牌结果有= 10 400 600种。
chap4_para410,4,,即使求解一种发牌结果也是相当困难的，所以求解1000万种更是不可能的。
chap4_para410,5,,处理这样巨大数目的一种方法是抽象（abstraction）：将相似的手牌视为相同手牌。
chap4_para410,6,,例如，手牌中的A和K非常重要，但是4或5就不那么重要了，可以将其抽象。
chap4_para411,1,,另一种处理方法是前向剪枝：只考虑一个小随机样本（样本数为N），再次计算Expectiminimax得分。
chap4_para411,2,,即使是相当小的N （例如100～1000），这种方法也能提供很好的近似值。
chap4_para411,3,,它也可以应用于确定性博弈，例如四国军棋（在四国军棋中，我们对游戏的可能的状态进行采样，而不是可能的发牌），只要我们有方法估计每个状态的可能性。
chap4_para411,4,,除了搜索整个博弈树，使用深度截断进行启发式搜索也很有帮助。
chap4_para412,1,,到目前为止，我们假设每种发牌结果的可能性相等。
chap4_para412,2,,对于惠斯特牌和红心大战，这样的假设是有意义的。
chap4_para412,3,,但是对于桥牌，比赛之前为叫牌阶段，在这个阶段中，每支队伍都会表明它要赢多少。
chap4_para412,4,,由于玩家是根据自己持有的牌出价，因此其他玩家可以了解到每种发牌结果的概率P(s)。
chap4_para412,5,,在决定如何玩这手牌时考虑这一点是很难的，原因就像我们在四国军棋的描述中所提到的：玩家在出价时，可能会尽量最小化传达给对手的信息。
chap4_para413,1,,计算机在扑克牌上的表现已经超出了人类水平。
chap4_para413,2,,在为期20天的无限注德州扑克比赛中，扑克程序Libratus与4位世界顶尖的扑克玩家展开较量，并果断地将他们全部击败。
chap4_para413,3,,因为在扑克中存在很多可能状态，Libratus使用抽象法减少状态空间：它可能会认为手牌AAA72和AAA64是等价的（它们都是“3个A和一些小牌”），并且可能认为赌200美元与赌201美元是一样的。
chap4_para413,4,,但是Libratus也会监视其他玩家，如果它发现他们正在使用抽象法，它会立即做一些额外的计算填补这个漏洞。
chap4_para413,5,,总的来说，它在超级计算机上耗费了2500万CPU小时才取得胜利。
chap4_para414,1,,Libratus的计算开销（以及AlphaZero和其他系统的开销）表明，预算有限的研究人员可能无法达到世界冠军水平。
chap4_para414,2,,从某种程度上来说，这是正确的：就像你不能指望在你的车库里用零部件组装出一辆F1冠军赛车一样，拥有超级计算机或专业硬件（如TPU）是有优势的。
chap4_para414,3,,训练一个系统时尤其如此，但训练也可以通过众包完成。
chap4_para414,4,,例如，开源LeelaZero系统是AlphaZero的复现，它通过志愿参与者计算机上的自我对弈进行训练。
chap4_para414,5,,一旦训练完成，实际比赛中的计算需求是适中的。
chap4_para414,6,,AlphaStar在使用单个GPU的商用台式计算机上赢得了《星际争霸II》比赛，而AlphaZero也可以在这种模式下运行。
chap4_para415,1,,5.7　博弈搜索算法的局限性
chap4_para416,1,,计算复杂博弈中的最优决策是非常困难的，因此所有算法都必须做出一些假设和近似。
chap4_para416,2,,搜索使用启发式评价函数作为近似，而蒙特卡罗搜索计算随机选择的模拟的近似平均值。
chap4_para416,3,,选择哪种算法在一定程度上取决于每种博弈的特征：当分支因子较高或评价函数难以定义时，首选蒙特卡罗搜索。
chap4_para416,4,,但这两种算法都存在其基本的局限性。
chap4_para417,1,,搜索的一个局限性是它容易受到启发式函数的近似误差的影响。
chap4_para417,2,,图5-16为一个二层博弈树，极小化极大搜索会选择右边的分支，因为100 99。
chap4_para417,3,,如果所有的评估值都是精确的，那么这就是正确的选择。
chap4_para417,4,,但假设每个节点的评估值都有一个独立于其他节点的随机分布的误差，其标准差为s。
chap4_para417,5,,当s = 5时，实际上71%的情况下是左侧分支更好，当s = 2时，58%的情况下左侧分支更好（因为在这些情况下，右侧分支的4个叶节点之一可能小于99）。
chap4_para417,6,,如果评价函数中的误差不是独立的，那么发生错误的可能性更大。
chap4_para417,7,,这是很难避免的，因为我们没有一个很好的兄弟节点值之间依赖关系的模型。
chap4_para418,1,,图5-16　启发式极小化极大算法可能出错的二层博弈树
chap4_para419,1,,搜索和蒙特卡罗搜索的第二个局限性是，它们都是设计用于计算合法移动的（边界）值的。
chap4_para419,2,,但有时其中一种移动显然是最佳的（例如，合法移动只有一种），在这种情况下，浪费时间计算它的值是没有意义的——最好是直接选择该移动。
chap4_para419,3,,更好的搜索算法应该使用节点扩展的效用值的思想，选择效用值高的节点扩展，所谓高效用值的节点是指，有可能导致算法发现一个明显更好的移动。
chap4_para419,4,,如果没有一个节点扩展的效用值高于它的代价（从时间上考虑），那么算法应该停止搜索并执行一个移动。
chap4_para419,5,,这不仅适用于存在明显更好移动的情况，也适用于对称情况，在这种情况下，再多的搜索也无法证明一种移动比另一种更好。
chap4_para42,1,•The size of the population.,● 重组过程。
chap4_para42,2,,一种常见的方法（假设）是随机选择一个杂交点（crossover point）来分割每个父字符串，并将这些部分重新组合以形成两个子串，一个是亲本1的第一部分和亲本2的第二部分的组合；另一个是亲本1的第二部分和亲本2的第一部分的组合。
chap4_para420,1,,这种关于计算该做什么的推理叫作元推理（metareasoning）（关于推理的推理）。
chap4_para420,2,,它不仅适用于博弈，也适用于任意一种推理。
chap4_para420,3,,所有计算都是为了做出更好的决策，所有计算都有代价，并且都有可能导致决策质量的一定程度上的改进。
chap4_para420,4,,蒙特卡罗搜索的确尝试进行元推理，将资源分配给树中最重要的部分，但不是以最优方式。
chap4_para421,1,,第三个局限性是搜索和蒙特卡罗搜索都是在单步移动的层级上进行所有推理的。
chap4_para421,2,,显然，这与人类玩游戏的方式不同：人类可以在更抽象的层级上进行推理，会考虑更高层级的目标（例如，诱捕对方的后），并使用该目标有选择地生成看似合理的规划。
chap4_para421,3,,在第11章中，我们将学习这种类型的规划，在11.4节中，我们将介绍如何用从抽象表示到具体表示的层次结构进行规划。
chap4_para422,1,,第四个问题是能否将机器学习融入博弈搜索过程。
chap4_para422,2,,早期的游戏程序依靠人类的专业知识人为制定评价函数、开局库、搜索策略和高效技巧。
chap4_para422,3,,"我们才刚刚开始看到像AlphaZero这样的程序（Silver et al., 2018），它依赖于自我对弈的机器学习，而非人类在特定游戏上的专业知识。"
chap4_para422,4,,我们将从第19章开始深入探讨机器学习。
chap4_para424,1,,我们探讨了各种各样的博弈，以理解什么是最佳玩法以及如何在实际中玩好游戏，还了解了智能体在任意类型的对抗性环境中应该如何行动。
chap4_para424,2,,最重要的思想如下。
chap4_para425,1,,● 博弈可以由初始状态（棋盘如何设置）、每个状态下的合法动作、每个动作的结果、终止测试（说明什么时候博弈结束）以及应用于终止状态表明输赢和最终比分的效用函数定义。
chap4_para426,1,,● 在具有完美信息的离散、确定性、轮流的双人零和博弈中，极小化极大算法可以通过对博弈树的深度优先枚举选出最优移动。
chap4_para427,1,,● 搜索算法可以计算出与极小化极大算法相同的最优移动，通过消除可证明与结果无关的子树来提高效率。
chap4_para428,1,,● 通常，考虑整个博弈树是不可行的（即使是搜索），所以我们需要在某个点截断搜索，然后应用启发式评价函数估计状态的效用值。
chap4_para429,1,,● 蒙特卡罗树搜索（MCTS）则是另一种方法，它不是通过应用启发式函数来评估状态，而是通过将游戏模拟到结束使用游戏规则来判断输赢。
chap4_para429,2,,因为在模拟过程中选择的移动可能不是最优移动，所以这个过程需要重复多次，对结果求平均值作为评估值。
chap4_para43,1,"•The representation of each individual. In genetic algorithms, each individual is a string over a finite alphabet (often a Boolean string), just as DNA is a string over the alphabet ACGT. In evolution strategies, an individual is a sequence of real numbers, and in genetic programming an individual is a computer program.",● 突变率（mutation rate），它决定了后代在其表示上发生随机突变的频率。
chap4_para43,2,,一旦产生了一个后代，其组成中的每位都将以与突变率相等的概率被翻转。
chap4_para430,1,,● 许多游戏程序会预先计算开局和残局的最佳移动表，这样它们就可以直接查表而不用搜索。
chap4_para431,1,,● 机会博弈可以通过期望极小化极大算法（极小化极大算法的扩展）来处理，该算法通过计算所有子节点的平均效用值并按每个子节点的概率加权来估计机会节点的平均效用值。
chap4_para432,1,,● 在不完美信息博弈中，例如四国军棋和扑克，最佳玩法需要对每个玩家当前和将来的信念状态进行推理。
chap4_para432,2,,可以通过对缺失信息的每种可能配置上的动作值取平均得到一个简单的近似。
chap4_para433,1,,● 在国际象棋、跳棋、黑白棋、围棋、扑克及许多其他游戏中，程序已经彻底击败了人类冠军选手。
chap4_para433,2,,在一些不完美信息博弈中人类仍然保持优势，如桥牌和四国军棋。
chap4_para433,3,,在像《星际争霸》和《刀塔2》这样的电子游戏中，程序可以与人类专家媲美，但它们的成功可能一部分要归功于它们可以快速执行许多动作的能力。
chap4_para436,1,,第6章　约束满足问题
chap4_para437,1,,在本章中，我们不把状态仅仅当作小黑盒，从而导出新的搜索方法和对问题结构的更深入理解。
chap4_para438,1,,第3章和第4章讨论了通过搜索状态空间进行问题求解的思想：状态空间是一个由节点表示状态，边表示动作的图。
chap4_para438,2,,我们看到，领域特定的启发式算法可以估计从给定状态到达目标的代价，但从搜索算法的角度来看，每个状态都是原子的，即不可分割的——一个没有内部结构的黑盒。
chap4_para438,3,,对于每个问题，我们需要领域特定的代码来描述状态之间的转移。
chap4_para439,1,,在本章中，我们通过对每个状态使用因子化表示（factored representation）来打破黑盒：因子化表示为一组变量，每个变量都有自己的值。
chap4_para439,2,,当每个变量的值都满足对该变量的所有约束时，问题就解决了。
chap4_para439,3,,以上述方式描述的问题称为约束满足问题（constraint satisfaction problem，CSP）。
chap4_para44,1,"•The mixing number, ρ, which is the number of parents that come together to form offspring. The most common case is ρ = 2: two parents combine their “genes” (parts of their representation) to form offspring. When ρ = 1 we have stochastic beam search (which can be seen as asexual reproduction). It is possible to have ρ > 2, which occurs only rarely in nature but is easy enough to simulate on computers.",● 下一代的构成。
chap4_para44,2,,可能只包括新形成的后代，也可能还包括一些上一代中得分最高的个体［这种做法被称为精英主义（elitism），它确保总体适应度永远不会随着时间的推移而下降］。
chap4_para44,3,,"而淘汰（culling），即丢弃所有分数低于给定阈值的个体，会使得进化加速（Baum et al., 1995）。"
chap4_para440,1,,CSP搜索算法利用了状态结构的优势，并且使用通用的而不是领域特定的启发式算法来求解复杂问题。
chap4_para440,2,,其主要思想是，通过识别违反约束的变量/值组合来一次性消除大部分搜索空间。
chap4_para440,3,,CSP的另一个优势是可以从问题描述中推导出行动和转移模型。
chap4_para441,1,,6.1　定义约束满足问题
chap4_para442,1,,约束满足问题由3个部分组成，即X、D和C。
chap4_para444,1,,● D是域集合，，每个变量有一个域。
chap4_para445,1,,● C是约束集合，用来规定允许的值的组合。
chap4_para446,1,,域Di，由变量Xi的一组允许的值组成。
chap4_para446,2,,例如，布尔变量的域为。
chap4_para446,3,,不同变量可以有不同大小的域。
chap4_para446,4,,每个约束Cj由对组成，其中scope是该约束中的变量元组，而rel定义了这些值应该满足的关系（relation）。
chap4_para446,5,,关系可以表示为满足约束的所有元组值的显式集合，或者表示为判断一个元组是否为关系成员的函数。
chap4_para446,6,,"例如，如果X1和X2的域都是{1, 2, 3}，那么约束“X1必须大于X2”可以表示为或。"
chap4_para447,1,,CSP要处理变量赋值（assignment）问题，即。
chap4_para447,2,,不违反任何约束的赋值称为一致（consistent）或合法赋值。
chap4_para447,3,,完整赋值（complete assignment）是指每个变量都已被赋值；CSP的解（solution）是一致完整赋值。
chap4_para447,4,,部分赋值（partial assignment）是指某些变量还未赋值，而部分解（partial solution）是一致部分赋值。
chap4_para447,5,,一般来说，CSP求解是NP完全问题，尽管CSP的一些重要子类已经可以非常高效地求解。
chap4_para448,1,,6.1.1　问题示例：地图着色
chap4_para449,1,,也许你已经逛够了罗马尼亚，现在来看看澳大利亚地图（如图6-1a所示）[1]，地图显示了澳大利亚的州和地区，分别是：西澳大利亚州（Western Australia）、北部地区（North Territory）、昆士兰州（Queensland）、新南威尔士州（New South Wales）、维多利亚州（Victoria）、南澳大利亚州（South Australia）、塔斯马尼亚州（Tasmania）、澳大利亚首都直辖区（Australia Capital Territory）。
chap4_para449,2,,我们的任务是给每个区域涂上红色、绿色或蓝色，要求相邻的两个区域颜色不能相同。
chap4_para449,3,,[2]为了将其形式化为CSP，我们将图中的区域定义为变量，变量名为各区域的英文名缩写：
chap4_para45,1,"•The selection process for selecting the individuals who will become the parents of the next generation: one possibility is to select from all individuals with probability proportional to their fitness score. Another possibility is to randomly select n individuals (n > ρ), and then select the ρ most fit ones as parents.",图4-6a为由4个8位数字符串组成的种群，每个字符串代表8皇后问题的一个状态：第c位数字表示第c列中皇后的行号。
chap4_para45,2,,在图4-6b中，每个状态根据适应度函数进行评级。
chap4_para45,3,,适应度越高越好，所以对于8皇后问题，我们使用非攻击皇后对的数量作为适应度，解的适应度为8×7/2 = 28。
chap4_para45,4,,图4-6b中4个状态的值分别为24、23、20和11。
chap4_para45,5,,然后将适应度得分归一化为概率，结果显示在图4-6b中的适应度旁边。
chap4_para451,1,,[1]　本图系原书原图。
chap4_para452,1,,[2]　本书未将澳大利亚首都直辖区作为一个待着色区域，这使该地图着色问题更简洁明晰。
chap4_para452,2,,——编者注
chap4_para453,1,,每个变量的域为集合。
chap4_para453,2,,约束要求相邻区域颜色不同。
chap4_para453,3,,由于相邻区域的边界线有9段，所以有9个约束：
chap4_para454,1,,这里我们使用缩写。
chap4_para454,2,,是的缩写，其中可以依次完整枚举为：
chap4_para455,1,,这个问题有很多可能的解，例如：
chap4_para456,1,,将CSP可视化为约束图（constraint graph）非常有用，如图6-1b所示。
chap4_para456,2,,图的节点对应于问题的变量，图的边连接同一约束中的任意两个变量。
chap4_para457,1,,为什么要将问题形式化为CSP呢？
chap4_para457,2,,第一个原因是CSP可以自然地表示各种问题，将一个问题形式化为CSP通常很容易；第二个原因是多年的研究工作使得CSP求解器快速而高效；第三个原因是相比于原子的状态空间搜索器，CSP求解器可以快速消除大面积搜索空间。
chap4_para457,3,,例如，一旦我们在澳大利亚问题中选择了，就可以得出结论，它的5个相邻变量都不能取值为blue。
chap4_para457,4,,不使用约束的搜索过程必须考虑这5个相邻变量的35 = 243种赋值；有了约束，我们只需考虑25 = 32种赋值，计算量减少了87%。
chap4_para458,1,,图6-1　（a）澳大利亚的州和地区。
chap4_para458,2,,对该地图着色可以看作约束满足问题（CSP）。
chap4_para458,3,,目标是为每个区域分配颜色，使得相邻区域颜色不同。
chap4_para458,4,,（b）用约束图表示地图着色问题
chap4_para459,1,,在原子的状态空间搜索中，我们只能问：这个特定状态是目标状态吗？
chap4_para459,2,,不是？
chap4_para459,3,,那么这一个呢？
chap4_para459,4,,使用CSP，一旦发现某个部分赋值违反了约束，我们可以马上放弃对该部分赋值的进一步改进。
chap4_para459,5,,此外，我们可以看出为什么某个赋值不是解——可以看出哪些变量违反了约束——从而把注意力集中在关键变量上。
chap4_para459,6,,因此，许多原子状态空间搜索难以求解的问题形式化为CSP后都可以快速求解。
chap4_para46,1,"•The recombination procedure. One common approach (assuming ρ = 2), is to randomly select a crossover point to split each of the parent strings, and recombine the parts to form two children, one with the first part of parent 1 and the second part of parent 2; the other with the second part of parent 1 and the first part of parent 2.",图4-6　遗传算法，图示为表示8皇后状态的数字字符串。
chap4_para46,2,,（a）中的初始种群根据（b）中的适应度函数进行排序从而得到（c）中的配对，（d）是产生的后代，（e）是可能发生的突变
chap4_para460,1,,6.1.2　问题示例：车间作业调度
chap4_para461,1,,工厂有很多日常工作调度问题，要满足各种约束。
chap4_para461,2,,在实践中，使用CSP技术可以求解很多这样的问题。
chap4_para461,3,,考虑汽车装配调度问题。
chap4_para461,4,,整个作业由不同任务组成，我们可以将每个任务建模成一个变量，其中每个变量的值为任务开始时间，由整数分钟数表示。
chap4_para461,5,,约束为“一个任务必须在另一个任务之前完成”（例如，安装车轮必须在安装轮毂盖之前完成）和“一次只能同时执行一定数量的任务”等断言。
chap4_para461,6,,约束还可以指定任务完成所需的时间。
chap4_para462,1,,我们考虑汽车装配的一小部分环节，包括15个任务：安装轮轴（axle）（前、后），固定4个车轮（wheel）（左和右、前和后），拧紧每个车轮的螺母（nuts），固定轮毂盖（cap），并检查（inspect）最终装配。
chap4_para462,2,,我们可以将任务表示为15个变量：
chap4_para463,1,,接着，我们需要表示各个任务间的优先约束（precedence constraint）。
chap4_para463,2,,当任务T1必须在T2之前完成且任务T1所需时间为d1时，我们将添加一个如下形式的算术约束：
chap4_para464,1,,在这个示例中，轮轴必须在车轮安装前到位，安装一个轮轴需要10分钟，所以有
chap4_para465,1,,接下来，我们必须固定每个车轮（需要1分钟），拧紧螺母（2分钟），最后安装轮毂盖（1分钟，但暂未表示）：
chap4_para466,1,,假设有4个工人来安装车轮，但他们必须共用一个工具来辅助安装轮轴。
chap4_para466,2,,此时我们需要一个析取约束（disjunctive constraint）表示AxleF和AxleB在时间上不能重叠：要么先做AxleF，要么先做AxleB：
chap4_para467,1,,这一约束看起来更加复杂，结合了算术约束和逻辑约束。
chap4_para467,2,,但它仍可以简化为AxleF和AxleB可以取的一组值。
chap4_para468,1,,我们还需要说明，检查是最后一项任务，需要3分钟。
chap4_para468,2,,对于除Inspect外的每个变量，我们都需要添加一个形式的约束。
chap4_para468,3,,最后，假设我们需要在30分钟内完成整个装配任务。
chap4_para468,4,,因此，所有变量的域被限制为
chap4_para469,1,,这一特定问题的求解非常琐碎，但CSP已经成功地应用于此类具有几千个变量的车间作业调度问题。
chap4_para47,1,"•The mutation rate, which determines how often offspring have random mutations to their representation. Once an offspring has been generated, every bit in its composition is flipped with probability equal to the mutation rate.",在图4-6c中，根据图4-6b中的概率选出两对父字符串。
chap4_para47,2,,注意，有一个个体被选择了两次，还有一个没有被选择。
chap4_para47,3,,对于每一对被选择的亲本，随机选择一个杂交点（虚线）。
chap4_para47,4,,在图4-6d中，我们在杂交点处交叉两个父串，以生成新的后代。
chap4_para47,5,,例如，第一对亲本中的第一个子串从第一个父串获得前三个数字（327），从第二个父串获得剩余数字（48552）。
chap4_para47,6,,这一重组步骤中所包含的8皇后状态如图4-7所示。
chap4_para470,1,,6.1.3　CSP形式体系的变体
chap4_para471,1,,"最简单的CSP所涉及的变量具有离散有限域（discrete, finite domain）。"
chap4_para471,2,,地图着色问题和带有时间限制的调度问题都属于这类问题。
chap4_para471,3,,8皇后问题（图4-3）也可以看作是一个有限域CSP，其中变量对应第1～8列中的皇后，每个变量的域为该列皇后可能的行号，。
chap4_para471,4,,约束为不允许两个皇后在同一行或同一对角线上。
chap4_para472,1,,离散域也可以是无限的（infinite），例如整数集或字符串集。
chap4_para472,2,,（如果我们不对作业调度问题设置截止时间，那么每个变量的开始时间构成的域将是无限的。
chap4_para472,3,,）对于无限域，我们必须使用类似这样的隐式约束，而不是显式的值元组。
chap4_para472,4,,对于整数变量的线性约束（linear constraint）（像刚刚给出的约束一样，每个变量都只以线性形式出现）存在特殊的求解算法（在这里不讨论）。
chap4_para472,5,,可以证明，不存在求解整数变量上一般非线性约束（nonlinear constraint）的算法——这个问题是不可判定的。
chap4_para473,1,,连续域（continuous domain）约束满足问题是真实世界中的常见问题，在运筹学领域得到了广泛研究。
chap4_para473,2,,例如，哈勃太空望远镜的实验调度需要非常精确的观测时间，每次观测和机动的开始时间、结束时间都是连续值变量，必须服从各种天文的、优先级的和电力的约束。
chap4_para473,3,,最著名的一类连续域CSP是线性规划问题，其约束必须为线性等式或不等式。
chap4_para473,4,,线性规划（linear programming）问题可以在关于变量个数的多项式时间内求解。
chap4_para473,5,,此外人们还研究了具有不同类型约束和目标函数的问题——二次规划、二阶锥规划等。
chap4_para473,6,,这些问题构成了应用数学的一个重要领域。
chap4_para474,1,,除了检查CSP中变量的类型以外，检查约束的类型也是很有用。
chap4_para474,2,,最简单的类型是一元约束（unary constraint），它限制单个变量的值。
chap4_para474,3,,例如，在地图着色问题中，南澳大利亚州人可能不喜欢绿色，我们可以用一元约束表示。
chap4_para474,4,,（变量的域的初始说明也可以看作一元约束。
chap4_para474,5,,）
chap4_para475,1,,二元约束（binary constraint）关系到两个变量。
chap4_para475,2,,例如，是一个二元约束。
chap4_para475,3,,二元CSP（binary CSP）只存在一元约束和二元约束，可以用如图6-1b所示的约束图表示。
chap4_para476,1,,我们也可以定义高阶约束。
chap4_para476,2,,"例如，三元约束Between(X, Y, Z)可以定义为。"
chap4_para477,1,,包含任意个数变量的约束称为全局约束（global constraint）。
chap4_para477,2,,（这个名称很传统，但容易混淆，因为它不需要包含问题中的所有变量）。
chap4_para477,3,,最常见的全局约束之一是Alldiff，它表示约束中涉及的所有变量必须具有不同的值。
chap4_para477,4,,在数独问题中（见6.2.6节），一行、一列或3×3框中的所有变量必须满足Alldiff约束。
chap4_para478,1,,另一个例子是密码算术（cryptarithmetic）谜题（图6-2a）。
chap4_para478,2,,密码算术谜题中的每个字母代表一个不同数字。
chap4_para478,3,,"图6-2a中的情况，将表示为全局约束Alldiff(F, T, U, W, R, O)。"
chap4_para478,4,,4列上的加法约束可以写成如下n元约束：
chap4_para479,1,,其中C1、C2和C3为辅助变量，表示十位、百位或千位上的进位数。
chap4_para479,2,,这些约束可以用约束超图（constraint hypergraph）表示，如图6-2b所示。
chap4_para479,3,,超图由普通节点（图中的圆圈）和表示n元约束的超节点（正方形）组成，n元约束为包含n个变量的约束。
chap4_para48,1,"•The makeup of the next generation. This can be just the newly formed offspring, or it can include a few top-scoring parents from the previous generation (a practice called elitism, which guarantees that overall fitness will never decrease over time). The practice of culling, in which all individuals below a given threshold are discarded, can lead to a speedup (Baum et al., 1995).",图4-7　对应于图4-6c中前两个亲本和图4-6d中第一个后代的8皇后状态。
chap4_para48,2,,在杂交步中，丢弃绿色列，保留红色列。
chap4_para48,3,,（图4-6中数字的解释：第1行是最下面一行，第8行是最上面一行）
chap4_para480,1,,图6-2　（a）密码算术问题。
chap4_para480,2,,不同字母表示不同数字，目的是找到使加法算式成立的代替字母的数字，附加约束为不允许前导零。
chap4_para480,3,,（b）密码算术问题的约束超图，用来表示Alldiff约束（最上面的方框）以及每列的加法约束（中间的4个方框）。
chap4_para480,4,,变量C1、C2和C3表示从右到左3列的进位数
chap4_para481,1,,或者，正如习题6.NARY需要你证明的，如果引入足够多的辅助变量，每个有限域约束都可以简化为一组二元约束。
chap4_para481,2,,这意味着我们可以将任意一个CSP转换为只有二元约束的CSP，这将使算法设计变得更加简单。
chap4_para481,3,,将n元CSP转换为二元CSP的另一种方式是对偶图（dual graph）变换：创建一个新图，原图中的每个约束用新图中的一个变量表示，原图中的每对共享变量的约束用新图中的一个二元约束表示。
chap4_para482,1,,例如，考虑变量为的CSP，每个变量的域为，带有两个约束和。
chap4_para482,2,,对偶图的变量则为，对偶图中C1变量的域为原问题C1约束中的元组的集合，同样地，C2的域是元组的集合。
chap4_para482,3,,对偶图具有二元约束，其中R1是定义C1和C2之间约束的新关系。
chap4_para482,4,,在这种情况下，。
chap4_para483,1,,然而，我们可能更喜欢Alldiff这样的全局约束，而不是一组二元约束，这有两个原因。
chap4_para483,2,,首先，使用Alldiff描述问题更简单而且更不容易出错。
chap4_para483,3,,其次，可以为全局约束设计相比于基元约束更有效的专用推理算法。
chap4_para483,4,,我们将在6.2.5节介绍这些推理算法。
chap4_para484,1,,到目前为止，我们所描述的约束都是绝对约束，违反这些约束的可能解将被排除。
chap4_para484,2,,许多真实世界的CSP包含偏好约束（preference constraint），偏好约束规定哪些解是首选的。
chap4_para484,3,,例如，在大学排课问题中，存在绝对约束，如一个教授不可以同时上两门课。
chap4_para484,4,,但也可能存在偏好约束：R教授可能更喜欢在上午上课，而N教授更喜欢在下午上课。
chap4_para484,5,,让R教授在下午2点上课仍是一个可行解（除非R教授碰巧是系主任），但不是最优解。
chap4_para485,1,,偏好约束通常可以编码为个别变量赋值的代价。
chap4_para485,2,,例如，为R教授分配一个下午时段相对于总体目标函数的代价为2分，而分配上午时段的代价为1分。
chap4_para485,3,,通过这样的形式化，带偏好约束的CSP可以用基于路径的或局部的优化搜索方法求解。
chap4_para485,4,,我们称这样的问题为约束优化问题（constrained optimization problem，COP）。
chap4_para485,5,,线性规划是一类COP。
chap4_para486,1,,6.2　约束传播：CSP中的推断
chap4_para487,1,,原子的状态空间搜索算法只有一种方式：通过扩展节点来访问后继节点。
chap4_para487,2,,CSP算法有不同选择。
chap4_para487,3,,它可以通过选择一个新的变量赋值来生成后继，或者执行一种称为约束传播（constraint propagation）的特定类型推断：使用约束减少一个变量的合法值的数量，这反过来又可以减少另一个变量的合法值，以此类推。
chap4_para487,4,,其思想是，通过这一过程，当我们选择下一个变量赋值时，需要考虑的选项会减少。
chap4_para487,5,,约束传播可以与搜索交替进行，也可以作为搜索开始前的预处理步骤。
chap4_para487,6,,有时这种预处理就可以求解整个问题，所以根本不需要搜索。
chap4_para488,1,,约束传播的核心思想是局部一致性（local consistency）。
chap4_para488,2,,如果我们将每个变量看作图中的一个节点（见图6-1b），将每个二元约束看作一条边，则增强图中每一部分局部一致性的过程会导致整个图中不一致的值被删除。
chap4_para488,3,,局部一致性有几种不同类型，我们现在依次介绍。
chap4_para489,1,,6.2.1　节点一致性
chap4_para49,1,"Figure 4.6(a) shows a population of four 8-digit strings, each representing a state of the 8-queens puzzle: the c-th digit represents the row number of the queen in column c. In (b), each state is rated by the fitness function. Higher fitness values are better, so for the 8-queens problem we use the number of nonattacking pairs of queens, which has a value of 8 × 7/2 = 28 for a solution. The values of the four states in (b) are 24, 23, 20, and 11. The fitness scores are then normalized to probabilities, and the resulting values are shown next to the fitness values in (b).",最后，在图4-6e中，每个字符串中的每个位置都以某个很小的独立概率发生随机突变。
chap4_para49,2,,第一个、第三个和第四个后代的某个位发生了突变。
chap4_para49,3,,在8皇后问题中，这相当于随机选择一个皇后，并将其随机移动到它所在列的某个位置。
chap4_para49,4,,通常情况下，早期的种群是多样化的，所以在搜索过程的早期阶段，杂交常常在状态空间中采取较大的步调（类似于模拟退火）。
chap4_para49,5,,在经过许多代选择提高了适应度后，种群的多样性减少，步调也随之变小。
chap4_para49,6,,图4-8介绍了实现所有这些步骤的算法。
chap4_para490,1,,如果单个变量的域中的所有值都满足该变量的一元约束，则该变量（对应于CSP图中的某个节点）是节点一致的。
chap4_para490,2,,例如，在澳大利亚地图着色问题（图6-1）的变体中，南澳大利亚州人不喜欢绿色，变量SA的初始域为，可以通过删除green使其保持节点一致，SA的域缩减为。
chap4_para490,3,,如果图中的每个变量都是节点一致的，那么整个图是节点一致的。
chap4_para491,1,,在求解过程开始时，通过缩减具有一元约束的变量的域，可以很容易地消除CSP中的所有一元约束。
chap4_para491,2,,如前文所述，还可以将所有n元约束转换为二元约束。
chap4_para491,3,,因此，一些CSP求解器只处理二元约束，要求用户提前消除其他约束。
chap4_para491,4,,除非特别说明，本章的剩余部分都基于这一假设。
chap4_para492,1,,6.2.2　弧一致性
chap4_para493,1,,如果CSP中某一变量的域内的所有值都满足该变量的二元约束，那么该变量就是弧一致的（arc consistent）[3]。
chap4_para493,2,,"更正式地说，对于变量Xi、Xj，如果对于当前域Di中的每个值，Dj中都存在一些值满足弧(Xi, Xj)上的二元约束，则称Xi相对于Xj是弧一致的。"
chap4_para493,3,,如果每个变量相对所有其他变量都是弧一致的，那么这个图就是弧一致的。
chap4_para493,4,,例如，考虑约束Y = X2，其中X和Y的域都是十进制数字。
chap4_para493,5,,我们可以将这一约束显式地写为。
chap4_para493,6,,"为了使X相对于Y弧一致，我们将X的域缩减为{0, 1, 2, 3}。"
chap4_para493,7,,"如果要使Y相对于X弧一致，那么Y的域为{0, 1, 4, 9}，此时整个CSP是弧一致的。"
chap4_para493,8,,但是，弧一致性对澳大利亚地图着色问题没有任何帮助。
chap4_para493,9,,"考虑(SA, WA)的如下不同色约束："
chap4_para495,1,,[3]　我们一直使用的术语是“边”而不是“弧”，所以将其称为“边一致”会更合适，但历史上使用的术语是“弧一致”。
chap4_para496,1,,无论为SA（或WA）选择哪个值，另一变量都存在一个有效值。
chap4_para496,2,,所以应用弧一致性对两个变量的域都没有影响。
chap4_para497,1,,最流行的增强弧一致性的算法为AC-3（见图6-3）。
chap4_para497,2,,为了使每个变量保持弧一致，AC-3算法将维护一个弧队列。
chap4_para497,3,,初始时，队列包含CSP中的所有弧。
chap4_para497,4,,（每个二元约束都有两条弧，每个方向各一条。
chap4_para497,5,,"）然后AC-3从队列中弹出任意一条弧(Xi, Xj)并使Xi相对于Xj弧一致。"
chap4_para497,6,,如果Di保持不变，算法就会处理下一条弧。
chap4_para497,7,,"但是如果Di得以修正（域变小），那么我们将所有的弧(Xk, Xi)添加到队列中，其中Xk是Xi的邻居。"
chap4_para497,8,,这样做的原因是，即使之前已经处理过Xk，Di的变化也可能会进一步缩减Dk。
chap4_para497,9,,如果Di变为空集，那么表示整个CSP不存在一致解，AC-3可以马上返回失败。
chap4_para497,10,,否则，我们继续检查，不断尝试缩减变量的域，直到队列中没有弧。
chap4_para497,11,,此时，我们得到了一个与原始CSP等价的CSP（它们的解相同），但弧一致CSP搜索起来会更快，因为它的变量的域更小。
chap4_para497,12,,在某些情况下，它可以完全求解问题（通过将每个域的大小缩减为1），而在其他情况下，它可以证明解不存在（通过将某些域的大小缩减为0）。
chap4_para498,1,,图6-3　弧一致性算法AC-3。
chap4_para498,2,,应用AC-3算法后，要么每条弧都是弧一致的，要么某些变量的域为空集，说明该CSP无解。
chap4_para498,3,,"“AC-3”这个名字来源于算法的发明者（Mackworth, 1977），因为他论文中用到的算法是开发的第三个版本"
chap4_para499,1,,AC-3的算法复杂性可以如下分析。
chap4_para499,2,,假设CSP有n个变量，每个变量的域大小不超过d，带有c个二元约束（弧）。
chap4_para499,3,,"每个弧(Xk, Xi)最多只能插入队列d次，因为Xi最多有d个值要删除。"
chap4_para499,4,,对弧一致性的检查可以在O(d2)时间内完成，因此最坏情况下的时间复杂性为O(cd3)。
chap4_para5,1,"In the search problems of Chapter 3 we wanted to find paths through the search space, such as a path from Arad to Bucharest.",局部搜索（local search）算法的操作是从一个起始状态搜索到其相邻状态，它不记录路径，也不记录已达状态集。
chap4_para5,2,"But sometimes we care only about the final state, not the path to get there.",这意味着它们不是系统性的——可能永远不会探索问题的解实际所在的那部分搜索空间。
chap4_para5,3,"For example, in the 8-queens problem (Figure 4.",但是，它们有两个主要优点：（1）使用很少的内存；（2）通常可以在系统性算法不适用的大型或无限状态空间中找到合理的解。
chap4_para5,4,"3), we care only about finding a valid final configuration of 8 queens (because if you know the configuration, it is trivial to reconstruct the steps that created it).",
chap4_para5,5,"This is also true for many important applications such as integrated-circuit design, factory floor layout, job shop scheduling, automatic programming, telecommunications network optimization, crop planning, and portfolio management.",
chap4_para50,1,"Description The first two chessboard arrangements are added up to form the third, which depicts the three steps of recombination. In the first step, the queens are positioned at G 1, H 1, B 2, E 2, “a” 3, F 4, D 5, and C 7. The first three columns are shaded in red, which are retained in the cross over step, and the next five columns are shaded in green which are lost. In the second step, the queens are positioned at “a” 2, H 2, B 4, D 4, F 5, G 5, C 7, and E 8. The first three columns are shaded in green, that are lost in the cross over step, and the next five columns are shaded in red and retained. In the last step, the queens are arranged at B 2, H 2, “a” 3, D 4, F 5, G 5, C 7, and E 8. All the columns are retained after the crossover step.",图4-8　遗传算法。
chap4_para50,2,,在这个函数中，population是种群中个体的有序列表，weights是每个个体所对应的适应度值的列表，而fitness是计算这些值的函数
chap4_para500,1,,6.2.3　路径一致性
chap4_para501,1,,假设我们要给澳大利亚地图涂上两种颜色，红色和蓝色。
chap4_para501,2,,此时弧一致性不起作用，因为将弧的一端涂成红色，另一端涂成蓝色可以分别满足每个约束。
chap4_para501,3,,但显然这个问题是无解的：因为西澳大利亚州、北领地和南澳大利亚州彼此相邻，仅仅是它们就需要至少3种颜色。
chap4_para502,1,,弧一致性利用弧（二元约束）将域（一元约束）收紧。
chap4_para502,2,,为了求解地图着色等问题，我们需要更强的一致性概念。
chap4_para502,3,,路径一致性（path consistency）使用隐式约束（通过观测变量的三元组推断）将二元约束收紧。
chap4_para503,1,,考虑两个变量的集合和第三个变量Xm，如果对于每个满足上约束（如果有的话）的赋值，都存在Xm的一个赋值满足和上的约束，则称相对于Xm是路径一致的。
chap4_para503,2,,这一名称是指从Xi途经Xm到Xj的路径的整体一致性。
chap4_para504,1,,让我们考虑用两种颜色为澳大利亚地图着色时的路径一致性。
chap4_para504,2,,我们要使集合相对于NT路径一致。
chap4_para504,3,,首先枚举集合的一致赋值。
chap4_para504,4,,在这种情况下，只有两个一致赋值：和。
chap4_para504,5,,可以看到，对于这两种赋值，NT不能是红色或蓝色（因为它会与WA或SA发生冲突）。
chap4_para504,6,,因为NT不存在有效选择，所以我们消除了这两种赋值，最终不存在有效赋值。
chap4_para504,7,,因此，我们知道了这个问题是无解的。
chap4_para505,1,,6.2.4　k一致性
chap4_para506,1,,可以用k一致性（k-consistency）的概念定义更强的传播形式。
chap4_para506,2,,如果对于CSP的任意(k −1)个变量的集合以及这些变量的任意一致赋值，任意第k个变量都存在一个一致赋值，则称该CSP是k一致的。
chap4_para506,3,,1一致性表示，给定空集，我们可以使任何单变量集合满足一致性，这就是我们所说的节点一致性。
chap4_para506,4,,2一致性等价于弧一致性。
chap4_para506,5,,对于二元约束图，3一致性等价于路径一致性。
chap4_para507,1,,如果一个CSP是k一致的，也是(k −1)一致的，(k −2)一致的……一直到1一致的，则称它是强k一致的（strongly k-consistent）。
chap4_para507,2,,现在假设我们有一个包含n个节点的CSP，并且是强n一致的(即当k = n时，强k一致)，那么可以这样求解该问题：首先，为X1选择一个一致值。
chap4_para507,3,,然后因为图是2一致的，所以保证能为X2选出一个一致值，因为它是3一致的，所以能为X3选出一个值，以此类推。
chap4_para507,4,,"对于每个变量Xi，我们只需在它的域的d个值中搜索，就可以找到一个与X1, …, Xi−1一致的值。"
chap4_para507,5,,总运行时间只有O(n2d)。
chap4_para508,1,,当然，世界上没有免费的午餐：约束满足问题通常是NP完全的，任何建立n一致性的算法在最坏情况下的时间复杂性都是n的指数级。
chap4_para508,2,,更糟的是，n一致性所需的空间复杂性也是n的指数级。
chap4_para508,3,,在实践中，确定适当的一致性检查层级基本上是一门经验科学。
chap4_para508,4,,比较常见的是计算2一致性，其次是计算3一致性。
chap4_para509,1,,6.2.5　全局约束
chap4_para51,1,Figure 4.,遗传算法类似于随机束搜索，但增加了杂交操作。
chap4_para51,2,"6A genetic algorithm, illustrated for digit strings representing 8-queens states.",如果存在可以执行有用功能的区域，杂交操作是有利的。
chap4_para51,3,The initial population in (a) is ranked by a fitness function in (b) resulting in pairs for mating in (c).,例如，将前3列皇后分别放在第2行、第4行和第6行（在这些位置上它们不会互相攻击），就组成了一个有用的区域，它可以与其他个体中出现的其他有用区域相结合，从而形成一个解。
chap4_para51,4,"They produce offspring in (d), which are subject to mutation in (e).",数学上可以证明，如果这些区域没有任何用途——例如，如果遗传密码的位置是随机排列的——那么杂交就没有任何优势。
chap4_para510,1,,前文提到，全局约束涉及任意个数的变量（但不一定是所有变量）。
chap4_para510,2,,实际问题中经常出现全局约束，可以通过专用算法处理这些约束，这些算法比目前介绍的一般方法更加高效。
chap4_para510,3,,例如，Alldiff约束规定所有相关变量必须取不同的值（如上文的密码算术问题和下文的数独问题）。
chap4_para510,4,,对Alldiff约束进行不一致性检测的一种简单形式如下所示：如果约束中涉及m个变量，而且它们一共具有n个可能的不同值，且，那么约束不可能满足。
chap4_para511,1,,这将导出以下简单算法。
chap4_para511,2,,首先，删除约束中任意一个单值变量（域中只有一个值的变量），并且从其余变量的域中删除该变量的值。
chap4_para511,3,,只要还存在单值变量，就重复上述过程。
chap4_para511,4,,如果在任一点上产生了空集，或者存在比剩余取值数更多的变量，则检测到了不一致性。
chap4_para512,1,,上述方法可以检测图6-1中赋值的不一致性。
chap4_para512,2,,注意，变量SA、NT和Q是通过Alldiff约束有效连接的，因为每对都必须取两种不同颜色。
chap4_para512,3,,将AC-3应用于这个部分赋值后，SA、NT和Q的域都缩减为。
chap4_para512,4,,也就是说，我们有3个变量，但只有两种颜色，这违反了Alldiff约束。
chap4_para512,5,,因此，对高阶约束进行简单一致性处理有时比对等价的二元约束集应用弧一致性更高效。
chap4_para513,1,,另一种重要的高阶约束是资源约束（resource constraint），有时也称为Atmost约束。
chap4_para513,2,,"例如，在一个调度问题中，设P1, …, P4分别表示分配给4个任务的人数。"
chap4_para513,3,,分配总人数不超过10的约束写为。
chap4_para513,4,,通过检验当前域的最小值之和可以检测不一致性。
chap4_para513,5,,"例如，如果每个变量的域都是{3, 4, 5, 6}，则不可能满足Atmost约束。"
chap4_para513,6,,另一个例子是，如果当前某个变量的域中的最大值加上所有其他变量的域的最小值超过约束，则可以通过删除该最大值来保持一致性。
chap4_para513,7,,"因此，如果示例中的每个变量的域都是{2, 3, 4, 5, 6}，那么可以从每个域中删除5和6。"
chap4_para514,1,,对于大规模的、具有整数值的资源有限问题（例如用几百辆车运送几千人的物流问题）将每个变量的域表示为一个大的整数集然后通过一致性检查方法逐渐缩减这个集合通常是不可能的。
chap4_para514,2,,相反，域由上界和下界表示，通过边界传播（bound propagation）处理。
chap4_para514,3,,例如，在航班调度问题中，假设存在两趟航班，F1和F2，其中飞机的容量分别为165和385。
chap4_para514,4,,F1和F2航班上乘客数量的初始域为
chap4_para516,1,,现在假设我们有附加约束，两趟航班所搭载的总乘客数必须是420：。
chap4_para516,2,,通过传播边界约束，我们将域缩减为
chap4_para518,1,,如果对于任意变量X和它的上下界值，任意变量Y，都存在满足X和Y之间约束的Y的值，则称CSP是边界一致的（bounds-consistent）。
chap4_para518,2,,这种边界传播在实际的约束问题中得到了广泛应用。
chap4_para52,1,"In (c), two pairs of parents are selected, in accordance with the probabilities in (b).",遗传算法理论用模式（schema）思想来解释它是如何运作的，模式是指其中某些位未确定的子串。
chap4_para52,2,Notice that one individual is selected twice and one not at all.,例如，模式246*****表示前3个皇后分别位于位置2、4和6的所有8皇后状态。
chap4_para52,3,"For each selected pair, a crossover point (dotted line) is chosen randomly.",与该模式相匹配的字符串（例如24613578）称作该模式的实例（instance）。
chap4_para52,4,"In (d), we cross over the parent strings at the crossover points, yielding new offspring.",可以证明，如果某模式实例的平均适应度高于平均值，那么该模式的实例数量将随着时间推移而不断增加。
chap4_para52,5,"For example, the first child of the first pair gets the first three digits (327) from the first parent and the remaining digits (48552) from the second parent.",
chap4_para52,6,The 8-queens states involved in this recombination step are shown in Figure 4.,
chap4_para52,7,7.,
chap4_para520,1,,数独（Sudoku）游戏非常流行，它将数百万人引入了约束满足问题，尽管他们可能没有意识到这一点。
chap4_para520,2,,数独棋盘由81个方格组成，有些方格预先填有1到9的数字。
chap4_para520,3,,谜题是将所有剩余方格填满，并且任意一行、一列或3×3方框中不存在相同数字（见图6-4）。
chap4_para520,4,,一行、一列或一个方框称为一个单元（unit）。
chap4_para521,1,,图6-4　（a）一个数独问题。
chap4_para521,2,,（b）它的解
chap4_para522,1,,报纸和益智书籍上的数独游戏都有一个特点，即有且只有一个解。
chap4_para522,2,,尽管有些问题手动求解很难，需要花费几十分钟，但CSP求解器每秒可以处理几千个问题。
chap4_para523,1,,可以将数独游戏看作含有81个变量的CSP，每个变量对应一个方格。
chap4_para523,2,,用变量名A1到A9表示第一行（从左到右），I1到I9表示最后一行。
chap4_para523,3,,"空方格的域为{1, 2, 3, 4, 5, 6, 7, 8, 9}，预先填好的方格的域只有一个值。"
chap4_para523,4,,此外，还有27个不同的Alldiff约束，每个单元（行、列和含有9个方格的方框）各有一个Alldiff约束：
chap4_para524,1,,"Alldiff (A1, A2, A3, A4, A5, A6, A7, A8, A9)"
chap4_para525,1,,"Alldiff (B1, B2, B3, B4, B5, B6, B7, B8, B9)"
chap4_para527,1,,"Alldiff (A1, B1, C1, D1, E1, F1, G1, H1, I1)"
chap4_para528,1,,"Alldiff (A2, B2, C2, D2, E2, F2, G2, H2, I2)"
chap4_para53,1,Description Two squares are marked at each stage depicting the left and right sides.,
chap4_para53,2,State 1: Dirts are at the left and right squares.,
chap4_para53,3,The vacuum cleaner is cleaning the dirt on the left square.,
chap4_para53,4,State 2: Dirts are at the left and right squares.,
chap4_para53,5,The vacuum cleaner is cleaning the dirt on the right square.,
chap4_para53,6,State 3: Dirt is on the left square.,
chap4_para53,7,The vacuum cleaner is cleaning the dirt on the left square.,
chap4_para53,8,The right square is clean.,
chap4_para53,9,State 4: Dirt is on the left square.,
chap4_para53,10,The vacuum cleaner is on the right square with no dirt.,
chap4_para53,11,State 5: Dirt is on the right square.,
chap4_para53,12,The vacuum cleaner is in the clean left square.,
chap4_para53,13,State 6: Dirt is on the right square.,
chap4_para53,14,The vacuum cleaner is on the right square.,
chap4_para53,15,The left square is clean.,
chap4_para53,16,State 7: Both the squares are clean.,
chap4_para53,17,The vacuum cleaner is on the left square.,
chap4_para53,18,State 8: Both the squares are clean.,
chap4_para53,19,The vacuum cleaner is on the right square.,
chap4_para530,1,,"Alldiff (A1, A2, A3, B1, B2, B3, C1, C2, C3)"
chap4_para531,1,,"Alldiff (A4, A5, A6, B4, B5, B6, C4, C5, C6)"
chap4_para533,1,,让我们看看弧一致性能带我们走多远。
chap4_para533,2,,假设Alldiff约束已被扩展为二元约束（例如A1 A2），这样我们就可以直接应用AC-3算法。
chap4_para533,3,,考虑图6-4a中的变量E6——正中间方框中2、8之间的空格。
chap4_para533,4,,按照方框的约束，我们可以从E6的域中删除1、2、7和8。
chap4_para533,5,,按照它所在列的约束，我们可以删除5、6、2、8、9和3（尽管2和8已经被删除）。
chap4_para533,6,,此时E6的域是{4}；换句话说，我们知道了E6的解。
chap4_para533,7,,现在考虑变量I6——最后一行中间方框中被1、3、3包围的空格。
chap4_para533,8,,在它所在列应用弧一致性，可以删除5、6、2、4（因为我们现在知道E6一定是4）、8、9和3。
chap4_para533,9,,我们利用它和I5的弧一致性删除1，此时I6的域中只剩下7。
chap4_para533,10,,现在第6列中有8个已知值，所以根据弧一致性可以推出A6一定是1。
chap4_para533,11,,沿着这样的思路继续推断，最终AC-3可以求解整个问题——所有变量的域都缩减为单个值，如图6-4b所示。
chap4_para534,1,,当然，如果每个数独问题都可以通过机械地应用AC-3求解，那么它很快就会失去吸引力，实际上AC-3只适用于最简单的数独问题。
chap4_para534,2,,稍微困难一点的问题可以用PC-2求解，但需要花费更大的计算代价：在一个数独问题中，需要考虑255 960个不同的路径约束。
chap4_para534,3,,为了求解最困难的数独问题并取得高效进展，我们必须更聪明一些。
chap4_para535,1,,事实上，数独对人类解谜者的吸引力在于，他们需要足智多谋地应用更复杂的推理策略。
chap4_para535,2,,数独爱好者给这些策略取了各种有趣的名字，如“三链数删减法”。
chap4_para535,3,,它的工作原理如下：在任一单元（行、列或方框）中，找到3个方格，它们的域包含相同的3个数字或这3个数字的子集。
chap4_para535,4,,例如，这3个域可能是、和。
chap4_para535,5,,我们并不知道哪个方格是1、3或8，但我们知道这3个数字一定分布在这3个方格中。
chap4_para535,6,,因此，我们可以将1、3和8从该单元中所有其他方格的域中删除。
chap4_para536,1,,有趣的是，这些方法并不只是专用于数独。
chap4_para536,2,,对于数独，我们确实必须说它有81个变量，域是数字1～9，有27个Alldiff约束。
chap4_para536,3,,但除此之外，所有策略（弧一致性、路径一致性等）普遍适用于所有CSP，而不仅仅是数独问题。
chap4_para536,4,,即使是三链数删减法，也是一种加强Alldiff约束一致性的策略，而不是特定于数独本身。
chap4_para536,5,,这就是CSP形式体系的作用：对于每个新问题域，我们只需按照约束定义问题，然后就可以使用一般的约束求解机制。
chap4_para537,1,,6.3　CSP的回溯搜索
chap4_para538,1,,有时我们完成约束传播过程后仍存在具有多个可能值的变量。
chap4_para538,2,,在这种情况下，我们必须通过搜索来求解问题。
chap4_para538,3,,本节中我们将介绍用于部分赋值的回溯搜索算法，6.4节中我们将介绍用于完整赋值的局部搜索算法。
chap4_para539,1,,考虑标准的深度受限搜索（第3章）是如何求解CSP的。
chap4_para539,2,,状态可能是一个部分赋值，而动作将对该赋值进行扩展，例如，在澳大利亚地图着色问题中，添加赋值NSW = red或SA = blue。
chap4_para539,3,,对于具有n个变量，域大小为d的CSP，我们最终将得到一个搜索树，所有的完整赋值（因此所有的解）都是深度为n的叶节点。
chap4_para539,4,,但要注意，第一层的分支因子为nd，因为n个变量中的任意变量都可以取d个值中的任意值。
chap4_para539,5,,下一层的分支因子是(n −1)d，以此类推n层。
chap4_para539,6,,所以树总共有n! · dn个叶节点，即使可能的完整赋值只有dn种！
chap4_para54,1,Figure 4.,"进化论是由查尔斯·达尔文（Charles Darwin）（Darwin, 1859）和艾尔弗雷德·拉塞尔·华莱士（Alfred Russel Wallace）（Wallace, 1858）各自独立提出的。"
chap4_para54,2,7The 8-queens states corresponding to the first two parents in Figure 4.,它的中心思想很简单：变异发生在繁殖过程中，并将在后代中以一定比例保存下来，大概与它们对生殖适应度的影响成比例。
chap4_para54,3,6(c) and the first offspring in Figure 4.,
chap4_para54,4,6(d).,
chap4_para54,5,The green columns are lost in the crossover step and the red columns are retained.,
chap4_para54,6,(To interpret the numbers in Figure 4.,
chap4_para54,7,"6: row 1 is the bottom row, and 8 is the top row.",
chap4_para54,8,),
chap4_para540,1,,如果意识到CSP具有的一个关键性质：可交换性（commutativity），我们就可以消去因子n!。
chap4_para540,2,,如果任意给定的动作集合的应用顺序对结果没有影响，则称该问题是可交换的。
chap4_para540,3,,在CSP中，不管我们先赋值NSW = red，再赋值SA = blue，还是交换顺序，都没有区别。
chap4_para540,4,,因此，我们只需考虑搜索树中每个节点上的单个变量。
chap4_para540,5,,在根节点上，我们可能需要在SA = red、SA = green和SA = blue之间做出选择，但我们永远不需要在NSW = red和SA = blue之间做出选择。
chap4_para540,6,,在这一限制下，叶节点的数量减少到dn，这正是我们所希望的。
chap4_para540,7,,在树的每一层中，我们都必须选择要处理哪个变量，但我们永远不需要回溯这一选择。
chap4_para541,1,,图6-5为CSP的回溯搜索过程。
chap4_para541,2,,它不断选择未赋值变量，然后依次尝试该变量的域中的所有值，试图通过递归调用将每个值扩展为一个解。
chap4_para541,3,,如果调用成功，则返回解，如果调用失败，则将赋值恢复到前一状态，然后尝试下一个值。
chap4_para541,4,,如果所有值都不成功，则返回失败。
chap4_para541,5,,澳大利亚地图着色问题的部分搜索树如图6-6所示，其中我们按照WA、 NT、Q……的顺序为变量赋值。
chap4_para542,1,,图6-5　约束满足问题的简单回溯算法。
chap4_para542,2,,该算法以第3章的递归深度优先搜索为模型。
chap4_para542,3,,函数Select-Unassigned- Variable和Order-Domain-Values实现了6.3.1节中讨论的通用启发式算法。
chap4_para542,4,,函数Inference可以根据需要选择性地使用弧一致性、路径一致性或k一致性检测。
chap4_para542,5,,如果一个赋值导致了失败（无论是在Inference还是在Backtrack中），那么该赋值（包括从Inference得到的值）将被撤销，然后重新尝试一个新的赋值
chap4_para543,1,,图6-6　图6-1中地图着色问题的部分搜索树
chap4_para544,1,,注意，Backtracking-Search只维护状态（赋值）的单个表示，然后对它进行修改，而不是创建一个新的表示（见3.4.3节）。
chap4_para545,1,,第3章的无信息搜索算法只能通过提供领域特定的启发式算法来改进，然而，事实证明，回溯搜索可以使用领域无关的启发式算法进行改进，这些算法利用了CSP的因子化表示。
chap4_para545,2,,在接下来的4节中，我们将介绍如何做到这一点。
chap4_para546,1,,● （6.3.1节）下一步应该给哪个变量赋值（Select-Unassigned-Variable），以及应该以什么顺序尝试它的值（Order-Domain-Values）？
chap4_para547,1,,● （6.3.2节）在每步搜索中应该执行怎样的推断（Inference）？
chap4_para548,1,,● （6.3.3节）我们能在适当的时候回溯（Backtrack）不止一步吗？
chap4_para549,1,,● （6.3.4节）我们可以保存和复用搜索的部分结果吗？
chap4_para55,1,"Finally, in (e), each location in each string is subject to random mutation with a small independent probability.",达尔文在《物种起源》（On the Origin of Species by Means of Natural Selection）中的理论没有解释生物体的特征是如何遗传和改变的。
chap4_para55,2,"One digit was mutated in the first, third, and fourth offspring.","控制这些过程的概率定律由修道士格雷戈尔·孟德尔（Gregor Mendel）（Mendel, 1866）首先发现，他使用豌豆进行了实验。"
chap4_para55,3,"In the 8-queens problem, this corresponds to choosing a queen at random and moving it to a random square in its column.","很久之后，沃森和克里克（Watson and Crick, 1953）确定了DNA分子的结构及其AGTC（腺嘌呤、鸟嘌呤、胸腺嘧啶、胞嘧啶）序列。"
chap4_para55,4,"It is often the case that the population is diverse early on in the process, so crossover frequently takes large steps in the state space early in the search process (as in simulated annealing).",在标准模型中，基因序列上某点发生突变和“杂交”（后代的DNA通过合成父母双方的DNA长片段产生）都会导致变异。
chap4_para55,5,"After many generations of selection towards higher fitness, the population becomes less diverse, and smaller steps are typical.",
chap4_para55,6,Figure 4.,
chap4_para55,7,8 describes an algorithm that implements all these steps.,
chap4_para550,1,,6.3.1　变量排序和值排序
chap4_para551,1,,回溯算法中包含这样一行：
chap4_para552,1,,Select-Unassigned-Variable的最简单的策略是使用静态排序：按列表顺序选择变量。
chap4_para552,2,,第二简单的策略是随机选择。
chap4_para552,3,,这两种策略都不是最优的。
chap4_para552,4,,例如，图6-6中，进行WA = red和NT = green赋值后，SA只有一个可能的值，因此接下来应该对SA赋值SA = blue而不是对Q赋值：事实上，对SA赋值后，Q、NSW和V的取值都是确定的。
chap4_para553,1,,这种直观的想法——选择“合法”值最少的变量——称为最少剩余值（minimum-remaining-value，MRV）启发式算法，也被称为“最受约束变量”或“失败优先”启发式算法，后一个名字是因为它选择了最有可能马上导致失败的变量，从而可以对搜索树剪枝。
chap4_para553,2,,如果某一变量X没有剩余合法值，那么MRV启发式算法将优先选择X然后马上检测到失败——避免遍历其他变量进行无意义地搜索。
chap4_para553,3,,MRV启发式算法通常比随机或静态排序表现得更好，有时会带来数量级上的效率差异，尽管结果可能因问题而异。
chap4_para554,1,,在选择澳大利亚地图的第一个着色区域时，MRV启发式算法完全不起作用，因为初始时每个区域都有3种合法颜色。
chap4_para554,2,,在这种情况下，度启发式（degree heuristic）算法就派上用场了。
chap4_para554,3,,它通过选择与其他未赋值变量的约束最多的变量来降低未来选择的分支因子。
chap4_para554,4,,在图6-1中，SA的度最大，为5；除了变量T的度为0，其他变量的度为2或3。
chap4_para554,5,,如果先赋值SA，我们就可以按顺时针或逆时针顺序访问5个陆地区域，并为每个区域赋予不同于SA和前一个区域的颜色。
chap4_para554,6,,最少剩余值启发式算法通常效果更好，但度启发式算法可以打破僵局。
chap4_para555,1,,一旦选择了一个变量，算法必须决定按什么顺序检验它的值。
chap4_para555,2,,最少约束值（least-constraining-value）启发式算法对此非常有效。
chap4_para555,3,,它优先选择那些为约束图中相邻变量留下最多选择的值。
chap4_para555,4,,例如，假设在图6-1中，我们已经生成了部分赋值WA = red和NT = green，并且下一步是为Q选择赋值。
chap4_para555,5,,此时蓝色是一个糟糕的选择，因为它消除了Q的邻居SA的最后一个可选的合法值。
chap4_para555,6,,因此，最少约束值启发式算法会优先选择红色而不是蓝色。
chap4_para555,7,,一般来说，启发式算法试图为后续变量赋值留下最大的灵活性。
chap4_para556,1,,为什么变量选择是失败优先，而值选择是失败延后呢？
chap4_para556,2,,每个变量最终都必须被赋值，因此通过选择那些有可能最先失败的变量，在统计意义上，需要通过回溯才能找到的成功赋值就会更少。
chap4_para556,3,,对于值排序，关键在于我们只需要找到一个解；因此，先寻找最有可能的值是有意义的。
chap4_para556,4,,如果我们的目标是枚举所有的解而不只是找到一个解，那么值排序就无关紧要了。
chap4_para557,1,,6.3.2　交替进行搜索和推理
chap4_para558,1,,我们已经讨论了AC-3算法如何在搜索前缩减变量的域。
chap4_para558,2,,但在搜索过程中，推断的作用可能更大：每次我们为某个变量选择某个值时，都有一个全新的机会推断其相邻变量的新的域缩减。
chap4_para559,1,,推断的最简单形式之一是前向检验（forward checking）。
chap4_para559,2,,当变量X被赋值时，前向检验过程为其建立弧一致性：对于每个通过约束与X连接的未赋值变量Y，从它的域中删除与X的取值不一致的值。
chap4_para56,1,Description A bold arrow labeled suck and an arrow labeled Right from the first state of the vacuum world point to the first two circular nodes.,进化和局部搜索算法的相似性前文已经介绍过了；随机束搜索和进化的主要区别在于是否为有性生殖，有性生殖中后代是由多个而非单个个体产生的。
chap4_para56,2,Two bold arrows from the first circular node with an arc point to states 7 and 5 of the vacuum world.,然而，进化的实际机制比大多数遗传算法要丰富得多。
chap4_para56,3,State 7 is labeled Goal.,例如，突变包括DNA的逆转、复制和大段移动；有些病毒会从一个生物体中借用DNA再将其自身插入另一个生物体；还有一些转座基因只是在基因组中把自己复制成千上万次。
chap4_para56,4,An arrow from the second circular node on the right points to state 2 of the vacuum world.,
chap4_para56,5,"A bold arrow labeled Right, and a light arrow labeled suck points to the third and the fourth circular nodes.",
chap4_para56,6,Arrows labeled left and suck from state 2 points to the fifth and the sixth nodes.,
chap4_para56,7,Arrows from the third node with an arc point to states 5 and 1 labeled Loop.,
chap4_para56,8,A bold arrow from the fourth node points to state 6 of the vacuum world.,
chap4_para56,9,An arrow from the fifth node points to state 1 of vacuum world labeled Loop.,
chap4_para56,10,Two arrows from the sixth node with an arc point to states 8 and 4 of the vacuum world.,
chap4_para56,11,State 8 is labeled Goal.,
chap4_para56,12,Two bold arrows from state 4 points outward.,
chap4_para56,13,"A bold arrow labeled Suck, and a light arrow labeled Left from state 6 points to the seventh and eighth nodes.",
chap4_para56,14,A bold arrow from the seventh node points to state 8 labeled goal state.,
chap4_para56,15,A light arrow from the eighth node points to state 5 labeled Loop.,
chap4_para560,1,,图6-7为在澳大利亚地图CSP上使用前向检验进行回溯搜索的过程。
chap4_para560,2,,关于这一示例，有两点需要注意。
chap4_para560,3,,首先，需要注意，在赋值WA = red和Q = green后，NT和SA的域缩减为单个值；通过从WA和Q传播信息，我们可以完全消除这些变量上的分支。
chap4_para560,4,,其次，需要注意，赋值V= blue后，SA的域为空集。
chap4_para560,5,,因此，前向检验检测到部分赋值与问题的约束不一致，算法立即回溯。
chap4_para561,1,,图6-7　带前向检验的地图着色搜索过程。
chap4_para561,2,,首先赋值WA = red；然后前向检验从其相邻变量NT和SA的域中删除red。
chap4_para561,3,,赋值Q = green后，从NT、SA和NSW的域中删除green。
chap4_para561,4,,赋值V = blue后，从NSW和SA的域中删除blue，此时SA没有合法值
chap4_para562,1,,对许多问题来说，将MRV启发式算法与前向检验相结合，可以使搜索更有效。
chap4_para562,2,,考虑图6-7中的赋值。
chap4_para562,3,,直观上，这一赋值似乎对它的相邻变量NT和SA有所约束，所以接下来应该先处理这些变量，然后是所有其他变量。
chap4_para562,4,,MRV正是这么做的：NT和SA各有两个值，所以先选择其中一个，接着是另一个，然后依次是Q、NSW和V。
chap4_para562,5,,最后T仍然有3个可能的值，任意一个都是有效的。
chap4_para562,6,,我们可以将前向检验看作一种以增量方式计算MRV启发式算法完成其工作所需信息的有效途径。
chap4_para563,1,,尽管前向检验能够检测出许多不一致，但它无法检测到所有的不一致。
chap4_para563,2,,问题在于，它向前看得不够远。
chap4_para563,3,,例如，考虑图6-7中的Q = green一行。
chap4_para563,4,,我们已经使WA和Q弧一致，但此时NT和SA的唯一可能的值都是蓝色，这违反了一致性，因为它们是相邻变量，相邻变量不能取相同的值。
chap4_para564,1,,维护弧一致性（maintaining arc consistency，MAC）算法能检测出这类不一致性。
chap4_para564,2,,"当变量Xi被赋值后，Inference程序调用AC-3，但我们开始时只考虑所有与Xi相邻的未赋值变量Xj的弧(Xj, Xi)，而不是CSP中的所有弧。"
chap4_para564,3,,从这出发，AC-3以通常的方式进行约束传播，如果任何变量的域缩减为空集，则AC-3调用失败，并立即回溯。
chap4_para564,4,,我们可以看到，MAC严格来说比前向检验更强大，因为前向检验所做的事情与MAC对其队列的初始弧所做的相同；但与MAC不同的是，当变量的域发生变化时，前向检验不会递归地传播约束。
chap4_para565,1,,6.3.3　智能回溯：向后看
chap4_para566,1,,当搜索的一个分支失败时，图6-5中的Backtracking-Search算法将采取一种非常简单的策略：退回到上一个变量，并为其尝试一个不同的值。
chap4_para566,2,,这称为时序回溯（chronological backtracking），因为时间上最近的决策点会被重新访问。
chap4_para566,3,,在本节中，我们考虑更好的可能策略。
chap4_para567,1,,考虑一下，当我们按照固定的变量顺序Q、NSW、V、 T、SA、WA、NT应用图6-1中的简单回溯时会发生什么。
chap4_para567,2,,假设我们已经生成了部分赋值。
chap4_para567,3,,当我们尝试下一个变量SA时，发现所有值都违反了约束。
chap4_para567,4,,我们退回到T，为塔斯马尼亚州尝试一种新颜色！
chap4_para567,5,,显然，这种做法是愚蠢的——重新给塔斯马尼亚州着色并不能解决南澳大利亚州的问题。
chap4_para568,1,,一种更智能的方法是回溯到有可能求解这一问题的变量——导致SA的某个可能值变成不可能值的变量。
chap4_para568,2,,为此，我们将记录与SA的某些值冲突的赋值集合。
chap4_para568,3,,该集合（在本例中为）称为SA的冲突集（conflict set）。
chap4_para568,4,,回跳（backjumping）方法将回溯到冲突集中最近的赋值，在本例中，回跳将越过塔斯马尼亚州，为V尝试一个新的值。
chap4_para568,5,,通过修改Backtrack算法，可以很容易地实现上述方法，即在检验合法值时，同时维护冲突集。
chap4_para568,6,,如果找不到合法值，算法应该返回失败指示和冲突集中最近的元素。
chap4_para569,1,,眼尖的读者可能已经注意到，前向检验不需要额外工作就能提供冲突集：当前向检验根据赋值X = x从Y的域中删除一个值时，它应该将X = x添加到Y的冲突集中。
chap4_para569,2,,如果Y的域中的最后一个值也被删除，那么Y的冲突集中的赋值也要被添加到X的冲突集中。
chap4_para569,3,,也就是说，我们现在知道X = x导致了（Y中的）矛盾，因此应该为X尝试不同赋值。
chap4_para57,1,Figure 4.,甚至还有一些基因会破坏不携带该基因的可能配对对象的细胞，从而增加它们自身的复制机会。
chap4_para57,2,8A genetic algorithm.,最重要的是，基因自身对基因组复制和翻译成生物体的机制进行编码。
chap4_para57,3,"Within the function, population is an ordered list of individuals, weights is a list of corresponding fitness values for each individual, and fitness is a function to compute these values.",在遗传算法中，这些机制是单独的程序，不体现在被操作的字符串中。
chap4_para570,1,,有眼力的读者可能已经注意到一些奇怪的事情：当域中的每个值都与当前赋值冲突时就会发生回跳，但前向检验能检测出这个事件并阻止搜索到达这样的节点！
chap4_para570,2,,事实上，可以证明，每个被回跳剪除的分支也会被前向检验剪枝。
chap4_para570,3,,因此，在前向检验搜索中，或者在使用更强一致性检验的搜索（如MAC）中，简单的回跳是多余的——你只需执行其中一项。
chap4_para571,1,,尽管存在上一段中的观测结果，回跳背后的思想仍然值得借鉴：基于失败原因进行回溯。
chap4_para571,2,,当变量的域变为空集时，回跳发现失败，但在许多情况下，在很早之前分支就注定要失败。
chap4_para571,3,,再次考虑部分赋值（从我们前面的讨论来看，它是不一致的）。
chap4_para571,4,,假设我们下一步尝试T = red，然后对NT、Q、V和SA赋值。
chap4_para571,5,,我们知道，最后这4个变量不存在有效赋值，所以最终在NT处终止。
chap4_para571,6,,现在，问题是，回溯到哪儿？
chap4_para571,7,,回跳是不可行的，因为NT确实存在与前面赋值过的变量一致的值——NT没有导致失败的前面变量的完整冲突集。
chap4_para571,8,,然而，我们知道，NT、Q、V和SA这4个变量放在一起会失败，是因为前面的一组变量一定与这4个变量有直接冲突。
chap4_para572,1,,这引出了（对于NT这样的变量的）一种不同的、更深层次的冲突集概念：正是前面一组变量共同导致了NT连同任何后续变量都不存在一致解。
chap4_para572,2,,在本例中，该集合是WA和NSW，所以算法应该跳过塔斯马尼亚州回溯到NSW。
chap4_para572,3,,使用以这种方式定义的冲突集的回跳算法称为冲突导向回跳（conflict-directed backjumping）。
chap4_para573,1,,现在我们必须解释如何计算这些新的冲突集。
chap4_para573,2,,方法其实很简单。
chap4_para573,3,,搜索分支的“终端”失败总是因为某个变量的域变为空集，该变量对应一个标准冲突集。
chap4_para573,4,,在我们的例子中，SA失败，它的冲突集是（例如）。
chap4_para573,5,,我们回溯到Q，Q将SA的冲突集（当然要减去Q本身）吸收到它自己的直接冲突集，新的冲突集是。
chap4_para573,6,,也就是说，给定前面对的赋值，从Q向前是没有解的。
chap4_para573,7,,因此，我们回溯到最近的变量NT。
chap4_para573,8,,NT将吸收到它自己的直接冲突集中，得到（如上一段所述）。
chap4_para573,9,,现在算法回跳到NSW，这正是我们所希望的。
chap4_para573,10,,总结一下：设Xj表示当前变量，conf(Xj)表示它的冲突集。
chap4_para573,11,,如果Xj的每个可能值都失败了，则回跳到conf(Xj)中最近的变量Xi，并使用下列公式重新计算Xi的冲突集：
chap4_para574,1,,6.3.4　约束学习
chap4_para575,1,,当我们遇到矛盾时，回跳可以告诉我们要退回多远，这样我们就不会浪费时间去改变那些无法求解问题的变量。
chap4_para575,2,,但我们也希望不要再遇到同样的问题。
chap4_para575,3,,当搜索得出一个矛盾时，我们知道这是冲突集的某个子集引起的。
chap4_para575,4,,约束学习（constraint learning）的思想是从冲突集中找出引起问题的最小变量集。
chap4_para575,5,,这组变量及其相应值称为无用赋值（no-good）。
chap4_para575,6,,如果想要记录无用赋值，要么通过向CSP中添加一个新的约束禁止这种赋值组合，要么通过维护一个单独的缓存。
chap4_para576,1,,例如，考虑图6-6最下面一行中的状态。
chap4_para576,2,,前向检验告诉我们这个状态是一个无用赋值，因为SA不存在有效赋值。
chap4_para576,3,,在这种特定情况下，记录该无用赋值是没有意义的，因为一旦从搜索树中剪掉了这一分支，我们再也不会遇到这种组合。
chap4_para576,4,,但假设图6-6中的搜索树实际上是更大的搜索树的一部分，该搜索树是从V和T的赋值开始的。
chap4_para576,5,,那么将记录为无用赋值是有意义的，因为对于V和T的每一组可能赋值，我们都会再次遇到同样的问题。
chap4_para577,1,,前向检验或回跳可以有效地利用无用赋值。
chap4_para577,2,,约束学习是现代CSP求解器用以提高复杂问题求解效率的最重要技术之一。
chap4_para578,1,,6.4　CSP的局部搜索
chap4_para579,1,,局部搜索算法（见4.1节）对于许多CSP的求解都非常有效。
chap4_para579,2,,它们使用完整状态形式（见4.1.1节），即每一状态为所有变量赋值，搜索一次改变一个变量的值。
chap4_para579,3,,例如，考虑6.1.3节中定义为CSP的8皇后问题。
chap4_para579,4,,在图6-8中，我们从左边开始，对8个变量进行了完整赋值，通常该赋值会违反一些约束。
chap4_para579,5,,然后我们随机选择一个发生冲突的变量，在此是最右边一列的Q8。
chap4_para579,6,,我们希望改变它的值，从而更接近问题的解。
chap4_para579,7,,最明显的方法是选择与其他变量冲突数最少的值——最少冲突（min-conflict）启发式算法。
chap4_para58,1,"Genetic algorithms are similar to stochastic beam search, but with the addition of the crossover operation. This is advantageous if there are blocks that perform useful functions. For example, it could be that putting the first three queens in positions 2, 4, and 6 (where they do not attack each other) constitutes a useful block that can be combined with other useful blocks that appear in other individuals to construct a solution. It can be shown mathematically that, if the blocks do not serve a purpose—for example if the positions of the genetic code are randomly permuted—then crossover conveys no advantage.",达尔文进化论可能看起来效率很低，它盲目地产生了大约1043个生物体，却丝毫没有改进它的搜索启发式函数。
chap4_para58,2,,但是学习在进化中确实起着作用。
chap4_para58,3,,"尽管另一位伟大的法国博物学家让·拉马克（Jean Lamarck）（Lamarck, 1809）曾错误地提出，生物体一生中通过适应而获得的特性会遗传给后代，但詹姆斯·鲍德温（James Baldwin）（Baldwin, 1896）提出的表面上相似的理论则是正确的：学习可以有效地放宽适应度要求，从而加快进化速度。"
chap4_para58,4,,如果一个生物体具有一种不太适应环境的特性，但它也具有足够的可塑性，可以学习以一种有益的方式适应环境，那么生物体会将这种特性传递下去。
chap4_para58,5,,"计算机仿真（Hinton and Nowlan, 1987）证实了鲍德温效应（Baldwin effect）是真实存在的，其结果是，难以学习的事情最终会存在于基因组中，而容易学习的事情不必进入基因组（Morgan and Griffiths, 2015）。"
chap4_para580,1,,图6-8　使用最少冲突法求解8皇后问题的示例。
chap4_para580,2,,每步选择一个皇后，在其所在列重新分配位置。
chap4_para580,3,,每个方格标有冲突数（在本例中是互相攻击的皇后个数）。
chap4_para580,4,,算法随机选择发生冲突的皇后，将皇后移动到冲突最少的方格
chap4_para581,1,,在图6-8中，我们看到有两行都只违反了一个约束，我们选择让Q8 = 3（也就是说，我们将皇后移动到第8列、第3行）。
chap4_para581,2,,下一次迭代，在图6-8的中间棋盘上，我们选择Q6作为要改变的变量，然后发现将该皇后移动到第8行不会发生冲突。
chap4_para581,3,,此时不再有发生冲突的变量，所以我们找到了一个解。
chap4_para581,4,,最少冲突算法如图6-9所示。
chap4_para581,5,,[4]
chap4_para583,1,,[4]　局部搜索可以很容易地扩展到约束优化问题（COP）。
chap4_para583,2,,在这种情况下，爬山法和模拟退火的所有技术都可以用于优化目标函数。
chap4_para584,1,,图6-9　CSP的Min-Conflicts局部搜索算法。
chap4_para584,2,,初始状态可以随机选择，也可以通过基于贪心法的赋值过程依次为每个变量选择最少冲突值。
chap4_para584,3,,在给定当前赋值的其余部分后，Conflicts函数统计特定值违反约束的数量
chap4_para585,1,,对许多CSP来说，最少冲突法都相当有效。
chap4_para585,2,,神奇的是，在n皇后问题上，如果不计入皇后的初始布局，最少冲突法的运行时间基本上与问题规模无关。
chap4_para585,3,,它甚至可以在（初始赋值后）平均50步内求解百万皇后问题。
chap4_para585,4,,这一不同寻常的现象是20世纪90年代大量研究局部搜索和难易问题间区别的动力，我们将在7.6.3节中讨论这些问题。
chap4_para585,5,,粗略地说，用局部搜索求解n皇后问题非常简单，因为解密集地分布在整个状态空间上。
chap4_para585,6,,最少冲突法也适用于困难问题。
chap4_para585,7,,例如，它已经被用于哈勃太空望远镜的观测调度，安排一周的观测调度所花费的时间可以从3周减少到大约10分钟。
chap4_para586,1,,4.1节中的所有局部搜索技术都可以应用于CSP，有些技术已被证实相当有效。
chap4_para586,2,,最少冲突启发式算法下的CSP地形图通常存在一系列平台区。
chap4_para586,3,,可能有数百万个变量赋值都只存在一个冲突。
chap4_para586,4,,平台区搜索——允许横向移动到另一个得分相同的状态——可以帮助局部搜索走出平台区。
chap4_para586,5,,这种在平台区的漫游可以由一种叫作禁忌搜索的技术导引：维护一个最近访问过的状态的列表，并禁止算法返回那些状态。
chap4_para586,6,,模拟退火也可以用于逃离平台区。
chap4_para587,1,,另一种技术称为约束加权（constraint weighting），旨在集中搜索重要约束。
chap4_para587,2,,每个约束都有一个数值权重，初始时都为1。
chap4_para587,3,,在每步搜索中，算法找出使其所违反的约束的总权重最低的变量，并修改其值。
chap4_para587,4,,然后，增加当前赋值所违反的每个约束的权重。
chap4_para587,5,,这种做法有两个好处：它为平台区增加了地形因素，确保从当前状态进行改进是有可能的；它还引入了学习策略，随着时间推移，难以求解的约束会被分配更高的权重。
chap4_para588,1,,局部搜索的另一个优点是，当问题发生变化时，它可以用于在线设定的问题（见4.5节）。
chap4_para588,2,,考虑一个航空公司每周航班调度问题。
chap4_para588,3,,它可能涉及上千趟航班和上万名人员的分配，但机场的恶劣天气可能会打乱这一调度。
chap4_para588,4,,我们希望以最少的改动修正日程表。
chap4_para588,5,,这可以通过从当前调度开始的局部搜索算法轻松完成。
chap4_para588,6,,使用新约束集的回溯搜索通常要花费更多时间，而且找到的解可能要对当前调度进行很多改动。
chap4_para59,1,"The theory of genetic algorithms explains how this works using the idea of a schema, which is a substring in which some of the positions can be left unspecified.",显然，如果相邻位之间完全不相关，效果就没那么显著，因为几乎不存在功能一致的连续区域。
chap4_para59,2,"For example, the schema 246***** describes all 8-queens states in which the first three queens are in positions 2, 4, and 6, respectively.",当模式对应于解中有意义的组件时，遗传算法效果最优。
chap4_para59,3,Strings that match the schema (such as 24613578) are called instances of the schema.,例如，如果字符串表示天线，那么模式则表示天线的各组成部分，如反射器和导向器。
chap4_para59,4,"It can be shown that if the average fitness of the instances of a schema is above the mean, then the number of instances of the schema will grow over time.",一个好的组件可能在各种不同的设计中都是好的。
chap4_para59,5,,这表明，遗传算法的成功依赖于精细的表示工程。
chap4_para590,1,,在这一节中，我们将研究如何利用由约束图表示的问题的结构来快速找到解。
chap4_para590,2,,这里的大多数方法也适用于CSP之外的其他问题，例如概率推理。
chap4_para591,1,,处理复杂的真实世界问题的唯一可能方法是将其分解为若干子问题。
chap4_para591,2,,回顾澳大利亚问题的约束图（图6-1b和图6-12a），可以发现一个问题：塔斯马尼亚州和大陆不相连。
chap4_para591,3,,[5]直观上看，对塔斯马尼亚州着色和对大陆着色显然是两个独立子问题（independent subproblem）——任何对大陆着色的解和任何对塔斯马尼亚州着色的解相结合都能得到整个地图的解。
chap4_para593,1,,[5]　细心的制图师或热爱塔斯马尼亚州的塔斯马尼亚人可能会反对将塔斯马尼亚州和离它最近的大陆邻域涂上相同的颜色，以免给人留下它可能是那个州的一部分的印象。
chap4_para594,1,,可以简单地通过寻找约束图的连通分量（connected component）来确定独立性。
chap4_para594,2,,每个连通分量对应一个子问题CSPi。
chap4_para594,3,,如果赋值Si是CSPi的解，那么就是的解。
chap4_para594,4,,为什么这很重要？
chap4_para594,5,,假设每个CSPi具有所有n个变量中的c个变量，其中c是一个常数。
chap4_para594,6,,那么共有n/c个子问题，求解每个子问题最多需要d c工作量，其中d是域的大小。
chap4_para594,7,,因此，总的工作量为O(dcn/c)，关于n是线性的；如果不进行问题分解，总的工作量为O(d n)，关于n是指数级的。
chap4_para594,8,,让我们更具体地说：将一个具有100个变量的布尔CSP分解为4个子问题，那么最坏情况下的求解时间将从宇宙生命周期减少到不到1秒。
chap4_para595,1,,完全独立的子问题很好，但很少见。
chap4_para595,2,,幸运的是，其他一些图结构也很容易求解。
chap4_para595,3,,例如，当任意两个变量都只由一条路径连接时，约束图是一棵树。
chap4_para595,4,,我们将证明任何树状结构的CSP都可以在变量个数的线性时间内求解。
chap4_para595,5,,[6]这里的关键是一种新的一致性概念——定向弧一致性（directional arc consistency）或DAC。
chap4_para595,6,,"变量顺序为X1, X2, …, Xn的CSP称为定向弧一致的，当且仅当，时，每个Xi相对于每个Xj都是弧一致的。"
chap4_para597,1,,[6]　遗憾的是，除了苏拉威西岛（Sulawesi）的地图比较接近树状外，世界上几乎没有一个地区是树状结构的地图。
chap4_para598,1,,为了求解树状结构的CSP，首先选择任一变量作为树的根节点，然后选择变量顺序，每个变量必须在其父节点之后。
chap4_para598,2,,这种排序称为拓扑排序（topological sort）。
chap4_para598,3,,图6-10a为一棵树，图6-10b为一种可能的排序。
chap4_para598,4,,任何有n个节点的树都有n−1条边，所以可以在O(n)步内使得该图具有定向弧一致性，每一步都必须比较两个变量的最多d个可能的值，总时间为O(nd2)。
chap4_para598,5,,一旦我们有了一个定向弧一致的图，就可以沿着变量列表选择任意剩余值。
chap4_para598,6,,因为从父节点到其子节点的每条边都是弧一致的，所以，对于父节点选择的任何值，子节点都存在一个可选的有效值。
chap4_para598,7,,这意味着我们不必回溯，可以沿着变量线性移动。
chap4_para598,8,,完整算法如图6-11所示。
chap4_para599,1,,图6-10　（a）树状结构CSP的约束图。
chap4_para599,2,,（b）与以A为根节点的树一致的变量的线性排序。
chap4_para599,3,,这称为变量的拓扑排序
chap4_para6,1,"Local search algorithms operate by searching from a start state to neighboring states, without keeping track of the paths, nor the set of states that have been reached. That means they are not systematic—they might never explore a portion of the search space where a solution actually resides. However, they have two key advantages: (1) they use very little memory; and (2) they can often find reasonable solutions in large or infinite state spaces for which systematic algorithms are unsuitable.",局部搜索算法也可以求解最优化问题（optimization problem），其目标是根据目标函数（objective function）找到最优状态。
chap4_para60,1,Evolution and Search,"实际上，遗传算法在广泛的最优化方法中占有一席之地（Marler and Arora, 2004），尤其是复杂结构问题，如电路布图或作业车间调度，以及最近的深度神经网络架构演变（Miikkulainen et al., 2019）。"
chap4_para60,2,,目前还不清楚遗传算法的吸引力是来自于它在特定任务上的性能优势，还是来自于进化本身。
chap4_para600,1,,既然我们有了关于树的高效算法，可以考虑更一般的约束图是否可以以某种方式简化为树结构。
chap4_para600,2,,有两种方法可以做到这一点：删除节点（6.5.1节）或合并节点（6.5.2节）。
chap4_para601,1,,图6-11　用于求解树状结构CSP的Tree-CSP-Solver算法。
chap4_para601,2,,如果CSP有解，我们可以在线性时间内找到它；如果无解，将检测到矛盾
chap4_para602,1,,6.5.1　割集调整
chap4_para603,1,,将约束图简化为树的第一种方法是为部分变量赋值使得剩余变量能够形成一棵树。
chap4_para603,2,,考虑澳大利亚问题的约束图，如图6-12a所示。
chap4_para603,3,,如果没有南澳大利亚州，这个图就会变成如图6-12b所示的一棵树。
chap4_para603,4,,幸运的是，我们可以通过将SA固定为某个值并从其他变量的域中删除任何与SA取值不一致的值来从图中删除南澳大利亚州。
chap4_para604,1,,图6-12　（a）图6-1中的原始约束图。
chap4_para604,2,,（b）除去SA后，约束图变成由两棵树组成的森林
chap4_para605,1,,现在，删除SA及其约束后，CSP的任意一个解都与SA的值一致。
chap4_para605,2,,（这适用于二元CSP，在高阶约束下，情况会更加复杂。
chap4_para605,3,,）因此，我们可以用上面给出的算法求解剩余的树，从而求解整个问题。
chap4_para605,4,,当然，在一般情况下（与地图着色不同），为SA选择的值可能是错误的，因此我们需要尝试每个可能的值。
chap4_para605,5,,一般算法如下。
chap4_para606,1,,（1）选择CSP变量的一个子集S，使得约束图在删除S后成为一棵树。
chap4_para606,2,,S称为环割集（cycle cutset）。
chap4_para607,1,,（2）对于满足S上所有约束的S中变量的每种可能赋值，
chap4_para608,1,,a. 从剩余变量的域中删除任何与S赋值不一致的值，并且
chap4_para609,1,,b. 如果剩余的CSP存在一个解，那么将其连同S的赋值一起返回。
chap4_para61,1,The theory of evolution was developed by Charles Darwin in On the Origin of Species by Means of Natural Selection (1859) and independently by Alfred Russel Wallace (1858).,4.2　连续空间中的局部搜索
chap4_para61,2,The central idea is simple: variations occur in reproduction and will be preserved in successive generations approximately in proportion to their effect on reproductive fitness.,
chap4_para610,1,,如果环割集的大小为c，那么总运行时间为：我们需要尝试S中变量的值的所有d c种组合，对于每种组合，我们需要求解一个大小为(n −c)的树问题。
chap4_para610,2,,如果约束图“几乎是一棵树”，那么c将会非常小，相比于直接使用回溯法，将省掉巨大的开销——对100个布尔变量的示例来说，如果我们能找到一个大小为c = 20的割集，时间开销可以从宇宙生命周期缩短到几分钟。
chap4_para610,3,,然而，在最坏情况下，c可能高达(n −2)。
chap4_para610,4,,寻找最小环割集问题是NP困难的，但有一些高效的近似算法。
chap4_para610,5,,算法的总体过程称为割集调整（cutset conditioning），我们将在第13章详细讨论，在那里它将用于概率推理。
chap4_para612,1,,将约束图简化为树的第二种方法基于构建约束图的树分解（tree decomposition）：将原始图转换为树，树中的每个节点由一组变量组成，如图6-13所示。
chap4_para612,2,,树分解必须满足以下3个要求。
chap4_para613,1,,● 原始问题中的每个变量必须至少出现在一个树节点中。
chap4_para614,1,,● 如果两个变量在原始问题中由一个约束连接，那么它们必须同时出现（连同约束）在至少一个树节点中。
chap4_para615,1,,● 如果一个变量出现在两个树节点中，那么它必须出现在连接这两个节点的路径上的所有节点中。
chap4_para616,1,,前两个条件保证了所有变量和约束在树分解中都有表示。
chap4_para616,2,,第三个条件似乎更具技术性，但保证了原始问题的任何变量无论在哪出现都具有相同的值：树中的约束表明一个树节点中的变量必须与其相邻节点中的相应变量具有相同的值。
chap4_para616,3,,例如，图6-13中SA出现在相连的所有4个节点中，因此树分解中的每条边都包含一个约束，一个节点中SA的值必须与下个节点中SA的值相同。
chap4_para616,4,,你可以从图6-12中验证这种分解是有意义的。
chap4_para617,1,,图6-13　图6-12a中约束图的一个树分解
chap4_para618,1,,一旦我们有了一个树状结构图，我们可以应用Tree-CSP-Solver在O(nd 2)时间内得到解，其中n是树节点的个数，d是最大域的大小。
chap4_para618,2,,但是要注意，在树中，域是一组值元组，而不只是单个值。
chap4_para619,1,,例如，图6-13中的左上节点表示在原始问题层级上，变量为，域为，约束为、和的子问题。
chap4_para619,2,,"而在树的层级上，节点表示单个变量，我们可以将其称为SANTWA，它的值必须是一个由颜色组成的三元组，如(red, green, blue)，但不能是(red, red, blue)，因为违反了原始问题中的约束。"
chap4_para619,3,,"然后我们可以从这个节点移动到相邻节点，其变量为SANTQ，此时只有一个元组(red, green, blue)与SANTWA的选择一致。"
chap4_para619,4,,对后两个节点重复完全相同的过程，但可以独立地为T作出任何选择。
chap4_para62,1,"Darwin’s theory was developed with no knowledge of how the traits of organisms can be inherited and modified. The probabilistic laws governing these processes were first identified by Gregor Mendel (1866), a monk who experimented with sweet peas. Much later, Watson and Crick (1953) identified the structure of the DNA molecule and its alphabet, AGTC (adenine, guanine, thymine, cytosine). In the standard model, variation occurs both by point mutations in the letter sequence and by “crossover” (in which the DNA of an offspring is generated by combining long sections of DNA from each parent).",在第2章中，我们解释了离散环境和连续环境之间的区别，并指出大多数的真实世界环境都是连续的。
chap4_para62,2,,连续动作空间的分支因子是无限的，因此我们目前介绍的大多数算法（除了首选爬山法和模拟退火）都无法处理连续空间。
chap4_para620,1,,使用Tree-CSP-Solver算法可以在O(nd2)时间内求解任何树分解问题，只要d保持较小值，它都是高效的。
chap4_para620,2,,回到100个布尔变量的示例，如果每个节点有10个变量，那么d = 210，我们可以在几秒内找到解。
chap4_para620,3,,但如果有一个节点包含30个变量，则需要几个世纪的时间。
chap4_para621,1,,一个给定的图允许多种树分解，在选择分解时，目标是使子问题尽可能小。
chap4_para621,2,,（将所有变量放在同一个节点中在技术上也是一棵树，但对求解问题没有帮助。
chap4_para621,3,,）图的树分解的树宽（tree width）为最大节点的大小减1，图本身的树宽定义为其所有树分解的最小宽度。
chap4_para621,4,,如果一个图的树宽为w，那么给定相应的树分解，该问题可以在O(ndw+1)时间内求解。
chap4_para621,5,,因此，如果CSP的约束图树宽有界，则该CSP在多项式时间内是可解的。
chap4_para622,1,,遗憾的是，找出树宽最小的分解是 一个NP困难问题，但有一些启发式方法在实践中效果很好。
chap4_para622,2,,时间为的割集分解和时间为O(ndw+1)的树分解哪个更好？
chap4_para622,3,,每当有一个大小为c的环割集时，也会有一个大小为的树宽，并且在某些情况下它可能要小得多。
chap4_para622,4,,所以从时间上考虑，应该选择树分解，但环割集方法的优点是，它可以在线性内存中执行，而树分解需要关于w的指数级内存。
chap4_para624,1,,到目前为止，我们已经讨论了约束图的结构。
chap4_para624,2,,在变量的值中，或在约束关系本身的结构中，也可能存在重要的结构。
chap4_para624,3,,考虑有d种颜色的地图着色问题。
chap4_para624,4,,对于每个一致解，实际上都有一组通过排列颜色名形成的d!个解。
chap4_para624,5,,例如，在澳大利亚地图中，我们知道WA、NT和SA肯定具有不同颜色，但实际上，将3种颜色分配给3个区域有3! = 6种方法。
chap4_para624,6,,这称为值对称（value symmetry）。
chap4_para624,7,,我们希望通过打破这种赋值对称性将搜索空间缩小d!倍。
chap4_para624,8,,可以通过引入对称性破缺约束（symmetry-breaking constraint）做到这一点。
chap4_para624,9,,对于我们的例子，可以施加一个任意的排序约束，，即要求3个值按字母顺序排列。
chap4_para624,10,,这个约束保证了d!个解中只有一个是可能解：。
chap4_para625,1,,对于地图着色问题，很容易找到一个消除对称性的约束。
chap4_para625,2,,一般来说，要消除所有的对称性是NP困难的，但打破值对称已被证明在许多问题上都是重要和有效的。
chap4_para627,1,,● 约束满足问题（CSP）的状态为一组变量/值对，解的条件为一组变量约束。
chap4_para627,2,,许多重要的真实问题都可以用CSP描述。
chap4_para628,1,,● 许多推断技术利用约束排除某些变量赋值。
chap4_para628,2,,这些约束包括节点一致性、弧一致性、路径一致性和k一致性。
chap4_para629,1,,● 回溯搜索是深度优先搜索的一种形式，通常用于求解CSP。
chap4_para629,2,,推断可以与搜索交替进行。
chap4_para63,1,"The analogy to local search algorithms has already been described; the principal difference between stochastic beam search and evolution is the use of sexual reproduction, wherein successors are generated from multiple individuals rather than just one.",本节将非常简要地介绍一些连续空间的局部搜索技术。
chap4_para63,2,"The actual mechanisms of evolution are, however, far richer than most genetic algorithms allow.",关于这个主题的文献有很多。
chap4_para63,3,"For example, mutations can involve reversals, duplications, and movement of large chunks of DNA; some viruses borrow DNA from one organism and insert it into another; and there are transposable genes that do nothing but copy themselves many thousands of times within the genome.",许多基本技术起源于牛顿和莱布尼茨发明微积分之后的17世纪。
chap4_para63,4,,[2]本书的一些章节会介绍这些技术的应用，包括学习、视觉和机器人技术相关的章节。
chap4_para630,1,,● 最少剩余值启发式算法和度启发式算法是领域无关的方法，用于决定在回溯搜索中下一步选择哪个变量。
chap4_para630,2,,最少约束值启发式算法有助于决定对于给定变量首先尝试哪个值。
chap4_para630,3,,回溯发生在某个变量找不到合法赋值时。
chap4_para630,4,,冲突导向回跳直接回溯到问题的根源。
chap4_para630,5,,约束学习记录在搜索过程中遇到的冲突，以免在以后的搜索中出现相同的冲突。
chap4_para631,1,,● 使用最少冲突启发式算法的局部搜索也已成功地应用于约束满足问题。
chap4_para632,1,,● CSP求解的复杂性与其约束图的结构密切相关。
chap4_para632,2,,树状结构问题可以在线性时间内求解。
chap4_para632,3,,割集调整可以将一般的CSP简化为树状结构的CSP，如果能找到一个较小的割集，算法会非常高效（只需线性内存）。
chap4_para632,4,,树分解技术将CSP转化为由子问题构成的树，当约束图的树宽较小时，算法是高效的；然而，它们需要约束图树宽的指数级的内存。
chap4_para632,5,,将割集调整和树分解相结合可以更好地权衡所需内存和时间。
chap4_para635,1,,第三部分　知识、推理和规划
chap4_para637,1,,在本章中，我们设计能够表示复杂世界的智能体，它使用推断过程来获取关于这个世界的新表示，并使用这种表示来推导下一步该怎么做。
chap4_para638,1,,人类似乎具有知识，人类的知识能够帮助他们做事。
chap4_para638,2,,在人工智能中，基于知识的智能体（knowledge-based agent）对知识的内部表示（representation）进行推理（reasoning）来确定要采取的动作。
chap4_para639,1,,第3章和第4章的问题求解智能体具有知识，但这种知识是非常有限且死板的。
chap4_para639,2,,它们知道可以采取哪些动作，也知道在某个状态采取某个动作将得到哪种结果，但它们不知道一般事实。
chap4_para639,3,,例如，寻路智能体不知道一条路的长度不可能是负数公里，而8数码智能体也不知道两块瓷砖无法放置在同一个空格当中。
chap4_para639,4,,问题求解智能体具有的知识对寻找从起点到终点的路径这种问题非常有用，但也仅限于此。
chap4_para64,1,"There are even genes that poison cells from potential mates that do not carry the gene, thereby increasing their own chances of replication.",
chap4_para64,2,Most important is the fact that the genes themselves encode the mechanisms whereby the genome is reproduced and translated into an organism.,
chap4_para64,3,"In genetic algorithms, those mechanisms are a separate program that is not represented within the strings being manipulated.",
chap4_para640,1,,问题求解智能体所使用的原子表示也有很大的局限性。
chap4_para640,2,,例如，在部分可观测的环境中，问题求解智能体表示它对当前状态的了解的唯一选项是列出所有可能的具体状态。
chap4_para640,3,,我可以让一个人驱车前往一个人口不超过1万的美国小镇，但如果要让问题求解智能体来做这件事，我只能明确地将目标描述为大约1.6万个符合条件的小镇的集合。
chap4_para641,1,,第6章引入了我们的第一个因子化表示，其中状态被表示为对变量的赋值。
chap4_para641,2,,这是朝正确方向前进的一步，它能使智能体的某些部分以与领域无关的方式运作，并支持更高效的算法。
chap4_para641,3,,在本章中，我们将这一步延伸到它的逻辑结论，可以说，我们将逻辑扩展为一类通用的表示，以支持基于知识的智能体。
chap4_para641,4,,这些智能体可以组合或重组信息以适应各种用途。
chap4_para641,5,,它可以与我们当下的需要毫不相关，就像数学家证明定理或天文学家计算地球的预期寿命一样。
chap4_para641,6,,基于知识的智能体能够接受明确描述的目标作为任务，能够通过主动学习或被告知关于环境的新知识快速地获得完成任务的能力，也能够通过更新相关知识适应环境的变化。
chap4_para642,1,,我们在7.1节开始介绍智能体的总体设计。
chap4_para642,2,,7.2节新引入了一个名为wumpus世界的简单环境，以便在不涉及任何技术细节的前提下，阐明基于知识的智能体的运作方式。
chap4_para642,3,,随后我们在7.3节解释逻辑的一般原理，在7.4节介绍命题逻辑的具体细节。
chap4_para642,4,,命题逻辑是一种因子化表示，尽管它的表达能力不如一阶逻辑（第8章）这种标准的结构化表示，但却能够阐明逻辑的所有基本概念。
chap4_para642,5,,命题逻辑还具有丰富的推断方法，我们将在7.5节和7.6节中描述这些内容。
chap4_para642,6,,最后，7.7节将基于知识的智能体的概念与命题逻辑的技术结合起来，为wumpus世界构建了一个简单的智能体。
chap4_para643,1,,7.1　基于知识的智能体
chap4_para644,1,,基于知识的智能体的核心部件是它的知识库（knowledge base，KB）。
chap4_para644,2,,知识库是一个语句集。
chap4_para644,3,,（此处“语句”是一个术语。
chap4_para644,4,,它与英语或其他自然语言的语句类似，但不完全相同。
chap4_para644,5,,）这些语句用知识表示语言（knowledge representation language）表达，代表了关于世界的某种断言。
chap4_para644,6,,如果一条语句是直接给出的，而不是从其他语句推导而来的，我们就称它为公理（axiom）。
chap4_para645,1,,向知识库添加新语句以及从知识库查询已知语句的方法是必不可少的。
chap4_para645,2,,这些操作的标准名称分别是Tell（告知）和Ask（询问）。
chap4_para645,3,,这两个操作都可能涉及推断（inference），也就是从原有语句中推导出新语句。
chap4_para645,4,,推断必须符合以下要求：当向知识库询问（Ask）时，答案应当遵循先前已经告知（Tell）知识库的内容而生成。
chap4_para645,5,,我们将在本章后续部分仔细讲解何为“遵循”。
chap4_para645,6,,现在，我们暂且将其理解为在推断过程中不能进行捏造。
chap4_para646,1,,图7-1展示了基于知识的智能体程序。
chap4_para646,2,,与所有的智能体一样，基于知识的智能体以一个感知作为输入，返回一个动作。
chap4_para646,3,,该智能体维护一个知识库KB，这个知识库最初可能包括一些背景知识（background knowledge）。
chap4_para647,1,,图7-1　通用的基于知识的智能体。
chap4_para647,2,,给定一个感知，智能体将这一感知添加进知识库，向知识库询问最优动作，并告知知识库它已经采取了这一动作
chap4_para648,1,,每次调用智能体程序时，程序会做3件事。
chap4_para648,2,,首先，它告知知识库它所感知到的东西。
chap4_para648,3,,然后，它询问知识库它应当采取什么动作。
chap4_para648,4,,在回答这一查询时，可能会对关于世界的当前状态、可能的动作序列的执行结果等进行大量推理。
chap4_para648,5,,最后，智能体程序告知知识库它选择的动作，并返回这一动作以便执行。
chap4_para649,1,,表示语言的细节隐藏在3个函数中，这3个函数一方面实现了传感器与执行器之间的接口，另一方面又实现了核心表示与推理系统的接口。
chap4_para649,2,,Make-Percept-Sentence构建了一个语句，断言智能体在给定时间接收到给定的感知。
chap4_para649,3,,Make-Action-Query构建了一个语句，询问当前时刻应当采取何种动作。
chap4_para649,4,,最后，Make-Action-Sentence构建了一个语句，断言选定的动作已经执行。
chap4_para649,5,,推断机制的细节隐藏在Tell与Ask中。
chap4_para649,6,,后续章节将阐明这些细节。
chap4_para65,1,"Darwinian evolution may appear inefficient, having generated blindly some 1043 or so organisms without improving its search heuristics one iota. But learning does play a role in evolution. Although the otherwise great French naturalist Jean Lamarck (1809) was wrong to propose that traits acquired by adaptation during an organism’s lifetime would be passed on to its offspring, James Baldwin’s (1896) superficially similar theory is correct: learning can effectively relax the fitness landscape, leading to an acceleration in the rate of evolution. An organism that has a trait that is not quite adaptive for its environment will pass on the trait if it also has enough plasticity to learn to adapt to the environment in a way that is beneficial. Computer simulations (Hinton and Nowlan, 1987) confirm that this Baldwin effect is real, and that a consequence is that things that are hard to learn end up in the genome, but things that are easy to learn need not reside there (Morgan and Griffiths, 2015).",[2]　向量、矩阵和导数的知识对于学习本节内容很有帮助（见附录A）。
chap4_para650,1,,图7-1所示的基于知识的智能体看起来与第2章所述的具有内部状态的智能体非常相似。
chap4_para650,2,,而由于Tell和Ask的定义，基于知识的智能体并不仅是普通的用来计算动作的程序。
chap4_para650,3,,它受到位于知识层面（knowledge level）的描述的操控，我们只需要在知识层面明确智能体所具有的知识和它的目标，就可以决定它的行为。
chap4_para651,1,,例如，一辆自动驾驶出租车的任务是将一名乘客从旧金山送往马林县，它或许知道金门大桥是两地间的唯一通路。
chap4_para651,2,,因此，我们可以猜测出租车将驶过金门大桥，因为它知道这样能达成目标。
chap4_para651,3,,注意，这一分析与出租车在实现层面（implementation level）的工作原理毫无关系。
chap4_para651,4,,不论它是用链表或点阵图来实现地理知识，还是通过操纵寄存器中的符号串或在神经元网络中传递有噪声的信号来进行推理，都与我们的分析无关。
chap4_para652,1,,我们可以仅通过告知智能体必需的知识来构建基于知识的智能体。
chap4_para652,2,,智能体设计者可以从空知识库开始，逐条告知智能体语句，直到它明白如何在它的环境中运作。
chap4_para652,3,,我们称之为陈述性（declarative）系统构建方法。
chap4_para652,4,,相对地，过程性（procedural）方法将所需的行为直接编码为程序代码。
chap4_para652,5,,在20世纪70年代和80年代，两种方法的提倡者进行了激烈的辩论。
chap4_para652,6,,我们现在明白，成功的智能体在设计中常常需要将陈述性和过程性这两种方法的元素结合起来，而陈述性的知识也往往能够被编译成更有效的过程性代码。
chap4_para653,1,,我们还可以给基于知识的智能体赋予自主学习的机制，我们将在第19章讲解的这些机制。
chap4_para653,2,,智能体能够利用这些机制从一系列感知中创建关于环境的一般知识。
chap4_para653,3,,进行学习的智能体可以是完全自主的。
chap4_para654,1,,7.2　wumpus世界
chap4_para655,1,,本节我们将描述一个能够体现基于知识的智能体的价值的环境。
chap4_para655,2,,wumpus世界（wumpus world）是一个洞穴，其中有许多房间，房间之间有走廊连接。
chap4_para655,3,,在洞穴的某处潜伏着可怕的wumpus，这是一只会吃掉任何进入其房间的人的怪兽。
chap4_para655,4,,智能体可以射杀wumpus，但智能体只有一支箭。
chap4_para655,5,,一些房间有无底洞，能困住任何漫游到这些房间中的人（wumpus除外，它体型大得无法落入无底洞）。
chap4_para655,6,,这个阴森环境的唯一回报是可能找到的金块。
chap4_para655,7,,尽管以现代电子游戏的眼光来看，wumpus世界相当乏味，但它却能展示出智能的一些重要属性。
chap4_para656,1,,图7-2展示了一个简单的wumpus世界示例。
chap4_para656,2,,任务环境的精确定义用2.3节所述的PEAS描述法给出。
chap4_para657,1,,图7-2　一个典型的wumpus世界。
chap4_para657,2,,智能体位于左下角，面朝东（向右）
chap4_para658,1,,● 性能度量：带着金块从洞穴爬出+1000，跌入无底洞或被wumpus吞食−1000，每采取一个动作−1，用尽箭支−10。
chap4_para658,2,,如果智能体死亡或爬出洞穴，游戏结束。
chap4_para659,1,,● 环境：一个4×4的房间网格，网格四周环绕着围墙。
chap4_para659,2,,"智能体始终从标为[1, 1]的方格开始，面向东方。"
chap4_para659,3,,金块和wumpus的位置是根据均匀分布从除了起始方格的所有方格中随机选定的。
chap4_para659,4,,另外，除起始方格外的每个方格都可能是无底洞，出现的概率为0.2。
chap4_para66,1,"Clearly, this effect is unlikely to be significant if adjacent bits are totally unrelated to each other, because then there will be few contiguous blocks that provide a consistent benefit.",考虑一个实例。
chap4_para66,2,Genetic algorithms work best when schemas correspond to meaningful components of a solution.,假设我们希望在罗马尼亚新建3个机场，使得地图上每个城市到其最近机场的直线距离平方和最小。
chap4_para66,3,"For example, if the string is a representation of an antenna, then the schemas may represent components of the antenna, such as reflectors and deflectors.",（罗马尼亚地图见图3-1。
chap4_para66,4,A good component is likely to be good in a variety of different designs.,"）状态空间定义为3个机场的坐标：(x1, y1)、(x2, y2)和(x3, y3)。"
chap4_para66,5,This suggests that successful use of genetic algorithms requires careful engineering of the representation.,这是一个六维空间；我们也可以说状态由6个变量（variable）定义。
chap4_para66,6,,一般地，状态定义为n 维向量，x。
chap4_para66,7,,在这个空间中移动对应于移动地图上的一个或多个机场。
chap4_para66,8,,"对于任一特定状态，一旦计算出最近城市，目标函数f(x) = f (x1, y1, x2, y2, x3, y3)的计算就会变得相对容易。"
chap4_para66,9,,设Ci是最近机场（在状态x下）为机场 i 的城市集合。
chap4_para66,10,,那么，我们有
chap4_para660,1,,● 执行器：智能体可以向前（Forward）、左转（TurnLeft）90°和右转（TurnRight）90°。
chap4_para660,2,,如果智能体进入有活着的wumpus或者有无底洞的方格，它将悲惨地死去。
chap4_para660,3,,（但进入有死掉的wumpus的方格是安全的，尽管气味会很臭。
chap4_para660,4,,）如果智能体试图前进并撞到墙，则智能体会原地不动。
chap4_para660,5,,如果智能体与金块在同一个方格，抓取（Grab）动作可以用于捡起金块。
chap4_para660,6,,射击（Shoot）动作可以用于向智能体面对的方向笔直地发射一支箭，这支箭会一直飞行，直到它命中wumpus（此时wumpus将被杀死）或击中墙壁。
chap4_para660,7,,智能体只有一支箭，因此只有第一次射击动作有效。
chap4_para660,8,,"最后，攀爬（Climb）动作可以用于爬出洞穴，但智能体仅能从方格[1, 1]爬出。"
chap4_para661,1,,● 传感器：该智能体有5个传感器，每个传感器给出一个单一信息。
chap4_para662,1,,❏ 在与wumpus直接（非对角）相邻的方格中，智能体会感知到臭味（Stench）。
chap4_para662,2,,[1]
chap4_para664,1,,[1]　wumpus所在的方格恐怕也有臭味，但任何进入该方格的智能体在能够进行感知前就会被吞食。
chap4_para665,1,,❏ 在与无底洞直接相邻的方格中，智能体会感知到微风（Breeze）。
chap4_para666,1,,❏ 在金块所在的方格中，智能体会感知到闪光（Glitter）。
chap4_para667,1,,❏ 智能体走向墙壁会感知到碰撞（Bump）。
chap4_para668,1,,❏ 如果wumpus被杀死，它将发出惨叫（Scream），智能体可以在洞穴的任意位置感知到。
chap4_para669,1,,感知将以由5个符号组成的列表的形式传给智能体程序。
chap4_para669,2,,"例如，如果有臭味和微风，但没有闪光、碰撞和惨叫，智能体程序将收到[Stench, Breeze, None, None, None]。"
chap4_para67,1,"In practice, genetic algorithms have their place within the broad landscape of optimization methods (Marler and Arora, 2004), particularly for complex structured problems such as circuit layout or job-shop scheduling, and more recently for evolving the architecture of deep neural networks (Miikkulainen et al.",
chap4_para67,2,", 2019).",
chap4_para67,3,"It is not clear how much of the appeal of genetic algorithms arises from their superiority on specific tasks, and how much from the appealing metaphor of evolution.",
chap4_para670,1,,我们可以在第2章所述的多个维度上描述wumpus环境。
chap4_para670,2,,显然，它是确定性的、离散的、静态的且单智能体的。
chap4_para670,3,,（好在wumpus不移动。
chap4_para670,4,,）它是序贯的，因为只有采取很多动作后才可能得到奖励。
chap4_para670,5,,它是部分可观测的，因为状态的一些方面是无法直接感知到的，如智能体的位置、wumpus的健康状况以及是否还有箭支可用。
chap4_para670,6,,对于无底洞和wumpus的位置，我们可以将其看作状态中没有观测到的部分，在这种情况下，环境的转移模型是完全已知的，找出无底洞和wumpus的位置就能补全智能体对状态的知识；抑或，我们也可以说转移模型本身是未知的，因为智能体不知道哪些向前动作是致命的，在这种情况下，找出无底洞和wumpus的位置能够补全智能体对于转移模型的知识。
chap4_para671,1,,对于环境中的智能体，主要的挑战是它起初并不知道环境的配置。
chap4_para671,2,,克服这种无知似乎需要逻辑推理。
chap4_para671,3,,在wumpus世界的大多数情况中，智能体是有可能安全地拾取金块的。
chap4_para671,4,,但智能体偶尔也需要在空手而归和冒死寻宝之间做出选择。
chap4_para671,5,,大约21%的环境是极不公平的，因为这时金块位于无底洞中，或被无底洞包围。
chap4_para672,1,,我们来看一个基于知识的智能体是如何探索图7-2所示的wumpus世界的环境的。
chap4_para672,2,,此处使用一种非形式化的知识表示语言，在网格中写下符号来表示（如图7-3和图7-4所示）。
chap4_para673,1,,图7-3　智能体在wumpus世界迈出的第一步。
chap4_para673,2,,"（a）在感知到[None, None, None, None, None]后的初始状态。"
chap4_para673,3,,"（b）在移动到[2, 1]后感知到[None, Breeze, None, None, None]"
chap4_para674,1,,智能体的初始知识库包括前述的环境规则。
chap4_para674,2,,"具体来说，智能体知道自己位于[1, 1]且[1, 1]是安全的方格。"
chap4_para674,3,,"我们在方格[1, 1]中用“A”和“OK”分别进行表示。"
chap4_para675,1,,"第一个感知是[None, None, None, None, None]，据此智能体可以认定它的相邻方格[1, 2]和[2, 1]是安全的——它们是“OK”的。"
chap4_para675,2,,图7-3a展示了此时智能体的知识状态。
chap4_para676,1,,图7-4　智能体运作时的两个后续状态。
chap4_para676,2,,"（a）回到[1, 1]再移动到[1, 2]后，感知到[Stench, None, None, None, None]。"
chap4_para676,3,,"（b）来到[2, 2]再移动到[2, 3]，感知到[Stench, Breeze, Glitter, None, None]"
chap4_para677,1,,一个谨慎的智能体只会移动到它所知的OK方格。
chap4_para677,2,,"我们假设智能体决定前进到[2, 1]。"
chap4_para677,3,,"这个智能体在[2, 1]感受到微风（用“B”表示），因此在相邻方格中必然存在无底洞。"
chap4_para677,4,,"根据游戏规则，无底洞不可能在[1, 1]，因此[2, 2]和[3, 1]其中之一必然有无底洞或二者都有。"
chap4_para677,5,,图7-3b中的记号“P?”表示这些方格中可能存在无底洞。
chap4_para677,6,,此时，仅有一个已知的且未访问过的“OK”方格。
chap4_para677,7,,"因此这个心思缜密的智能体将扭头，回到[1, 1]，然后移步[1, 2]。"
chap4_para678,1,,"智能体在[1, 2]感知到臭味，导致知识状态变为图7-4a所示的状况。"
chap4_para678,2,,"[1, 2]有臭味表明附近肯定有wumpus。"
chap4_para678,3,,"但根据游戏规则wumpus不可能在[1, 1]，也不在[2, 2]（否则智能体先前在[2, 1]时会探测到臭味）。"
chap4_para678,4,,"因此，智能体可以推断出wumpus在[1, 3]。"
chap4_para678,5,,记号“W!”表示这一推断。
chap4_para678,6,,"而[1, 2]没有微风表明[2, 2]没有无底洞。"
chap4_para678,7,,"考虑到智能体先前已经推断出[2, 2]或[3, 1]中必然有无底洞，因此无底洞必然位于[3, 1]。"
chap4_para678,8,,这是一次相当复杂的推断，因为它结合了在不同时间、不同地点获取的信息，并在缺乏感知的情况下迈出了关键的一步。
chap4_para679,1,,"现在智能体已经证明了[2, 2]中既没有无底洞也没有wumpus，因此可以移动到那里。"
chap4_para679,2,,"我们没有展示智能体在[2, 2]的知识状态，姑且假设智能体转向并移动到[2,3]，形成了图7-4b所示的情况。"
chap4_para679,3,,"在[2, 3]中，智能体探测到闪光，因此它应该抓取金块然后回家。"
chap4_para68,1,4.,这一方程不仅对于状态x是正确的，而且对于x局部邻域中的状态也是正确的。
chap4_para68,2,2Local Search in Continuous Spaces,然而，对全局来说，它是不正确的；如果我们偏离x太远（通过大幅改变一个或多个机场的位置），那么该机场的最近城市集合会发生变化，我们需要重新计算Ci。
chap4_para680,1,,注意，在智能体从可用信息中得出结论的每个情形下，如果可用信息是正确的，则可以保证结论都是正确的。
chap4_para680,2,,这是逻辑推理的一个重要性质。
chap4_para680,3,,本章剩余部分将描述如何构建能够表示信息并得出类似前述的结论的逻辑智能体。
chap4_para682,1,,本节综述逻辑表示和推理的基本概念。
chap4_para682,2,,这些漂亮的想法独立于逻辑的具体形式。
chap4_para682,3,,因此，我们将形式的技术细节推后到7.4节介绍，本节代之以熟悉的普通算术问题作为示例。
chap4_para683,1,,在7.1节，我们说过知识库由语句组成。
chap4_para683,2,,这些语句是根据表示语言的语法（syntax）表达的，语法规定了所有的合规语句。
chap4_para683,3,,用简单的算术就能清晰地说明语法这个概念：“x + y = 4”是合规的语句，而“x4y+=”不是。
chap4_para684,1,,一种逻辑还必须定义语句的语义，或者说语句的含义。
chap4_para684,2,,语义定义每条语句在每个可能世界中的真值。
chap4_para684,3,,例如，算术的语义指明“x + y = 4”在一个x为2且y为2的世界为真，但在一个x为1且y为1的世界中为假。
chap4_para684,4,,在标准的逻辑学中，每个可能世界中的每条语句要么为真，要么为假——没有中间地带。
chap4_para684,5,,[2]
chap4_para686,1,,[2]　第13章讨论的模糊逻辑（fuzzy logic）允许存在不同程度的真值。
chap4_para687,1,,当需要精确描述时，我们用模型来代替“可能世界”。
chap4_para687,2,,可能世界可以被认为是（潜在的）真实环境，智能体可能在也可能不在其中，而模型是数学抽象，对于每个相关的语句，每个模型都有固定的真值（真或假）。
chap4_para687,3,,非正式地举个例子：我们可以认为一个可能世界是让x个男士和y个女士坐在一张桌子边上玩桥牌，如果总共有4个人，则语句x+y=4为真。
chap4_para687,4,,正式地说，可能的模型是对变量x和y进行非负整数赋值的所有可能。
chap4_para687,5,,每个这样的赋值都确定了任何一个变量为x和y的算术语句的真值。
chap4_para687,6,,如果语句在模型m中为真，我们说m满足，有时也可以说m是的一个模型。
chap4_para687,7,,我们使用记号来代表的所有模型的集合。
chap4_para688,1,,有了真值的概念，我们就可以讨论逻辑推理了。
chap4_para688,2,,这涉及语句之间的逻辑蕴含（entailment），即一个语句逻辑上引发另一语句。
chap4_para688,3,,数学上，我们用
chap4_para689,1,,来表示语句蕴含语句。
chap4_para689,2,,蕴含的形式化定义是：当且仅当在为真的每个模型中也为真。
chap4_para689,3,,用刚才介绍的记法，我们可以将其写作
chap4_para69,1,"In Chapter 2, we explained the distinction between discrete and continuous environments, pointing out that most real-world environments are continuous. A continuous action space has an infinite branching factor, and thus can’t be handled by most of the algorithms we have covered so far (with the exception of first-choice hill climbing and simulated annealing).",处理连续状态空间的一种方法是离散化（discretize）。
chap4_para69,2,,"例如，我们可以将(xi, yi)的位置限制在矩形网格上间距为的固定点，而不是允许它的位置可以为连续二维空间中的任意点。"
chap4_para69,3,,那么，空间中的每个状态将存在12个后继（对应于将6个变量分别增加），而不是之前的无限多个。
chap4_para69,4,,然后我们就可以对离散空间应用任意局部搜索算法。
chap4_para69,5,,或者，我们可以通过随机采样后继状态，即在随机方向上移动一个小量，使分支因子变为有限值。
chap4_para69,6,,通过两个相邻点之间目标函数值的变化来衡量进度的方法称为经验梯度（empirical gradient）法。
chap4_para69,7,,经验梯度搜索与离散化状态空间中的最陡上升爬山法相同。
chap4_para69,8,,随着时间逐渐减小的值可以得到更准确的解，但不一定在极限范围内收敛到全局最优值。
chap4_para691,1,,（注意此处⊆的方向：若，则是比更强的断言，它排除了更多的可能世界。
chap4_para691,2,,）蕴含关系用算术来说明会更为亲切一些：我们很容易理解语句x=0蕴含语句xy=0。
chap4_para691,3,,显然，在任一x为0的模型中，xy也必然为0（而无论y的值是多少）。
chap4_para692,1,,我们可以将同样的分析应用于7.2节所述的wumpus世界推理的例子。
chap4_para692,2,,"考虑图7-3b所示的情形：智能体在[1, 1]中什么都没有探测到，在[2, 1]中探测到微风。"
chap4_para692,3,,这些感知与智能体所具有的wumpus世界规则的知识一同构成了知识库。
chap4_para692,4,,"智能体所感兴趣的是相邻的方格[1, 2]、[2, 2]和[3, 1]是否有无底洞。"
chap4_para692,5,,这3个方格中的每一个都可能有或没有无底洞，因此（暂且忽略这个世界的其他方面），总共有23=8个可能的模型。
chap4_para692,6,,图7-5展示了这8个模型。
chap4_para692,7,,[3]
chap4_para694,1,,"[3]　尽管该图用部分wumpus世界来表示模型，但模型实际上只是对类似“[1, 2]中有无底洞”这样的语句进行真或假的赋值。"
chap4_para694,2,,从数学的角度来看，模型中并不需要有可怕的长毛wumpus。
chap4_para695,1,,"图7-5　方格[1, 2]、[2, 2]和[3, 1]中无底洞存在性的可能的模型。"
chap4_para695,2,,"在[1, 1]中没有观测到任何东西且在[2, 1]中观测到微风的知识库用实线表示。"
chap4_para695,3,,"（a）虚线表示的模型（[1, 2]中没有无底洞）。"
chap4_para695,4,,"（b）虚线表示的模型（[2, 2]中没有无底洞）"
chap4_para696,1,,KB可以理解为一个语句的集合，或断言了所有单个语句的单个语句。
chap4_para696,2,,在与智能体已知相矛盾的模型中，KB为假。
chap4_para696,3,,"例如，在所有[1, 2]含有无底洞的模型中，KB都为假，因为[1, 1]中没有微风。"
chap4_para696,4,,实际上，使KB为真的模型只有3个，这些模型在图7-5中用实线包围。
chap4_para696,5,,我们现在考虑两个可能的结论：
chap4_para697,1,,"=“[1, 2]中没有无底洞”　=“[2, 2]中没有无底洞”"
chap4_para698,1,,在图7-5a和图7-5b中分别用虚线包围了和的模型。
chap4_para698,2,,仔细观察后，我们可以得出
chap4_para699,1,,在所有KB为真的模型中，也为真
chap4_para7,1,"Local search algorithms can also solve optimization problems, in which the aim is to find the best state according to an objective function.",为了理解局部搜索，我们考虑在状态空间地形图（state-space landscape）中布局的问题状态，如图4-1所示。
chap4_para7,2,,地形图中的每个点（状态）都有一个“标高”，由目标函数值定义。
chap4_para7,3,,如果标高对应于目标函数，那么目的就是找到最高峰——全局极大值（global maximum）——我们称这个过程为爬山（hill climbing）；如果标高对应于代价，那么目的就是找到最低谷——全局极小值（global minimum）——我们称之为梯度下降（gradient descent）。
chap4_para70,1,This section provides a very brief introduction to some local search techniques for continuous spaces.,通常我们有一个以数学形式表达的目标函数，这样我们就可以用微积分来解析地而非经验地求解问题。
chap4_para70,2,"The literature on this topic is vast; many of the basic techniques originated in the 17th century, after the development of calculus by Newton and Leibniz.",许多方法都试图利用地形图的梯度（gradient）来找到最大值。
chap4_para70,3,"2 We find uses for these techniques in several places in this book, including the chapters on learning, vision, and robotics.",目标函数的梯度是一个向量∇f，它给出了最陡斜面的长度和方向。
chap4_para70,4,,对于我们的问题，有
chap4_para700,1,,"因此，，即[1,2]中没有无底洞。"
chap4_para700,2,,我们还可以得出
chap4_para701,1,,在一些KB为真的模型中，为假
chap4_para702,1,,"因此，KB不蕴含，即智能体无法断定[2,2]中没有无底洞。"
chap4_para702,2,,"（也无法断定[2,2]中有无底洞。"
chap4_para702,3,,）[4]
chap4_para704,1,,"[4]　智能体可以计算[2,2]中有无底洞的概率，第12章将介绍如何计算。"
chap4_para705,1,,前述的例子不仅阐明了什么是蕴含，还展示了如何用蕴含的定义来推导出结论，即进行逻辑推断。
chap4_para705,2,,图7-5所示的推断算法被称为模型检验，因为这个示例枚举了所有可能的模型来检验在所有KB为真的模型中都为真，即。
chap4_para706,1,,将KB的所有推论的集合比作干草堆而将比做一根针或许有助于理解蕴含和推断。
chap4_para706,2,,蕴含正如草堆中的针一样，而推断就像找到这根针的过程。
chap4_para706,3,,一些形式化记法体现了这种区别：如果一个推断算法i可以从KB中推导出，则记为
chap4_para707,1,,读作“是由i从KB中推得的”或“i从KB推得”。
chap4_para708,1,,一个仅推导蕴含语句的推断算法被称为是可靠的或保真的。
chap4_para708,2,,可靠性是极为重要的属性。
chap4_para708,3,,一个不可靠的推断过程在运作时本质上会编造事实——它会声称发现了并不存在的针。
chap4_para708,4,,我们很容易看出，模型检验在适用时[5]是一个可靠的程序。
chap4_para71,1,We begin with an example.,在某些情况下，我们可以通过解∇f = 0方程找到一个极大值。
chap4_para71,2,"Suppose we want to place three new airports anywhere in Romania, such that the sum of squared straight-line distances from each city on the map to its nearest airport is minimized.",（这是可以做到的，例如，如果我们只新建一个机场；问题的解是所有城市坐标的算术平均值。
chap4_para71,3,(See Figure 3.,）然而，在许多情况下，这个方程不存在闭式解。
chap4_para71,4,1 for the map of Romania.,例如，对于3个机场的情况，梯度的表达式依赖于当前状态中哪些城市离各个机场最近。
chap4_para71,5,") The state space is then defined by the coordinates of the three airports: (x1, y1), (x2, y2), and (x3, y3).",这意味着我们只能局部地（而非全局地）计算梯度，例如，
chap4_para71,6,This is a six-dimensional space; we also say that states are defined by six variables.,
chap4_para71,7,"In general, states are defined by an n-dimensional vector of variables, x.",
chap4_para71,8,Moving around in this space corresponds to moving one or more of the airports on the map.,
chap4_para71,9,"The objective function f(x) = f(x1, y1, x2, y2, x3, y3) is relatively easy to compute for any particular state once we compute the closest cities.",
chap4_para71,10,Let Ci be the set of cities whose closest airport (in the state x) is airport i.,
chap4_para71,11,"Then, we have",
chap4_para710,1,,[5]　如果模型空间是有限的，则模型检验是有效的，例如，在固定大小的wumpus世界中。
chap4_para710,2,,而对算术来说，模型空间是无限的：即使我们局限于整数范围，语句x+y=4中x和y的值也是有无限多对的。
chap4_para711,1,,完备性也是很重要的属性：如果一个推断算法能够推导出所有蕴含的语句，则它是完备的。
chap4_para711,2,,真正的草堆大小是有限的，对其进行全面仔细的检查就一定能确定针在不在草堆里，这似乎是很显然的道理。
chap4_para711,3,,然而，对许多知识库来说，推论的草堆是无限的，因而完备性就成了一个重大问题。
chap4_para711,4,,[6]幸运的是，逻辑学中有完备的推断过程，其表达能力足以处理许多知识库。
chap4_para713,1,,[6]　比如说，在第3章的无限搜索空间的情形中，深度优先搜索就是不完备的。
chap4_para714,1,,我们已经描述了一个推理过程，在前提为真的任何世界中都保证结论为真。
chap4_para714,2,,具体来说，如果KB在真实世界中为真，则用可靠的推断过程从KB中推出的所有语句在真实世界中也为真。
chap4_para714,3,,因此，当推断过程在“语法”（例如，寄存器中的位或大脑中的电信号模式这样的内部物理结构）上进行操作时，这个过程对应于一个真实世界的关系，即真实世界的某个部分为真是因为真实世界的其他一些部分为真。
chap4_para714,4,,[7]这种世界与表示的对应如图7-6所示。
chap4_para716,1,,"[7]　正如路德维希•维特根斯坦（Ludwig Wittgenstein）在其著名的《逻辑哲学论》（Tractatus）（Wittgenstein, 1922）中所述：“世界就是所有为真的一切。"
chap4_para716,2,,”
chap4_para717,1,,最后要考虑的问题是落地，也就是逻辑推理过程与智能体所存在的真实环境的联系。
chap4_para717,2,,尤其是，我们如何知道KB在真实世界中为真？
chap4_para717,3,,（毕竟KB只是存在于智能体头脑中的“语法”。
chap4_para717,4,,）这是一个哲学问题，众多的书籍都对此进行了讨论（见第27章）。
chap4_para717,5,,一个简单的回答是，智能体的传感器创建了这个联系。
chap4_para717,6,,例如，我们的wumpus世界智能体有嗅觉传感器。
chap4_para717,7,,一旦有气味，智能体程序就会创建一条合适的语句。
chap4_para717,8,,因此，一旦这条语句被包含在知识库中，就意味着它在真实世界中也为真。
chap4_para717,9,,这样，感知语句的含义和真值就是由产生这些语句的感知过程和语句构建过程定义的。
chap4_para717,10,,那么智能体知识的其他部分呢？
chap4_para717,11,,例如，它对于“wumpus相邻的方格有臭味”这件事的信念呢？
chap4_para717,12,,这不是单个感知的直接表示，而是一项一般规则，它可能是从感知的经验推导出的，却与经验陈述并不完全相同。
chap4_para717,13,,这种一般规则是通过被称为学习的语句构建过程产生的，这是第五部分的主题。
chap4_para717,14,,学习是难免会出错的。
chap4_para717,15,,一种可能的情况是，wumpus有臭味但闰年2月29日这一天除外，因为这一天它要洗澡。
chap4_para717,16,,因此，KB在真实世界中可能并不为真，但因为有很好的学习过程，我们对此就有理由乐观。
chap4_para718,1,,图7-6　语句是智能体的物理结构，而推理是从旧结构构建新结构的过程。
chap4_para718,2,,逻辑推理应当确保新结构所表示的部分世界确实能够从旧结构所表示的部分世界推得
chap4_para719,1,,7.4　命题逻辑：一种非常简单的逻辑
chap4_para72,1,This equation is correct not only for the state x but also for states in the local neighborhood of x.,
chap4_para72,2,"However, it is not correct globally; if we stray too far from x (by altering the location of one or more of the airports by a large amount) then the set of closest cities for that airport changes, and we need to recompute Ci.",
chap4_para720,1,,本节讲解命题逻辑（propositional logic）。
chap4_para720,2,,我们将阐述其语法（即语句的结构）和语义（确定语句真值的方法）。
chap4_para720,3,,由此，我们将推导出一个简单的、语法的逻辑推断算法，它能够实现蕴含的语义概念。
chap4_para720,4,,当然，这一切都仍将发生在wumpus世界中。
chap4_para722,1,,命题逻辑的语法定义合法的语句。
chap4_para722,2,,原子语句（atomic sentence）由单个命题符号（proposition symbol）构成。
chap4_para722,3,,每个这样的符号代表一个为真或假的命题。
chap4_para722,4,,"我们使用以大写字母开头的、可能包含其他字母或下标的符号来表示，例如P、Q、R、W1,3以及FacingEast等。"
chap4_para722,5,,"我们可以任意地进行命名，但通常选择一些有助记功能的名字，例如，使用W1,3代表“wumpus位于[1, 3]”。"
chap4_para722,6,,"请记住，像W1,3这样的符号是原子的，也就是说分开的W、1、3并非符号的有意义的部分。"
chap4_para722,7,,）有两个命题符号有固定的含义：True是永真命题，False是永假命题。
chap4_para722,8,,使用括号和被称作逻辑联结词（logical connective）的运算符可以将简单语句构造成复合语句（complex sentence）。
chap4_para722,9,,常用的联结词有5个。
chap4_para723,1,,● （非）。
chap4_para723,2,,"类似这样的语句称为W1,3的否定。"
chap4_para723,3,,一个文字要么是原子语句，即正文字，要么是原子语句的否定，即负文字。
chap4_para724,1,,● ∧（与）。
chap4_para724,2,,主要联结词是∧的语句称为合取式，例如，其各部分称为合取子句。
chap4_para724,3,,（∧看起来像是“And”中的“A”。
chap4_para724,4,,）
chap4_para725,1,,● ∨（或）。
chap4_para725,2,,"主要联结词是∨的语句称为析取式，例如，其各部分为析取子句，本例中分别为和W2,2。"
chap4_para726,1,,● （蕴涵）。
chap4_para726,2,,如这样的语句称为蕴涵式（implication）或条件式，其前提（premise）或前件（antecedent）是，其结论（conclusion）或后件（consequent）是。
chap4_para726,3,,蕴涵式也被称为规则（rule）或if-then声明。
chap4_para726,4,,有时，蕴涵符号在一些书籍中写作或。
chap4_para727,1,,● （当且仅当）。
chap4_para727,2,,语句是双向蕴涵式（biconditional）。
chap4_para728,1,,图7-7给出了命题逻辑的形式文法。
chap4_para728,2,,［附录B将会介绍巴克斯-诺尔范式（Backus-Naur form，BNF）的概念。
chap4_para728,3,,］我们在BNF文法上附加了运算符优先级，以避免在使用多个运算符时出现歧义。
chap4_para728,4,,“非”运算符的优先级最高，这意味着在语句中，的结合力更强，因此它等价于而不是。
chap4_para728,5,,（这与普通算术一样：−2+4等于2而不是−6。
chap4_para728,6,,）我们也会适时地使用圆括号和方括号来明确语句结构，以改善可读性。
chap4_para729,1,,图7-7　命题逻辑中语句的BNF文法以及从高到低排列的运算符优先级
chap4_para73,1,"One way to deal with a continuous state space is to discretize it. For example, instead of allowing the (xi, yi) locations to be any point in continuous two-dimensional space, we could limit them to fixed points on a rectangular grid with spacing of size δ (delta). Then instead of having an infinite number of successors, each state in the space would have only 12 successors, corresponding to incrementing one of the 6 variables by ±δ. We can then apply any of our local search algorithms to this discrete space. Alternatively, we could make the branching factor finite by sampling successor states randomly, moving in a random direction by a small amount, δ. Methods that measure progress by the change in the value of the objective function between two nearby points are called empirical gradient methods. Empirical gradient search is the same as steepest-ascent hill climbing in a discretized version of the state space. Reducing the value of δ over time can give a more accurate solution, but does not necessarily converge to a global optimum in the limit.",给定一个局部正确的梯度表达式，我们可以根据下式来更新当前状态从而实现最陡上升爬山法：
chap4_para731,1,,了解了命题逻辑的语法后，我们来说明其语义。
chap4_para731,2,,语义定义了用于判定特定模型中语句真值的规则。
chap4_para731,3,,命题逻辑中，模型就是对每个命题符号设定真值，即真（true）或假（false）。
chap4_para731,4,,"例如，如果知识库中的语句使用了命题符号P1,2、P2,2和P3,1，则一个可能模型为"
chap4_para732,1,,由于含有3个命题符号，因此有23=8种可能的模型，与图7-5所示的完全相同。
chap4_para732,2,,但要注意，这些模型是纯粹的数学对象，不必与wumpus世界有关。
chap4_para732,3,,"P1,2只是符号，它可能代表“[1, 2]中有无底洞”，也可能代表“我今天和明天都在巴黎”。"
chap4_para733,1,,命题逻辑的语义必须指定在给定模型下如何计算任一语句的真值。
chap4_para733,2,,这是以递归的方式实现的。
chap4_para733,3,,所有语句都是由原子语句和5个联结词构建的。
chap4_para733,4,,因此，我们需要指定如何计算原子语句的真值和用5个联结词构建的语句的真值。
chap4_para733,5,,对原子语句来说这很简单。
chap4_para734,1,,● true在每个模型里都为真，false在每个模型里都为假。
chap4_para735,1,,● 其余命题符号的真值必须在模型中直接指定。
chap4_para735,2,,"例如，在先前给出的模型m1中，P1,2为假。"
chap4_para736,1,,对于复合语句，有5条规则，它们对任一模型m中的任一子句P和Q（原子语句或复合语句）都成立。
chap4_para737,1,,● 为真，当且仅当在m中P为假。
chap4_para738,1,,● 为真，当且仅当在m中P和Q都为真。
chap4_para739,1,,● 为真，当且仅当在m中P或Q中至少一个为真。
chap4_para74,1,"Often we have an objective function expressed in a mathematical form such that we can use calculus to solve the problem analytically rather than empirically. Many methods attempt to use the gradient of the landscape to find a maximum. The gradient of the objective function is a vector ∇f that gives the magnitude and direction of the steepest slope. For our problem, we have",其中是一个很小的常数，通常称为步长（step size）。
chap4_para74,2,,存在很多调整的方法。
chap4_para74,3,,基本问题是，如果太小，需要的迭代步太多；如果太大，搜索可能会越过最大值。
chap4_para74,4,,线搜索（line search）技术试图通过不断延伸当前梯度方向——通常通过对反复加倍——直到f再次开始减小来克服上述困境。
chap4_para74,5,,出现上述现象的点成为新的当前状态。
chap4_para74,6,,在这点上如何选择新的方向，有几种不同的方法。
chap4_para740,1,,● 为真，除非在m中P为真而Q为假。
chap4_para741,1,,● 为真，当且仅当在m中P和Q都为真或都为假。
chap4_para742,1,,这些规则也可以用真值表表示。
chap4_para742,2,,真值表指明在对复合语句的组成部分进行每种可能的真值赋值后，该复合语句的真值。
chap4_para742,3,,图7-8给出了5个联结词的真值表。
chap4_para742,4,,任一语句s关于任一模型m的真值都可以用简单的递归求值来计算。
chap4_para742,5,,例如，在模型m1中求语句的值，得到。
chap4_para742,6,,"习题7.TRUV要求写出算法PL-True?(s, m)，用于计算命题逻辑语句s在模型m中的真值。"
chap4_para743,1,,图7-8　5个逻辑联结词的真值表。
chap4_para743,2,,若要使用真值表计算在P为真、Q为假时的值，首先在左边找到P为true而Q为false的行（第3行），然后找到该行位于列处的值，得到结果true
chap4_para744,1,,“与”“或”“非”的真值表与我们对这些词的直观认识非常接近。
chap4_para744,2,,可能会混淆的关键点是当P为真或Q为真，或者二者同时为真时，为真。
chap4_para744,3,,而另一个联结词“排他或”（简称“异或”）则会在两个子句都为真时为假。
chap4_para744,4,,[8]排他或没有公认的符号，有些人选择使用、或者⊕。
chap4_para746,1,,[8]　在拉丁语中，“或”用两个词表示：“vel”是相容或，“aut”是排他或。
chap4_para747,1,,⇒的真值表可能不太符合人们对“P蕴涵Q”或“若P则Q”的直观理解。
chap4_para747,2,,一种解释是，命题逻辑并不要求P和Q之间有任何因果关系或相关性。
chap4_para747,3,,（在一般的理解下）语句“5是奇数蕴涵东京是日本的首都”是命题逻辑中的真语句，尽管这句话相当奇怪。
chap4_para747,4,,另一个容易混淆之处在于前件为假的所有蕴涵式都为真。
chap4_para747,5,,例如，“5是偶数蕴涵Sam很聪明”为真，而不论Sam是否聪明。
chap4_para747,6,,这似乎很怪异，但如果你将“”当作“如果P为真，则我可以断言Q为真，否则我无法断言”的话，就可以理解了。
chap4_para747,7,,这条语句为假的唯一情形是当P为真而Q为假时。
chap4_para748,1,,当与均为真时，双向蕴涵式为真，英语中常写作“P if and only if Q”（P当且仅当Q）。
chap4_para748,2,,wumpus世界的大部分规则都可以用很好地表示。
chap4_para748,3,,例如，当一个方格的相邻方格中有无底洞，该方格有微风，而且，仅当一个方格的某个相邻方格中有无底洞，该方格有微风。
chap4_para748,4,,因此，我们需要使用双向蕴涵式
chap4_para749,1,,"其中B1, 1代表[1, 1]有微风。"
chap4_para75,1,"In some cases, we can find a maximum by solving the equation ∇f = 0. (This could be done, for example, if we were placing just one airport; the solution is the arithmetic mean of all the cities’ coordinates.) In many cases, however, this equation cannot be solved in closed form. For example, with three airports, the expression for the gradient depends on what cities are closest to each airport in the current state. This means we can compute the gradient locally (but not globally); for example,",对于许多问题，最有效的算法是古老的牛顿-拉弗森法（Newton-Raphson method）。
chap4_para75,2,,这是一种求函数根（即求解g(x) = 0形式的方程）的通用方法。
chap4_para75,3,,它的工作原理是根据牛顿公式计算根x的一个新的估计值：
chap4_para750,1,,7.4.3　一个简单的知识库
chap4_para751,1,,我们已经定义了命题逻辑的语义，现在可以为wumpus世界构建一个知识库了。
chap4_para751,2,,首先关注wumpus世界的不变部分，后面章节再处理其可变部分。
chap4_para751,3,,"对于每个位置[x, y]，需要用到下列符号："
chap4_para752,1,,"当[x, y]有无底洞，Px, y为真。"
chap4_para753,1,,"当wumpus在[x, y]，不论其死活Wx, y都为真。"
chap4_para754,1,,"当[x, y]有微风，Bx, y为真。"
chap4_para755,1,,"当[x, y]处有臭味，Sx, y为真。"
chap4_para756,1,,"当智能体位于位置[x, y]，Lx, y为真。"
chap4_para757,1,,"我们写下的语句将足以推得（[1, 2]中没有无底洞），正如7.3节用非形式化的方法所做的那样。"
chap4_para757,2,,我们用Ri代表每个语句，以便推导。
chap4_para758,1,,"● [1, 1]中没有无底洞："
chap4_para759,1,,● 一个方格有微风，当且仅当其相邻方格中有无底洞。
chap4_para759,2,,必须对每个方格都进行这样的表示，在此我们只写出相关方格的表示：
chap4_para76,1,"Given a locally correct expression for the gradient, we can perform steepest-ascent hill climbing by updating the current state according to the formula",要找到f的最大值或最小值，需要找到使得梯度为零向量（即）的x。
chap4_para76,2,,因此，牛顿公式中的g(x)为，更新方程可以写成矩阵-向量形式：
chap4_para760,1,,● 上述语句在所有wumpus世界中都为真。
chap4_para760,2,,我们现在为智能体在这个特定世界中已访问过的前两个方格引入微风感知，以形成图7-3b所示的情形：
chap4_para761,1,,7.4.4　一个简单的推断过程
chap4_para762,1,,我们现在的目标是确定对于一些语句，是否成立。
chap4_para762,2,,例如，我们的KB是否蕴含？
chap4_para762,3,,我们的第一个推理算法是模型检验方法，它直接实现了蕴含的定义：枚举所有模型，检验在KB为真的每个模型中是否为真。
chap4_para762,4,,模型是对每个命题符号进行真或假的赋值。
chap4_para762,5,,"回到例子中的wumpus世界，它涉及的命题符号是B1, 1、B2, 1、P1, 1、P1, 2、P2, 1、P2, 2和P3, 1。"
chap4_para762,6,,在有7个符号的情况下，总共有27=128个可能的模型，KB在其中3个模型中为真（如图7-9所示）。
chap4_para762,7,,"在这3个模型中，为真，因此[1, 2]中没有无底洞。"
chap4_para762,8,,"但是，在3个模型中，P2, 2在其中两个模型中为真，在另一个模型中为假，因此我们还无法确定[2, 2]中是否有无底洞。"
chap4_para763,1,,图7-9以更准确的形式再现了图7-5所示的推理。
chap4_para763,2,,图7-10描述了一个确定命题逻辑中蕴含关系的通用算法。
chap4_para763,3,,与6.3节所示的Backtracking-Search算法类似，TT-Entails?在符号赋值的有限空间中进行递归枚举。
chap4_para763,4,,这个算法是可靠的，因为它直接实现了蕴含的定义；这个算法也是完备的，因为它对所有KB和都适用，并且算法最后都会终止——因为需要检验的模型数量是有限的。
chap4_para764,1,,图7-9　根据文中所述的知识库构建的真值表。
chap4_para764,2,,如果从R1到R5都为true，则KB为true。
chap4_para764,3,,这种情况在全部128行中只出现了3次（在最右侧的列中用下划线标出）。
chap4_para764,4,,"在这3行中，P1, 2均为false，因此[1, 2]中没有无底洞。"
chap4_para764,5,,"但是，[2, 2]中可能有（也可能没有）无底洞"
chap4_para765,1,,图7-10　用于确定命题蕴含的真值表枚举算法（TT代表真值表）。
chap4_para765,2,,当语句在一个模型中成立，PL-True?返回true。
chap4_para765,3,,变量model代表部分模型——对于部分符号的赋值。
chap4_para765,4,,此处的关键字and不是命题逻辑中的运算符，而是伪代码编程语言中的中缀；如果其两个参数中的任意一个为true，则返回true
chap4_para766,1,,当然，“有限数量”并不总是等同于“少量”。
chap4_para766,2,,如果KB和总共含有n个符号，那么就会有2n个模型。
chap4_para766,3,,这样，算法的时间复杂性就会达到O(2n)。
chap4_para766,4,,（空间复杂性仅为O(n)，因为枚举是深度优先的。
chap4_para766,5,,）在本章稍后部分，我们将展示一个在大多数情况下更高效的算法。
chap4_para766,6,,遗憾的是，命题蕴含是余NP完全的（即很可能不比NP完全简单，见附录A），因此命题逻辑所有已知推断算法的最坏情况复杂性都是输入规模的指数量级。
chap4_para767,1,,7.5　命题定理证明
chap4_para768,1,,至此，我们已经展示了如何用模型检验判定蕴含关系：枚举模型，并验证语句在所有模型中必须成立。
chap4_para768,2,,本节将展示如何通过定理证明找出蕴含关系。
chap4_para768,3,,定理证明对知识库中的语句直接应用推断规则，它能够在不检验模型的情况下，构建对所需语句的证明。
chap4_para768,4,,如果模型的数量很多，但其证明很短，则定理证明会比模型检验更为高效。
chap4_para769,1,,在深入定理证明算法的细节之前，我们还需要了解一些与蕴含相关的概念。
chap4_para769,2,,第一个概念是逻辑等价（logical equivalence）：如果两个语句和在相同的模型集合中都为真，则这两个语句逻辑等价，可以写作。
chap4_para769,3,,（注意，用于对语句进行声明，而则用作语句的一部分。
chap4_para769,4,,）例如，我们可以很容易地（用真值表）证明与是逻辑等价的。
chap4_para769,5,,其他逻辑等价见图7-11。
chap4_para769,6,,这些等价关系在逻辑中扮演的角色与算术恒等式在普通数学中的角色非常相似。
chap4_para769,7,,等价的另一种定义为“任意两条语句和是等价的，当且仅当它们互相蕴含”：
chap4_para77,1,"where α (alpha) is a small constant often called the step size. There exist a huge variety of methods for adjusting α. The basic problem is that if α is too small, too many steps are needed; if α is too large, the search could overshoot the maximum. The technique of line search tries to overcome this dilemma by extending the current gradient direction—usually by repeatedly doubling α—until f starts to decrease again. The point at which this occurs becomes the new current state. There are several schools of thought about how the new direction should be chosen at this point.",其中Hf(x)为二阶导数的黑塞矩阵（Hessian matrix），其元素Hij由给出。
chap4_para77,2,,对于上述机场问题实例，从式（4-2）可以看出，Hf(x)相当简单：非对角元素为零，机场i的对角线元素的值恰好为Ci中城市数目的两倍。
chap4_para77,3,,每一时刻的计算表明，每一步更新将机场i直接移动到Ci的质心处，即式（4-1）中f的局部表达式的最小值。
chap4_para77,4,,[3]然而，对于高维问题，计算黑塞矩阵的n2个元素以及对它求逆的开销可能非常昂贵，因此产生了许多牛顿-拉弗森法的近似版本。
chap4_para771,1,,第二个概念是有效性（validity）。
chap4_para771,2,,如果一条语句在所有模型中都为真，则这条语句是有效的。
chap4_para771,3,,例如，语句是有效的。
chap4_para771,4,,有效的语句也被称为重言式（tautology）——它们必然为真。
chap4_para771,5,,由于语句True在所有模型中都为真，所有有效的语句都逻辑等价于True。
chap4_para771,6,,有效语句有什么用？
chap4_para771,7,,从蕴含的定义可以推导出古希腊人早已懂得的演绎定理（deduction theorem）：
chap4_para772,1,,对于任意语句和，当且仅当语句是有效的。
chap4_para773,1,,（习题7.DEDU要求对其进行证明。
chap4_para773,2,,）因此，可以像图7-10所示的推断算法那样，通过检验是否在每个模型中为真来确定是否成立，或者通过证明等价于True来确定是否成立。
chap4_para773,3,,反过来，演绎定理表明每条有效的蕴涵语句都描述一个合法的推断。
chap4_para774,1,,图7-11　标准的逻辑等价。
chap4_para774,2,,符号、、代表任意命题逻辑语句
chap4_para775,1,,最后一个概念是可满足性（satisfiability）。
chap4_para775,2,,如果一条语句在某些模型中为真或能够被满足，则这条语句是可满足的。
chap4_para775,3,,例如，前述的知识库中，是可满足的，因为如图7-9所示，它在3个模型中为真。
chap4_para775,4,,可以通过枚举可能的模型，直到找出满足语句的模型来验证可满足性。
chap4_para775,5,,在命题逻辑中确定语句的可满足性的问题——SAT问题——是第一个被证明为NP完全的问题。
chap4_para775,6,,计算机科学中的许多问题实际上都是可满足性问题。
chap4_para775,7,,例如，第6章的所有约束满足问题询问约束是否可以通过某种赋值来满足。
chap4_para776,1,,有效性和可满足性当然是有联系的：是有效的，当且仅当是不可满足的；换言之，是可满足的，当且仅当不是有效的。
chap4_para776,2,,我们还能得出下述非常有用的结论：
chap4_para777,1,,当且仅当语句是不可满足的
chap4_para778,1,,通过检验的不可满足性，可以从证明，这正是数学证明方法中标准的归谬法（reductio ad absurdum，意为“归结为荒谬之物”）。
chap4_para778,2,,它也被称为反证法或矛盾法。
chap4_para778,3,,假设为假，并证明这会导致与已知公理矛盾，这个矛盾的含义与声明语句是不可满足的完全相同。
chap4_para779,1,,7.5.1　推断与证明
chap4_para78,1,"For many problems, the most effective algorithm is the venerable Newton–Raphson method. This is a general technique for finding roots of functions—that is, solving equations of the form g(x) = 0. It works by computing a new estimate for the root x according to Newton’s formula",
chap4_para780,1,,本节介绍可以用于推导证明的推断规则。
chap4_para780,2,,证明是一系列可以引向所需目标的结论。
chap4_para780,3,,最著名的规则是肯定前件（Modus Ponens，mode that affirms的拉丁语），写作
chap4_para781,1,,它的意思是，当给出和具有形式的语句时，可以推导出语句。
chap4_para781,2,,例如，如果给出，并且已知，可以推导出Shoot。
chap4_para782,1,,另一个有用的推断规则是合取消去（and-elimination），即可以从一个合取式推导出任一合取子句：
chap4_para783,1,,例如，由，可推导出WumpusAlive。
chap4_para784,1,,通过考虑和的可能真值，可以证明肯定前件和合取消去是可靠的。
chap4_para784,2,,这些规则可用于任意适用的实例，不必枚举所有模型就可以生成可靠的推断。
chap4_para785,1,,图7-11所示的所有逻辑等价都可以用作推断规则。
chap4_para785,2,,例如，等价消去可以产生两条推断规则：
chap4_para786,1,,并非所有推断规则都能像上面这样双向适用。
chap4_para786,2,,例如，不能反向运用肯定前件规则，从得出和。
chap4_para787,1,,让我们来看看这些推断规则和等价关系是如何应用于wumpus世界的。
chap4_para787,2,,"我们从含有R1到R5的知识库开始，演示如何证明，即证明[1, 2]中没有无底洞。"
chap4_para788,1,,（1）对R2使用等价消去，得到
chap4_para789,1,,（2）对R6使用合取消去，得到
chap4_para79,1,"To find a maximum or minimum of f, we need to find x such that the gradient is a zero vector (i.e., ∇f(x) = 0). Thus, g(x) in Newton’s formula becomes ∇f(x), and the update equation can be written in matrix–vector form as",[3]　一般来说，牛顿-拉弗森更新可以看作在x处用一个二次曲面拟合f，下一步则直接移动到该曲面的最小值——如果f是二次的，则也是f的最小值。
chap4_para790,1,,（3）假言易位逻辑等价关系得到
chap4_para791,1,,（4）对R8和感知R4（即）使用肯定前件，得到
chap4_para792,1,,（5）使用德摩根律，得到结论
chap4_para793,1,,"也就是，[1, 2]和[2, 1]都没有无底洞。"
chap4_para794,1,,应用第3章的任意搜索算法都可以找到构成这种证明的一系列步骤。
chap4_para794,2,,只需要定义如下的证明问题。
chap4_para795,1,,● 初始状态（Initial State）：最初的知识库。
chap4_para796,1,,● 动作（Actions）：动作的集合，它包含所有推断规则应用于所有符合上半部分推断规则的语句。
chap4_para797,1,,● 结果（Result）：一个动作的结果是将推断规则下半部分的语句实例加入知识库。
chap4_para798,1,,● 目标（Goal）：目标是含有我们试图证明的语句的状态。
chap4_para799,1,,这样，搜索证明就可以替代枚举模型。
chap4_para799,2,,在许多实际案例中，找出某种证明的效率更高，因为证明可以忽略许多无关的命题，不论这种命题有多少。
chap4_para799,3,,"例如，刚才给出的，得出的证明并没有提及命题B2,1、P1,1、P2,2或P3,1。"
chap4_para799,4,,"由于目标命题P2,1只出现于语句R2，因此可以忽略它们；而R2中的其他命题只出现在R4和R2中，因此R1、R3和R5与证明无关。"
chap4_para799,5,,即使在知识库中再添加一百万条语句，这一结果依然成立。
chap4_para799,6,,而简单的真值表算法将无法承受这种模型的指数级爆炸式增长。
chap4_para8,1,"To understand local search, consider the states of a problem laid out in a state-space landscape, as shown in Figure 4.1. Each point (state) in the landscape has an “elevation,” defined by the value of the objective function. If elevation corresponds to an objective function, then the aim is to find the highest peak—a global maximum—and we call the process hill climbing. If elevation corresponds to cost, then the aim is to find the lowest valley—a global minimum—and we call it gradient descent.",图4-1　一维状态空间地形图，其标高对应于目标函数。
chap4_para8,2,,目的是找到全局极大值
chap4_para80,1,"where Hf (x) is the Hessian matrix of second derivatives, whose elements Hij are given by ∂2f/∂xi∂xj. For our airport example, we can see from Equation (4.2) that Hf (x) is particularly simple: the off-diagonal elements are zero and the diagonal elements for airport i are just twice the number of cities in Ci. A moment’s calculation shows that one step of the update moves airport i directly to the centroid of Ci, which is the minimum of the local expression for f from Equation (4.1).3 For high-dimensional problems, however, computing the n2 entries of the Hessian and inverting it may be expensive, so many approximate versions of the Newton–Raphson method have been developed.",局部搜索方法在连续状态空间和离散状态空间中一样，同样受到局部极大值、岭和平台区的影响。
chap4_para80,2,,随机重启和模拟退火通常很有用。
chap4_para80,3,,然而，高维连续空间非常大，算法很容易陷入困境。
chap4_para800,1,,逻辑系统的最后一个属性是单调性，它表明蕴含的语句集只能随着信息被加入知识库而增长。
chap4_para800,2,,[9]对于任意语句和，
chap4_para802,1,,[9]　违反单调性的非单调逻辑刻画了人类推理的常见性质：改变想法。
chap4_para802,2,,我们将在10.6节对其进行讨论。
chap4_para804,1,,例如，假设知识库含有额外的断言，它表明世界中恰好有8个无底洞。
chap4_para804,2,,"这条知识可能有助于智能体得出额外的结论，但它不能使任何已经得出的结论失效，例如[1,2]中没有无底洞这样的结论。"
chap4_para804,3,,单调性意味着只要在知识库中找到合适的前提，就可以使用推断规则——规则的结论必然是合理的，不论知识库中还有什么东西。
chap4_para805,1,,7.5.2　通过归结证明
chap4_para806,1,,我们已经论证了目前所说的推断规则是可靠的，但还没讨论过使用这些规则的推断算法的完备性问题。
chap4_para806,2,,像迭代加深搜索（3.4.4节）这样的搜索算法能够找到任意的可达目标，从这种意义上说它是完备的；但如果可用的推断规则不充分，则目标是不可达的——仅使用这些推断规则的证明是不存在的。
chap4_para806,3,,例如，如果去掉等价消去规则，7.5.1节所述的证明就行不通了。
chap4_para806,4,,本节我们只介绍一个推断规则——归结（resolution），当它与任意完备的搜索算法结合后，可以产生一个完备的推断算法。
chap4_para807,1,,我们从在wumpus世界使用简单的归结规则入手。
chap4_para807,2,,"考虑导致图7-4a所示状态的步骤开始：智能体从[2, 1]返回到[1, 1]，然后走到[1, 2]，它在此处感知到臭味，但没有微风。"
chap4_para807,3,,我们将如下事实添加到知识库中：
chap4_para808,1,,"用先前推得R10时使用的相同步骤，可以推出[2, 2]和[1, 3]中没有无底洞（别忘了已知[1, 1]中没有无底洞）："
chap4_para809,1,,"还可以对R3使用等价消去，然后对R5使用肯定前件，以得到[1, 1]、[2, 2]或[3, 1]中有无底洞的事实："
chap4_para81,1,"Local search methods suffer from local maxima, ridges, and plateaus in continuous state spaces just as much as in discrete spaces.",最后一个话题是约束优化（constrained optimization）。
chap4_para81,2,Random restarts and simulated annealing are often helpful.,如果一个优化问题的解必须满足对变量值的一些硬性约束，那么这个问题就是受约束的。
chap4_para81,3,"High-dimensional continuous spaces are, however, big places in which it is very easy to get lost.",例如，在机场选址问题中，我们可能会将选址限制在罗马尼亚境内的陆地上（而不是某个湖中心）。
chap4_para81,4,,约束优化问题的难度取决于约束和目标函数的性质。
chap4_para81,5,,最著名的一类问题是线性规划（linear programming）问题，其约束必须是能构成凸集的线性不等式[4]，目标函数也必须是线性的。
chap4_para81,6,,线性规划的时间复杂性是关于变量数目的多项式。
chap4_para810,1,,"现在我们首次运用归结规则：R13中的文字与R15中的文字P2,2归结，得到归结句（resolvent）"
chap4_para811,1,,"用自然语言描述：如果[1, 1]、[2, 2]或[3, 1]中必有无底洞，而[2, 2]中没有无底洞，则无底洞在[1, 1]或[3, 1]中。"
chap4_para811,2,,"类似地，R1中的文字与R16中的文字P1,1归结，得到"
chap4_para812,1,,"用自然语言描述：如果[1, 1]或[3, 1]中有无底洞，无底洞又不在[1, 1]中，则它在[3, 1]中。"
chap4_para812,2,,最后两步推断采用了单元归结（unit resolution）规则
chap4_para813,1,,其中每个都是文字，而和m是互补文字（即各自是对方的否定）。
chap4_para813,2,,这样，单元归结推断规则使用一个子句（文字的析取式）以及一个文字，生成一个新的子句。
chap4_para813,3,,注意，单个文字可看作是一个文字的析取式，也被称为单元子句。
chap4_para814,1,,单元归结规则可以推广为全归结规则
chap4_para815,1,,其中，li和mj是互补文字。
chap4_para815,2,,这表明归结使用两个子句并产生一个新的子句，该新子句包含除一对互补文字以外的原始子句的所有文字，例如，我们有
chap4_para816,1,,可以一次只归结一对互补文字。
chap4_para816,2,,例如，可以归结P和推得
chap4_para817,1,,但不能同时归结P和Q来推得R。
chap4_para817,2,,归结规则还有一个技术细节：结果子句只能含有每个文字的一个副本。
chap4_para817,3,,[10]去除文字的多个副本被称为因子提取。
chap4_para817,4,,例如，如果我们用归结，得到，通过因子提取简化为A。
chap4_para819,1,,[10]　如果一个子句被视作文字的集合，则这条限制自然地适用。
chap4_para819,2,,对子句使用集合的概念可以使归结规则更简洁，但代价是引入了额外的记号。
chap4_para82,1,A final topic is constrained optimization.,
chap4_para82,2,An optimization problem is constrained if solutions must satisfy some hard constraints on the values of the variables.,
chap4_para82,3,"For example, in our airport-siting problem, we might constrain sites to be inside Romania and on dry land (rather than in the middle of lakes).",
chap4_para82,4,The difficulty of constrained optimization problems depends on the nature of the constraints and the objective function.,
chap4_para82,5,"The best-known category is that of linear programming problems, in which constraints must be linear inequalities forming a convex set4 and the objective function is also linear.",
chap4_para82,6,The time complexity of linear programming is polynomial in the number of variables.,
chap4_para820,1,,通过对文字和另一个子句中的互补文字mj的讨论，我们可以很容易理解归结规则的可靠性。
chap4_para820,2,,如果为真，则mj为假，因此必然为真，因为已知。
chap4_para820,3,,如果为假，则必为真，因为已知。
chap4_para820,4,,现无论为真还是为假，结论必然成立，这与归结法则所述的完全相同。
chap4_para821,1,,归结法则更为惊人的部分在于，它形成了一类完备推断过程的基础。
chap4_para821,2,,基于归结的定理证明器可以对命题逻辑中的任意语句和确定是否成立。
chap4_para821,3,,接下来的“合取范式”和“归结算法”两小节将解释归结是如何完成这项任务的。
chap4_para823,1,,归结规则仅适用于子句（也就是文字的析取式），因此它似乎只能用于含有子句的知识库和查询。
chap4_para823,2,,那么对于所有命题逻辑，它如何实现完备的推断过程？
chap4_para823,3,,答案是，命题逻辑的所有语句逻辑上都等价于子句合取式。
chap4_para824,1,,形式为子句合取式的语句被称为合取范式（conjunctive normal form）或CNF（见图7-12）。
chap4_para824,2,,下面介绍把语句转换为CNF的过程。
chap4_para824,3,,我们通过将语句 转换为CNF来阐明这一过程。
chap4_para824,4,,转换的步骤如下。
chap4_para825,1,,（1）消去，将替换为：
chap4_para826,1,,（2）消去，将替换为
chap4_para827,1,,（3）CNF要求只能在文字前出现，因此我们反复应用图7-11的如下等价关系“将内移”：
chap4_para83,1,Linear programming is probably the most widely studied and broadly useful method for optimization.,[4]　如果点集S中任意两点的连线也包含在S中，则称S是凸的。
chap4_para83,2,"It is a special case of the more general problem of convex optimization, which allows the constraint region to be any convex region and the objective to be any function that is convex within the constraint region.",凸函数（convex function）是指其上方空间构成凸集的函数；根据定义，凸函数没有局部（相对于全局）极小值。
chap4_para83,3,"Under certain conditions, convex optimization problems are also polynomially solvable and may be feasible in practice with thousands of variables.",
chap4_para83,4,Several important problems in machine learning and control theory can be formulated as convex optimization problems (see Chapter 21).,
chap4_para831,1,,本例中，我们只需运用最后一条规则一次：
chap4_para832,1,,（4）现在我们得到了一个∧和∨嵌套、运算符直接作用于文字的语句。
chap4_para832,2,,运用图7-11的分配律，尽可能地对∧分配∨：
chap4_para833,1,,原始语句现在已经成为CNF，是3个子句的合取式。
chap4_para833,2,,它读起来难了很多，但它可以作为归结过程的输入。
chap4_para834,1,,图7-12　合取范式、霍恩子句、确定子句、目标子句的文法。
chap4_para834,2,,形式如这样的CNF子句可以写成确定子句
chap4_para836,1,,基于归结的推断过程使用7.5.1节介绍的反证法来进行证明。
chap4_para836,2,,也就是说，为了证明，我们要证明是不可满足的。
chap4_para836,3,,我们通过证明矛盾来做到这一点。
chap4_para837,1,,图7-13展示了一个归结算法。
chap4_para837,2,,首先，被转换为CNF。
chap4_para837,3,,然后，归结规则被应用在得到的子句上。
chap4_para837,4,,每一对互补文字都被归结生成新的子句，如果新子句没有出现过，就将其加入子句集合。
chap4_para837,5,,这一过程不断持续，直到发生下述的两件事情之一。
chap4_para838,1,,● 没有可供添加的新子句，此时KB不蕴含；
chap4_para839,1,,● 两个子句归结为空子句，此时KB蕴含。
chap4_para84,1,4.,线性规划可能是最广泛研究和最有用的优化方法。
chap4_para84,2,3Search with Nondeterministic Actions,它是更一般的凸优化（convex optimization）问题的一种特例，允许约束区域为任意凸区域，目标函数为约束区域内的任意凸函数。
chap4_para84,3,,在一定条件下，凸优化问题也是多项式时间内可解的，即使有上千个变量，也可能是实际可行的。
chap4_para84,4,,机器学习和控制理论中的几个重要问题可以形式化为凸优化问题（见第20章）。
chap4_para840,1,,图7-13　简单的命题逻辑归结算法。
chap4_para840,2,,PL-Resolve返回对其两个输入进行归结得到的所有可能子句集合
chap4_para841,1,,空子句是一个没有析取子句的析取式，它等价于False，因为仅当至少一个析取子句为真时析取式为真。
chap4_para841,2,,另外，空子句仅在归结两个矛盾的单元子句（如P和）时出现。
chap4_para842,1,,我们可以将归结过程用在wumpus世界中一个很简单的推断中。
chap4_para842,2,,"当智能体位于[1,1]时，该处没有微风，因此相邻的方格没有无底洞。"
chap4_para842,3,,相关的知识库是
chap4_para843,1,,我们要证明，即。
chap4_para843,2,,如果将转换为CNF，我们就能得到在图7-14顶部所示的子句。
chap4_para843,3,,该图的第二行列出了归结第一行后的子句。
chap4_para843,4,,"随后，当P1,2与归结后，我们得到了空子句，用小方块表示。"
chap4_para843,5,,观察图7-14，可以发现许多归结是毫无意义的。
chap4_para843,6,,例如，子句等价于，进而等价于True。
chap4_para843,7,,推出True为真并没有什么用处。
chap4_para843,8,,因此，我们可以忽略所有含有两个互补文字的子句。
chap4_para844,1,,图7-14　对wumpus世界的一个简单推断部分运用PL-Resolution来证明查询。
chap4_para844,2,,顶行最左侧的4个子句的每一个与其他3个都互相成对，运用归结规则产生底行的子句。
chap4_para844,3,,"顶行的第3个和第4个子句结合生成，它继而与P1,2归结，生成空子句，表明查询被证明"
chap4_para846,1,,作为对归结的讨论的总结，现在来了解为何PL-Resolution是完备的。
chap4_para846,2,,为此，我们引入子句集合S的归结闭包（resolution closure）RC(S)，即对S中子句及其生成子句反复使用归结规则可推得的所有子句的集合。
chap4_para846,3,,归结闭包就是RL-Resolution计算所得的变量clauses的最终值。
chap4_para846,4,,"易知RC(S)必然是有限的：得益于因子提取，由S中出现的符号P1, …, Pk得出的子句数量是有限的。"
chap4_para846,5,,因此，PL-Resolution总是能够终止。
chap4_para847,1,,命题逻辑中归结的完备性定理被称为基本归结定理（ground resolution theorem）：
chap4_para848,1,,如果一个子句集是不可满足的，则这些子句的归结闭包含有空子句。
chap4_para849,1,,定理的证明是通过其假言易位进行的：如果闭包RC(S)不含有空子句，则S可满足。
chap4_para849,2,,"实际上，可以为S构建一个在P1, …, Pk上有适当真值的模型。"
chap4_para849,3,,构建过程如下：
chap4_para85,1,"In Chapter 3, we assumed a fully observable, deterministic, known environment. Therefore, an agent can observe the initial state, calculate a sequence of actions that reach the goal, and execute the actions with its “eyes closed,” never having to use its percepts.",4.3　使用非确定性动作的搜索
chap4_para851,1,,"● 如果RC(S)中的子句含有文字且所有其他文字在对P1, …, Pi−1选定的赋值下为假，则对Pi赋值为false；"
chap4_para852,1,,● 否则，对Pi赋值为true。
chap4_para853,1,,"对P1, …, Pk的赋值是S的一个模型。"
chap4_para853,2,,要搞清楚这一点，我们假设其反面——在序列中的某处i，对符号Pi赋值使得某个子句C为假。
chap4_para853,3,,"此时，情况必然是C中所有其他文字都已经被对P1, …, Pi−1的赋值定为假。"
chap4_para853,4,,因此，C的形式必然类似或。
chap4_para853,5,,如果只有其中一个在RC(S)中，则算法将对Pi赋适当的值以使C为真，因此仅在这两个子句都在RC(S)中时，C才会为假。
chap4_para854,1,,"现在，由于RC(S)在归结时是闭的，它会含有这两个子句的归结句，且这个归结句的所有文字已经被对P1, …, Pi−1的赋值定为假。"
chap4_para854,2,,这与我们的假设，即第一个为假的子句出现在i处矛盾。
chap4_para854,3,,因此，我们证明了这种构建永远无法使RC(S)中的子句为假，也就是说它创建了一个RC(S)的模型。
chap4_para854,4,,最后，由于S包含在RC(S)中，因此任意RC(S)的模型也是S本身的模型。
chap4_para855,1,,7.5.3　霍恩子句与确定子句
chap4_para856,1,,归结的完备性使其成为一种非常重要的推断方法。
chap4_para856,2,,而许多实际情形并不需要用到归结的全部能力。
chap4_para856,3,,一些真实世界的知识库中的语句满足某些限制，这使得它们可以使用更为受限而更高效的推断算法。
chap4_para857,1,,其中一种受限形式是确定子句（definite clause），它是文字的析取式，其中只有一个为正文字。
chap4_para857,2,,例如，子句是确定子句而不是，因为它含有两个正文字。
chap4_para858,1,,更一般性的是霍恩子句（Horn clause），它是文字的析取式，其中最多只有一个为正文字。
chap4_para858,2,,因此所有的确定子句都是霍恩子句，没有正文字的子句也是霍恩子句——也被称为目标子句（goal clause）。
chap4_para858,3,,霍恩子句在归结时是闭的：如果归结两个霍恩子句，仍然会得到霍恩子句。
chap4_para858,4,,还有一种类型是k-CNF语句，它是每个子句最多含有k个文字的CNF语句。
chap4_para859,1,,仅含有确定子句的知识库很有意义，原因有3个。
chap4_para86,1,"When the environment is partially observable, however, the agent doesn’t know for sure what state it is in; and when the environment is nondeterministic, the agent doesn’t know what state it transitions to after taking an action. That means that rather than thinking “I’m in state s1 and if I do action a I’ll end up in state s2,” an agent will now be thinking “I’m either in state s1 or s3, and if I do action a I’ll end up in state s2, s4 or s5.” We call a set of physical states that the agent believes are possible a belief state.",在第3章中，我们假设环境为完全可观测的、确定性的、已知的。
chap4_para86,2,,因此，智能体可以观测到初始状态，计算出可以到达目标的动作序列，然后“闭着眼睛”执行这些动作，而不需要使用自己的感知。
chap4_para860,1,,（1）每个确定子句都可以写成一个蕴涵式，前提是正文字的合取式，结论是一个正文字。
chap4_para860,2,,（见习题7.DISJ。
chap4_para860,3,,）例如，确定子句可以写成蕴涵式。
chap4_para860,4,,"蕴涵形式的语句更容易理解：它说明如果智能体位于[1, 1]，且感知到微风，则[1, 1]有微风。"
chap4_para860,5,,在霍恩形式中，前提被称为体（body）而结论被称为头（head）。
chap4_para860,6,,"由单个正文字构成的语句，例如L1,1，被称为事实（fact）。"
chap4_para860,7,,"它也可以写成形式的蕴涵式，但只写成L1,1更为简洁。"
chap4_para861,1,,（2）用霍恩子句进行推断可以通过前向链接（forward-chaining）算法和反向链接（backward-chaining）算法完成，我们稍后会介绍。
chap4_para861,2,,这些算法都很自然，因为它们的推断步骤很直观，便于人类理解。
chap4_para861,3,,这类推断是逻辑编程（logic programming）的基础，我们将在第9章进行讨论。
chap4_para862,1,,（3）用霍恩子句确定蕴含关系所需的时间与知识库大小呈线性关系，这格外令人满意。
chap4_para863,1,,7.5.4　前向链接与反向链接
chap4_para864,1,,"前向链接算法PL-FC-Entails?(KB,q)确定单个命题符号q（即查询）是否被确定子句的知识库所蕴含。"
chap4_para864,2,,它从知识库中的已知事实（正文字）开始。
chap4_para864,3,,如果一个蕴涵式的所有前提都已知，则将其结论添加到已知事实的集合中。
chap4_para864,4,,"例如，如果L1,1和Breeze已知，且在知识库中，则在知识库中添加B1,1。"
chap4_para864,5,,这一过程持续进行，直到查询q被添加，或直到无法进一步进行推断。
chap4_para864,6,,这一算法在图7-15中展示，我们要记住的要点是它的运行时间是线性的。
chap4_para865,1,,用图和示例来理解算法是最好的办法。
chap4_para865,2,,图7-16a展示了一个简单的霍恩子句知识库，其中有A和B两个已知事实。
chap4_para865,3,,图7-16b展示了绘制为与或图（见第4章）的同一个知识库。
chap4_para865,4,,在与或图中，用曲线连接的多个边表示一个合取式，每个边都要证明；而没有曲线连接的多个边表示一个析取式，证明任一边即可。
chap4_para865,5,,图上很容易看懂前向链接是如何运作的。
chap4_para865,6,,已知的叶节点（此处为A和B）具有真值之后，推断就会沿着图尽可能远地向上传递。
chap4_para865,7,,当出现合取式时，传递过程开始等待，直到所有合取子句都已知。
chap4_para865,8,,我们鼓励读者细致地研究这个示例。
chap4_para866,1,,图7-15　命题逻辑的前向链接算法。
chap4_para866,2,,queue记录了已知为真但还没“处理过”的符号。
chap4_para866,3,,表count记录每个蕴涵式尚未证明的前提数量。
chap4_para866,4,,一旦queue中的新符号p被处理，count就会为每个前提中出现p的蕴涵式减1（使用合适的索引方法，很容易在常数时间内完成）。
chap4_para866,5,,如果count为0，则蕴涵式的所有前提都已知，因此其结论可以添加到queue。
chap4_para866,6,,最后，我们还需要记录哪个符号已经被处理过，如此在已推断符号集inferred中的符号就无需被再次加入queue。
chap4_para866,7,,这避免了重复的工作，也避免了由类似P⇒Q和Q⇒P这样的蕴涵式引起的循环
chap4_para867,1,,图7-16　（a）一个霍恩子句集。
chap4_para867,2,,（b）相应的与或图
chap4_para868,1,,显然，前向链接是可靠的：每个推断实际上都是对肯定前件的运用。
chap4_para868,2,,前向链接也是完备的：所有蕴含的原子语句都将被推得。
chap4_para868,3,,要理解这一点，最简单的方法是考虑（在算法到达不动点，无法产生新推断的时候）inferred表格的最终状态。
chap4_para868,4,,该表中每个推得的符号都为真，所有其他符号都为假。
chap4_para868,5,,我们可以将这个表看作一个逻辑模型，且原始KB的每条确定子句在这个模型中都为真。
chap4_para869,1,,为理解这一点，可以假设其反面，即存在子句在模型中为假。
chap4_para869,2,,则在模型中必然为真，且b在模型中必然为假。
chap4_para869,3,,这与我们假设的算法已经到达不动点相矛盾，因为我们此时可以将b加入知识库。
chap4_para869,4,,因此我们可以断定，不动点处推得的原子语句集定义了一个原始知识库的模型。
chap4_para869,5,,更进一步地，知识库蕴含的任意原子语句q必然在其所有模型中都为真，在这个特定模型中也一样。
chap4_para869,6,,因此，所有蕴含的原子语句q必然会被算法推得。
chap4_para87,1,"In partially observable and nondeterministic environments, the solution to a problem is no longer a sequence, but rather a conditional plan (sometimes called a contingency plan or a strategy) that specifies what to do depending on what percepts agent receives while executing the plan.",然而，当环境部分可观测时，智能体并不确定它处于什么状态；当环境是非确定性的时，智能体不知道在执行某个动作后将转移到什么状态。
chap4_para87,2,We examine nondeterminism in this section and partial observability in the next.,这意味着智能体所思考的不再是“我现在位于s1状态，如果我执行a动作，我将会进入s2状态”，而是“我现在位于s1或s3状态，如果我执行a动作，我将会进入s2、s4或s5状态”。
chap4_para87,3,,我们把智能体认为其可能位于的物理状态集合称为信念状态（belief state）。
chap4_para870,1,,前向链接是数据驱动（data-driven）推理这一更广泛概念的例子，也就是其注意力开始集中在已知数据的推理。
chap4_para870,2,,它可以用于智能体，以便从收到的感知推导出结论，且常常是在没有特定查询的情况下。
chap4_para870,3,,例如，wumpus世界的智能体可以用递增前向链接算法（即新的事实可以被加入队列来启动新的推断）将它的感知告知知识库。
chap4_para870,4,,对人类来说，当获取新信息后会出现一定数量的数据驱动推理。
chap4_para870,5,,例如，如果我在屋子里听到外面开始下雨，则我可能会想到取消野餐；但是，我大概不会想到邻居花园里最大的一朵玫瑰的第17片花瓣会淋湿——人类会对前向链接进行精心地控制，以免被无关的结果淹没。
chap4_para871,1,,反向链接算法如其名称所示，从查询开始反向运作。
chap4_para871,2,,如果查询q已知为真，则不需要做任何操作。
chap4_para871,3,,否则，算法将在知识库中找寻结论为q的蕴涵式。
chap4_para871,4,,如果这些蕴涵式的所有前提都可以（用反向链接）证明为真，则q为真。
chap4_para871,5,,将反向链接算法用于图7-16的查询Q时，它反向地向图的下方运行，直到到达构成证明基础的已知事实集，即A和B。
chap4_para871,6,,算法实质上与图4-11的And-Or-Graph-Search算法完全相同。
chap4_para871,7,,与前向链接一样，它的高效实现的时间复杂性是线性的。
chap4_para872,1,,反向链接是一种目标导向推理（goal-directed reasoning）。
chap4_para872,2,,它对于回答类似“我现在该做什么？
chap4_para872,3,,”和“我的钥匙在哪里？
chap4_para872,4,,”这样的特定问题非常有用。
chap4_para872,5,,通常，反向链接的代价远小于知识库规模的线性变化，因为这个过程仅涉及相关的事实。
chap4_para873,1,,7.6　高效命题模型检验
chap4_para874,1,,本节，我们介绍两种高效的、基于模型检验的一般命题推断的算法，其中一种是基于回溯搜索的，另一种则基于局部爬山搜索。
chap4_para874,2,,这些算法是命题逻辑的“技术”部分。
chap4_para874,3,,首次阅读本章时可以略过本节内容。
chap4_para875,1,,我们描述的算法是用于可满足性检验的，即SAT问题。
chap4_para875,2,,（如7.5节所述，可以通过检验的不可满足性来检验蕴含。
chap4_para875,3,,）我们在7.5节中提到过找到满足逻辑语句的模型与找到约束满足问题的解的关系，因此这两种命题可满足性算法与6.3节的回溯算法和6.4节的局部搜索算法非常相似并不令人意外。
chap4_para875,4,,尽管如此，这些算法本身还是极为重要的，因为许多计算机科学中的组合问题都可以被归为检验命题语句的可满足性。
chap4_para875,5,,对可满足性算法的任何改进对于我们处理复杂性的能力都有巨大的作用。
chap4_para876,1,,7.6.1　完备的回溯算法
chap4_para877,1,,"我们要探讨的第一个算法常称为戴维斯-普特南算法（Davis-Putnam algorithm），得名于马丁·戴维斯（Martin Davis）和希拉里·普特南（Hilary Putnam）的重要论文（Davis and Putnam, 1960）。"
chap4_para877,2,,"这个算法实际上采用的是戴维斯、洛吉曼和洛夫兰所描述的版本（Davis, Logemann, and Loveland, 1962），因此我们用所有4位作者姓氏的首字母DPLL命名这个算法。"
chap4_para877,3,,DPLL使用一个合取范式形式（即一个子句集）的语句作为输入。
chap4_para877,4,,类似于Backtracking-Search和TT-Entails?，它本质上是递归地、深度优先地枚举可能的模型。
chap4_para877,5,,它在TT-Entails?的基础上进行了3项改进。
chap4_para878,1,,● 提前终止：算法可以用部分完成的模型来检测语句是否必然为真或为假。
chap4_para878,2,,如果任一文字为真则子句为真，即使其他文字还没有真值；这样，整条语句在模型完成之前就可以断定其真值。
chap4_para878,3,,例如，若A为真则语句为真，无论B和C的值是什么。
chap4_para878,4,,类似地，若任一子句为假，即其所有文字为假，则语句为假。
chap4_para878,5,,同样，这种情形可能会在模型完成前很久就发生。
chap4_para878,6,,提前终止避免了在搜索空间中检查全部子树。
chap4_para879,1,,● 纯符号启发式方法：纯符号是指在所有子句中“符号位”都相同的符号。
chap4_para879,2,,例如，在3个子句、和中，A是纯符号，因为它只以正文字的形式出现；B也是纯符号，因为它总以负文字的形式出现。
chap4_para879,3,,而C是不纯的。
chap4_para879,4,,易知如果一条语句有模型，则存在一个模型对纯符号的赋值使其文字为真，因为这样做不会使子句为假。
chap4_para879,5,,注意，在确定符号是否为纯时，算法可以忽略当前已构建的模型中已知为真的子句。
chap4_para879,6,,例如，如果上述模型含有B=false，则子句已经为真，且在剩余子句中C仅作为正文字出现，因此C变为纯符号。
chap4_para88,1,4.,在部分可观测的和非确定性的环境中，问题的解不再是一个序列，而是一个条件规划（conditional plan）（有时也称为应变规划或策略），条件规划根据智能体在执行规划时接收到的感知来指定动作。
chap4_para88,2,3.,本节先讨论非确定性，部分可观测性留待4.4节讨论。
chap4_para88,3,1The erratic vacuum world,
chap4_para880,1,,● 单元子句启发式方法：之前对单元子句的定义是只有一个文字的子句。
chap4_para880,2,,在DPLL中，它也指那些除了一个文字外，其余文字都被模型赋值为false的子句。
chap4_para880,3,,例如，如果模型含有B = true，则简化为，这是一个单元子句。
chap4_para880,4,,显然，要使这个子句为真，C必须赋值为false。
chap4_para880,5,,单元子句启发式方法在余下的部分出现分支前对所有这样的符号赋值。
chap4_para880,6,,这种启发式的一个重要结果是，所有对知识库中的已有文字进行的证明（通过反证法）将立刻得证（见习题7. KNOW）。
chap4_para880,7,,还要注意的是，对一个单元子句赋值可能会创建另一个单元子句，例如，当C被置为假，也变成了单元子句，使得A被赋值为真。
chap4_para880,8,,这种强制赋值的“级联”被称为单元传播（unit propagation）。
chap4_para880,9,,这类似于确定子句的前向链接。
chap4_para880,10,,实际上，如果CNF表达式仅含有确定子句，则DPLL本质上复制了前向链接。
chap4_para880,11,,（见习题7. DPLL。
chap4_para880,12,,）
chap4_para881,1,,DPLL算法如图7-17所示，它给出了搜索程序的主要结构，但并未实现其细节。
chap4_para882,1,,图7-17　用于检验命题逻辑语句可满足性的DPLL算法。
chap4_para882,2,,Find-Pure-Symbol和Find-Unit-Clause背后的思路在正文中进行了介绍。
chap4_para882,3,,这两个函数都返回一个符号（或返回空）以及要赋给这个符号的真值。
chap4_para882,4,,和TT-Entails?一样，DPLL在部分模型上运行
chap4_para883,1,,图7-17没有展示使SAT求解器能够用于大规模问题的技巧。
chap4_para883,2,,有趣的是，这些技巧实际上都很寻常，我们之前已经见过它们的其他形式。
chap4_para884,1,,（1）分量分析（如CSP中的塔斯马尼亚岛问题所见）：当DPLL为变量赋真值时，子句集可能会被分割成不相交的子集，我们称之为分量，它们没有共同的未赋值变量。
chap4_para884,2,,给定一个高效探测这一状况的方法，求解器就可以通过对每个分量独立求解来加快速度。
chap4_para885,1,,（2）变量排序与值排序（如在6.3.1节的CSP中所见）：我们对DPLL的简单实现使用任意的变量顺序，并在赋值时总是先尝试赋真再尝试赋假。
chap4_para885,2,,度启发式算法（6.3.1节）建议在所有剩余子句中优先选择最常出现的变量。
chap4_para886,1,,（3）智能回溯（如在6.3.3节的CSP中所见）：许多用按时序回溯几小时都求解不了的问题，如果改用智能回溯直接回溯到导致冲突的相关点上，那么问题可以在几秒内求解。
chap4_para886,2,,所有运用智能回溯的SAT求解器都使用冲突子句学习的某种形式来记录冲突，以避免在后续的搜索中重复出现。
chap4_para886,3,,通常只保留有限大小的冲突集，丢弃极少使用的冲突。
chap4_para887,1,,（4）随机重启（在4.1.1节用于爬山法）：有时单次运行似乎无法取得进展。
chap4_para887,2,,此时，我们可以从搜索树的顶端重新开始，而非尝试继续搜索。
chap4_para887,3,,重启后（对变量和值选取）进行不同的随机选择。
chap4_para887,4,,第一次运行中学习到的子句在重启后依然被保留，这有助于对搜索空间进行剪枝。
chap4_para887,5,,重启并不保证能更快地找到解，但它能够减小求解时间的方差。
chap4_para888,1,,（5）聪明索引（在许多算法中可以见到）：DPLL和其他现代求解器用到的加速方法需要快速索引“Xi作为正文字出现的子句集合”。
chap4_para888,2,,这一任务相当复杂，因为算法所感兴趣的只是先前的变量赋值尚未满足的子句，因此索引结构必须在计算过程中动态更新。
chap4_para889,1,,有了这些改进，现代求解器可以处理有数千万个变量的问题。
chap4_para889,2,,它们为诸如硬件验证和安全协议验证这样的领域带来革命性的变化。
chap4_para889,3,,在此之前，这些领域需要十分费力的、手动证明。
chap4_para89,1,"The vacuum world from Chapter 2 has eight states, as shown in Figure 4.9. There are three actions—Right, Left, and Suck—and the goal is to clean up all the dirt (states 7 and 8). If the environment is fully observable, deterministic, and completely known, then the problem is easy to solve with any of the algorithms in Chapter 3, and the solution is an action sequence. For example, if the initial state is 1, then the action sequence [Suck, Right, Suck] will reach a goal state, 8.",4.3.1　不稳定的真空吸尘器世界
chap4_para890,1,,7.6.2　局部搜索算法
chap4_para891,1,,我们已经在本书中见过了一些局部搜索算法，包括Hill-Climbing（4.1.1节）和Simulated-Annealing（4.1.2节）。
chap4_para891,2,,只要我们选择了正确的评价函数，这些算法可就以被直接用于可满足性问题。
chap4_para891,3,,由于目标是找出满足所有子句的赋值，一个对未满足的子句进行计数的评价函数就可以胜任这项工作。
chap4_para891,4,,实际上，这正是用于CSP的Min-Conflict算法所使用的量度（见6.4节）。
chap4_para891,5,,这些算法都在完全赋值的空间采取动作，每次只翻转一个符号的真值。
chap4_para891,6,,这个空间通常含有许多局部极小值，要跳出这些极小值，需要各种形式的随机方法。
chap4_para891,7,,近年来，人们进行了大量实验，试图在贪婪性与随机性之间找到一个良好的平衡。
chap4_para892,1,,这些算法中最为简单和有效的算法之一是WalkSAT（如图7-18所示）。
chap4_para892,2,,算法每次循环都选择一个未满足的子句，并在该子句中选择一个符号来翻转。
chap4_para892,3,,选择要翻转的符号的方法有两种：（1）最小化新状态中未满足子句的数量的“最小冲突”方法；（2）随机挑选一个符号的“随机游走”方法。
chap4_para892,4,,算法随机选取一种。
chap4_para893,1,,图7-18　通过随机翻转变量的值来检验可满足性的WalkSAT算法。
chap4_para893,2,,这个算法有很多版本
chap4_para894,1,,当WalkSAT返回一个模型时，输入语句就是可满足的。
chap4_para894,2,,但当它返回failure时，则有两种可能的原因：语句不可满足，或我们需要多给算法一些时间。
chap4_para894,3,,如果我们设定且p 0，WalkSAT最终将返回一个模型（如果存在的话），因为随机游走步骤终将遇到一个解。
chap4_para894,4,,如果max_flips为无穷大，而语句不可满足，则算法永远不会终止！
chap4_para895,1,,因此，当我们预计问题有解的时候，WalkSAT最为有用。
chap4_para895,2,,例如，第3章和第6章讨论过的问题通常有解。
chap4_para895,3,,但是，WalkSAT并不总是能检测到不可满足性，而对判定蕴含来说这是必备的。
chap4_para895,4,,例如，wumpus世界中，一个智能体不能使用WalkSAT来可靠地证明一个方格是安全的。
chap4_para895,5,,不过，它可以说：“我思考了一小时，都想不出存在一种这个方格不安全的可能世界。
chap4_para895,6,,”这也许是个不错的经验性指示，表明方格是安全的，但它绝对不是一种证明。
chap4_para896,1,,7.6.3　随机SAT问题概览
chap4_para897,1,,某些SAT问题比其他要难。
chap4_para897,2,,简单的问题可以用任意老算法求解，但由于我们知道SAT是NP完全的，至少有一些问题必须需要指数级的运行时间。
chap4_para897,3,,在第6章中，我们见过一些针对某种问题的惊人发现。
chap4_para897,4,,例如，对于回溯搜索算法，n皇后问题被认为是相当困难的，而对于局部搜索方法，如最小冲突法，求解这一问题却非常容易。
chap4_para897,5,,这是由于在赋值空间中，解的分布非常密集，任意初始赋值都能保证在其附近存在解。
chap4_para897,6,,因此，n皇后问题很简单，因为它是欠约束的（underconstrained）。
chap4_para898,1,,当我们考虑合取范式的可满足性问题时，一个欠约束的问题是约束变量的子句非常少的情形。
chap4_para898,2,,例如，下面是一条随机生成的3-CNF语句，它有5个符号和5个子句：
chap4_para899,1,,在32个可能的赋值中，有16个是这条语句的模型。
chap4_para899,2,,因此，平均而言，只需进行两次随机猜测就可以找到一个模型。
chap4_para899,3,,与大部分这样的欠约束问题一样，这是一个简单的可满足性问题。
chap4_para899,4,,但是，一个过约束的问题很可能没有解，因为相对于其变量数量，其子句数量过多。
chap4_para899,5,,过约束问题通常很容易求解，因为这些约束将很快导致算法找出一个解，或进入无法逃离的死胡同。
chap4_para9,1,"Description The curve starts from the right of the origin and rises toward the upper right until a mid-left point, and remains horizontally constant for a small distance.",4.1.1　爬山搜索
chap4_para9,2,The constant area is labeled shoulder.,
chap4_para9,3,The curve further rises and forms a peak labeled global maximum.,
chap4_para9,4,"The curve further drops to its minimum, rises toward the upper right, and forms a small peak labeled local maximum.",
chap4_para9,5,A point is marked on the rising path toward this peak and is labeled current state.,
chap4_para9,6,"The curve further drops and forms a trough, then again rises, and forms a flat peak, labeled ""flat"" local maximum.",
chap4_para9,7,The curve then further drops toward the lower right and ends at the lower right of the graph.,
chap4_para9,8,The heights of the peak decrease from global maximum to flat local maximum.,
chap4_para90,1,Description A bold arrow labeled suck and another arrow labeled Right from the first state of the vacuum world point to the first two circular nodes.,如图4-9所示，第2章中的真空吸尘器世界具有8种状态。
chap4_para90,2,An arrow from the second node on the right with an arc points back to state 1 and another arrow points to state 2 of the vacuum world.,有3种动作——向左Left、向右Right和吸尘Suck，目标是清理所有的灰尘（状态7和8）。
chap4_para90,3,Two bold arrows from state 2 points outward.,如果环境是完全可观测的、确定性的和完全已知的，那么使用第3章的任意算法都很容易求解这个问题，它的解是一个动作序列。
chap4_para90,4,A bold arrow from the first node points to state 5 of the vacuum world.,"例如，如果初始状态是1，那么动作序列[Suck, Right, Suck]可以到达目标状态8。"
chap4_para90,5,"A bold arrow labeled Right, from state 5, points to the third node with an arc.",
chap4_para90,6,A bold arrow from the third node points back to state 5.,
chap4_para90,7,Another bold arrow from the third node points to state 6 of the vacuum world.,
chap4_para90,8,Two arrows from state 6 points outward.,
chap4_para900,1,,要超越这些基本的直观理解，我们必须明确定义如何生成随机语句。
chap4_para900,2,,"记法CNFk(m, n)表示一个有m个子句、n个符号的k-CNF语句，其中子句是均匀地、独立地、无放回地从所有有k个文字的子句中选取的，文字的正负也是随机的。"
chap4_para900,3,,（一个符号在子句中不能多次出现，一个子句也不能在语句中多次出现。
chap4_para900,4,,）
chap4_para901,1,,给定一个随机语句源，我们就可以测量可满足性的概率。
chap4_para901,2,,"图7-19a绘制了CNF3(m, 50)的概率，也就是有50个变量、每条子句有3个文字的语句，这一概率被绘制为子句/符号，即m/n的函数。"
chap4_para901,3,,如我们预期，对于较小的m/n，可满足性的概率接近0，而在较大的m/n处这一概率接近0。
chap4_para901,4,,概率在m/n = 4.3左右急剧下降。
chap4_para901,5,,经验上，我们发现这一“峭壁”出现在大致相同的位置（对于k = 3），并随着n的增长越来越陡峭。
chap4_para902,1,,"理论上，可满足性阈值猜想（satisfiability threshold conjecture）表明对所有，存在一个阈值比rk，使得当n接近无穷时CNFk(rn, n)可满足的概率对于所有低于阈值的r接近于1，对于所有高于阈值的r接近于0。"
chap4_para902,2,,即便对于如k = 3这样的特例，这一猜想仍未被证明。
chap4_para902,3,,不论这是不是一个定理，这样的阈值效应在可满足性问题和其他类型的NP困难问题中都是相当寻常的。
chap4_para903,1,,现在我们对可满足和不可满足问题分别会出现在什么地方有了很好的了解，接下来的问题是，困难的问题会出现在什么地方？
chap4_para903,2,,其实它们也经常位于阈值处。
chap4_para903,3,,图7-19b显示，阈值4.3处的50个符号的问题比阈值3.3处的相同问题大约难20倍。
chap4_para903,4,,欠约束问题很好求解（因为很容易就能猜到一个解），而过约束问题不如欠约束问题简单，却仍然比恰好在阈值处的问题简单得多。
chap4_para904,1,,图7-19　（a）有n个符号的随机3-CNF语句的可满足概率图，概率是子句/符号比m/n的函数。
chap4_para904,2,,（b）DPLL和WalkSAT在随机3-CNF语句上的（多次运行后测量的）运行时间中位数图。
chap4_para904,3,,最为困难的问题的子句/符号比约为4.3
chap4_para905,1,,7.7　基于命题逻辑的智能体
chap4_para906,1,,本节我们将目前所学的内容结合起来构建使用命题逻辑的wumpus世界智能体。
chap4_para906,2,,首先我们要使智能体能够根据其历史感知对世界的状态尽可能地进行推导。
chap4_para906,3,,这需要写出动作效果的完整逻辑模型。
chap4_para906,4,,随后我们介绍智能体在wumpus世界中如何使用逻辑推断。
chap4_para906,5,,我们还会介绍智能体如何在不查看每次推断的历史感知的情况下有效地跟踪世界的变化。
chap4_para906,6,,最后，我们介绍在已知其知识库在实际世界中为真的情况下，智能体如何使用逻辑推断来构建能确保达到目标的规划。
chap4_para907,1,,7.7.1　世界的当前状态
chap4_para908,1,,如本章开头所述，逻辑智能体通过用关于世界的语句知识库推导接下来的动作来运作。
chap4_para908,2,,知识库由公理（也就是关于世界如何运行的一般知识）和从智能体在某个特定世界获得的感知语句构成。
chap4_para908,3,,本节，我们聚焦于推导wumpus世界的当前状态这一问题，如我在哪里、方格是否安全等。
chap4_para909,1,,我们从7.4.3节开始收集公理。
chap4_para909,2,,智能体知道起始方格没有无底洞（）也没有wumpus（）。
chap4_para909,3,,此外，对于每个方格，它知道当且仅当一个方格的相邻方格有无底洞，该方格有微风；当且仅当一个方格的相邻方格有wumpus，该方格有臭味。
chap4_para909,4,,由此，我们引入了具有如下形式的大量语句：
chap4_para91,1,Figure 4.,图4-9　真空吸尘器世界的8种可能状态；状态7和8是目标状态
chap4_para91,2,9The eight possible states of the vacuum world; states 7 and 8 are goal states.,
chap4_para910,1,,智能体还知道恰恰只有一个wumpus。
chap4_para910,2,,我们用两部分表示。
chap4_para910,3,,首先，我们说至少有一个wumpus：
chap4_para911,1,,然后我们必须说最多只有一个wumpus。
chap4_para911,2,,我们对每对方格添加一个语句，来表明其中至少一个方格没有wumpus：
chap4_para912,1,,到目前为止都还不错。
chap4_para912,2,,现在让我们考虑智能体的感知。
chap4_para912,3,,"我们使用了S1,1来表示[1, 1]有臭味，那么我们可以只用一个命题Stench来表示智能体感知到臭味吗？"
chap4_para912,4,,遗憾的是，不行。
chap4_para912,5,,如果在之前的时间步中没有臭味，就已经被断言，那么新的断言将与之矛盾。
chap4_para912,6,,我们发现，如果感知只对当前时间的事情进行断言，这个问题就很容易求解。
chap4_para912,7,,如此，假如时间步（与输入图7-1中Make-Percept-Sentence的一样）是4，则我们在知识库中添加Stench4而非Stench，这样就能轻松地避免与矛盾。
chap4_para912,8,,对微风、碰撞、闪光和惨叫等感知也同样处理。
chap4_para913,1,,这个将命题与时间步相关联的思路可以拓展到这个世界中所有随时间变化的部分。
chap4_para913,2,,"例如，最初知识库中有——智能体在时刻0位于[1, 1]，以及FacingEast 0、HaveArrow 0和WumpusAlive0。"
chap4_para914,1,,我们使用流（fluent，源于拉丁语fluens，意为流动）来表示世界随时间变化的部分。
chap4_para914,2,,“流”与2.4.7节所述的对因子化表示的讨论中的“状态变量”同义。
chap4_para914,3,,与世界的不变部分相关的符号不需要时间上标，它们有时被称为非时序变量（atemporal variable）。
chap4_para915,1,,我们可以将微风和臭味直接与体验到这些感知的方格的属性连接。
chap4_para915,2,,"[11]对任意时间步t和任意方格[x, y]，我们断言"
chap4_para917,1,,[11]　7.4.3节出于简便考虑，隐藏了这项要求。
chap4_para918,1,,当然，现在我们需要能够使智能体跟进像这样的流的公理。
chap4_para918,2,,智能体采取动作会改变这些流，因此，用第3章的术语来说，我们需要将wumpus世界的转移模型写成逻辑语句的集合。
chap4_para919,1,,首先我们需要表示发生动作的命题符号。
chap4_para919,2,,与感知一样，这些符号用时间索引。
chap4_para919,3,,因此Forward 0表示智能体在时刻0执行前进动作。
chap4_para919,4,,习惯上，给定时间步的感知先发生，然后是这个时间步上的动作，然后是到下一个时间步的转移。
chap4_para92,1,Now suppose that we introduce nondeterminism in the form of a powerful but erratic vacuum cleaner.,现在假设我们以一个功能强大但不稳定的真空吸尘器的形式引入非确定性。
chap4_para92,2,"In the erratic vacuum world, the Suck action works as follows:",在不稳定的真空吸尘器世界中，Suck的工作原理如下。
chap4_para920,1,,为描述世界如何变化，我们可以试着写出指明动作在下一个时间步产生的结果的效应公理（effect axiom）。
chap4_para920,2,,"例如，如果智能体位于[1, 1]，在时刻0时面朝东并向前走，结果是智能体位于方格[2, 1]且不再在[1, 1]："
chap4_para922,1,,对每个可能的时间步、16个方格中的每一个方格、4个方向中的每一个方向我们都需要类似这样的语句。
chap4_para922,2,,对于其他动作，即抓取、射击、攀爬、左转、右转我们也需要类似的语句。
chap4_para923,1,,假设智能体在时刻0决定向前移动，并在其知识库对此进行了断言。
chap4_para923,2,,"给定式（7-1）的效应公理，结合时刻0时对状态的初始断言，智能体可以推得它位于[2, 1]。"
chap4_para923,3,,也就是，Ask。
chap4_para923,4,,到目前为止，一切还好。
chap4_para923,5,,"遗憾的是，如果我们Ask(KB, HaveArrow1)，答案会是假，也就是智能体无法证明它仍然有箭，它也无法证明它没有箭！"
chap4_para923,6,,信息丢失了，因为效应公理没有说明动作的结果未改变哪些状态。
chap4_para923,7,,对这项功能的需求引出了框架问题。
chap4_para923,8,,[12]框架问题的一个可能的求解办法是明确地添加断言所有不变命题的框架公理。
chap4_para923,9,,例如，对于每个时刻t，我们有
chap4_para925,1,,[12]　“框架问题”（frame problem）的名字来源于物理学中的参照系（frame of reference），也就是测量运动时假设的静止背景。
chap4_para925,2,,电影的帧（frame）也借用了它的含义，其中前景变化时，大部分背景保持静止。
chap4_para926,1,,其中明确地提到了在采取前进动作时所有从时刻t到时刻t+1维持不变状态的命题。
chap4_para926,2,,尽管智能体现在已经知道它在前进后仍然有箭，且wumpus没有死去或复活，但激增的框架公理似乎相当低效。
chap4_para926,3,,在有m个不同动作和n个流的世界，框架公理集的大小为O(mn)。
chap4_para926,4,,这种框架问题被称作表示框架问题。
chap4_para926,5,,这个问题在人工智能史上扮演过重要的角色，我们在本章最后的参考文献与历史注释中将进行进一步探索。
chap4_para927,1,,表示框架问题很重要，因为即便保守来说，真实世界中的流也很多。
chap4_para927,2,,幸运的是，对我们人类来说，每个动作改变的流通常不多于k个（k是某个较小的值），也就是说世界具有局部性。
chap4_para927,3,,求解表示框架问题需要定义公理集大小为O(mk)而非O(mn)的转移模型。
chap4_para927,4,,还有一个问题是推断框架问题：将t步动作规划的结果在O(kt)时间而非O(nt)时间内前向推进的问题。
chap4_para928,1,,问题的解是关注于写出关于流而非动作的公理。
chap4_para928,2,,这样的话，对于每个流F，以时刻t时的所有流（包括F本身）和时刻t时可能发生的动作来定义Ft+1的真值的公理。
chap4_para928,3,,现在，Ft+1的真值可以用两种方法之一来确定：一种是时刻t的动作导致F在t+1为真，另一种是F在时刻t已经为真而时刻t的动作没有导致它为假。
chap4_para928,4,,这种形式的公理叫作后继状态公理（successor-state axiom），具有如下形式：
chap4_para929,1,,有箭（HaveArrow）的公理是最简单的后继状态公理。
chap4_para929,2,,因为没有重新装填箭支的行动，ActionCausesFt部分可以去掉，所以我们有
chap4_para93,1,"•When applied to a dirty square the action cleans the square and sometimes cleans up dirt in an adjacent square, too.",● 在一个脏的方格中，Suck会清理这一方格，有时也会清理它的相邻方格。
chap4_para931,1,,对智能体的位置来说，后继状态公理要更为复杂。
chap4_para931,2,,"例如，如果（a）智能体在面向南方时从[1, 2]，或面向西方时从[2, 1]向前移动，或者（b）已经为真且动作未产生移动（因为动作不是向前或动作导致撞墙），则为真。"
chap4_para931,3,,用命题逻辑写出，就是
chap4_para933,1,,习题7.SSAX要求写出剩余的wumpus世界的流的公理。
chap4_para934,1,,给定完整的后继状态公理和本节开始列出的其他公理，智能体就能够询问和回答世界当前状态的所有可解答问题。
chap4_para934,2,,例如，在7.2节，感知和动作的初始序列是
chap4_para935,1,,此时，有Ask，因此智能体知道它在什么位置。
chap4_para935,2,,而且，Ask和Ask，因此智能体已经找到了wumpus和一个无底洞。
chap4_para935,3,,对于智能体最重要的问题是一个方格是否能够进入，也就是这个方格是否没有无底洞也没有wumpus。
chap4_para935,4,,为此添加公理很容易，形式如下：
chap4_para936,1,,"最后，Ask，因此方格[2, 2]可以安全进入。"
chap4_para936,2,,实际上，给定一个如DPLL的可靠且完备的推断算法，智能体可以回答关于哪个方格安全的任意可解答问题，而且对于小型到中型的wumpus世界可以在几毫秒内完成回答。
chap4_para937,1,,求解表示框架问题和推断框架问题是一步重大的前进，但仍有一个亟待解决的问题：我们需要确认一个动作的所有必要的前提都成立才能保证结果效应。
chap4_para937,2,,我们说过向前动作使智能体向前方移动，除非前方有墙，但也有许多其他意外会导致动作失败：智能体可能会被绊倒，会犯心脏病，会被巨型蝙蝠抓走，诸如此类。
chap4_para937,3,,明确所有这些意外被称为资格问题（qualification problem）。
chap4_para937,4,,它在逻辑学的范畴内没有完备的解，在决定要多么详细地明确模型以及要忽略哪些细节时，系统设计者必须做出很好的判断。
chap4_para937,5,,我们将在第12章中看到，概率论允许以非显式的方式总结所有意外。
chap4_para938,1,,7.7.2　混合智能体
chap4_para939,1,,推导世界状态的多个方面的能力可以直接与条件-动作规则（见2.4.2节）以及第3章和第4章的问题求解算法结合，产生一个wumpus世界的混合智能体。
chap4_para939,2,,图7-20展示了达成这个目标的一种可能方式。
chap4_para939,3,,智能体程序维护并更新一个知识库和一个当前规划。
chap4_para939,4,,初始知识库含有非时变公理——不依赖于时间t的公理，例如将方格的微风与无底洞的存在联系起来的公理。
chap4_para939,5,,在每个时间步，新的感知和所有依赖于t的公理，如后继状态公理，被加入知识库。
chap4_para939,6,,（7.7.3节将解释为何智能体不需要未来时间步的公理。
chap4_para939,7,,）然后，智能体通过向知识库询问来使用逻辑推断，以找出哪些方格是安全的且未被访问过。
chap4_para94,1,•When applied to a clean square the action sometimes deposits dirt on the carpet.5,● 在一个干净方格中，Suck有时反而会把灰尘弄到地面上。
chap4_para94,2,,[5]
chap4_para940,1,,智能体程序的主体根据目标优先级降序创建一个规划。
chap4_para940,2,,首先，如果存在闪光，则程序创建一个抓取金块、原路返回初始位置并爬出洞穴的规划。
chap4_para940,3,,否则，如果没有当前规划，程序会规划一个前往最近的、未被访问过的安全方格的路线，并确保路线仅经过安全方格。
chap4_para941,1,,路径规划使用A*搜索算法完成，而没有用Ask。
chap4_para941,2,,如果没有可探索的安全方格，下一步——如果智能体还有箭的话——就是试图对一个可能有wumpus的位置射击来创造一个安全方格。
chap4_para941,3,,这是通过询问Ask在何处为假完成的，也就是智能体还不知道的没有wumpus的地方。
chap4_para941,4,,函数Plan-Shot（图中未展示）使用Plan-Route规划一系列动作来完成这次射击。
chap4_para941,5,,如果失败，则程序寻找尚未证明是不安全的方格，也就是询问Ask返回假的方格。
chap4_para941,6,,"如果不存在这样的方格，则任务不可能完成，智能体撤退到[1, 1]并爬出洞穴。"
chap4_para942,1,,图7-20　wumpus世界的一个混合智能体。
chap4_para942,2,,它使用命题知识库来推断世界的状态，结合问题求解搜索和论域特定代码来选择动作。
chap4_para942,3,,每次调用Hybrid-Wumpus-Agent，它都会将感知添加到知识库，然后依据先前定义的规划或创建一个新规划，弹出这个规划的第一步作为下一个要采取的动作
chap4_para943,1,,7.7.3　逻辑状态估计
chap4_para944,1,,图7-20所示的智能体工作得不错，但它有一个重大弱点：随着时间流逝，涉及对Ask调用的计算开销不断增大。
chap4_para944,2,,这主要是由于所需的推断不得不回到越来越早的时间点，并涉及越来越多的命题符号。
chap4_para944,3,,显然，这是不可持续的——我们不能让一个智能体处理每次感知的时间随着其寿命的增长成比例地增加！
chap4_para944,4,,我们真正需要的是常数更新时间，也就是，与t无关。
chap4_para944,5,,一个显然的答案是保存或缓存（cache）推断的结果，以便下一个时间步的推断过程构建在先前的结果上，而非必须从零开始。
chap4_para945,1,,如我们在4.4节所见，感知的历史和所有其后果都可以用信念状态代替，即对所有可能的当前世界状态集合的某种表示[13]。
chap4_para945,2,,在新感知到来时更新信念的过程被称为状态估计（见4.4.4节）。
chap4_para945,3,,而在4.4节，信念状态是状态的显式列表，此处我们可以使用含有关于当前时间步的命题符号，以及非时变符号的逻辑语句。
chap4_para945,4,,例如，逻辑语句
chap4_para947,1,,[13]　我们可以认为感知历史本身就是一个信念状态的表示，但它是一个随着历史变长使得推断代价逐渐增加的表示。
chap4_para949,1,,"代表时刻1的所有状态的集合，这时wumpus还活着，智能体位于[2, 1]，方格中有微风，[3, 1]或[2, 2]其中之一有无底洞或两个都有无底洞。"
chap4_para95,1,"To provide a precise formulation of this problem, we need to generalize the notion of a transition model from Chapter 3.",
chap4_para95,2,"Instead of defining the transition model by a RESULT function that returns a single outcome state, we use a RESULTS function that returns a set of possible outcome states.",
chap4_para95,3,"For example, in the erratic vacuum world, the Suck action in state 1 cleans up either just the current location, or both locations:",
chap4_para950,1,,维护一个精确的、逻辑公式形式的信念状态并不简单。
chap4_para950,2,,如果对于时刻t有n个流符号，则会有2n个可能的状态，也就是对这些符号的所有赋值。
chap4_para950,3,,而现在，信念状态的集合是物理状态的超集（所有子集的集合）。
chap4_para950,4,,总共有2n个物理状态，因此有个信念状态。
chap4_para950,5,,即便我们对逻辑公式尽可能地使用紧凑的编码方式，即每个信念状态用一个二进制数表示，我们也需要位来标记当前的信念状态。
chap4_para950,6,,也就是说，精确的状态估计需要的逻辑公式的规模可能是符号数量的指数级别的。
chap4_para951,1,,一个用于近似状态估计的常见且自然的方法是用文字的合取式表示信念状态，即1-CNF公式。
chap4_para951,2,,为此，智能体程序只需要在给定时刻t−1的信念状态的情况下，为每个符号X t证明X t和 （以及真值未知的非时变符号）即可。
chap4_para951,3,,可证明文字的合取式成为了新的信念状态，先前的信念状态被丢弃。
chap4_para952,1,,要了解的是，随着时间流逝，这个方法可能会损失一些信息。
chap4_para952,2,,"例如，如果式（7-4）的语句是真正的信念状态，则P3,1和P2,2都无法被单独证明，也都不会出现在1-CNF信念状态中。"
chap4_para952,3,,（习题7.HYBR探索了这一问题的一个可行的解法。
chap4_para952,4,,）另外，由于1-CNF信念状态中的每一个文字都是由前一信念状态证得的，而且初始信念状态是一个真实的断言，可得出整个1-CNF信念状态必然为真。
chap4_para952,5,,因此，1-CNF信念状态所表示的可能状态的集合包含了给定全部感知历史时的所有确实可能的状态。
chap4_para952,6,,如图7-21所示，1-CNF信念状态就是准确信念状态的一个外包络，即保守近似（conservative approximation）。
chap4_para952,7,,我们可以在人工智能的许多领域反复见到复杂集合的保守近似这一概念。
chap4_para953,1,,图7-21　1-CNF信念状态（粗实线外轮廓）作为对准确信念状态（虚线轮廓的深色区域）的简单的、可表示的保守近似。
chap4_para953,2,,每个可能世界都使用圆圈表示，深色圆圈与所有感知一致
chap4_para954,1,,7.7.4　用命题推断进行规划
chap4_para955,1,,图7-20所示的智能体使用逻辑推断来确定哪个方格是安全的，但使用了A*搜索来进行规划。
chap4_para955,2,,本节展示如何通过逻辑推断来进行规划。
chap4_para955,3,,它的思想非常简单。
chap4_para956,1,,（1）构建一个语句，它含有：
chap4_para957,1,,a. 对于初始状态的断言集Init0；
chap4_para958,1,,b. 到最大为时刻t为止的每一时间步的所有可能动作的后继状态公理 ；
chap4_para959,1,,c. 目标在时刻t达成的断言。
chap4_para96,1,"If we start in state 1, no single sequence of actions solves the problem, but the following conditional plan does:",[5]　我们假设大多数读者都会遇到类似的问题，并且会共情我们的智能体。
chap4_para96,2,,我们向那些拥有现代化高效清洁设备从而无法利用这一教学设计的读者道歉。
chap4_para960,1,,（2）将所有语句提供给SAT求解器。
chap4_para960,2,,如果求解器找到一个可满足的模型，则目标是可达成的；如果语句不可满足，则问题无解。
chap4_para961,1,,（3）假设找到了一个模型，从模型中提取代表动作并被赋值为true的变量。
chap4_para961,2,,它们代表一个达成目标的规划。
chap4_para962,1,,图7-22展示了一个命题规划程序SATPlan。
chap4_para962,2,,它实现了上述的想法，仅做了一点改变。
chap4_para962,3,,由于智能体并不知道它需要多少步才能达成目标，算法会尝试每个可能的t步，直到某个可行的最大规划长度Tmax。
chap4_para962,4,,这样，如果这一规划存在的话，它能够确保找到最短的规划。
chap4_para962,5,,由于SATPlan搜索解的特定方式，它无法在部分可观测的环境中使用；SATPlan只能将不可观测的变量设定为它所需的值来求解。
chap4_para963,1,,图7-22　SATPlan算法。
chap4_para963,2,,规划问题被转换为CNF语句，其中目标被断言在固定的时间步t时成立，到t为止的每个时间步都含有公理。
chap4_para963,3,,如果可满足性算法找到了一个模型，则通过查看指向动作并在模型中被赋值为true的命题符号来提取规划。
chap4_para963,4,,如果模型不存在，则将目标后移一步，重复这一过程
chap4_para964,1,,使用SATPlan的关键步骤是构建知识库。
chap4_para964,2,,大体来看，7.7.1节所述的wumpus世界公理似乎足以构成上述步骤1中的a和b。
chap4_para964,3,,但蕴含（正如用Ask来检验的那些）和可满足性对公理的要求有重要的区别。
chap4_para965,1,,"例如，考虑智能体的位置初始为[1, 1]，假设智能体的目标仅为在时刻1时移动到[2, 1]。"
chap4_para965,2,,初始知识库含有，目标为。
chap4_para965,3,,如果断言Forward0，则我们可以使用Ask证得；如果被断言的是Shoot0，则我们无法证得。
chap4_para965,4,,现在，SATPlan会找到规划[Forward0]，目前看起来没什么问题。
chap4_para966,1,,遗憾的是，SATPlan也会找到规划[Shoot0]。
chap4_para966,2,,为什么会这样呢？
chap4_para966,3,,"要找出其原因，先检查一下SATPlan构建的模型：它包括赋值，也就是智能体可以在时刻0时就位于[2, 1]并进行射击，故而在时刻1时也会在[2, 1]。"
chap4_para966,4,,"有人会问：“我们不是刚说过智能体在时刻0时位于[1, 1]吗？"
chap4_para966,5,,”的确如此，但我们没有告诉智能体它不能同时位于两个位置！
chap4_para966,6,,对蕴含来说，是未知的，因此不能被用于证明；而对于可满足性，是未知的，因此可以被设定为任意有助于达成目标的值。
chap4_para967,1,,对知识库来说，SATPlan是很好的调试工具，因为它能够暴露出知识缺失的地方。
chap4_para967,2,,在这个例子中，我们可以使用类似于用来断言恰恰只存在一个wumpus的语句集，来断言在每个时刻智能体只能位于一个位置，以修复知识库。
chap4_para967,3,,"或者，我们可以对除[1, 1]之外的所有位置断言；关于位置的后继状态公理用于处理之后的时刻。"
chap4_para967,4,,相同的修复方式也可以用于确保智能体在一个时刻有且仅有一个朝向。
chap4_para968,1,,但SATPlan还有更怪异的表现。
chap4_para968,2,,首先是，它会找出含有不可能采取的动作的模型，例如在没有箭支的时候射击。
chap4_para968,3,,要理解其原因，我们需要更为仔细地查看后继状态公理，如式（7-3），对于前提无法满足的动作的描述。
chap4_para968,4,,公理的确正确地预测了执行这种动作不会产生任何结果（见习题7.SATP），但它没有表明这一动作不能被执行！
chap4_para968,5,,要避免生成含有不合规动作的规划，我们必须加入表明动作的出现需要满足其前提的前提公理（precondition axiom）。
chap4_para968,6,,[14]例如，我们需要说，对于每个时刻t，有
chap4_para97,1,"Here we see that a conditional plan can contain if–then–else steps; this means that solutions are trees rather than sequences. Here the conditional in the if statement tests to see what the current state is; this is something the agent will be able to observe at runtime, but doesn’t know at planning time. Alternatively, we could have had a formulation that tests the percept rather than the state. Many problems in the real, physical world are contingency problems, because exact prediction of the future is impossible. For this reason, many people keep their eyes open while walking around.",为了更准确地形式化这一问题，我们需要推广第3章的转移模型概念。
chap4_para97,2,,我们不使用返回单个结果状态的Result函数来定义转移模型，而是使用返回一组可能的结果状态的新的Result函数。
chap4_para97,3,,例如，在不稳定的真空吸尘器世界中，状态1中的Suck动作要么只清理当前位置，要么同时清理两个位置：
chap4_para970,1,,[14]　注意，加入前提公理意味着我们不再需要在后继状态公理中包含动作的前提条件。
chap4_para971,1,,这就确保了如果规划在某一时刻选择采取动作Shoot，则此时智能体必然有一支箭。
chap4_para972,1,,SATPlan的另一个怪异的行为是它会创建具有多个同时进行的动作的规划。
chap4_para972,2,,例如，它会生成一个Fotward0和Shoot0都为真的模型，而这是不允许的。
chap4_para972,3,,要解决这个问题，我们引入动作排除公理（action exclusion axiom）：对于每对动作和，我们加入公理
chap4_para973,1,,可能有人会提出同时向前走并射击并不是很困难，但如果是同时抓取并射击的话就相当不现实了。
chap4_para973,2,,通过只对相互冲突的每对动作施以动作排除公理，可以使规划同时含有多个动作——而由于SATPlan能找出最短的合规规划，我们就可以确定它能够利用同时动作这个能力。
chap4_para974,1,,总之，SATPlan能对含有初始状态、目标、后继状态公理、前提公理和动作排除公理的语句找出模型。
chap4_para974,2,,由于不再存在任何错误的“解”，我们可以证明这一公理集是充分的。
chap4_para974,3,,所有满足命题语句的模型都将是原始问题的有效解。
chap4_para974,4,,现代SAT求解技术使得这一方法相当实用。
chap4_para974,5,,例如，一个DPLL风格的求解器可以毫不费力地生成图7-2所示的wumpus世界的解。
chap4_para975,1,,本节已经讲过构建智能体的一个陈述性方法：智能体通过结合在知识库中断言语句和执行逻辑推断运行。
chap4_para975,2,,"这种方法有一些弱点，它们就隐含于类似“对于每个时刻t”和“对于每个方格[x, y]”这样的表述中。"
chap4_para975,3,,对于所有实用的智能体，这些表述必须用从一般语句模式中自动生成实例的代码来实现，这些实例被用于插入知识库中。
chap4_para975,4,,对于一个规模适中（相当于小型计算机游戏的大小）的wumpus世界，我们可能需要一个100×100的场地和1000个时间步，这样的话知识库中的语句就会有上亿条之多。
chap4_para976,1,,这种情况不仅相当不现实，也揭露了一个深层次的问题：我们对wumpus世界的理解（即它的“物理学”在所有方格和所有时刻都一样）不能直接用命题逻辑的语言来表示。
chap4_para976,2,,"要解决这个问题，我们需要更有表达能力的语言，也就是那种可以自然地写出像“对于每个时刻t”和“对于每个方格[x, y]”这种表述的语言。"
chap4_para976,3,,第8章所述的一阶逻辑就是一种这样的语言。
chap4_para976,4,,在一阶逻辑中，任意大小、任意时长的wumpus世界都可以用大约10条逻辑语句来描述，而非1000万条乃至1万亿条。
chap4_para978,1,,我们已经介绍了基于知识的智能体，也展示了如何定义一种逻辑，以便使这种智能体能够对世界进行推理。
chap4_para978,2,,本章重点如下。
chap4_para979,1,,● 智能体需要关于世界的知识来获得良好的决策。
chap4_para98,1,4.3.2AND–OR search trees,如果我们是从状态1开始，那么没有任何一个单独的动作序列能够求解问题，因此我们需要如下的条件规划：
chap4_para980,1,,● 知识包含在智能体中，其形式为存储于知识库中的、用知识表示语言表述的语句。
chap4_para981,1,,● 一个基于知识的智能体由一个知识库和一套推断机制组成。
chap4_para981,2,,它的运作方式是在知识库中存储关于世界的语句，使用推断机制推断新语句，并使用这些语句来决定采取何种动作。
chap4_para982,1,,● 一种表示语言是用其语法和语义来定义的，语法规定了语句的结构，语义定义了每个可能世界或模型中每条语句的真值。
chap4_para983,1,,● 语句之间的蕴含关系对于我们对推理的理解非常重要。
chap4_para983,2,,在所有为真的世界中也为真，则语句蕴含语句。
chap4_para983,3,,其等价定义包括语句的有效性和语句的不可满足性。
chap4_para984,1,,● 推断是从旧语句推得新语句的过程。
chap4_para984,2,,可靠的推断算法只推出蕴含的语句，完备的算法则可以推得所有蕴含的语句。
chap4_para985,1,,● 命题逻辑是由命题符号和逻辑联结词构成的简单语言。
chap4_para985,2,,它可以处理已知为真、为假或完全未知的命题。
chap4_para986,1,,● 给出固定命题词汇表的前提下，可能的模型的集合是有限的，因此蕴含可以用枚举模型来检验。
chap4_para986,2,,用于命题逻辑的高效模型检验推断算法包括回溯和局部搜索方法，它们通常能快速求解大规模问题。
chap4_para987,1,,● 推断规则是可靠推断的模式，它可以用于证明。
chap4_para987,2,,归结规则能产生一个用于知识库的完备推断算法，以合取范式的形式表示。
chap4_para987,3,,前向链接和反向链接是霍恩形式知识库的非常自然的推理算法。
chap4_para988,1,,● 如WalkSAT这样的局部搜索方法可以用于问题求解。
chap4_para988,2,,这种算法是可靠的，但不是完备的。
chap4_para989,1,,● 逻辑状态估计需要使描述可能状态集的逻辑语句与历史观测保持一致。
chap4_para989,2,,每一步更新都需要使用环境的转移模型进行推断，转移模型是根据规定流的变化方式的后继状态公理构建的。
chap4_para99,1,"How do we find these contingent solutions to nondeterministic problems? As in Chapter 3, we begin by constructing search trees, but here the trees have a different character. In a deterministic environment, the only branching is introduced by the agent’s own choices in each state: I can do this action or that action. We call these nodes OR nodes. In the vacuum world, for example, at an OR node the agent chooses Left or Right or Suck. In a nondeterministic environment, branching is also introduced by the environment’s choice of outcome for each action. We call these nodes AND nodes. For example, the Suck action in state 1 results in the belief state {5,7}, so the agent would need to find a plan for state 5 and for state 7. These two kinds of nodes alternate, leading to an AND-OR tree as illustrated in Figure 4.10.",
chap4_para990,1,,● 逻辑智能体内部的决策可以用求解SAT的方式进行：找出描述能达到目标的未来动作序列的可能的模型。
chap4_para990,2,,这个方法仅能用于完全可观测或无传感器环境。
chap4_para991,1,,● 命题逻辑无法扩大到大小无限制的环境中，因为它有限的表达能力不能简洁地处理时间、空间和对象间关系的通用模式。
chap4_para995,1,,在本章中，我们将注意到世界被赋予了许多对象，其中一些对象与另一些对象相关，而我们努力对其进行推理。
chap4_para996,1,,命题逻辑足以展示逻辑、推断和基于知识的智能体的基本概念。
chap4_para996,2,,遗憾的是，命题逻辑的表达能力有限。
chap4_para996,3,,本章我们介绍一阶逻辑，[1]它可以简洁地表达更多东西。
chap4_para996,4,,我们在8.1节中总体上讨论表示语言，在8.2节中介绍一阶逻辑的语法和语义，然后在8.3节和8.4节中展示一阶逻辑在简单表示中的运用。
chap4_para998,1,,[1]　一阶逻辑也称为一阶谓词演算（first-order predicate calculus），可缩写为FOL或FOPC。
chap5_para1,1,CONSTRAINT SATISFACTION PROBLEMS,在本章中，我们将探索有其他智能体计划与我们对抗时的环境。
chap5_para10,1,C is a set of constraints that specify allowable combinations of values.,5.5节讨论了包含机会因素（通过掷骰子或洗牌）的博弈，5.6节讨论了不完美信息（imperfect information）博弈（如扑克和桥牌，即并非所有牌对所有玩家都可见）。
chap5_para100,1,Notice that BACKTRACKING-SEARCH keeps only a single representation of a state (assignment) and alters that representation rather than creating new ones (see page 98).,5.3.4　搜索和查表
chap5_para1000,1,,知道一个方格有微风很有用，因为我们知道无底洞是不能移动的。
chap5_para1000,2,,注意，Breezy没有时间参数。
chap5_para1001,1,,发现了哪些位置有微风（或有臭味）以及同样重要的哪些位置没有微风（或没有臭味），智能体就可以推导出无底洞的位置（以及wumpus的位置）。
chap5_para1001,2,,在命题逻辑中每个方格都需要一条公理（见7.4.3节的R2和R3），并且对每种世界的地形布局都需要一套不同的公理。
chap5_para1001,3,,而在一阶逻辑中我们只需要一条公理：
chap5_para1003,1,,类似地，一阶逻辑中我们可以量化所有时间，因此，对于每个谓词我们只需要一个后继状态公理，而非对每个时间步都保留副本。
chap5_para1003,2,,例如，箭的公理［式（7-2）］变为
chap5_para1004,1,,从这两个例子的语句可以看出，一阶逻辑的表达方式并不比第7章给出的自然语言描述更复杂。
chap5_para1004,2,,我们鼓励读者对智能体的位置和朝向构建类似的公理——在这些情况下，公理需要量化时间和空间。
chap5_para1004,3,,如命题状态估计一样，智能体可以对这样的公理使用逻辑推断来了解不能直接观测的那部分世界。
chap5_para1004,4,,第11章会更深入地研究一阶逻辑的后继状态公理以及它在构建规划中的用处。
chap5_para1005,1,,8.4　一阶逻辑中的知识工程
chap5_para1006,1,,8.3节展示了如何用一阶逻辑在3个简单的论域中表示知识。
chap5_para1006,2,,本节描述知识库构建的一般过程，这一过程称作知识工程（knowledge engineering）。
chap5_para1006,3,,知识工程师是研究一个特定论域，了解这个论域中哪些概念是重要的，并创建该论域中对象和关系的形式化表示的人。
chap5_para1006,4,,我们会阐述在电子电路论域中进行知识工程的过程。
chap5_para1006,5,,我们采用的方法适于构建专用知识库，这种知识库的论域是精心划定的，其查询的范围也是已知的。
chap5_para1006,6,,通用知识库则涵盖了较大范围的人类知识，用于支持像自然语言理解这样的任务，我们在第10章对其进行讨论。
chap5_para1007,1,,8.4.1　知识工程的过程
chap5_para1008,1,,知识工程项目的内容、范围和难度各不相同，但所有这样的项目都包括如下的步骤。
chap5_para1009,1,,（1）确定问题。
chap5_para1009,2,,知识工程必须描述知识库要支持的问题范围，以及对每个特定问题实例可获取的事实类型。
chap5_para1009,3,,例如，wumpus知识库是需要能够选择动作，还是只需要回答关于环境内容的问题？
chap5_para1009,4,,传感器事实是否需要包括当前位置？
chap5_para1009,5,,任务将决定为了将问题实例连接到回答必须表示哪些知识。
chap5_para1009,6,,这一步类似于第2章用于设计智能体的PEAS过程。
chap5_para101,1,"Whereas the uninformed search algorithms of Chapter 3 could be improved only by supplying them with domain-specific heuristics, it turns out that backtracking search can be improved using domain-independent heuristics that take advantage of the factored representation of CSPs.",对一个国际象棋程序来说，开局就考虑一个包含10亿个博弈状态的树似乎有些过犹不及：漫长的搜索得出的结论仅仅是将兵放到e4（最常见的第一步）。
chap5_para101,2,In the following four sections we show how this is done:,"一个世纪以来，许多国际象棋书籍都介绍了如何下好开局和残局（Tattersall, 1911）。"
chap5_para101,3,,因此，许多游戏程序使用查表而非搜索来处理开局和残局也就不足为奇了
chap5_para1010,1,,（2）收集相关知识。
chap5_para1010,2,,知识工程师可能已经是领域专家，也可能需要与真正的专家合作来获得他们的知识——这个过程叫作知识获取（knowledge acquisition）。
chap5_para1010,3,,在这一阶段，知识并非形式化表示的，这一步的主要目的是了解任务所确定的知识库的范围，以及了解这一领域的运行方式。
chap5_para1011,1,,对由人工产生的规则集定义的wumpus世界来说，我们很容易找出相关知识。
chap5_para1011,2,,（但是要注意，相邻关系的定义并不是由wumpus世界规则明确给出。
chap5_para1011,3,,）对于真实世界的论域，相关性问题可能非常困难，例如，仿真VLSI设计的系统可能需要，也可能不需要考虑杂散电容和集肤效应问题。
chap5_para1012,1,,（3）确定谓词、函数和常量的词汇表。
chap5_para1012,2,,也就是说，将重要的论域级概念翻译为逻辑级名称。
chap5_para1012,3,,这就涉及知识工程风格的许多问题。
chap5_para1012,4,,类似于编程风格，知识工程风格可能对项目最终成功与否产生重要影响。
chap5_para1012,5,,例如，无底洞应当被表示为对象还是表示为方格的一元谓词？
chap5_para1012,6,,智能体的朝向应当是函数还是谓词？
chap5_para1012,7,,wumpus的位置是否与时间相关？
chap5_para1012,8,,一旦做出这些决定，就会形成被称为论域的本体论（ontology）的词汇表。
chap5_para1012,9,,“本体论”一词是指关于存在或实存的本质的理论。
chap5_para1012,10,,本体论决定哪些东西存在，但不能决定它们的具体性质和相互关系。
chap5_para1013,1,,（4）对论域的通用知识编码。
chap5_para1013,2,,知识工程师为词汇表中的所有项写出公理。
chap5_para1013,3,,这就（尽可能地）固定了项的含义，使专家能够检查其内容。
chap5_para1013,4,,这一步经常会发现词汇表的概念误解或理解偏差，这必须返回第3步进行修正并重复这个过程。
chap5_para1014,1,,（5）对问题实例的描述编码。
chap5_para1014,2,,如果本体论确定得很恰当，这一步就相当容易。
chap5_para1014,3,,它涉及写出本体论中的概念实例的简单原子语句。
chap5_para1014,4,,对逻辑智能体来说，问题实例是由传感器提供的，而“无形”的知识库获取语句的方式与传统程序获取输入数据的方式相同。
chap5_para1015,1,,（6）向推断过程提出查询并获得答案。
chap5_para1015,2,,这是获得回报的一步：我们可以让推断过程在公理和问题相关的事实上运行来推导我们有兴趣了解的事实。
chap5_para1015,3,,这样，我们就不需要编写应用相关的求解算法了。
chap5_para1016,1,,（7）调试并评估知识库。
chap5_para1016,2,,很遗憾，查询得到的答案一开始往往是错误的。
chap5_para1016,3,,更准确地说，答案对于现有的知识库是正确的（如果假设推断过程是可靠的），但它们不是用户期望的答案。
chap5_para1016,4,,例如，如果缺失了一条公理，一些查询就不能从知识库中得到答案。
chap5_para1016,5,,这就需要大量的调试过程。
chap5_para1016,6,,关注推理链意外停止的地方可以轻易找出缺失或过弱的公理。
chap5_para1016,7,,例如，如果知识库为找到wumpus而含有诊断规则（见习题8.WUMD）：
chap5_para1017,1,,而没有采用双向蕴涵，智能体就永远不能证明wumpus不存在。
chap5_para1017,2,,不正确的公理是关于世界的错误陈述，因此可以被找出。
chap5_para1017,3,,例如，语句
chap5_para1018,1,,对爬行动物、两栖动物和桌子都不成立。
chap5_para1018,2,,判断这条语句的错误性可以不依赖于知识库的其他部分。
chap5_para1018,3,,但是，程序中的一个典型错误则如下：
chap5_para1019,1,,在不理解上下文的情况下，不可能判断offset应当是position还是position+1。
chap5_para102,1,"•(5.3.1) Which variable should be assigned next (SELECT-UNASSIGNED-VARIABLE), and in what order should its values be tried (ORDER-DOMAIN-VALUES)?",对于开局，计算机主要依靠人类的专业知识。
chap5_para102,2,,可以从书中复制人类专家关于如何打好每个开局的最佳建议并将其输入表中供计算机使用。
chap5_para102,3,,此外，计算机还可以从以前玩过的游戏的数据库中收集统计数据，以判断哪种开局最容易取胜。
chap5_para102,4,,最开始的几步可能的局面很少，大多数局面都能存储在表中。
chap5_para102,5,,通常，移动10～15步后，我们会到达一个很少见到的局面，程序必须从查表切换到搜索。
chap5_para1020,1,,当你的知识库中没有明显的错误时，似乎就要大功告成了。
chap5_para1020,2,,但最好还是通过在查询测试套件上运行系统并测量正确答案的数量来正式地评估系统，除非你的知识库明显没有错误。
chap5_para1020,3,,没有客观度量的话，你很容易就以为任务已经完成了。
chap5_para1020,4,,为了更好地理解这7个步骤，我们现在将其应用于一个扩展的示例——电子电路论域。
chap5_para1021,1,,8.4.2　电子电路论域
chap5_para1022,1,,我们将构建一个本体论和一个知识库，使我们能够进行关于图8-6所示的数字电路的推理。
chap5_para1022,2,,我们将遵循知识工程的7个步骤。
chap5_para1023,1,,图8-6　一位全加器的数字电路C1。
chap5_para1023,2,,前两个输入是要相加的两位，第三个输入是进位位。
chap5_para1023,3,,第一个输出是和，第二个输出是通往下一个加法器的进位位。
chap5_para1023,4,,电路包含两个异或门、两个与门和一个或门
chap5_para1025,1,,涉及数字电路的推理任务很多。
chap5_para1025,2,,最高层次的任务是分析电路的功能性。
chap5_para1025,3,,例如，图8-6的电路是否能够正确地做加法？
chap5_para1025,4,,如果所有输入都为高，A2门的输出是什么？
chap5_para1025,5,,关于电路结构的问题同样有趣。
chap5_para1025,6,,例如，连接到第一个输入端子的门有哪些？
chap5_para1025,7,,电路是否含有反馈回路？
chap5_para1025,8,,这都是这一步骤中的任务。
chap5_para1025,9,,还有更详细的分析层次，包括关于延迟、电路面积、功耗以及生产成本等的分析。
chap5_para1025,10,,所有这些层次的分析都需要额外的知识。
chap5_para1027,1,,我们对数字电路了解多少？
chap5_para1027,2,,根据我们的目的，这包括导线和门。
chap5_para1027,3,,信号沿着导线传输到门的输入端，每个门则在输出端产生一个信号沿着另一条导线传输。
chap5_para1027,4,,要确定这些信号是什么，我们需要了解门如何转换其输入信号。
chap5_para1027,5,,门有4种：具有两个输入端子的与门（AND）、或门（OR）和异或门（XOR），以及只有一个输入端子的非门（NOT）。
chap5_para1027,6,,所有门都只有一个输出端子。
chap5_para1027,7,,像门一样，电路本身也有输入端子和输出端子。
chap5_para1028,1,,要推理电路的功能性和连接性，我们不需要涉及导线本身、导线路径或导线连接点。
chap5_para1028,2,,重要的只有端子之间的连接——我们可以说某个输出端子连接到另一个输入端子，而不需要了解其实际的连接方式。
chap5_para1028,3,,其他因素，像元件的尺寸、形状、颜色或价格与我们的分析也不相关。
chap5_para1029,1,,如果我们的目的不是在门的层级验证设计，本体论就完全不同。
chap5_para1029,2,,例如，如果我们对于故障电路修复有兴趣，那么将导线纳入本体论就很可能是个好主意，因为导线的故障会妨碍在其中传输的信号。
chap5_para1029,3,,要解决时序故障，我们需要把门延迟加进本体论。
chap5_para1029,4,,如果我们要设计可盈利的产品，电路价格及其相对于市场上其他产品的速度就会很重要。
chap5_para103,1,•(5.3.2) What inferences should be performed at each step in the search (INFERENCE)?,在游戏接近结束时，可能的局面又变少，因此更容易查表。
chap5_para103,2,,这是计算机的专长：计算机对残局的分析能力远远超过了人类。
chap5_para103,3,,新手玩家按照一些简单的规则就能在王、车对王（KRK）残局中获胜。
chap5_para103,4,,而其他残局，例如王、象、马对王（KBNK），则很难掌握，也不存在简明的策略。
chap5_para1031,1,,我们现在已经知道我们要涉及电路、端子、信号和门。
chap5_para1031,2,,下一步选择用于表示它们的函数、谓词和常量。
chap5_para1031,3,,我们需要先将不同的门与其他对象区分开。
chap5_para1031,4,,每个门由常量命名的对象表示，我们用Gate(X1)来断言X1是门。
chap5_para1031,5,,每个门的行为由其类型决定，即常量AND、OR、XOR和NOT中的一种。
chap5_para1031,6,,由于一个门只能有一种类型，我们可以使用函数Type(X1) = XOR。
chap5_para1031,7,,电路与门类似，使用一个谓词来表示——Circuit(C1)。
chap5_para1032,1,,接下来我们考虑端子，使用谓词Terminal(x)表示。
chap5_para1032,2,,一个电路可以有一个或多个输入端子和一个或多个输出端子。
chap5_para1032,3,,"我们使用函数In(1, X1)来表示电路X1的第1个输入端子。"
chap5_para1032,4,,"相似的函数Out(n, c)用于输出端子。"
chap5_para1032,5,,"谓词Arity(c, i, j)断言电路c有i个输入端子和j个输出端子。"
chap5_para1032,6,,门之间的连接性可以用谓词Connected表示，它需要两个端子作为参数，如。
chap5_para1033,1,,最后，我们需要知道一个信号是通还是断。
chap5_para1033,2,,一种可能是使用一元谓词On(t)，在某个端子的信号通时为真。
chap5_para1033,3,,但这会增加提出类似“电路C1输出端子的所有可能信号值有哪些？
chap5_para1033,4,,”的问题的难度。
chap5_para1033,5,,因此我们引入两个信号值1和0作为对象，分别表示“通”和“断”，而用函数Signal(t)表示端子t的信号值。
chap5_para1034,1,,4. 对论域的通用知识编码
chap5_para1035,1,,好的本体论仅需要少量通用规则，并且可以简明地声明这些规则。
chap5_para1035,2,,如下是我们需要的全部公理。
chap5_para1036,1,,（1）如果两个端子连通，则它们信号相同：
chap5_para1037,1,,（2）每个端子的信号只能是1或0：
chap5_para1038,1,,（3）Connected具有交换性：
chap5_para1039,1,,（4）门的类型有4种：
chap5_para104,1,•(5.3.3) Can we BACKTRACK more than one step when appropriate?,另外，计算机可以通过生成一种策略完全解决残局问题，这一策略是从每种可能状态到该状态下最佳移动的映射。
chap5_para104,2,,这样计算机就可以在这个表中查到正确移动从而完美完成棋局。
chap5_para104,3,,这个表由逆向（retrograde）极小化极大搜索构建：首先考虑在棋盘上放置KBNK的所有方法。
chap5_para104,4,,有些局面是白方获胜，将它们标为“赢”。
chap5_para104,5,,然后反转国际象棋规则，做逆向移动。
chap5_para104,6,,无论黑方的应对是什么，白方的任何一步最终位于“赢”局面的移动，都标为“赢”。
chap5_para104,7,,继续上述搜索，直到所有可能局面都被解析为赢、输或平局，这样就得到了一个包含所有KBNK残局的准确无误的查询表。
chap5_para104,8,,这种做法不仅适用于KBNK残局，也适用于所有棋子数不超过7的残局，这样的表格包含400万亿个状态。
chap5_para104,9,,棋子数为8的表则包含40 000万亿个状态。
chap5_para1040,1,,（5）与门的输出为0，当且仅当其任意输入为0：
chap5_para1041,1,,（6）或门的输出为1，当且仅当其任意输入为1：
chap5_para1042,1,,（7）异或门的输出为1，当且仅当其输入不相同：
chap5_para1043,1,,（8）非门的输出与其输入不同：
chap5_para1044,1,,（9）除了非门之外的所有门都有两个输入和一个输出：
chap5_para1045,1,,（10）电路有端子，数量不超过其输入和输出元数，不存在超出元数的任何东西：
chap5_para1046,1,,（11）门、端子和信号是不同的：
chap5_para1048,1,,5. 对特定问题实例编码
chap5_para1049,1,,图8-6所示的电路被编码为电路C1并有如下描述。
chap5_para1049,2,,首先我们对电路及其门元件进行分类：
chap5_para105,1,•(5.3.4) Can we save and reuse partial results from the search?,5.4　蒙特卡罗树搜索
chap5_para1050,1,,随后我们给出其连接情况：
chap5_para1051,1,,6. 向推断过程提出查询
chap5_para1052,1,,哪种输入组合会使C1的第一个输出（求和位）为0，第二个输出（进位位）为1？
chap5_para1053,1,,答案是变量i1、i2和i3的置换，以使得语句被知识库所蕴含。
chap5_para1053,2,,AskVars将给我们3种这样的置换：
chap5_para1054,1,,加法器电路中所有端子的可能值的集合有哪些？
chap5_para1055,1,,最后这个查询将返回设备的完整输入输出表，可以用于检验它是否能正确做加法。
chap5_para1055,2,,这是电路验证（circuit verification）的一个简单示例。
chap5_para1055,3,,我们也可以使用电路的定义来构建更大的数字系统，并使用相同的验证方式。
chap5_para1055,4,,（见习题8.ADDR）许多论域都支持这种结构化的知识库创建方式，但需要在简单概念的基础上定义更为复杂的概念。
chap5_para1057,1,,我们可以以各种方式查询知识库以了解它会出现哪些错误行为。
chap5_para1057,2,,例如，假设我们没有阅读8.2.8节，因而忘记断言10。
chap5_para1057,3,,假设我们发现系统除了输入000和110的情况，无法证明电路的任何输出，我们可以通过询问每个门的输出的方式来找到问题。
chap5_para1057,4,,我们可以询问：
chap5_para1058,1,,结果显示在X1处对于输入10和01没有输出。
chap5_para1058,2,,因此，我们查看应用于X1的异或门的公理：
chap5_para1059,1,,如果输入已知为1和0，则上式简化为
chap5_para106,1,5.,对围棋来说，启发式树搜索有两个主要缺点：首先，围棋的分支因子开始时为361，这意味着搜索被限制在4～5层。
chap5_para106,2,3.,其次，很难为围棋定义一个好的评价函数，因为子力价值并不是一个强有力的指标，而且大多数状态直到最后阶段都在不断变化。
chap5_para106,3,1Variable and value ordering,为了应对这两个挑战，现代围棋程序已经放弃了搜索，而是使用一种称为蒙特卡罗树搜索（Monte Carlo tree search，MCTS）的策略。
chap5_para106,4,,[5]
chap5_para1060,1,,现在，问题就很明显了：系统不能推断出，因此，我们需要告诉它10。
chap5_para1062,1,,本章介绍了一阶逻辑，一种命题逻辑更具表达能力的表示语言。
chap5_para1062,2,,本章要点如下。
chap5_para1063,1,,● 知识表示语言应当是说明性的、合成式的、有表达能力的、上下文无关的且无歧义的。
chap5_para1064,1,,● 逻辑之间的区别在于其本体论约定和认识论约定，命题逻辑仅约定事实的存在，一阶逻辑则约定对象和关系的存在，因而增加了表达能力，适用于像wumpus世界和电子电路这样的论域。
chap5_para1065,1,,● 命题逻辑和一阶逻辑在表示模糊命题上都有困难。
chap5_para1065,2,,这一困难限制了它们在需要个人判断的论域的应用性，如政治或烹饪。
chap5_para1066,1,,● 一阶逻辑的语法构建于命题逻辑之上。
chap5_para1066,2,,它增加了项来表示对象，并且有全称量词和存在量词来构建关于被量化的变量的全部或部分可能值的断言。
chap5_para1067,1,,● 一阶逻辑的一个可能世界或模型包括一个对象集和一种将常量符号映射到对象、将谓词符号映射到对象的关系、将函数符号映射到对象上的函数的解释。
chap5_para1068,1,,● 一条原子语句为真，仅当谓词命名的关系在项命名的对象之间成立。
chap5_para1068,2,,扩展解释将量词变量映射到模型中的对象，定义了量化语句的真值。
chap5_para1069,1,,● 在一阶逻辑中构建知识库需要严谨的过程来分析论域、选择词汇表、编码能支持所需推断的公理。
chap5_para107,1,The backtracking algorithm contains the line,
chap5_para1072,1,,第9章　一阶逻辑中的推断
chap5_para1073,1,,在本章中，我们定义有效的过程来回答用一阶逻辑提出的问题。
chap5_para1074,1,,在本章中，我们阐述能够回答所有可解的一阶逻辑问题的算法。
chap5_para1074,2,,9.1节介绍量词的推断规则，并展示如何将一阶逻辑推断约简为命题逻辑推断，尽管这样做代价巨大。
chap5_para1074,3,,9.2节描述了如何用合一来构建直接用于一阶逻辑的推断规则。
chap5_para1074,4,,随后我们讨论一阶逻辑推断的3类主要算法：前向链接（9.3节）、反向链接（9.4节）和基于归结的定理证明（9.5节）。
chap5_para1075,1,,9.1　命题推断与一阶推断
chap5_para1076,1,,进行一阶推断的方法之一是将一阶知识库转换为命题逻辑并使用我们已知的命题推断。
chap5_para1076,2,,第一步是消去全称量词。
chap5_para1076,3,,例如，假设我们的知识库含有典型的朴素道德公理，认为所有贪婪的国王都是邪恶的：
chap5_para1077,1,,由此我们可以推断出下列任一语句：
chap5_para1078,1,,一般来说，全称量词实例化（universal instantiation，UI）表明我们可以通过用基本项（没有变量的项）置换全称量化的变量来推断任意语句。
chap5_para1078,2,,[1]
chap5_para108,1,"The simplest strategy for SELECT-UNASSIGNED-VARIABLE is static ordering: choose the variables in order, {X1,X2,.",[5]　“蒙特卡罗”算法是以摩纳哥蒙特卡罗赌场命名的随机算法。
chap5_para108,2,.,
chap5_para108,3,.,
chap5_para108,4,}.,
chap5_para108,5,The next simplest is to choose randomly.,
chap5_para108,6,Neither strategy is optimal.,
chap5_para108,7,"For example, after the assignments for WA = red and NT = green in Figure 5.",
chap5_para108,8,"6, there is only one possible value for SA, so it makes sense to assign SA = blue next rather than assigning Q.",
chap5_para108,9,"in fact, after SA is assigned, the choices for Q, NSW, and V are all forced.",
chap5_para1080,1,,[1]　不要把此处的置换与8.2.6节用于定义量词语义的扩展解释搞混了。
chap5_para1080,2,,置换用项（term，语法片段）代替变量来产生新的语句，而解释将变量映射到论域中的实例。
chap5_para1081,1,,我们使用8.3节介绍过的置换来形式化地写出推断规则。
chap5_para1081,2,,令表示对语句应用置换后的语句。
chap5_para1081,3,,则对于任意变量v和基本项g，规则写作
chap5_para1082,1,,前述的3条语句就是分别用置换、和得到的。
chap5_para1083,1,,类似地，存在量词实例化（existential instantiation）用一个新的常量符号替换存在量化的变量。
chap5_para1083,2,,其形式化描述如下：对于任意语句、变量v和未在知识库其他地方出现的常量符号k，
chap5_para1086,1,,只要C1未在知识库的其他地方出现。
chap5_para1086,2,,简单来说，存在语句表明存在满足某个条件的对象，运用存在实例化就是给这个对象命名。
chap5_para1086,3,,当然，这个名称不能已经属于其他对象。
chap5_para1086,4,,数学中有一个很好的例子：假设我们发现有一个数字比2.718 28稍大，并满足等式中的x。
chap5_para1086,5,,我们可以将这个数字命名为e，但不能将其命名为已经存在的对象名，如。
chap5_para1086,6,,在逻辑中，新的名称被称为斯科伦常量（Skolem constant）。
chap5_para1087,1,,全称量词实例化可以多次用于同一条公理来产出许多不同结果，而存在量词实例化只需要使用一次，随后就可以丢掉存在量化的语句。
chap5_para1087,2,,"例如，一旦我们添加了语句Kill(Murderer, Victim)的话，就不再需要。"
chap5_para1089,1,,我们现在展示如何将任意一阶知识库转换为命题知识库。
chap5_para1089,2,,第一个想法是，正如存在量化语句能够用一个实例代替一样，全称量化语句也可以用所有可能实例的集合代替。
chap5_para1089,3,,例如，假设我们的知识库仅含有语句
chap5_para109,1,"This intuitive idea—choosing the variable with the fewest “legal” values—is called the minimum-remaining-values (MRV) heuristic. It also has been called the “most constrained variable” or “fail-first” heuristic, the latter because it picks a variable that is most likely to cause a failure soon, thereby pruning the search tree. If some variable X has no legal values left, the MRV heuristic will select X and failure will be detected immediately—avoiding pointless searches through other variables. The MRV heuristic usually performs better than a random or static ordering, sometimes by orders of magnitude, although the results vary depending on the problem.",基本的MCTS策略不使用启发式评价函数。
chap5_para109,2,,相反，状态值是根据从该状态开始的多次完整博奕模拟（simulation）的平均效用值估算的。
chap5_para109,3,,一次模拟（也被称为一个playout或rollout）先为一个参与者选择移动，接着为另一个参与者选择，重复上述操作直到到达某个终止局面。
chap5_para109,4,,这时，博弈规则（而非不可靠的启发式）决定输赢以及比分。
chap5_para109,5,,对于那些只有输赢两种结果的博弈，“平均效用值”为“获胜百分比”。
chap5_para1091,1,,且对象仅有John和Richard。
chap5_para1091,2,,我们用所有可能的置换，和，对第一条语句应用全称量词实例化。
chap5_para1091,3,,我们得到
chap5_para1092,1,,接下来用命题符号（如JohnIsKing）替换基本原子语句（如King(John)）。
chap5_para1092,2,,最后，用第7章的任意完备的命题算法得到如JohnIsEvil的结论，它等价于Evil(John)。
chap5_para1093,1,,正如我们将在9.5节中讨论的，这种命题化（propositionalization）技术可以被彻底一般化。
chap5_para1093,2,,然而，如果知识库中包含函数符号，可能的基本项置换集是无穷的！
chap5_para1093,3,,例如，如果知识库提到Father函数，就可以构建像Father(Father(Father(John)))这样的无穷多的嵌套项。
chap5_para1094,1,,"幸运的是，雅克·埃尔布朗（Jacques Herbrand）针对这一现象提出了著名的定理，即如果语句被原始的一阶知识库蕴含，则存在仅涉及命题化知识库的有限子集的证明（Herbrand, 1930）。"
chap5_para1094,2,,由于任意这样的子集都有其基本项的最大嵌套深度，我们可以通过先生成含有常量符号（Richard和John）的所有实例化，然后再生成深度为1的所有项（Father(Richard)和Father(John)），然后是深度为2的所有项，以此类推，直到我们能够构建所蕴含语句的命题证明。
chap5_para1095,1,,我们已经概述了通过命题化进行一阶逻辑推断的完备方法，也就是，所有蕴含的语句都可以被证明。
chap5_para1095,2,,这是一个重大的成就，特别是在可能模型的空间无限大的情况下。
chap5_para1095,3,,但是，在证明完成前我们并不知道语句是被蕴含的！
chap5_para1095,4,,如果语句并不被蕴含怎么办？
chap5_para1095,5,,我们能证明吗？
chap5_para1095,6,,实际上，对于一阶逻辑，答案是否定的。
chap5_para1095,7,,我们的证明程序会一直运行，生成越来越深的嵌套项，但我们不知道它是陷入绝望的循环，还是就快要得出证明结果。
chap5_para1095,8,,这非常类似于图灵机的停机问题。
chap5_para1095,9,,"艾伦·图灵（Turing, 1936）和阿朗佐·丘奇（Church, 1936）分别以不同方式证明了这种情况的不可避免性。"
chap5_para1095,10,,一阶逻辑的蕴含问题是半可判定的，也就是，存在能判定所有蕴含的语句的算法，却不存在能够判定所有不蕴含的语句的算法。
chap5_para1096,1,,9.2　合一与一阶推断
chap5_para1097,1,,眼尖的读者可能已经注意到命题化方法生成了许多不必要的全称量化语句的实例。
chap5_para1097,2,,我们希望有一个方法，仅使用一条规则，以如下方式推理出解答了查询：给定贪婪的国王都是邪恶的这条规则，找出某个x使得x为国王且x是贪婪的，进而推断出这个x是邪恶的。
chap5_para1097,3,,更一般地说，如果存在某个置换使得每个蕴涵式前提的合取子句与知识库中的语句完全相同，那么我们就在应用后，断言蕴涵式的结论。
chap5_para1097,4,,这种情况下，置换能达到这一目的。
chap5_para1097,5,,假设现在我们不知道Greedy(John)，但我们知道所有人都是贪婪的：
chap5_para1099,1,,则我们仍然能够断定Evil(John)，因为我们知道约翰是国王（已给定）且约翰是贪婪的（因为每个人都是贪婪的）。
chap5_para1099,2,,为了能采取这种做法，我们需要找出一个置换，来同时取代蕴涵语句中的变量和知识库中待匹配语句中的变量。
chap5_para1099,3,,这种情况下，对蕴涵式的前提King(x)和Greedy(x)使用置换就会使它们完全相同。
chap5_para1099,4,,这样我们可以推断出蕴涵式的后件。
chap5_para11,1,"A domain, Di, consists of a set of allowable values, {v1,..., vk}, for variable Xi. For example, a Boolean variable would have the domain {true, false}. Different variables can have different domains of different sizes. Each constraint Cj consists of a pair 〈scope, rel〉, where scope is a tuple of variables that participate in the constraint and rel is a relation that defines the values that those variables can take on. A relation can be represented as an explicit set of all tuples of values that satisfy the constraint, or as a function that can compute whether a tuple is a member of the relation. For example, if X1 and X2 both have the domain {1,2,3}, then the constraint saying that X1 must be greater than X2 can be written as 〈(X1, X2), {(3,1), (3,2), (2,1)}〉 or as 〈(X1, X2), X1 > X2〉.",
chap5_para110,1,"The MRV heuristic doesn’t help at all in choosing the first region to color in Australia, because initially every region has three legal colors. In this case, the degree heuristic comes in handy. It attempts to reduce the branching factor on future choices by selecting the variable that is involved in the largest number of constraints on other unassigned variables. In Figure 5.1, SA is the variable with highest degree, 5; the other variables have degree 2 or 3, except for T, which has degree 0. If we assign the SA first, we can then go around the five mainland regions in clockwise or counterclockwise order and assign each one a color that is different than SA and different than the previous region. The minimum-remaining-values heuristic is usually a more powerful guide, but the degree heuristic can be useful as a tie-breaker.",在模拟中我们如何选择要采取的移动？
chap5_para110,2,,如果只是随机选择，那么多次模拟之后，我们仅能得到“如果两个参与者都随机选择，那么最佳移动是什么？
chap5_para110,3,,”这一问题的答案。
chap5_para110,4,,对于一些简单游戏，这恰好与“如果两名参与者都玩得很好，那么最佳移动是什么？
chap5_para110,5,,”的答案相同，但对大多数游戏却并非如此。
chap5_para110,6,,为了从模拟中获得有用信息，我们需要一个模拟策略（playout policy），使其偏向于好的行动。
chap5_para110,7,,对围棋和其他游戏来说，人们已经使用神经网络成功地从自我对弈中学习到了模拟策略。
chap5_para110,8,,有时还会根据游戏的不同，使用不同的启发式方法，如国际象棋中的“考虑吃子”，或黑白棋中的“占据角落”。
chap5_para1100,1,,这种推断过程可以表述为一条单独的推断规则被称为一般化肯定前件[2]（generalized Modus Ponens）。
chap5_para1100,2,,对于原子语句pi、和q，存在置换使得对所有i有，有
chap5_para1102,1,,[2]　一般化肯定前件比肯定前件（7.5.1节）更一般化，因为已知的事实和蕴涵式的前提只需要与一个置换匹配，而不需要完全一致。
chap5_para1102,2,,但肯定前件允许任意语句作为前提，而非仅是原子语句的合取。
chap5_para1103,1,,这条规则有n+1个前提：n个原子语句和一个蕴涵式。
chap5_para1103,2,,结论是对后件q运用置换的结果。
chap5_para1103,3,,对我们的例子来说：
chap5_para1104,1,,是King(John)　　　　　　　　　　 p1是King(x)
chap5_para1105,1,,是Greedy(y)　　　　　　　　　　　p2是Greedy(x)
chap5_para1106,1,,是　　　　　　　　q是Evil(x)
chap5_para1107,1,,是Evil(John)
chap5_para1108,1,,很容易证明一般化肯定前件是可靠的推断规则。
chap5_para1108,2,,首先，我们观察到，对于任意语句p（假设其变量是全称量化的）和任意置换，
chap5_para1109,1,,根据全称量词实例化为真。
chap5_para1109,2,,特别地，它对于满足一般化肯定前件规则条件的为真。
chap5_para1109,3,,因此，我们可以从推断
chap5_para111,1,"Once a variable has been selected, the algorithm must decide on the order in which to examine its values. The least-constraining-value heuristic is effective for this. It prefers the value that rules out the fewest choices for the neighboring variables in the constraint graph. For example, suppose that in Figure 5.1 we have generated the partial assignment with WA = red and NT = green and that our next choice is for Q. Blue would be a bad choice because it eliminates the last legal value left for Q’s neighbor, SA. The least-constraining-value heuristic therefore prefers red to blue. In general, the heuristic is trying to leave the maximum flexibility for subsequent variable assignments.",给定了模拟策略，我们接下来需要决定两件事：从什么局面开始模拟，以及分配给每个局面多少次模拟？
chap5_para111,2,,最简单的答案是纯蒙特卡罗搜索（pure Monte Carlo search），即从博弈当前状态开始做N次模拟，并记录从当前局面开始哪一种可能移动胜率最高。
chap5_para1110,1,,并且，从蕴涵式我们可以推断
chap5_para1111,1,,现在，一般化肯定前件规则中的已被定义为对所有i使得，因此这两条语句中，第一条语句正好匹配第二条语句的前提。
chap5_para1111,2,,根据肯定前件规则可得。
chap5_para1112,1,,一般化肯定前件是肯定前件的提升版——它将肯定前件从基本（无变量的）命题逻辑提升到一阶逻辑。
chap5_para1112,2,,我们将在本章其余部分看到第7章中的前向链接、反向链接和归结算法的提升版。
chap5_para1112,3,,提升版推断规则相比于命题化的重要优势在于，提升版推断规则只需必要的置换就可以进行特定的推断。
chap5_para1114,1,,提升版推断规则需要找出使不同的逻辑表达式看起来相同的置换。
chap5_para1114,2,,这一过程被称作合并（unification），是所有一阶逻辑推断算法的重要组成部分。
chap5_para1114,3,,合一算法Unify接收两条语句作为输入，如果存在置换，则为它们返回一个合一子（unifier）（即这个置换）：
chap5_para1115,1,,我们用一个例子来展示Unify的工作方式。
chap5_para1115,2,,"假设有查询AskVar(Knows(John, x))：约翰认识谁？"
chap5_para1115,3,,"这条查询的答案可以通过找出知识库中所有与Knows(John, x)合一的语句来找到。"
chap5_para1115,4,,此处有与4条不同语句合并而来的结果，它们可能在知识库中：
chap5_para1116,1,,最后一条合一失败了，因为x不能同时取值为John和Elizabeth。
chap5_para1116,2,,"但我们知道Knows(x, Elizabeth)的意思是“所有人都认识伊丽莎白”，因此我们应该可以推断出约翰认识伊丽莎白。"
chap5_para1116,3,,之所以出现问题是因为两条语句恰好使用了相同的变量名x。
chap5_para1116,4,,对要合一的两条语句中的一条进行标准化分离（standardizing apart），也就是对其变量进行重命名来避免名称冲突，就可以解决这一问题。
chap5_para1116,5,,"例如，我们可以将Knows(x, Elizabeth)中的x重命名为（新变量名）x17而不会改变其含义。"
chap5_para1116,6,,现在就可以进行合一了：
chap5_para1117,1,,习题9.STAN深入探讨了标准化分离的必要性。
chap5_para1118,1,,还有一个麻烦：我们说过Unify应当返回使两个参数看起来相同的置换。
chap5_para1118,2,,但这样的合一子可能不止一种。
chap5_para1118,3,,例如，可能返回或者。
chap5_para1118,4,,第一个合一子的结果是，而第二个合一子的结果是。
chap5_para1118,5,,第二个结果可以在第一个结果的基础上置换得出，因此我们说第一个合一子比第二个更一般化，因为它对变量的值的限制更少。
chap5_para1119,1,,每一对可合一的表达式都有一个最一般合一子（most general unifier，MGU），在不考虑变量的重命名和置换的情况下，它是唯一的。
chap5_para1119,2,,例如，和被看作是等价的，和也是等价的。
chap5_para112,1,"Why should variable selection be fail-first, but value selection be fail-last?",对于一些随机游戏，随着N的增加，这一策略会收敛到最优策略，但对大多数博弈来说，这还不够——我们需要一个选择策略（selection policy），有选择地将计算资源集中在博弈树的重要部分上。
chap5_para112,2,"Every variable has to be assigned eventually, so by choosing the ones that are likely to fail first, we will on average have fewer successful assignments to backtrack over.",选择策略需要平衡两个因素以做出更准确的估计：对那些模拟次数很少的状态的探索（exploration），以及对那些在过去的模拟中表现良好的状态的利用（exploitation）。
chap5_para112,3,"For value ordering, the trick is that we only need one solution; therefore it makes sense to look for the most likely values first.",（有关探索/利用权衡的更多信息，请参阅17.3节。
chap5_para112,4,"If we wanted to enumerate all solutions rather than just find one, then value ordering would be irrelevant.",）蒙特卡罗树搜索维护一个搜索树，它在每次迭代（包含以下4个步骤）中不断增长，如图5-10所示。
chap5_para1120,1,,图9-1展示了一个用于计算最一般合一子的算法。
chap5_para1120,2,,这一过程很简单：同时递归地交替探索两个表达式，并在这个过程中创建合一子，如果结构中的两个对应点不匹配则返回失败。
chap5_para1120,3,,这个过程中存在一个高代价的步骤：当匹配某变量和一个复合项时，必须检查这个变量是否出现在这一复合项中；如果是，则匹配失败，因为无法构建一致的合一子。
chap5_para1120,4,,例如，S(x)无法与S(S(x))合一。
chap5_para1120,5,,这种出现检验（occur check）使得整个算法的复杂性是待合一的表达式规模的二次方。
chap5_para1120,6,,包括许多逻辑编程系统在内的一些系统干脆取消了出现检验，将避免不可靠推断的责任推给用户。
chap5_para1120,7,,其他系统则使用具有线性复杂性的更为复杂的合一算法。
chap5_para1121,1,,图9-1　合一算法。
chap5_para1121,2,,参数x和y可以是任意表达式：一个常量或者一个变量，或复合表达式（如复合的语句或项），或一系列表达式。
chap5_para1121,3,,参数是一个置换，初始值为空置换，但会随着我们在输入、逐个比较表达式元素的递归中加入。
chap5_para1121,4,,"在如F(A, B)的复合表达式中，Op(x)函数提取函数符号F而Args(x)函数提取参数表(A,B)"
chap5_para1122,1,,9.2.2　存储与检索
chap5_para1123,1,,用于告知和询问知识库的Tell、Ask和AskVar函数的底层是更基本的Store和Fetch函数。
chap5_para1123,2,,Store(s)将语句s存入知识库，而Fetch(q)返回所有使查询q与知识库中某个语句合一的合一子。
chap5_para1123,3,,"之前我们用于解释合一的例题（找出能与Knows(John, x)合一的所有事实）就是Fetch的一个实例。"
chap5_para1124,1,,实现Store和Fetch最简单的方式就是在一个长列表中列出所有事实，并将每个查询与列表中的每个元素合一。
chap5_para1124,2,,这种过程很低效，却可以正常工作。
chap5_para1124,3,,本节余下部分将概述使检索更为高效的方法。
chap5_para1125,1,,我们可以通过确保仅对有一定合一可能的语句进行合一来使Fetch更高效。
chap5_para1125,2,,"例如，合一Knows(John, x)和Brother(Richard, John)就没什么意义。"
chap5_para1125,3,,我们可以通过索引知识库中的事实来避免这种合一。
chap5_para1125,4,,一种叫作谓词索引的简单方法将所有Knows开头的事实放入一个存储桶内，而将所有Brother开头的事实放入另一个存储桶内。
chap5_para1125,5,,而这些存储桶可以用哈希表存储，以提高效率。
chap5_para1126,1,,谓词索引对于谓词符号很多而每个符号只有少量子句的情形非常有用。
chap5_para1126,2,,但有时，一个谓词有许多子句。
chap5_para1126,3,,"例如，假设税务部门想用谓词Employs(x, y)掌握雇佣关系情况。"
chap5_para1126,4,,这就会形成一个非常大的存储桶，其中很可能有几百万雇主和几千万雇员。
chap5_para1126,5,,"用谓词索引方法回答如Employs(x, Richard)这样的查询就需要搜索整个存储桶。"
chap5_para1127,1,,对于这类特殊的查询，如果除谓词外再使用第二个参数一起索引事实的话，就可能改善效率。
chap5_para1127,2,,这种方法也许要用到组合的哈希表键值。
chap5_para1127,3,,这样我们只要用查询构造键值，就能精确地检索到能与查询合一的事实。
chap5_para1127,4,,"对于其他查询，如Employs(IBM, y)，我们可能需要结合谓词和第一个参数来索引事实。"
chap5_para1127,5,,因此，事实可以存储在多个索引键值之下，以便各种可能与之合一的查询迅速地找到它们。
chap5_para1128,1,,给定要存储的语句，可以对所有可能与之合一的查询构建索引。
chap5_para1128,2,,"对于Employs(IBM, Richard)这样的事实，查询为"
chap5_para1129,1,,"Employs(IBM, Richard)（IBM是否雇佣了理查？"
chap5_para1129,2,,）
chap5_para113,1,5.,图5-10　使用蒙特卡罗树搜索（MCTS）选择移动的算法的一次迭代，该算法使用“应用于树搜索的置信上界”法（UCT）作为选择度量，此时已完成了100次迭代。
chap5_para113,2,3.,（a）选择移动，沿着树一直向下，到标记为27/35（35次模拟中黑方赢了27次）的叶节点结束。
chap5_para113,3,2Interleaving search and inference,（b）扩展所选节点并进行模拟，最终黑方获胜。
chap5_para113,4,,（c）将模拟结果沿树反向传播
chap5_para1130,1,,"Employs(x, Richard)（谁雇佣了理查？"
chap5_para1130,2,,）
chap5_para1131,1,,"Employs(IBM, y)（IBM雇佣了谁？"
chap5_para1131,2,,）
chap5_para1132,1,,"Employs(x, y)（谁雇佣了谁？"
chap5_para1132,2,,）
chap5_para1133,1,,这些查询构成了一个包容格（subsumption lattice），如图9-2a所示。
chap5_para1133,2,,包容格具有一些有趣的性质。
chap5_para1133,3,,格中任意节点的子节点都是对父节点进行一次置换而来，而任意两个节点的 “最高” 共同后代则是应用最一般合一子的结果。
chap5_para1133,4,,具有重复常量的语句的格略有不同，如图9-2b所示。
chap5_para1133,5,,尽管函数符号并未在图中体现，但它们也可以被纳入这种格结构中。
chap5_para1134,1,,"图9-2　（a）最低节点为Employs(IBM, Richard)的包容格。"
chap5_para1134,2,,"（b）语句Employs(John, John)的包容格"
chap5_para1135,1,,对于只有少量参数的谓词符号，为包容格中每一个点创建一个索引是一种很好的权衡。
chap5_para1135,2,,这增加了一点点存储时间，但节省了检索时间。
chap5_para1135,3,,然而，对于有n个参数的谓词，其包容格含有O(2n)个节点。
chap5_para1135,4,,如果允许函数符号的话，节点的数量同样是要存储的语句中项的数量的指数级。
chap5_para1135,5,,这就会导致大量的索引。
chap5_para1136,1,,我们不得不采用一些方法将索引的范围限制为可能被查询频繁使用的节点，否则我们花在创建索引上的时间可能比使用索引而节省的时间还多。
chap5_para1136,2,,我们可以采取固定的策略，譬如只维护键值由一个谓词和单个参数构成的索引。
chap5_para1136,3,,我们还可以习得一种自适应的策略，它能够创建索引来满足各类查询的要求。
chap5_para1136,4,,对于事实数量以十亿计的商用数据库，一直有对这一课题的大量的研究、技术开发和持续改进。
chap5_para1138,1,,在7.5节中我们展示了用于命题确定子句知识库的前向链接算法。
chap5_para1138,2,,本节我们拓展这个概念以涵盖一阶确定子句。
chap5_para1139,1,,当然，有一些逻辑语句无法被表述为确定子句，因此也无法用这种方法处理。
chap5_para1139,2,,但形如Antecedent ⇒ Consequent的规则足以涵盖许多有趣的真实世界系统。
chap5_para114,1,We saw how AC-3 can reduce the domains of variables before we begin the search.,● 选择：从搜索树的根节点开始，选择一个移动（在选择策略的指导下），到达一个后继节点，然后重复该过程，沿着树向下移动到叶节点。
chap5_para114,2,"But inference can be even more powerful during the course of a search: every time we make a choice of a value for a variable, we have a brand-new opportunity to infer new domain reductions on the neighboring variables.",图5-10a为一棵搜索树，根表示白方刚刚移动的状态，到目前为止，白方已经在100次模拟中赢了37次。
chap5_para114,3,,粗箭头表示黑方选择的移动，在它指向的节点上黑方赢了60/79次。
chap5_para114,4,,这是3种移动中最高的胜率，所以选择它是一次利用。
chap5_para114,5,,但为了探索，选择2/11节点也是合理的——只有11次模拟，该节点的估值仍有很高的不确定性，如果我们获得更多相关信息，它最终可能是最好的。
chap5_para114,6,,继续选择直到到达标有27/35的叶节点。
chap5_para1140,1,,9.3.1　一阶确定子句
chap5_para1141,1,,一阶确定子句是文字的析取式，其中必须有且仅有一个正文字。
chap5_para1141,2,,这意味着确定子句要么是原子的，要么是前件为正文字的合取、后件为单个正文字的蕴涵式。
chap5_para1141,3,,存在量词在此处不能使用，而全称量词则被隐式地表示：如果你在确定子句中看到x，就意味着有隐含的∀x量词。
chap5_para1141,4,,典型的一阶逻辑确定子句如下：
chap5_para1142,1,,但文字King(x)和Greedy(y)也可以看作确定子句。
chap5_para1142,2,,一阶文字可以含有变量，因此Greedy(y)被解释为“每个人都是贪婪的”（全称量词是隐含的）。
chap5_para1143,1,,我们用确定子句表示如下问题：
chap5_para1144,1,,法律规定，美国人将武器出售给敌对国家是犯罪行为。
chap5_para1144,2,,诺诺（Nono）国是美国的敌人，它拥有一些导弹，所有导弹都是韦斯特（West）上校出售给它的，而韦斯特上校是美国人。
chap5_para1145,1,,首先，我们用一阶确定子句表示这些事实。
chap5_para1146,1,,“……美国人将武器出售给敌对国家是犯罪行为”：
chap5_para1148,1,,表示“诺诺国……拥有一些导弹”的语句被转换为两个存在量化的确定子句，其中引入了新的常量M1：
chap5_para115,1,One of the simplest forms of inference is called forward checking.,● 扩展：我们通过为所选节点生成一个新的子节点的方式增长搜索树，图5-10b中展示了标记为0/0的新节点。
chap5_para115,2,"Whenever a variable X is assigned, the forward-checking process establishes arc consistency for it: for each unassigned variable Y that is connected to X by a constraint, delete from Y 's domain any value that is inconsistent with the value chosen for X.",（一些版本在这一步中会生成多个子节点。
chap5_para115,3,,）
chap5_para1151,1,,“所有导弹都是韦斯特上校出售给它的”：
chap5_para1153,1,,我们还需要知道导弹是武器：
chap5_para1155,1,,且我们必须知道美国的敌人是“敌对的”：
chap5_para1157,1,,“而韦斯特上校是美国人……”：
chap5_para1159,1,,“诺诺国是美国的敌人……”：
chap5_para116,1,Figure 5.,● 模拟：我们从新生成的子节点开始执行一次模拟，根据模拟策略为两个参与者选择移动。
chap5_para116,2,7 shows the progress of backtracking search on the Australia CSP with forward checking.,这些移动不会记录在搜索树中。
chap5_para116,3,There are two important points to notice about this example.,在图中，模拟结果为黑方获胜。
chap5_para116,4,"First, notice that after WA = red and Q = green are assigned, the domains of NT and SA are reduced to a single value; we have eliminated branching on these variables altogether by propagating information from WA and Q.",
chap5_para116,5,"A second point to notice is that after V = blue, the domain of SA is empty.",
chap5_para116,6,"Hence, forward checking has detected that the partial assignment {WA = red, Q = green, V = blue} is inconsistent with the constraints of the problem, and the algorithm backtracks immediately.",
chap5_para1161,1,,这个知识库恰好是一个数据日志（datalog）知识库：数据日志是由不含函数符号的一阶确定子句组成的语言。
chap5_para1161,2,,它能够表示由关系数据库生成的陈述类型，故得名。
chap5_para1161,3,,没有了函数符号使推断更容易。
chap5_para1162,1,,9.3.2　简单的前向链接算法
chap5_para1163,1,,图9-3展示了简单的前向链接推断算法。
chap5_para1163,2,,它从已知事实开始，触发所有前提被满足的规则，将结论添加到已知事实中。
chap5_para1163,3,,这一过程不断重复，直到查询得到回答（假设只需要一个回答）或没有新的事实被添加。
chap5_para1163,4,,注意，如果一个事实只是某个已知事实的重命名，也就是只有变量名字不同的语句，那它就不是一个“新”事实。
chap5_para1163,5,,"例如，Likes(x, IceCream)与Likes(y, IceCream)互为重命名。"
chap5_para1163,6,,它们都意味着相同的事情：“每个人都喜欢冰激凌”。
chap5_para1164,1,,图9-3　一个概念上很直观，但低效的前向链接算法。
chap5_para1164,2,,每次迭代，它都将那些用一步就可以从已经在KB中的蕴涵语句和原子语句推断出的原子语句添加到KB中。
chap5_para1164,3,,函数Standardize-Variables用先前未使用过的变量替换其所有的参数
chap5_para1165,1,,下面我们使用前面的犯罪问题来解释FOL-FC-Ask。
chap5_para1165,2,,可用于链接的蕴涵语句为式（9-3）、式（9-6）、式（9-7）和式（9-8）。
chap5_para1165,3,,这里需要两次迭代。
chap5_para1166,1,,● 第一次迭代中，规则式（9-3）的前提未满足。
chap5_para1167,1,,满足规则式（9-6），添加。
chap5_para1168,1,,满足规则式（9-7），添加。
chap5_para1169,1,,满足规则式（9-8），添加。
chap5_para117,1,"Description Part (“a”): Selection. The node at the top is labeled 37 by 100. The three child nodes of the node are labeled 60 by 79, 1 by 10, and 2 by 11. The two child nodes of 60 by 79 are labeled 3 by 26 and 16 by 53. The two child nodes of 1 by 10 are labeled 6 by 6 and 3 by 4. The two child nodes of 16 by 53 are labeled 27 by 35 and 10 by 18. The two child nodes of 6 by 6 are labeled 0 by 3 and 0 by 3. Normal arrows are shown from parent nodes to child nodes. Bold arrows are shown for the following. From 37 by 100 to 60 by 79. From 60 by 79 to 16 by 53. From 16 by 53 to 27 by 35. Part (b): Expansion and simulation. The node at the top is labeled 37 by 100. The three child nodes of the node are labeled 60 by 79, 1 by 10, and 2 by 11. The two child nodes of 60 by 79 are labeled 3 by 26 and 16 by 53. The two child nodes of 1 by 10 are labeled 6 by 6 and 3 by 4. The two child nodes of 16 by 53 are labeled 27 by 35 and 10 by 18. The two child nodes of 6 by 6 are labeled 0 by 3 and 0 by 3. The child node of 27 by 35 is labeled 0 by 0. Normal arrows are shown from parent nodes to child nodes. A bold arrow is shown from 27 by 35 to 0 by 0. A curved arrow from 0 by 0 is labeled black wins. Part (c): Backpropagation. The node at the top is labeled 37 by 101. The three child nodes of the node are labeled 61 by 80, 1 by 10, and 2 by 11. The two child nodes of 61 by 80 are labeled 3 by 26 and 16 by 54. The two child nodes of 1 by 10 are labeled 6 by 6 and 3 by 4. The two child nodes of 16 by 54 are labeled 28 by 36 and 10 by 18. The two child nodes of 6 by 6 are labeled 0 by 3 and 0 by 3. The child node of 28 by 36 is labeled 0 by 1. Normal arrows are shown from parent nodes to child nodes. Bold arrows are shown from child nodes to parent nodes for the following. From 0 by 1 to 28 by 36. From 28 by 36 to 16 by 54. From 16 by 54 to 61 by 80. From 61 by 80 to 37 by 101.",● 反向传播：我们现在使用模拟结果自底向上地更新所有搜索树节点。
chap5_para117,2,,因为这次模拟的结果是黑方获胜，所以黑方节点的获胜次数和模拟次数都会增加，27/35变为28/36，60/79变为61/80。
chap5_para117,3,,因为白方失败，其节点只增加模拟次数，所以16/53变为16/54，根节点的37/100变为37/101。
chap5_para1170,1,,● 第二次迭代中，规则式（9-3）被满足，添加推断。
chap5_para1171,1,,图9-4展示了所生成的证明树。
chap5_para1171,2,,注意，此时已不可能再产生新的推断，因为每个可以用前向链接得出的语句已经显式地被纳入知识库。
chap5_para1171,3,,这种知识库被称为推断过程的不动点。
chap5_para1171,4,,对一阶确定子句使用前向链接得到的不动点与命题前向链接中的类似（7.5.4节），主要的区别在于一阶逻辑不动点可以含有全称量化的原子语句。
chap5_para1172,1,,FOL-FC-Ask很容易分析。
chap5_para1172,2,,首先，它是可靠的，因为每个推断都是对一般化肯定前件的应用，而一般化肯定前件是可靠的。
chap5_para1172,3,,其次，它对于确定子句知识库是完备的，也就是说，它能够对所有答案蕴涵在确定子句知识库中的查询做出回答。
chap5_para1173,1,,对于不含有函数符号的数据日志知识库，完备性的证明相当简单。
chap5_para1173,2,,先对可能被添加的事实进行计数，这决定着迭代的次数。
chap5_para1173,3,,令k为最大元数（参数的数量），p为谓词数量，n为常量符号的数量。
chap5_para1173,4,,显然，基本事实的数量不可能超过pnk个，因此在这么多次迭代后，算法必然已经到达了不动点。
chap5_para1173,5,,然后我们就可以得出论据，它非常类似于命题前向链接完备性的证明。
chap5_para1173,6,,（见7.5.4节。
chap5_para1173,7,,）如何从命题逻辑完备性转进到一阶逻辑完备性的细节在9.5节介绍归结算法时给出。
chap5_para1174,1,,图9-4　前向链接算法为犯罪问题生成的证明树。
chap5_para1174,2,,最早的事实出现在最下层，第一次迭代推断得到的事实在中间层，而第二次迭代推断得出的事实在最顶层
chap5_para1175,1,,对于含有函数符号的一般确定子句，FOL-FC-Ask会生成无穷多的新事实，因此我们需要非常小心。
chap5_para1175,2,,在查询语句q的答案被蕴含的情形下，我们只能凭借埃尔布朗定理（9.1.1节）来证实算法将找到证明。
chap5_para1175,3,,（见9.5节的归结情形。
chap5_para1175,4,,）如果查询没有答案，算法在某些情况下就无法终止。
chap5_para1175,5,,例如，如果知识库含有皮亚诺公理
chap5_para1176,1,,则前向链接将添加NatNum(S(0))、NatNum(S(S(0)))、NatNum(S(S(S(0))))等。
chap5_para1176,2,,一般来说，这个问题是无法避免的。
chap5_para1176,3,,如我们在常规一阶逻辑中所见，确定子句的蕴含是半可判定的。
chap5_para1177,1,,9.3.3　高效前向链接
chap5_para1178,1,,图9-3所示的前向链接算法为了便于理解而牺牲了效率。
chap5_para1178,2,,低效的原因有3个。
chap5_para1178,3,,首先，算法的内层循环试图对知识库中的每一条规则和每一条事实进行匹配。
chap5_para1178,4,,其次，算法每次迭代都检查所有规则，尽管知识库只有少量更新。
chap5_para1178,5,,最后，算法会生成许多与目标无关的事实。
chap5_para1178,6,,我们依次解决这些问题。
chap5_para1179,1,,1. 将规则与已知事实进行匹配
chap5_para118,1,Figure 5.,我们在固定次数的迭代中重复这4个步骤，或者迭代到所分配的时间耗尽，然后返回模拟次数最多的移动。
chap5_para118,2,7The progress of a map-coloring search with forward checking.,
chap5_para118,3,WA = red is assigned first; then forward checking deletes red from the domains of the neighboring variables NT and SA.,
chap5_para118,4,"After Q = green is assigned, green is deleted from the domains of NT, SA, and NSW.",
chap5_para118,5,"After V = blue is assigned, blue is deleted from the domains of NSW and SA, leaving SA with no legal values.",
chap5_para1180,1,,将规则的前提与知识库中的事实进行匹配的问题似乎很简单。
chap5_para1180,2,,例如，假设我们要应用规则
chap5_para1181,1,,则我们需要找出所有与匹配的事实；被恰当索引的知识库可以在常量时间内对每个事实完成这项操作。
chap5_para1181,2,,现在考虑规则
chap5_para1182,1,,同样，我们可以在常量时间内找出诺诺国拥有的所有对象，然后对于每个对象，我们可以检查它是否是导弹。
chap5_para1182,2,,但如果知识库含有许多诺诺国拥有的对象而其中只有极少数是导弹，先找出所有的导弹然后再检查它们是否被诺诺国所拥有就是更好的操作。
chap5_para1182,3,,这就是合取子句排序（conjunct ordering）问题：求解规则前提的合取子句的排序，使总代价最小。
chap5_para1182,4,,实际上找出最优排序是NP困难问题，不过可以使用很好的启发式算法求解。
chap5_para1182,5,,例如，在第6章用于CSP的最小剩余值（MRV）启发式算法会建议，如果导弹的数量比诺诺国拥有的对象数量少，就对合取子句进行排序先查找导弹。
chap5_para1183,1,,实际上，模式匹配与约束满足的联系十分紧密。
chap5_para1183,2,,我们可以将每个合取子句看作一条对它所包含的变量的约束，例如，是x的一元约束。
chap5_para1183,3,,拓展这种想法，就能将所有有限域CSP表示为单个确定子句和相关的基本事实。
chap5_para1183,4,,考虑图6-1中的地图着色问题，这里显示于图9-5a。
chap5_para1183,5,,图9-5b给出了其等价的单个确定子句形式。
chap5_para1183,6,,很明显，只有CSP有解，才可以推断出结论Colorable()。
chap5_para1183,7,,因为3-SAT问题是一般CSP的一个特例，我们可以断定，将确定子句与事实集进行匹配的问题是NP困难问题。
chap5_para1184,1,,图9-5　（a）用于为澳大利亚地图着色的约束图。
chap5_para1184,2,,（b）用单个确定子句表示的地图着色CSP。
chap5_para1184,3,,每个地图区域都用变量表示，变量的值可以为常量red、green、blue（使用Diff声明）
chap5_para1185,1,,前向链接的内层循环含有NP困难的匹配问题看起来相当令人沮丧。
chap5_para1185,2,,但还是有3种方法能令我们振奋起来。
chap5_para1186,1,,● 我们可以发现，真实世界知识库的大部分规则是简洁的（如同犯罪例子中所示），而不是繁复的（如图9-5所示的CSP形式化）。
chap5_para1186,2,,在数据库世界中，很常用的假设是规则的长短和谓词的元数都限于一个常数，只需关心数据复杂性的问题，也就是，形式为知识库中基本事实数量的函数的推断复杂性。
chap5_para1186,3,,很容易证明前向链接的数据复杂性是多项式级别的，而非指数量级的。
chap5_para1187,1,,● 我们可以考虑使匹配变得高效的规则的子类别。
chap5_para1187,2,,本质上，所有数据日志子句都可以视作定义一个CSP，因此，如果对应的CSP容易求解，则匹配也容易求解。
chap5_para1187,3,,第6章描述了几种易解的CSP。
chap5_para1187,4,,例如，如果约束图（节点为变量，边为约束的图）构成一棵树，那么CSP就可以在线性时间内求解。
chap5_para1187,5,,完全相同的情况对匹配也成立。
chap5_para1187,6,,例如，如果我们从图9-5的地图中去掉南澳大利亚州SA，得到的子句就是：
chap5_para1188,1,,它对应于6.5.1节的图6-12所示的简化CSP。
chap5_para1188,2,,用于求解树状结构CSP的算法可以直接用来求解规则匹配问题。
chap5_para1189,1,,● 我们可以试着消除前向链接算法中冗余的规则匹配尝试，如下一部分内容所述。
chap5_para119,1,"For many problems the search will be more effective if we combine the MRV heuristic with forward checking. Consider Figure 5.7 after assigning {WA = red}. Intuitively, it seems that that assignment constrains its neighbors, NT and SA, so we should handle those variables next, and then all the other variables will fall into place. That’s exactly what happens with MRV: NT and SA each have two values, so one of them is chosen first, then the other, then Q, NSW, and V in order. Finally T still has three values, and any one of them works. We can view forward checking as an efficient way to incrementally compute the information that the MRV heuristic needs to do its job.",一种非常有效的选择策略称为“应用于树搜索的置信上界”，即UCT。
chap5_para119,2,,它根据称为UCB1的置信上界公式对每个可能的移动排序。
chap5_para119,3,,（详见17.3.3节。
chap5_para119,4,,）对节点n来说，公式为
chap5_para1191,1,,我们先前在解释前向链接算法在犯罪问题示例中的工作方式时作弊了。
chap5_para1191,2,,具体而言，我们省略了由图9-3所示的算法完成的规则匹配。
chap5_para1191,3,,例如，在第二次迭代中，规则
chap5_para1192,1,,（第二次）匹配到了Missile(M1)，当然地，结论Weapon(M1)已知，因此什么都没发生。
chap5_para1192,2,,如果我们有如下的观察：所有在第t次迭代中推断出的新事实必然是从至少一个在第t−1次迭代中推断出的新事实推得的，就可以避免这种多余的规则匹配。
chap5_para1192,3,,这是正确的，因为所有不需要来自第t−1次迭代的新事实的推断，肯定在第t−1次迭代时就已经得出了。
chap5_para1193,1,,这一观察结果自然地引出增量前向链接算法，其中在第t次迭代时，我们仅检查前提含有合取子句pi的规则，pi能够与在第t−1次迭代新产生的事实p'i合一。
chap5_para1193,2,,规则匹配步骤随后固定pi来与p'i合一，但允许规则的其他合取子句与任意先前迭代产生的事实匹配。
chap5_para1193,3,,这个算法在每次迭代中生成的事实与图9-3所示的算法完全一致，但高效得多。
chap5_para1194,1,,如果有合适的索引，就很容易找到所有能够由任意已知事实触发的规则。
chap5_para1194,2,,很多真实系统在“更新”模式下运作，也就是每次收到Tell时都以前向链接作为回应。
chap5_para1194,3,,推断在规则集上逐级运行，直到达到不动点。
chap5_para1194,4,,这一过程对下一个新事实重复执行。
chap5_para1195,1,,一般来说，知识库中只有少部分规则是由新添加的已知事实而触发的。
chap5_para1195,2,,这就意味着在反复构建某些前提不满足的部分匹配时产生了大量冗余的工作。
chap5_para1195,3,,我们的犯罪问题示例由于太简单而无法很好地展示这种情形，但注意，第一次迭代中构建了一个规则
chap5_para1196,1,,和事实American(West)的部分匹配。
chap5_para1196,2,,这一部分匹配被丢弃，并在第二次迭代中重新构建（当规则匹配成功时）。
chap5_para1196,3,,比较好的做法是，保留部分匹配，并在新事实到来时逐步补全部分匹配而非直接丢弃它们。
chap5_para1197,1,,Rete算法（Rete algorithm）[3]首先求解了这一问题。
chap5_para1197,2,,算法对知识库中的规则集进行预处理来构建一个数据流网络，其中每个节点是规则前提中的一个文字。
chap5_para1197,3,,变量绑定在网络中流动，并在无法匹配某个文字时被过滤掉。
chap5_para1197,4,,如果一条规则中的两个文字共用一个变量，例如犯罪示例中的，则每个文字的绑定会被一个相等节点过滤。
chap5_para1197,5,,当变量绑定到达一个n元文字（如）的节点时，可能需要在过程继续运行前等待其他变量绑定的建立。
chap5_para1197,6,,在任意给定时刻，Rete网络的状态都会捕获所有规则的部分匹配，避免了大量的重新计算。
chap5_para1199,1,,[3]　Rete是拉丁语“网”的意思。
chap5_para1199,2,,它与“条约”（treaty）的英语发音押韵。
chap5_para12,1,"CSPs deal with assignments of values to variables, {Xi = vi, Xj = vj,.",人工智能领域中最常研究的博弈（例如国际象棋和围棋）是博弈论学者所称的确定性、双人、轮流、完美信息（perfect information）的零和博弈（zero-sum game）。
chap5_para12,2,.,“完美信息”是“完全可观测”的同义词[2]，“零和”意味着对一方有利的东西将对另一方同等程度有害：不存在“双赢”结果。
chap5_para12,3,.,在博弈论中，我们通常用移动（move）作为“动作”（action）的同义词，用局面（position）作为“状态”（state）的同义词。
chap5_para12,4,}.,
chap5_para12,5,An assignment that does not violate any constraints is called a consistent or legal assignment.,
chap5_para12,6,"A complete assignment is one in which every variable is assigned a value, and a solution to a CSP is a consistent, complete assignment.",
chap5_para12,7,"A partial assignment is one that leaves some variables unassigned, and a partial solution is a partial assignment that is consistent.",
chap5_para12,8,"Solving a CSP is an NP-complete problem in general, although there are important subclasses of CSPs that can be solved very efficiently.",
chap5_para120,1,"Although forward checking detects many inconsistencies, it does not detect all of them. The problem is that it doesn't look ahead far enough. For example, consider the Q = green row of Figure 5.7. We’ve made WA and Q arc-consistent, but we’ve left both NT and SA with blue as their only possible value, which is an inconsistency, since they are neighbors.",其中U(n)为经过节点n的所有模拟的总效用值，N(n)是经过节点n的模拟次数，Parent(n)是树中n的父节点。
chap5_para120,2,,因此为利用项，即节点n的平均效用值。
chap5_para120,3,,带有平方根的项是探索项：分母为N(n)，这意味着对只探索过几次的节点来说，这一项的值比较高；分子记录了我们对n的父节点的探索次数，这意味着，如果我们选择n的概率不是0，那么随着计数的增加，探索项会趋于零，最终模拟次数将被分配给平均效用值最高的节点。
chap5_para1200,1,,Rete网络和以它为基础的各种改进已经成为了所谓的产生式系统（production system）的关键组成部分。
chap5_para1200,2,,产生式系统是最早被大量使用的前向链接系统之一。
chap5_para1200,3,,"[4]Xcon系统（最初被称为R1；McDermott, 1982）就是用产生式系统的结构构建的。"
chap5_para1200,4,,Xcon含有用于为DEC公司的客户设计计算机部件规格的数千条规则。
chap5_para1200,5,,它是最早在专家系统这一新兴领域取得显著商业成功的系统之一。
chap5_para1200,6,,许多其他类似的系统都以相同的核心技术构建，这一技术已经在通用语言Ops-5中实现。
chap5_para1202,1,,[4]　“产生式系统”中的“产生式”表示一种条件-行动规则。
chap5_para1203,1,,产生式系统在认知架构（cognitive architecture）中也很流行。
chap5_para1203,2,,"认知架构也就是人类推理的模型，如ACT（Anderson, 1983）和Soar（Laird et al., 1987）。"
chap5_para1203,3,,在这些系统中，系统的“工作记忆”对人类的短期记忆进行建模，而产生式则是长期记忆的一部分。
chap5_para1203,4,,在每个操作周期中，产生式被匹配到事实的工作记忆。
chap5_para1203,5,,条件得到满足的产生式可以在工作记忆中添加或删除事实。
chap5_para1203,6,,相比于数据库中的典型情形，产生式系统往往有很多规则，却只有很少的事实。
chap5_para1203,7,,运用适当的优化匹配技术，系统可以在有几百万条规则的情况下实时运行。
chap5_para1205,1,,另一个低效的原因是前向链接允许所有基于已知事实的推断，即使它们与目标并不相关。
chap5_para1205,2,,在犯罪示例中，没有能够得出不相关结论的规则。
chap5_para1205,3,,但如果存在很多描述美国人饮食习惯，或导弹的部件及价格的规则，那么FOL-FC-Ask就会产生不相关结论。
chap5_para1206,1,,一种避免得到不相关结论的方法是使用反向链接，在9.4节中将进行讨论。
chap5_para1206,2,,另一种方法是将前向链接限制到特意挑选的规则子集上，如PL-FC-Entails?所示（7.5.4节）。
chap5_para1206,3,,第三种方法已经出现在演绎数据库（deductive database）中，这是一种大规模数据库，类似于关系数据库，但使用前向链接而非SQL查询作为标准推断工具。
chap5_para1206,4,,它的基本原理是使用目标信息重写规则集，以便在前向推理中只考虑相关的变量绑定，也就是那些属于所谓的魔法集（magic set）的绑定。
chap5_para1206,5,,例如，如果目标是Criminal(West)，能得出Criminal(x)的规则就会被重写，以便包含附加的、限制x的值的合取子句：
chap5_para1207,1,,事实Magic(West)也被加入知识库中。
chap5_para1207,2,,这样，即使知识库含有关于几百万美国人的事实，也只有韦斯特上校会在前向链接中被考虑到。
chap5_para1207,3,,定义魔法集、重写知识库的完整过程过于复杂，在此不详细描述，但其基本概念是从目标进行某种“通用”的反向推断，以此来找出哪些变量绑定需要被约束。
chap5_para1207,4,,因此，魔法集方法可以被认为是一种前向推断和反向预处理的混合。
chap5_para1209,1,,另一种主要的逻辑推断算法对确定子句使用反向链接。
chap5_para1209,2,,这些算法从目标开始反向运行，链接规则以找出支持证明的已知事实。
chap5_para121,1,"The algorithm called MAC (for Maintaining Arc Consistency) detects inconsistencies like this. After a variable Xi is assigned a value, the INFERENCE procedure calls AC-3, but instead of a queue of all arcs in the CSP, we start with only the arcs (Xj, Xi) for all Xj that are unassigned variables that are neighbors of Xi. From there, AC-3 does constraint propagation in the usual way, and if any variable has its domain reduced to the empty set, the call to AC-3 fails and we know to backtrack immediately. We can see that MAC is strictly more powerful than forward checking because forward checking does the same thing as MAC on the initial arcs in MAC’s queue; but unlike MAC, forward checking does not recursively propagate constraints when changes are made to the domains of variables.",C是一个平衡利用和探索的常数。
chap5_para121,2,,有一种理论认为C应该是，但在实践中，程序员会尝试多个C值，从中选择一个表现最好的。
chap5_para121,3,,（有些程序则使用一些稍微不同的公式。
chap5_para121,4,,例如，AlphaZero增加了一个行动概率项，由根据之前的自我对弈训练得到的神经网络计算。
chap5_para121,5,,）当C = 1.4时，图5-10中60/79节点的UCB1值最高，而当C = 1.5时，2/11节点分值最高。
chap5_para1210,1,,9.4.1　反向链接算法
chap5_para1211,1,,图9-6展示了用于确定子句的反向链接算法。
chap5_para1211,2,,"如果知识库含有形如lhs ⇒ goal的规则，就能证得FOL-BC-Ask(KB, goal)，其中lhs（左手侧）是合取子句列表。"
chap5_para1211,3,,原子事实，如Americal(West)被视为lhs为空列表的子句。
chap5_para1211,4,,现在，含有变量的查询可以用多种方式证明。
chap5_para1211,5,,例如，查询Person(x)可以用置换和证明。
chap5_para1211,6,,因此，我们将FOL-BC-Ask实现为生成器，也就是能多次返回的函数，每次返回值给出一个可能的结果（见附录B）。
chap5_para1212,1,,反向链接是一种与或搜索——或的部分是由于目标查询可以用知识库中的任意规则证明，而与的部分是由于所有lhs中的合取子句都必须被证明。
chap5_para1212,2,,FOL-BC-Or的工作方式是抓取所有可能与目标合一的子句，将子句中的变量标准化为全新变量，如果子句的rhs确实能够与目标合一，就使用FOL-BC-And证明lhs中的所有合取子句。
chap5_para1212,3,,这个函数的工作方式是轮流证明合取子句，并记录运行中积累的所有置换。
chap5_para1212,4,,图9-7是从式（9-3）到式（9-10）推导Criminal(West)的证明树。
chap5_para1213,1,,如前所述，反向链接明显是深度优先搜索算法。
chap5_para1213,2,,这意味着其空间需求与证明规模呈线性关系，也意味着反向链接（不同于前向链接）受制于重复状态和不完备性。
chap5_para1213,3,,尽管有这些局限，事实表明反向链接在逻辑编程语言中仍然是非常流行且有效的。
chap5_para1214,1,,图9-6　用于一阶知识库的简单的反向链接算法
chap5_para1215,1,,图9-7　使用反向链接构建证明树来证明韦斯特是有罪的。
chap5_para1215,2,,树的阅读方式是深度优先，从左至右。
chap5_para1215,3,,要证明Criminal(West)，我们必须先证明其下方的4个合取子句。
chap5_para1215,4,,其中一些在知识库中，而另一些需要进一步反向链接。
chap5_para1215,5,,每次成功置换的绑定显示在对应的子目标旁边。
chap5_para1215,6,,注意，只要合取式中的一个子目标达成，其置换就被用于接下来的子目标。
chap5_para1215,7,,这样，当FOL-BC-Ask运行到最后一个合取子句，即最初为Hostile(z)的子句时，z就已经被绑定为Nono
chap5_para1216,1,,9.4.2　逻辑编程
chap5_para1217,1,,逻辑编程是一种接近第7章所述的陈述性理念的技术，即系统应当通过用形式语言表示的知识来构建，而问题应当通过在这些知识上运行推断过程来求解。
chap5_para1217,2,,这项理念在罗伯特·科瓦尔斯基（Robert Kowalski）的等式中得以总结：
chap5_para1219,1,,Prolog是最为广泛使用的逻辑编程语言。
chap5_para1219,2,,"它主要被用作快速原型语言，也用于像编写编译器（Van Roy, 1990）、自然语言分析（Pereira and Warren, 1980）这样的符号处理任务。"
chap5_para1219,3,,许多用于法律、医疗、财经和其他领域的专家系统都使用Prolog编写。
chap5_para122,1,5.,图5-11给出了完整的UCT MCTS算法。
chap5_para122,2,3.,当迭代终止时，算法返回模拟次数最多的移动。
chap5_para122,3,3Intelligent backtracking: Looking backward,你可能认为应该返回平均效用值最高的节点，但算法的思想是获胜65/100次的节点优于获胜2/3次的节点，因为后者有很多不确定性。
chap5_para122,4,,在任何情况下，UCB1公式确保模拟次数最多的节点几乎总是拥有最高的获胜概率，因为随着模拟次数的增加，选择过程将越来越偏向获胜概率。
chap5_para1220,1,,Prolog程序是确定子句集，但记法与标准的一阶逻辑有所不同。
chap5_para1220,2,,Prolog使用大写字母表示变量，小写字母则表示常量——与逻辑中的约定相反。
chap5_para1220,3,,"确定子句中的合取子句用逗号区分，而确定子句的书写也与我们所习惯的“相反”：不同于写为，在Prolog中我们将其写作C :- A, B。"
chap5_para1220,4,,这里有一个典型的例子：
chap5_para1221,1,,"criminal(X) :- american(X), weapon(Y), sells(X,Y,Z), hostile(Z)"
chap5_para1222,1,,在Prolog中，记法[E|L]表示第一个元素为E其余部分为L的列表。
chap5_para1222,2,,"下面是append(X,Y,Z)的Prolog程序，如果列表Z是列表Y追加到X后的结果，则程序返回成功："
chap5_para1223,1,,"append([],Y,Y)"
chap5_para1224,1,,"append([A|X],Y,[A|Z]) :- append(X,Y,Z)"
chap5_para1225,1,,我们可以将这些子句用自然语言描述为：（1）将列表Y追加到空列表后得到相同的列表Y；（2）在给定Z是Y追加到X后的结果的情况下，[A|Z]是[Y]追加到[A|X]后的结果。
chap5_para1225,2,,在大多数高级语言中我们可以写出类似的递归函数来描述如何追加列表，但实际上Prolog的定义更为强大，因为它描述了3个参数间的关系，而非用两个参数算出的函数。
chap5_para1225,3,,"例如，我们可以提出查询append(X,Y,[1,2,3])：哪两个列表追加能产生[1,2,3]？"
chap5_para1225,4,,Prolog为我们返回的解是
chap5_para1226,1,,"X=[] 　Y=[1,2,3];"
chap5_para1227,1,,"X=[1] 　Y=[2,3];"
chap5_para1228,1,,"X=[1,2] 　Y=[3];"
chap5_para1229,1,,"X=[1,2,3]　Y=[];"
chap5_para123,1,The BACKTRACKING-SEARCH algorithm in Figure 5.,图5-11　蒙特卡罗树搜索算法。
chap5_para123,2,5 has a very simple policy for what to do when a branch of the search fails: back up to the preceding variable and try a different value for it.,首先，初始化博弈树tree，然后重复Select/Expand/Simulate/Back-Propagate的循环，直到时间耗尽，最后返回指向模拟次数最多的节点的移动
chap5_para123,3,This is called chronological backtracking because the most recent decision point is revisited.,
chap5_para123,4,"in this subsection, we consider better possibilities.",
chap5_para1230,1,,Prolog程序的执行是通过深度优先的反向链接完成的，其中确定子句以其在知识库中的顺序进行尝试。
chap5_para1230,2,,Prolog的设计代表着陈述性与执行效率的妥协。
chap5_para1230,3,,Prolog的一些方面不属于标准的逻辑推断。
chap5_para1231,1,,● Prolog使用8.2.8节所述的数据库语义而非一阶语义，这可以明显地从它对等词和否定的处理看出（见9.4.4节）。
chap5_para1232,1,,● 有一系列用于算术的内置函数。
chap5_para1232,2,,使用这些函数符号的文字是通过执行代码而非进行深入推断“证得”的。
chap5_para1232,3,,例如，目标“X is 4+3”当X被绑定为7时达成。
chap5_para1232,4,,而目标“5 is X+Y”则无法达成，因为内置函数无法求解任意等式。
chap5_para1233,1,,● 存在执行时会产生副作用的内置谓词。
chap5_para1233,2,,这包括输入-输出谓词和用于修改知识库的assert/retract谓词。
chap5_para1233,3,,这类谓词在逻辑中没有对应物，会导致令人困惑的结果，例如，如果事实是在证明树的一个最终会失败的分支中断言的。
chap5_para1234,1,,● 出现检验在Prolog的合一算法中被略去。
chap5_para1234,2,,这就意味着会产生一些不可靠的推断。
chap5_para1234,3,,这在实际中几乎完全不会发生。
chap5_para1235,1,,● Prolog使用深度优先反向链接搜索，并且不检查无限递归。
chap5_para1235,2,,在恰当使用的情况下，这种做法使得编程语言可用且高效。
chap5_para1235,3,,但这也意味着某些看起来是有效逻辑的程序将无法终止。
chap5_para1236,1,,9.4.3　冗余推断和无限循环
chap5_para1237,1,,我们现在来看Prolog的致命弱点：深度优先搜索和包含了重复状态和无限路径的搜索树之间的错配。
chap5_para1237,2,,考虑如下的逻辑程序，这一程序判断有向图中的两点是否存在路径：
chap5_para1238,1,,"path(X,Z) :- link(X,Z)"
chap5_para1239,1,,"path(X,Z) :- path(X,Y), link(Y,Z)"
chap5_para124,1,"Consider what happens when we apply simple backtracking in Figure 5.1 with a fixed variable ordering Q, NSW, V, T, SA, WA, NT. Suppose we have generated the partial assignment {Q = red, NSW = green,V = blue,T = red}. When we try the next variable, SA, we see that every value violates a constraint. We back up to T and try a new color for Tasmania! Obviously this is silly—recoloring Tasmania cannot possibly help in resolving the problem with South Australia.",计算一次模拟结果的时间对博弈树的深度来说是线性的，而不是指数级的，因为在每个选择点上只采用一个移动。
chap5_para124,2,,这样我们就有足够的时间进行多次模拟。
chap5_para124,3,,例如，假设有一个分支因子为32的博弈，博弈平均持续100步。
chap5_para124,4,,如果我们有足够的计算能力可以在执行移动前考虑10亿个博弈状态，那么极小化极大算法可以搜索6层深度，具有完美行动顺序的算法可以搜索12层深度，蒙特卡罗搜索算法可以搜索1000万次模拟。
chap5_para124,5,,哪种方法更好呢？
chap5_para124,6,,这取决于所用的启发式函数与选择策略、模拟策略的准确性的高下。
chap5_para1240,1,,"事实link(a,b)和link(b,c)描述的一个简单的三节点图如图9-8a所示。"
chap5_para1240,2,,"在这个程序中，查询path(a,c)生成了图9-9a所示的证明树。"
chap5_para1240,3,,与此同时，如果我们按顺序写出如下子句：
chap5_para1243,1,,则Prolog会进入图9-9b所示的无限路径。
chap5_para1243,2,,因此，作为一个确定子句——甚至对于本例所示的数据日志程序——的定理证明器，Prolog是不完备的，因为对于某些知识库，它无法证明其所蕴含的语句。
chap5_para1243,3,,"注意，前向链接并没有这种问题：只要path(a,b)、path(b,c)和path(a,c)被推得，前向链接就会停止。"
chap5_para1244,1,,图9-8　（a）找出从A到C的路径会导致Prolog陷入死循环；（b）每个节点连接到下一层中两个随机后继的图。
chap5_para1244,2,,找到从A1到J4的路径需要877次推断
chap5_para1245,1,,图9-9　（a）证明从A到C存在一条路径。
chap5_para1245,2,,（b）子句顺序“错误”时生成的无限证明树
chap5_para1246,1,,深度优先反向链接也有冗余计算的问题。
chap5_para1246,2,,例如，当查找图9-8b中从A1到J4的路径时，Prolog进行了877次推断，大部分推断用于找出到达无法达成目标的节点的所有可能路径。
chap5_para1246,3,,这类似于第3章所述的重复状态问题。
chap5_para1246,4,,推断的总量随着生成的基本事实的数量增加而呈指数增长。
chap5_para1246,5,,"如果我们使用前向链接而非反向链接，连接到n个节点的path(X,Y)数量至多为n2个。"
chap5_para1246,6,,对于图9-8b所示的问题则仅需要62次推断。
chap5_para1247,1,,图搜索问题中的前向链接是动态规划（dynamic programming）的一个实例，其子问题的解是由更小的子问题的解递增构建的，通过缓存更小的子问题来避免重复计算。
chap5_para1247,2,,我们可以在反向链接中达到类似的效果，只需要将大目标分解为小目标而非从小目标构建大目标。
chap5_para1248,1,,不论如何，存储中间结果以避免重复计算是问题的关键。
chap5_para1248,2,,这是表格化逻辑编程（tabled logic programming）系统所采取的方法，它使用高效的存储和检索机制。
chap5_para1248,3,,表格化逻辑编程结合了反向链接的目标导向性以及前向链接动态规划的高效性。
chap5_para1248,4,,它对于数据日志知识库是完备的，这意味着程序员不太需要为死循环而担忧。
chap5_para1248,5,,"（使用类似father(X,Y)这种指代可能有无穷多对象的语句时，它仍然可能会进入死循环。"
chap5_para1248,6,,）
chap5_para1249,1,,9.4.4　Prolog的数据库语义
chap5_para125,1,"A more intelligent approach is to backtrack to a variable that might fix the problem—a variable that was responsible for making one of the possible values of SA impossible. To do this, we will keep track of a set of assignments that are in conflict with some value for SA. The set (in this case {Q = red, NSW = green, V = blue}), is called the conflict set for SA. The backjumping method backtracks to the most recent assignment in the conflict set; in this case, backjumping would jump over Tasmania and try a new value for V. This method is easily implemented by a modification to BACKTRACK such that it accumulates the conflict set while checking for a legal value to assign. If no legal value is found, the algorithm should return the most recent element of the conflict set along with the failure indicator.",传统观点认为，对于围棋这种分支因子非常高（因此搜索不够深）或者很难定义一个好的评价函数的游戏，蒙特卡罗搜索要优于搜索。
chap5_para125,2,,考虑到对手的目标是最小化得分，搜索将选择指向可实现评价函数得分最高的节点的路径。
chap5_para125,3,,因此，如果评价函数不准确，搜索也会不准确。
chap5_para125,4,,对单个节点的错误计算可能导致搜索错误地选择（或避开）指向该节点的路径。
chap5_para125,5,,而蒙特卡罗搜索依赖于多次模拟的聚合，因此不容易受到单次错误的影响。
chap5_para125,6,,我们也可以将MCTS和评价函数结合起来：对一定数量的移动进行模拟，然后截断模拟，并在截断的节点上应用评价函数。
chap5_para1250,1,,Prolog使用8.2.8节讨论过的数据库语义。
chap5_para1250,2,,唯一名称假设表明每个Prolog常量和每个基本项都仅指代唯一的对象，而封闭世界假设表明为真的语句只能是知识库蕴含的语句。
chap5_para1250,3,,Prolog无法断言某条语句是假的。
chap5_para1250,4,,这使得Prolog的表达能力比一阶逻辑差，但这正是使Prolog更为高效简洁的原因之一。
chap5_para1250,5,,考虑如下关于一些课程的断言：
chap5_para1252,1,,在唯一名称假设下，CS和EE是不同的（101、102和106也不同），因此这表示有4门不同的课程。
chap5_para1252,2,,在封闭世界假设下，不存在其他课程，因此只有4门课程。
chap5_para1252,3,,但如果它是一阶逻辑（FOL）的断言，而非数据库语义的话，我们只能说课程的数量介于1到无穷之间。
chap5_para1252,4,,这是由于FOL中的断言并不否认存在未提及的课程的可能性，也不表明提到的课程各自不同。
chap5_para1252,5,,如果我们想将式（9-11）翻译成FOL，我们就会得到如下语句：
chap5_para1254,1,,这就是对式（9-11）的完备化（completion）。
chap5_para1254,2,,在FOL中它表示最多有4门课程。
chap5_para1254,3,,要用FOL表示最少有4门课程的概念，我们需要写出等词的完备化：
chap5_para1255,1,,完备化对于理解数据库语义是有益的，但为了实用，如果你的问题可以用数据库语义描述，则用Prolog和其他数据库语义系统进行推理会更加高效，而不是翻译为FOL后用完备的定理证明器推理。
chap5_para1256,1,,9.4.5　约束逻辑编程
chap5_para1257,1,,在对前向链接的讨论中（9.3节），我们展示了约束满足问题（CSP）是如何被编码为确定子句的。
chap5_para1257,2,,标准的Prolog求解此类问题的方法与图6.5所示的回溯算法完全一样。
chap5_para1258,1,,由于回溯算法枚举变量的域，因而只能用于有限域CSP。
chap5_para1258,2,,用Prolog的方式来说，如果目标含有未绑定变量的问题，其解的数量必须是有限的。
chap5_para1258,3,,（例如，在地图着色问题中，每个变量可以取4种不同的颜色中的一种。
chap5_para1258,4,,）无限域CSP（例如含有实数变量或整数变量的CSP）需要完全不同的算法，例如边界传播或线性规划。
chap5_para1259,1,,考虑如下的例子。
chap5_para1259,2,,"我们定义triangle(X,Y,Z)为其3个参数满足三角不等式时成立的谓词："
chap5_para126,1,"The sharp-eyed reader may have noticed that forward checking can supply the conflict set with no extra work: whenever forward checking based on an assignment X = x deletes a value from Y’s domain, it should add X = x to Y’s conflict set. If the last value is deleted from Y’s domain, then the assignments in the conflict set of Y are added to the conflict set of X. That is, we now know that X = x leads to a contradiction (in Y), and thus a different assignment should be tried for X.",也可以将搜索和蒙特卡罗搜索结合。
chap5_para126,2,,例如，在可以持续很多步的博弈中，我们可能希望提前终止模拟（early playout termination），即终止持续太多步的模拟，并使用启发式评价函数对其进行评估，或者干脆宣布平局。
chap5_para1260,1,,"triangle(X,Y,Z) :-"
chap5_para1261,1,,"X0, Y0, Z0, X+YZ, Y+ZX, X+ZY."
chap5_para1262,1,,"如果我们向Prolog查询triangle(3,4,5)，它会返回成功；而如果我们询问triangle(3,4,Z)，它就无法找到解，因为Prolog无法处理子目标Z0。"
chap5_para1262,2,,我们不能将未绑定的值与0比较。
chap5_para1263,1,,约束逻辑编程（constraint logic programming）允许变量是被约束的而非被绑定的。
chap5_para1263,2,,CLP的解是从知识库中可以推得的、查询变量的最为具体的约束集。
chap5_para1263,3,,"例如，triangle(3,4,Z)的解是约束7Z1。"
chap5_para1263,4,,标准的逻辑程序只是CLP中约束必须为等式约束（也就是绑定）的特殊情形。
chap5_para1264,1,,CLP系统整合了各种约束求解算法用于该语言所支持的约束。
chap5_para1264,2,,例如，支持实值变量线性不等式的系统可能包含线性规划算法来求解这些约束。
chap5_para1264,3,,CLP系统也采用更为灵活的方法来求解标准的逻辑编程查询。
chap5_para1264,4,,例如，它可能使用第6章所述的任一高效算法，而非使用深度优先、从左到右回溯。
chap5_para1264,5,,因此，CLP系统结合了约束满足算法、逻辑编程和演绎数据库的要素。
chap5_para1265,1,,已经出现了一些允许程序员对用于推断的搜索顺序有更多控制的系统。
chap5_para1265,2,,"MRS语言（Genesereth and Smith, 1981; Russell, 1985）允许程序员编制元规则（metarule）来决定首先处理哪些合取式。"
chap5_para1265,3,,用户可以编制规则，说明要首先尝试变量最少的目标，或者也可以对某个谓词编制论域特定的规则。
chap5_para1267,1,,逻辑系统家族中的最后一个成员，也是唯一能够用于所有知识库而不仅是确定子句的成员，是归结。
chap5_para1267,2,,我们在7.5.2节了解了命题归结是命题逻辑的完备推断过程。
chap5_para1267,3,,在本节中，我们将其拓展到一阶逻辑。
chap5_para1268,1,,9.5.1　一阶逻辑的合取范式
chap5_para1269,1,,第一步是将语句转换为合取范式（CNF）——每个子句为文字析取的子句合取式。
chap5_para1269,2,,[5]在CNF中，文字可以包含变量，假定这些变量是全称量化的。
chap5_para1269,3,,例如，语句
chap5_para127,1,"The eagle-eyed reader may have noticed something odd: backjumping occurs when every value in a domain is in conflict with the current assignment; but forward checking detects this event and prevents the search from ever reaching such a node! In fact, it can be shown that every branch pruned by backjumping is also pruned by forward checking. Hence, simple backjumping is redundant in a forward-checking search or, indeed, in a search that uses stronger consistency checking, such as MAC—you need only do one or the other.",蒙特卡罗搜索可以应用于没有任何经验可以用来定义评价函数的全新博弈。
chap5_para127,2,,只要我们知道博弈规则，蒙特卡罗搜索不需要任何附加信息。
chap5_para127,3,,选择和模拟策略可以充分利用人工制定的专家知识，也可以通过仅仅使用自我对弈训练得到的神经网络来学习好的策略。
chap5_para1271,1,,[5]　子句也可以用原子语句合取式为前提，原子语句析取式为结论的蕴涵式表示（习题9.DISJ）。
chap5_para1271,2,,"这被称为蕴涵范式或科瓦尔斯基范式［特别是写成从右到左的蕴涵符号时（Kowalski, 1979）］，它通常比有许多否定文字的析取式更易读。"
chap5_para1273,1,,关键在于每条一阶逻辑语句都可以转换为推断上等价的CNF语句。
chap5_para1274,1,,转换成CNF的过程与命题逻辑中类似，我们已在7.5.2节中学习过。
chap5_para1274,2,,关键的差别在于对存在量词的消除。
chap5_para1274,3,,我们通过翻译语句“Everyone who loves all animals is loved by someone”（爱所有动物的每个人被一些人爱），即
chap5_para1275,1,,来描述转换过程，步骤如下。
chap5_para1276,1,,● 蕴涵消去：使用取代。
chap5_para1276,2,,在我们的例句中，需要操作两次。
chap5_para1277,1,,● 内移：除了针对否定联结词的一般规则，我们还需要针对否定量词的规则。
chap5_para1277,2,,因此，我们有
chap5_para1278,1,,我们的语句经过如下变换：
chap5_para1279,1,,注意，蕴涵式前提中的全称量词（∀y）已经变为存在量词。
chap5_para1279,2,,语句现在解读为“要么存在x不喜爱的动物，要么（如果事实并非如此的话）有人喜爱x”。
chap5_para1279,3,,显然，原始语句的含义被保留了下来。
chap5_para128,1,"Despite the observations of the preceding paragraph, the idea behind backjumping remains a good one: to backtrack based on the reasons for failure. Backjumping notices failure when a variable’s domain becomes empty, but in many cases a branch is doomed long before this occurs. Consider again the partial assignment {WA = red, NSW = red} (which, from our earlier discussion, is inconsistent). Suppose we try T = red next and then assign NT, Q, V, SA. We know that no assignment can work for these last four variables, so eventually we run out of values to try at NT. Now, the question is, where to backtrack? Backjumping cannot work, because NT does have values consistent with the preceding assigned variables—NT doesn’t have a complete conflict set of preceding variables that caused it to fail. We know, however, that the four variables NT, Q, V, and SA, taken together, failed because of a set of preceding variables, which must be those variables that directly conflict with the four.",当单步移动可以改变游戏进程时，蒙特卡罗搜索存在缺陷，因为蒙特卡罗搜索的随机性意味着它可能不会考虑这一移动。
chap5_para128,2,,换句话说，蒙特卡罗搜索中的B型剪枝意味着它可能根本没有探索关键路线。
chap5_para128,3,,当博弈状态“明显”是一方或另一方获胜时（根据人类的知识和评价函数），蒙特卡罗搜索也存在缺陷，它仍然需要模拟很多步来验证获胜者。
chap5_para128,4,,长期以来，人们一直认为，在国际象棋等具有较低分支因子和较好评价函数的游戏中，搜索更好。
chap5_para128,5,,但最近，蒙特卡罗方法在国际象棋及其他游戏中也取得了成功。
chap5_para1280,1,,● 变量标准化：对于如这样两次使用相同变量名的语句，更改其中一个变量名。
chap5_para1280,2,,这可以避免在消除量词时产生歧义。
chap5_para1280,3,,因此，有
chap5_para1281,1,,● 斯科伦化：斯科伦化（Skolemization）就是通过消去移除存在量词的过程。
chap5_para1281,2,,在这个简单例子中，它就像9.1节所述的存在量词实例化，将翻译为P(A)，其中A是一个新变量。
chap5_para1281,3,,然而，我们无法对上述的语句应用存在量词实例化，因为它不符合的形式。
chap5_para1281,4,,语句中只有一部分满足这一形式。
chap5_para1281,5,,如果我们盲目地对两个符合的部分应用这一规则，得到
chap5_para1282,1,,其含义完全是错误的。
chap5_para1282,2,,它表明每个人要么无法爱上特定动物A，要么就被某个特定实体B所爱。
chap5_para1282,3,,而实际上，我们的原始语句允许每个人不爱不同的动物，或者被不同的人喜爱。
chap5_para1282,4,,我们希望斯科伦实体依赖于x：
chap5_para1283,1,,此处F和G为斯科伦函数（Skolem function）。
chap5_para1283,2,,总的规则是，斯科伦函数的参数全部是全称量化的变量，要消去的存在量词出现在这些变量的辖域内。
chap5_para1283,3,,与存在量词实例化一样，斯科伦化的语句的可满足性与原始语句完全一致。
chap5_para1284,1,,● 全称量词消除：此时，所有剩余变量必然是全称量化的。
chap5_para1284,2,,因此，我们消除全称量词不会损失任何信息：
chap5_para1286,1,,这一步可能还需要展开嵌套的合取式和析取式。
chap5_para1287,1,,语句现在成为了含有两个子句的CNF。
chap5_para1287,2,,它比原本含有蕴涵的语句难读多了。
chap5_para1287,3,,（将斯科伦函数F(x)解释为可能不被x所爱的动物，而将G(x)解释为可能爱着x的人，可能会对理解有所帮助。
chap5_para1287,4,,）幸运的是，人类很少需要考察CNF语句——翻译过程很容易自动化。
chap5_para1288,1,,9.5.2　归结推断规则
chap5_para1289,1,,一阶子句的归结规则就是7.5.2节命题归结规则的提升版。
chap5_para1289,2,,两条进行了标准化分离、没有共同变量的子句，如果它们含有互补文字则可以被归结。
chap5_para1289,3,,如果两个命题文字相互否定，则这两个命题文字是互补的；如果两个一阶逻辑文字中的一个能够与另一个的否定合一，则这两个一阶逻辑文字是互补的。
chap5_para1289,4,,因此，我们有
chap5_para129,1,"This leads to a different–and deeper–notion of the conflict set for a variable such as NT: it is that set of preceding variables that caused NT, together with any subsequent variables,to have no consistent solution. In this case, the set is WA and NSW, so the algorithm should backtrack to NSW and skip over Tasmania. A backjumping algorithm that uses conflict sets defined in this way is called conflict-directed backjumping.",模拟未来的行动，观测结果，并根据结果来确定哪些行动是好的，这样的一般思想其实就是一种强化学习思想，我们将在第22章中介绍。
chap5_para1290,1,,其中。
chap5_para1290,2,,例如，我们可以归结两个子句
chap5_para1292,1,,通过用合一子来消去互补文字和，生成归结式子句
chap5_para1293,1,,这个规则叫作二元归结（binary resolution）规则，因为它刚好归结两个文字。
chap5_para1293,2,,二元归结本身并不产生完备的推断过程。
chap5_para1293,3,,完备的归结规则能够归结每个子句的可合一文字子集。
chap5_para1293,4,,另一种方法是将因子提取（也就是对冗余文字的消除）拓展到一阶逻辑。
chap5_para1293,5,,命题逻辑因子提取将两个相同的文字约简为一个，一阶逻辑因子提取则约简两个可合一的文字。
chap5_para1293,6,,这种合一子必须应用于整个子句。
chap5_para1293,7,,二元归结和因子提取的组合是完备的。
chap5_para1294,1,,9.5.3　证明范例
chap5_para1295,1,,归结通过证明不可满足来证明，也就是说，通过推导空子句来证明。
chap5_para1295,2,,它的算法与命题逻辑情形相同，如图7-13所示，因此我们不在此重复。
chap5_para1295,3,,但我们会给出两个证明范例。
chap5_para1295,4,,第一个是9.3节的犯罪示例。
chap5_para1295,5,,CNF形式的语句为
chap5_para1296,1,,我们还包括了目标的否定。
chap5_para1296,2,,图9-10展示了归结证明。
chap5_para1296,3,,注意其结构：一条“主线”从目标子句开始，归结知识库中的子句，直到生成空子句。
chap5_para1296,4,,这是在霍恩子句知识库上进行归结的特点。
chap5_para1296,5,,实际上，沿着主线的子句严格对应于图9-6反向链接算法中目标变量的值。
chap5_para1296,6,,这是由于我们总是选择归结正文字能够与主线中“当前”子句最左边文字合一的子句；这与反向链接一模一样。
chap5_para1296,7,,因此，反向链接是归结的一个特例，它具有特定的控制策略来决定下一步要进行哪个归结。
chap5_para1297,1,,图9-10　归结证明韦斯特有罪。
chap5_para1297,2,,每个归结步骤中，合一文字用加粗字体表示，带有正文字的子句用蓝底表示
chap5_para1298,1,,我们的第二个范例使用斯科伦化，并涉及非确定子句。
chap5_para1298,2,,这会导致更为复杂的证明结构。
chap5_para1298,3,,其自然语言描述如下。
chap5_para1299,1,,Everyone who loves all animals is loved by someone.（每个爱所有动物的人都被一些人所爱。
chap5_para1299,2,,）
chap5_para13,1,5.,
chap5_para13,2,1.,
chap5_para13,3,1Example problem: Map coloring,
chap5_para130,1,"We must now explain how these new conflict sets are computed. The method is in fact quite simple. The “terminal” failure of a branch of the search always occurs because a variable’s domain becomes empty; that variable has a standard conflict set. In our example, SA fails, and its conflict set is (say) {WA, NT, Q}. We backjump to Q, and Q absorbs the conflict set from SA (minus Q itself, of course) into its own direct conflict set, which is {NT, NSW}; the new conflict set is {WA, NT, NSW}. That is, there is no solution from Q onward, given the preceding assignment to {WA, NT, NSW}. Therefore, we backtrack to NT, the most recent of these. NT absorbs {WA, NT, NSW} – {NT} into its own direct conflict set {WA}, giving {WA, NSW} (as stated in the previous paragraph). Now the algorithm backjumps to NSW, as we would hope. To summarize: let Xj be the current variable, and let conf (Xj) be its conflict set. If every possible value for Xj fails, backjump to the most recent variable Xi in conf (Xj) and recompute the conflict set for Xi as follows:",
chap5_para1300,1,,Anyone who kills an animal is loved by no one.（任何害死动物的人都不被人所爱。
chap5_para1300,2,,）
chap5_para1301,1,,Jack loves all animals.（杰克爱所有动物，）
chap5_para1302,1,,"Either Jack or Curiosity killed the cat, who is named Tuna.（要么是杰克要么是好奇心害死了那只猫，猫的名字叫Tuna。"
chap5_para1302,2,,）
chap5_para1303,1,,Did Curiosity kill the cat?（是好奇心害死了那只猫吗？
chap5_para1303,2,,）
chap5_para1304,1,,首先，我们将原始语句，也就是一些背景知识，以及目标G的否定表示为一阶逻辑：
chap5_para131,1,5.,包含随机因素（例如掷骰子）的随机博弈（stochastic game）使我们更接近现实生活的不可预测性。
chap5_para131,2,3.,西洋双陆棋是一种典型的运气和技巧相结合的随机游戏。
chap5_para131,3,4Constraint learning,在图5-12的西洋双陆棋局面中，黑方掷出“6-5”，有4种可能走法［每种走法将一个棋子向前（顺时针）移动5步，另一个棋子向前移动6步］。
chap5_para1312,1,,然后，我们使用转换过程将每条语句转换为CNF：
chap5_para132,1,"When we reach a contradiction, backjumping can tell us how far to back up, so we don’t waste time changing variables that won’t fix the problem. But we would also like to avoid running into the same problem again. When the search arrives at a contradiction, we know that some subset of the conflict set is responsible for the problem. Constraint learning is the idea of finding a minimum set of variables from the conflict set that causes the problem. This set of variables, along with their corresponding values, is called a no-good. We then record the no-good, either by adding a new constraint to the CSP to forbid this combination of assignments or by keeping a separate cache of no-goods.",图5-12　一个典型的西洋双陆棋局面。
chap5_para132,2,,游戏的目标是把自己的所有棋子移出棋盘。
chap5_para132,3,,黑方向25顺时针移动，白方向0逆时针移动。
chap5_para132,4,,一个棋子可以移动到任何位置，除非那里有多个对方棋子；如果只有一个对方棋子，对方棋子就会被吃掉，然后必须从起点重新开始。
chap5_para132,5,,"图中所示的局面，黑棋已经掷出了6-5，必须从(5−11, 5−10)、(5−11, 19−24)、(5−10, 10−16)和(5−11, 11−16)这4种合法移动中选择，其中符号(5−11, 11−16)表示将一个棋子从位置5移动到位置11，另一个棋子从位置11移动到位置16"
chap5_para1321,1,,图9-11展示了“好奇心害死猫”的归结证明。
chap5_para1321,2,,在自然语言中，证明可以释义为：
chap5_para1322,1,,假设好奇心没有害死Tuna。
chap5_para1322,2,,我们知道要么是杰克要么是好奇心做了这件事，因此一定是杰克干的。
chap5_para1322,3,,现在，Tuna是一只猫，而猫是动物，因此Tuna是动物。
chap5_para1322,4,,因为任何害死动物的人都不被人所爱，我们就知道没人爱杰克。
chap5_para1322,5,,但是，杰克爱所有动物；至此有人爱他；至此我们得到了一个矛盾。
chap5_para1322,6,,因此，好奇心害死了那只猫。
chap5_para1323,1,,证明回答了问题“是好奇心害死了那只猫吗？
chap5_para1323,2,,”但我们常常希望提出更一般的问题，例如“谁害死了那只猫？
chap5_para1323,3,,”归结可以做到这一点，但需要稍微增加一些工作才能得到答案。
chap5_para1323,4,,"目标是∃w Kills(w, Tuna)，其CNF形式的否定为。"
chap5_para1323,5,,用新的否定的目标重复图9-11所示的证明，我们得到了类似的证明树，其中一步的置换为。
chap5_para1323,6,,因此，这种情况下，找出谁害死了那只猫就只是记录证明中查询变量的绑定的问题了。
chap5_para1323,7,,遗憾的是，归结有时会对存在量化目标产生非构造性证明（nonconstructive proof），我们知道一个查询为真，但却不知道这个变量的唯一绑定。
chap5_para1324,1,,图9-11　好奇心害死猫的归结证明。
chap5_para1324,2,,"注意，在推导子句Loves(G(Jack), Jack)时使用了因子分解。"
chap5_para1324,3,,"还要注意，在右上角，合一Loves(x, F(x))和Loves(Jack, x)只有在变量标准化分离后才可以进行"
chap5_para1325,1,,9.5.4　归结的完备性
chap5_para1326,1,,本节给出归结完备性证明。
chap5_para1326,2,,认为归结完备性是理所当然的读者可以略过本节。
chap5_para1327,1,,我们展示归结是反演完备的（refutation-complete），这意味着如果一个语句集是不可满足的，则归结总能推出矛盾。
chap5_para1327,2,,归结不能用于生成语句集的所有逻辑结果，但它可以用于证明给定语句是某个语句集所蕴含的。
chap5_para1327,3,,因此，它可以通过证明不可满足来找到给定问题Q(x)的所有答案。
chap5_para1328,1,,我们认定了一阶逻辑的所有语句（不含等词）都可以重写为CNF中的子句集。
chap5_para1328,2,,"它以原子语句为基础，在语句的形式上进行归纳来证明（Davis and Putnam, 1960）。"
chap5_para1328,3,,因此我们的目标是证明下面的陈述：如果S是不可满足的子句集，则对S应用有限次归结会产生矛盾。
chap5_para1329,1,,"我们的证明遵循鲁宾逊（Robinson）的原始证明，同时使用了（Genesereth and Nilsson, 1987）中的一些简化。"
chap5_para1329,2,,证明的基本结构（见图9-12）如下。
chap5_para133,1,"For example, consider the state {WA = red, NT = green, Q = blue} in the bottom row of Figure 5.",此时，黑方知道可以走什么棋，但不知道白方会掷出什么，因此也不知道白方的合法移动会是什么。
chap5_para133,2,6.,这意味着黑方无法构建我们在国际象棋和井字棋中看到的那种标准博弈树。
chap5_para133,3,Forward checking can tell us this state is a no-good because there is no valid assignment to SA.,西洋双陆棋的博弈树除了max和min节点外，还必须包括机会节点（chance node）。
chap5_para133,4,"In this particular case, recording the no-good would not help, because once we prune this branch from the search tree, we will never encounter this combination again.",机会节点如图5-13中的圆圈所示。
chap5_para133,5,But suppose that the search tree in Figure 5.,从每个机会节点引出的分支表示可能掷出的骰子点数，每个分支都标有掷出的点数及其概率。
chap5_para133,6,6 were actually part of a larger search tree that started by first assigning values for V and T.,两个骰子有36种组合，每一种都是等可能的，但是，因为6-5和5-6是一样的，所以只有21种不同的点数组合。
chap5_para133,7,"Then it would be worthwhile to record {WA = red, NT = green, Q = blue} as a no-good because we are going to run into the same problem again for each possible set of assignments to V and T.",6个点数相同的组合（1-1到6-6）的概率都是1/36，即P(1−1) = 1/36。
chap5_para133,8,,其他15种不同组合的概率都是1/18。
chap5_para1330,1,,（1）我们观察到如果S不可满足，则存在S中子句的某个基本实例集使得该集合同样无法满足（埃尔布朗定理）。
chap5_para1331,1,,（2）我们引入第7章给出的基本归结定理，它证明命题归结对于基本语句是完备的。
chap5_para1332,1,,（3）我们使用提升引理来证明，对于使用基本语句集的任意命题归结证明，都存在相应的一阶归结证明，它使用一阶语句，从中可以得到基本语句。
chap5_para1333,1,,图9-12　归结完备性证明的结构
chap5_para1335,1,,通过稍微拓展一阶逻辑语言来允许算术中的数学归纳法，库尔特·哥德尔的不完全性定理证明存在无法证明的真值算术语句。
chap5_para1336,1,,不完全性定理的证明有点超出本书的讨论范畴，要证明它至少需要30页纸，但我们在此可以给出一些思路。
chap5_para1336,2,,我们从逻辑数论开始。
chap5_para1336,3,,在该理论中，只存在单个常量0和单个函数S（后继函数）。
chap5_para1336,4,,在预期模型中，S(0)表示1，S(S(0))表示2，以此类推。
chap5_para1336,5,,因此语言中所有自然数都有名称。
chap5_para1336,6,,它的词汇表还包含函数符号+、×和Expt（幂运算）以及普通的逻辑联结词和量词。
chap5_para1337,1,,首先要注意的是，在这种语言中我们能够写出的语句集是可以枚举的。
chap5_para1337,2,,（想象给符号定义字母序，然后按字母顺序依次排列长度分别为1、2……的语句集。
chap5_para1337,3,,）我们就可以为每条语句编号一个唯一的自然数（即哥德尔数）。
chap5_para1337,4,,这很重要：数论包含了它的每个语句的名字。
chap5_para1337,5,,同样地，我们可以为每个证明P编号为哥德尔数G(P)，因为证明都是一个有限的语句序列。
chap5_para1338,1,,现在假设我们有递归可枚举的语句集A，它是对自然数的真命题。
chap5_para1338,2,,别忘了A可以由给定的整数集命名，我们可以想象用我们的语言写出如下类型的语句：
chap5_para1339,1,,不是哥德尔数为j的语句的证明的哥德尔数，其中证明只使用A中的前提。
chap5_para134,1,No-goods can be effectively used by forward checking or by backjumping.,图5-13　西洋双陆棋局面的博弈树图解
chap5_para134,2,Constraint learning is one of the most important techniques used by modern CSP solvers to achieve efficiency on complex problems.,
chap5_para1340,1,,然后，令为语句，也就是表明其自身不可由A证明的语句。
chap5_para1340,2,,（也就是，这条语句恒为真，但并不明显。
chap5_para1340,3,,）
chap5_para1341,1,,现在我们提出如下的巧妙观点：假设是可由A证明的，则为假（因为说自己是不可证明的）。
chap5_para1341,2,,但这样我们就有一个可以从A证明的真值为假的语句，因此A不可能只包含真语句——这与我们的前提矛盾。
chap5_para1341,3,,因此是不可由A证明的。
chap5_para1341,4,,但这正如自己所述，因此是一个真语句。
chap5_para1342,1,,因此，我们证明了（略去了页）对于数论的所有真语句集，特别是所有基本公理集，存在由这些公理无法证明的真语句。
chap5_para1342,2,,这就明确了我们无法在任何给定公理系统内证明所有数学定理。
chap5_para1342,3,,显然，这是数学的重要发现。
chap5_para1342,4,,它对人工智能的重要性已经被广泛的争论，这种争论正始于哥德尔本人的猜想。
chap5_para1342,5,,我们在第27章探讨这些争论。
chap5_para1343,1,,要进行第一步，我们需要3个新概念。
chap5_para1344,1,,（1）埃尔布朗域（Herbrand universe）：如果S是子句集，则S的埃尔布朗域HS是可以由下面几项构建的基本项集合。
chap5_para1345,1,,a. S中的函数符号，如果存在的话。
chap5_para1346,1,,b. S中的常量符号，如果存在的话；如果不存在，则为默认常量符号S。
chap5_para1347,1,,例如，如果S仅含有子句 ，则HS为如下基本项的无限集：
chap5_para1348,1,,（2）饱和（saturation）：如果S为子句集，P是基本项集，则P(S)为S对于P的饱和，它是通过对S中的变量应用所有可能P中基本项的一致置换得到的所有基本子句的集合。
chap5_para1349,1,,（3）埃尔布朗基（Herbrand base）：子句集S关于其埃尔布朗域的饱和称为S的埃尔布朗基，写作HS(S)。
chap5_para1349,2,,例如，如果S仅含有上述的子句，则HS(S)是无限子句集
chap5_para135,1,5.,下一步是了解如何做出正确决策。
chap5_para135,2,4Local Search for CSPs,显然，我们仍然想选择能够到达最佳局面的那一步棋。
chap5_para135,3,,然而，局面没有明确的极小化极大值。
chap5_para135,4,,我们只能计算局面的期望值（expected value）：机会节点所有可能结果的平均值。
chap5_para1350,1,,"这些定义使我们可以陈述埃尔布朗定理（Herbrand, 1930）的一种形式："
chap5_para1351,1,,如果子句集S不可满足，则存在HS(S)的一个不可满足的有限子集。
chap5_para1352,1,,令S'为基本语句的有限子集。
chap5_para1352,2,,现在我们可以使用接地归结定理（7.5.2节）来证明归结闭包RC(S')含有空子句。
chap5_para1352,3,,也就是说，使用命题归结对S'进行完备化会推得矛盾。
chap5_para1353,1,,现在我们已经证明了必然存在涉及S的埃尔布朗基的有限子集的归结证明，下一步是证明存在使用S本身的子句的归结证明，它们不一定是基本子句。
chap5_para1353,2,,我们从考虑单次运用归结规则的情形开始。
chap5_para1353,3,,鲁宾逊阐述了如下引理：
chap5_para1354,1,,令C1和C2为两个不含相同变量的子句，C'1和C'2分别为C1和C2的基本实例。
chap5_para1354,2,,如果C'是C'1和C'2的归结式，则存在子句C使得：（1）C是C1和C2的归结式；（2）C'是C的基本实例。
chap5_para1355,1,,这就是提升引理（lifting lemma），因为它将基本子句的证明提升到一般一阶逻辑子句。
chap5_para1355,2,,鲁宾逊为了证明其基本提升引理而不得不发明了合一且推导了最一般合一子的所有性质。
chap5_para1355,3,,我们仅阐明该引理而不在此进行证明：
chap5_para1356,1,,我们看到C'实际上是C的基本实例。
chap5_para1356,2,,一般来说，要使C'1和C'2具有归结式，就必须通过先对C1和C2使用C1和C2中的互补文字的最一般合一子来构建它们。
chap5_para1356,3,,由提升引理，易得任意多次应用归结规则时的相似结论：
chap5_para1357,1,,对于归结闭包S'内的任意子句C'，有归结闭包S内的子句C使得C'为C的基本实例且对C的推导长度与对C'的推导长度相同。
chap5_para1358,1,,由此可得，如果归结闭包S'内有空子句，则它必然也在归结闭包S中。
chap5_para1358,2,,这是由于空子句不可能是任何其他子句的基本实例。
chap5_para1358,3,,概括来说：我们已经证明了如果S不可满足，则存在使用归结规则的对空子句的有限推导。
chap5_para1359,1,,定理证明从基本子句提升到一阶子句大大增加了其能力。
chap5_para1359,2,,这种能力的增加来源于以下事实：一阶逻辑证明只需要在证明确有必要时才实例化变量，而基本子句方法则需要检查大量的任意实例化。
chap5_para136,1,"Local search algorithms (see Section 4.1) turn out to be very effective in solving many CSPs. They use a complete-state formulation (as introduced in Section 4.1.1) where each state assigns a value to every variable, and the search changes the value of one variable at a time. As an example, we’ll use the 8-queens problem, as defined as a CSP on page 167. In Figure 5.8 we start on the left with a complete assignment to the 8 variables; typically this will violate several constraints. We then randomly choose a conflicted variable, which turns out to be Q8, the rightmost column. We’d like to change the value to something that brings us closer to a solution; the most obvious approach is to select the value that results in the minimum number of conflicts with other variables—the min-conflicts heuristic.",可以将确定性博弈的极小化极大值推广为包含机会节点的博弈的期望极小化极大值（expectiminimax value）。
chap5_para136,2,,终止节点、max节点和min节点的工作方式与之前完全相同（注意，max和min的合法移动取决于前一个机会节点的掷骰子结果）。
chap5_para136,3,,对于机会节点，我们则计算期望值，即用每个机会动作的概率加权的所有结果的值之和：
chap5_para1361,1,,本章到目前为止讲述过的所有推断方法都不能在不增加额外工作的情况下处理形如x = y的断言。
chap5_para1361,2,,为此可以采取3种不同的方法。
chap5_para1361,3,,第一种方法是公理化等词，也就是在知识库中写入相等关系的语句。
chap5_para1361,4,,我们需要说明相等是自反的、对称的和传递的，我们还需要说明我们可以在所有谓词或函数中用相等量置换相等量。
chap5_para1361,5,,因此我们需要3类基本公理，另外每个谓词和函数都需要一条公理：
chap5_para1362,1,,给定这些语句，标准的推断过程，如归结，就可以执行需要等词推理的任务，如求解数学方程。
chap5_para1362,2,,不过，这些公理会产生大量结论，其中大多数对证明没有帮助。
chap5_para1362,3,,因此第二种方法是添加推断规则而非公理。
chap5_para1362,4,,最简单的规则是解调，它取单元子句x = y和一个含有x项的子句，生成一个用y置换中的x得出的新子句。
chap5_para1362,5,,如果中的项能够与x合一，解调就可以使用，而不需要完全等于x。
chap5_para1362,6,,注意，解调是有方向性的，给定x = y，x总是会被y替换，而非相反。
chap5_para1362,7,,这意味着解调可以用形如z + 0 = z或z1 = z这样的解调器来简化表达式。
chap5_para1362,8,,下面的例子中，给定
chap5_para1363,1,,我们可以通过解调得出
chap5_para1364,1,,更为形式化地，我们有
chap5_para1365,1,,● 解调（demodulation）：对于任意项x、y和z，其中z出现在文字mi中的某处且 ，
chap5_para1366,1,,其中Subst是对绑定表的一般置换，而表示在m中的某处用y替换x。
chap5_para1367,1,,这个规则可以拓展到处理含有等词的非单元子句。
chap5_para1368,1,,● 超解调（paramodulation）：对于任意项x、y和z，其中z出现在文字mi中的某处且，
chap5_para137,1,Description Two dice show the numbers 6 and 5.,"其中，r表示可能的掷骰子结果（或其他概率事件），而Result(s, r)仍表示状态s，附加了掷骰子结果r。"
chap5_para137,2,The columns in the top row are numbered from 1 to 12 from the left to right.,
chap5_para137,3,The columns in the bottom row are numbered from 13 to 24 from the right to left.,
chap5_para137,4,"Top row: Column 1, two whites.",
chap5_para137,5,"Column 2, empty.",
chap5_para137,6,"Column 3, three blacks.",
chap5_para137,7,"Column 4, two whites.",
chap5_para137,8,"Column 5, two blacks.",
chap5_para137,9,"Column 6, three blacks.",
chap5_para137,10,"Column 7, three whites.",
chap5_para137,11,"Column 8, two whites.",
chap5_para137,12,"Column 9, two whites.",
chap5_para137,13,"Column 10, one white.",
chap5_para137,14,"Columns 11 and 12, empty.",
chap5_para137,15,"Bottom row: Column 13 to 18, empty.",
chap5_para137,16,"Column 19, two blacks.",
chap5_para137,17,"Column 20, empty.",
chap5_para137,18,"Column 21, two blacks.",
chap5_para137,19,"Column 22, two blacks.",
chap5_para137,20,"Column 23, three blacks.",
chap5_para137,21,"Column 24, one black.",
chap5_para1371,1,,我们有，通过超解调我们可以得到结论
chap5_para1372,1,,超解调产生含有等词的一阶逻辑的一个完备推断程序。
chap5_para1373,1,,第三种方法仅使用拓展的合一算法处理等词推理。
chap5_para1373,2,,也就是说，如果若干项在某种置换下可证明为相等，则它们是可合一的，其中“可证明”允许等词推理。
chap5_para1373,3,,例如，项1 + 2和2 + 1通常不可合一，但知道的合一算法可以用空置换合一它们。
chap5_para1373,4,,这种等词合一（equational unification）可以用针对特定公理（交换性、结合性等）设计的高效算法完成，而非通过直接用这些公理推断。
chap5_para1373,5,,使用这种技术的定理证明器与9.4节所述的CLP系统密切相关。
chap5_para1374,1,,9.5.6　归结策略
chap5_para1375,1,,我们知道只要证明存在，反复运用归结推断规则总会找到一个证明。
chap5_para1375,2,,在本节中我们考察有助于高效找出证明的策略。
chap5_para1376,1,,单元优先（unit preference）：这个策略优先处理其中一条语句为单文字（也就是单元子句）的归结。
chap5_para1376,2,,这一策略的思路是，我们试图产生空子句，因此先处理产生较短子句的推断可能是个好主意。
chap5_para1376,3,,归结单元语句（如P）与其他任意语句（如）总是生成比其他子句短的子句（本例中为）。
chap5_para1376,4,,当这种单元优先策略在1964年首次被用于命题推断时，它产生了巨大的加速作用，使得它能够证明许多先前无法处理的定理。
chap5_para1376,5,,单元归结是归结的一种受限形式，其中归结的每一步都含有单元子句。
chap5_para1376,6,,单元归结总体上是不完备的，但对霍恩子句是完备的。
chap5_para1376,7,,霍恩子句上的单元归结证明与前向链接类似。
chap5_para1377,1,,"Otter定理证明器（McCune, 1990）使用了最佳优先搜索。"
chap5_para1377,2,,其启发函数度量每个子句的“权重”，并偏好权重较轻的子句。
chap5_para1377,3,,启发式函数的选择取决于用户，但通常子句的权重应当与其规模或难度相关。
chap5_para1377,4,,它认为单元子句权重较轻，因此这种搜索可以被看作单元优先策略的一般化。
chap5_para1378,1,,支撑集（set of support）：优先尝试某些归结是有用的，但一般来说一起消除某些有潜力的归结是更为高效的做法。
chap5_para1378,2,,例如，我们可以使每个归结步都用到一个特殊子句集的至少一个元素，这个特殊子句集就是支撑集。
chap5_para1378,3,,归结式随后被加入支撑集中。
chap5_para1378,4,,如果支撑集远小于整个知识库，则搜索空间会大大简化。
chap5_para1379,1,,为确保这种策略的完备性，我们可以选择使得语句的剩余部分同时可满足的支撑集S。
chap5_para1379,2,,例如，假设原始知识库是一致的，我们就可以使用否定查询作为支撑集（毕竟，如果知识库不一致，则查询符合知识库也没什么意义了）。
chap5_para1379,3,,支撑集策略还有一个好处，它能够生成目标导向的证明树，利于人类理解。
chap5_para138,1,Figure 5.,
chap5_para138,2,8A two-step solution using min-conflicts for an 8-queens problem.,
chap5_para138,3,"At each stage, a queen is chosen for reassignment in its column.",
chap5_para138,4,"The number of conflicts (in this case, the number of attacking queens) is shown in each square.",
chap5_para138,5,"The algorithm moves the queen to the min-conflicts square, breaking ties randomly.",
chap5_para1380,1,,输入归结（input resolution）：这种策略中，每个归结都是一个输入语句（来自知识库或查询）与其他一些语句的结合。
chap5_para1380,2,,图9-10所示的证明仅使用输入归结，因而具有单条“主线”且单条语句向主线结合的结构特征。
chap5_para1380,3,,显然，这种证明树的空间小于整个证明图的空间。
chap5_para1380,4,,在霍恩知识库中，肯定前件是一种输入归结策略，因为它将原知识库中的一个蕴涵式与其他语句结合。
chap5_para1380,5,,因此，我们知道输入归结对于霍恩形式的知识库是完备的，但一般情况下它是不完备的。
chap5_para1380,6,,如果P在原始知识库中或P在证明树上是Q的祖先的话，线性归结（linear resolution）策略允许P和Q一同归结。
chap5_para1380,7,,线性归结是完备的。
chap5_para1381,1,,包容（subsumption）：包容方法消除所有知识库中已有语句所包含的语句（也就是更为精确的语句）。
chap5_para1381,2,,例如，如果P(x)在知识库中，则添加语句P(A)就没有意义，添加P(A) ∨ Q(B)则更无意义。
chap5_para1381,3,,包容能够使知识库较小，进而有助于减小搜索空间。
chap5_para1382,1,,学习（learning）：我们可以通过从经验中学习改进定理证明器。
chap5_para1382,2,,给定先前证得的定理集，训练机器学习系统来回答问题：给定前提集和证明目标，哪些证明步骤与之前成功的证明步骤类似？
chap5_para1382,3,,"DeepHOL系统（Bansal et al., 2019）做到了这一点，它使用深度神经网络（见第21章）来构建目标和前提的模型（称为嵌入），并使用这些模型来选择步骤。"
chap5_para1382,4,,训练可以同时使用人类或计算机生成的证明作为样本，并至少需要10 000个证明。
chap5_para1383,1,,归结定理证明器的实际用途
chap5_para1384,1,,我们已经展示了一阶逻辑是如何表示简单的、涉及出售、武器、公民权等问题的真实世界场景的。
chap5_para1384,2,,但复杂的真实世界场景有太多未知和不确定性。
chap5_para1384,3,,逻辑已经被证明在涉及形式化、严格定义的概念的场景中表现出色，例如硬件和软件的合成（synthesis）与验证（verification）。
chap5_para1384,4,,定理证明研究还在硬件设计、编程语言和软件工程领域展开，而不仅限于人工智能领域。
chap5_para1385,1,,在硬件领域，公理描述了信号和电路元件之间的相互作用。
chap5_para1385,2,,（见8.4.2节的例子。
chap5_para1385,3,,"）专门用于验证的逻辑推理器已经能够验证整个CPU，包括验证其时序（Srivas and Bickford, 1990）。"
chap5_para1385,4,,"Aura定理证明器已经用于生成比所有已有设计更为紧凑的电路设计（Wojciechowski and Wojcik, 1983）。"
chap5_para1386,1,,在软件领域，对程序进行推理与动作推理非常相似，如在第7章中，公理描述每个命题的前提和效果。
chap5_para1386,2,,"算法的形式化合成是定理证明器最早的应用之一，如科德尔·格林（Green, 1969a）所述。"
chap5_para1386,3,,"科德尔·格林的论述基于更早由赫伯特·西蒙（Simon, 1963）提出的思路。"
chap5_para1386,4,,这种思路是对效果“存在满足特定规范的程序p”构造性地证明定理。
chap5_para1386,5,,尽管全自动演绎合成还不能用于通用编程，人工引导的演绎合成却已经成功用于设计一些新颖、精妙的算法。
chap5_para1386,6,,像科学计算代码这样的专用程序的合成也是研究的热门领域。
chap5_para1387,1,,"类似的技术现在已经被用于软件验证，对应的系统有Spin模型检查器（Holzmann, 1997）等。"
chap5_para1387,2,,"例如，Remote Agent空间飞行器控制程序在飞行前后都进行了验证（Havelund et al., 2000）。"
chap5_para1387,3,,"RSA公钥加密算法和BM（Boyer-Moore）字符串匹配算法也使用这种方式进行验证（Boyer and Moore, 1984）。"
chap5_para1389,1,,我们已经分析了一阶逻辑中的逻辑推断，以及一些相关的算法。
chap5_para139,1,"In the figure we see there are two rows that only violate one constraint; we pick Q8 = 3 (that is, we move the queen to the 8th column, 3rd row).",和极小化极大算法一样，可以通过在某点截断搜索并对每个叶节点应用评价函数来近似估计期望极小化极大值。
chap5_para139,2,"On the next iteration, in the middle board of the figure, we select Q6 as the variable to change, and note that moving the queen to the 8th row results in no conflicts.",有人可能会认为，西洋双陆棋等游戏的评价函数应该与国际象棋的评价函数类似——更好的局面得分更高。
chap5_para139,3,"At this point there are no more conflicted variables, so we have a solution.",但事实上，机会节点的存在意味着我们必须更加仔细地定义这些值。
chap5_para139,4,The algorithm is shown in Figure 5.,
chap5_para139,5,9.,
chap5_para139,6,2,
chap5_para1390,1,,● 第一种方法使用推断规则（全称量词实例化和存在量词实例化）来命题化推断问题。
chap5_para1390,2,,通常，这种方法速度慢，除非论域非常小。
chap5_para1391,1,,● 使用合一来找出适当的变量置换消去一阶证明中的实例化步骤，在许多情况下提高了这一过程的效率。
chap5_para1392,1,,● 肯定前件的提升版使用了合一，产生了一般化肯定前件这种自然、强大的推断规则。
chap5_para1392,2,,前向链接算法和反向链接算法对确定子句集使用这条规则。
chap5_para1393,1,,● 一般化肯定前件对确定子句是完备的，但蕴含问题是半可判定的。
chap5_para1393,2,,对于不含函数的确定子句构成的数据日志知识库，蕴含是可判定的。
chap5_para1394,1,,● 前向链接用于演绎数据库，此时它可以与关系数据库的操作结合。
chap5_para1394,2,,它也用于对超大规则集进行高效更新的产生式系统。
chap5_para1394,3,,前向链接对于数据日志是完备的，并可以在多项式时间内运行。
chap5_para1395,1,,● 反向链接用于逻辑编程系统，它利用巧妙的编译器技术来实现超快速推断。
chap5_para1395,2,,反向链接受制于冗余推断和死循环，可以通过备忘来缓解这些问题。
chap5_para1396,1,,● Prolog与一阶逻辑不同，它使用了封闭世界中的名称唯一假设，并视否定为失败。
chap5_para1396,2,,这使Prolog成为很实用的编程语言，但也偏离了纯粹的逻辑。
chap5_para1397,1,,● 一般化的归结推断规则使用合取范式知识库为一阶逻辑提供了完备的推断系统。
chap5_para1398,1,,● 一些用于减小归结系统搜索空间的策略不牺牲其完备性。
chap5_para1398,2,,最重要的问题之一是处理等词，我们展示了如何使用解调和超解调。
chap5_para1399,1,,● 基于归结的高效定理证明器已经被用于证明有趣的数学定理和验证及合成软件和硬件。
chap5_para14,1,"Suppose that, having tired of Romania, we are looking at a map of Australia showing each of its states and territories (Figure 5.",[2]　对应英文player在博弈论中为“参与者”，但在本书中不同语境下会根据具体情况使用参与者、玩家、选手等。
chap5_para14,2,1(a)).,——译者注
chap5_para14,3,"We are given the task of coloring each region either red, green, or blue in such a way that no two neighboring regions have the same color.",
chap5_para14,4,"To formulate this as a CSP, we define the variables to be the regions:",
chap5_para140,1,Description Up and down triangles represent MAX and MIN nodes and circles represent CHANCE nodes.,"图5-14表明：如果评价函数给叶节点分配的值为[1, 2, 3, 4]，那么移动a1是最佳的；如果值为[1, 20, 30, 400]，移动a2是最佳的。"
chap5_para140,2,The first level of the game tree is labeled MAX and the root node is a MAX node.,因此，如果我们更改一些评估值，即使优先顺序保持不变，程序的选择也会完全不同。
chap5_para140,3,The second level is labeled CHANCE and contains many circles.,
chap5_para140,4,Paths from the node in the MAX level connect to each circle.,
chap5_para140,5,The third level is labeled MIN and the nodes are MIN nodes.,
chap5_para140,6,"Four nodes are shown with labels 1 by 36, 1 to 1; 1 by 18, 1 to 2; 1 by 18, 6 to 5; and 1 by 36, 6 to 6.",
chap5_para140,7,Paths from the third circle in the CHANCE level connect to each of the nodes in the MIN level.,
chap5_para140,8,The fourth level is labeled CHANCE and contains many circles.,
chap5_para140,9,The first circle is labeled C.,
chap5_para140,10,"Paths from the MIN node labeled 1 by 18, 6 to 5 in the MIN level connect to each of the circles in the second CHANCE level.",
chap5_para140,11,The fifth level is labeled MAX and the nodes are MAX nodes.,
chap5_para140,12,"Four nodes are shown with labels 1 by 36, 1 to 1; 1 by 18, 1 to 2; 1 by 18, 6 to 5; and 1 by 36, 6 to 6.",
chap5_para140,13,Paths from circle C in the second CHANCE level connect to each node in the second MAX level.,
chap5_para140,14,The final level is labeled TERMINAL.,
chap5_para140,15,"Paths from the MAX node labeled 1 by 18, 6 to 5 in the second MAX level connect to the nodes in the terminal level.",
chap5_para140,16,"The nodes are labeled 2, negative 1, 1, negative 1, and 1.",
chap5_para1403,1,,在本章中，我们展示如何以一阶逻辑表示真实世界中的各种事实。
chap5_para1404,1,,前面的章节展示了具有知识库的智能体如何进行推断，以便能采取正确的行动。
chap5_para1404,2,,本章我们回答要把什么样的内容放进这种智能体的知识库中，也就是如何表示关于世界的事实。
chap5_para1404,3,,我们使用一阶逻辑作为表示语言，而后续章节将介绍其他表示的形式体系，例如用于规划推理的分层任务网络（第11章），用于不确定性推理的贝叶斯网络（第13章），用于进行时序推理的马尔可夫模型（第17章），以及用于推理图像、声音和其他数据的深度神经网络（第21章）。
chap5_para1404,4,,不论你使用什么表示，都始终需要处理关于世界的事实。
chap5_para1404,5,,本章将使你建立处理这些问题的直觉。
chap5_para1405,1,,10.1节介绍通用本体论的思想，将世界上所有的事物用层次类别组织起来；10.2节涵盖对象、物质和度量的基本类别；10.3节介绍事件；10.4节讨论关于信念的知识。
chap5_para1405,2,,然后，我们再考虑用这些内容进行推理的方法，10.5节讨论设计用于高效类别推断的推理系统，10.6节讨论具有缺省信息的推理。
chap5_para1406,1,,10.1　本体论工程
chap5_para1407,1,,在“玩具”领域，选择何种表示并不那么重要，很多表示都可以良好运作。
chap5_para1407,2,,但在复杂的领域，如网上购物或者在车流中驾驶，就需要更为通用和灵活的表示方法。
chap5_para1407,3,,本章将展示如何创建这些表示，主要关注于许多不同领域中都会出现的一般性的概念，如事件、时间、对象、信念等。
chap5_para1407,4,,有时，表示这些抽象概念被称为本体论工程（ontological engineering）。
chap5_para1408,1,,我们不能奢求表示世界中的一切事物，我们甚至无法表示1000页的教科书，但我们会留出一些位置，使所有领域的新知识都可以填入。
chap5_para1408,2,,例如，我们将定义对象是什么，而不同种类对象的细节——机器人、电视机、书或者无论什么——可以随后再进行填充补全。
chap5_para1408,3,,这类似于面向对象编程框架（如Java Swing图形化框架）的设计者定义窗口之类的一般性概念，并期待用户使用它们来定义更为具体的概念，如表单窗口。
chap5_para1408,4,,概念的一般性的框架被称为上层本体论（upper ontology），因为我们惯于将更一般性的概念绘制于更具体的概念之上，如图10-1所示。
chap5_para1409,1,,在进一步考虑本体论之前，我们要先说明一项重要的提醒。
chap5_para1409,2,,尽管真实世界的一些层面很难用一阶逻辑来刻画，我们仍选择使用FOL来讨论知识的内容和组织。
chap5_para1409,3,,主要的难点在于，大多数一般化都有其例外，或仅在某种程度上成立。
chap5_para1409,4,,例如，尽管“番茄是红色的”是一条有用的规则，但一些番茄是绿色的、黄色的或橙色的。
chap5_para1409,5,,本章的大多数规则都可以找到类似的例外。
chap5_para1409,6,,处理例外和不确定性的能力极其重要，但它却与理解一般性的本体论无关。
chap5_para1409,7,,因此，我们在10.5节之前都不讨论例外情形，而在第12章才讨论在不确定性下进行推理的更一般性的话题。
chap5_para141,1,Figure 5.,图5-14　在保持叶节点值排序不变的情况下，不同的叶节点赋值改变了最佳移动
chap5_para141,2,9The MIN-CONFLICTS local search algorithm for CSPs.,
chap5_para141,3,The initial state may be chosen randomly or by a greedy assignment process that chooses a minimal-conflict value for each variable in turn.,
chap5_para141,4,"The CONFLICTS function counts the number of constraints violated by a particular value, given the rest of the current assignment.",
chap5_para1410,1,,上层本体论的用处是什么？
chap5_para1410,2,,考虑8.4.2节的电路本体论。
chap5_para1410,3,,它进行了许多简化假设：时间被完全无视；信号是固定的且不需要传播；电路的结构保持不变。
chap5_para1410,4,,更一般性的本体论会考虑特定时间的信号，也会考虑导线的长度和传播延迟。
chap5_para1410,5,,这能使我们模拟电路的时序性质——实际上，电路设计师常常进行这种模拟。
chap5_para1411,1,,图10-1　世界的上层本体论，它展示了本章稍后要讲述的内容。
chap5_para1411,2,,每条线表示低层概念是高层概念的一种具体化。
chap5_para1411,3,,具体化不一定是排他的——人类既是动物，又是智能体。
chap5_para1411,4,,我们会在10.3.2节看到为何对象在一般化事件的下层
chap5_para1412,1,,我们还可以通过描述电路技术（TTL、COMS等）或输入输出规范等方法引入更为有趣的门电路类型。
chap5_para1412,2,,如果我们要讨论可靠性或进行诊断，我们就需要考虑电路的结构和门电路属性自发改变的可能性。
chap5_para1412,3,,要考察杂散电容，我们就需要表示导线在电路板上的位置。
chap5_para1413,1,,wumpus世界中也有类似的因素需要考虑。
chap5_para1413,2,,尽管我们表示了时间，但它的结构却过于简单：智能体在不行动时什么都不会发生，而所有变化都是瞬间发生的。
chap5_para1413,3,,更适于真实世界的、更为一般性的本体论能够允许变化随时间同时发生。
chap5_para1413,4,,我们还使用了Pit谓词来表示哪个方格有无底洞。
chap5_para1413,5,,我们其实可以通过在无底洞类别下增加不同属性的无底洞个体来允许出现不同种类的无底洞。
chap5_para1413,6,,类似地，我们可能还想允许wumpus之外的其他动物出现。
chap5_para1413,7,,从可用的感知可能无法确定动物的确切物种，因此我们可能需要构建生物分类学层级来帮助智能体从匮乏的线索中预测穴居者的行为。
chap5_para1414,1,,对所有专用本体论来说，做类似这样的修改来使其更为一般化是可行的。
chap5_para1414,2,,显然，这样做就产生了一个问题：这些本体论是否最终都会发展为通用本体论？
chap5_para1414,3,,在几个世纪的哲学和计算研究中，答案是“有可能”。
chap5_para1414,4,,本节我们展示一种通用本体论，它综合了这几百年的思想。
chap5_para1414,5,,通用本体论与专用本体论有两个主要的区别。
chap5_para1415,1,,● 通用本体论在所有专用论域都应当可以或多或少地适用（在增加论域特定的公理后）。
chap5_para1415,2,,这意味着它不能无视任何表示问题。
chap5_para1416,1,,● 在所有足够复杂的论域中，不同领域的知识必须是统一的，因为推理和问题求解会同时涉及多个领域。
chap5_para1416,2,,例如，一个机器人电路维修系统需要在电气连通性和物理布局方面推理电路，也需要出于电路时序分析和估计劳动力成本的目的而进行关于时间的推理。
chap5_para1416,3,,因此，描述时间的语句必须能够结合描述空间布局的语句，在处理纳秒或分钟、埃或米时也必须具有相同的性能。
chap5_para1417,1,,我们首先要说的是，目前为止，通用本体论工程的进展仍然相当有限。
chap5_para1417,2,,所有顶尖的人工智能应用（如第1章所列出的）都没有使用通用本体论——它们都使用专用知识工程和机器学习。
chap5_para1417,3,,对于争论各方，社会和政治考虑使得他们很难对某个本体论达成共识。
chap5_para1417,4,,"如汤姆·格鲁伯（Tom Gruber）（Gruber, 2004）所述：“每一种本体论都是一群有共同动机去分享的人之间的合约——社会共识。"
chap5_para1417,5,,”当竞争方面的考虑超过共享时，就不会有共同的本体论。
chap5_para1417,6,,"利益相关者的数量越少，就越容易构建本体论，因此构建通用本体论要难于构建用途有限的本体论，例如开放生物医学本体论（Smith et al., 2007）。"
chap5_para1417,7,,这些已有的本体论根据4条路径构建。
chap5_para1418,1,,（1）通过训练有素的本体论学家或逻辑学家团队来构建本体论并写出公理。
chap5_para1418,2,,"CYC系统基本上是用这种方法构建的（Lenat and Guha, 1990）。"
chap5_para1419,1,,（2）通过从现有数据库中引入类别、属性和值。
chap5_para1419,2,,"DBpedia通过从维基百科中引入结构化事实构建（Bizer et al., 2007）。"
chap5_para142,1,"Min-conflicts is surprisingly effective for many CSPs. Amazingly, on the n-queens problem, if you don’t count the initial placement of queens, the run time of min-conflicts is roughly independent of problem size. It solves even the million-queens problem in an average of 50 steps (after the initial assignment). This remarkable observation was the stimulus leading to a great deal of research in the 1990s on local search and the distinction between easy and hard problems, which we take up in Section 7.6.3. Roughly speaking, n-queens is easy for local search because solutions are densely distributed throughout the state space. Min-conflicts also works well for hard problems. For example, it has been used to schedule observations for the Hubble Space Telescope, reducing the time taken to schedule a week of observations from three weeks (!) to around 10 minutes.",为了避免这一问题，评价函数应该返回获胜概率（对于结果非输或赢的博弈返回的是期望效用值）的正线性变换值。
chap5_para142,2,,这是在不确定性下非常重要和普遍的性质，将在第16章进一步讨论。
chap5_para1420,1,,（3）通过分析文本文件，从中提取信息。
chap5_para1420,2,,"TextRunner通过阅读大量网页语料库来构建（Banko and Etzioni, 2008）。"
chap5_para1421,1,,（4）通过诱导无技能的业余人士输入常识知识。
chap5_para1421,2,,"OpenMind系统通过用英语提出事实的志愿者构建（Singh et al., 2002; Chklovski and Gil, 2005）。"
chap5_para1422,1,,举例来说，谷歌知识图谱使用来自维基百科的半结构化内容，并结合了从大量网页中收集的、经过人类整合的内容。
chap5_para1422,2,,"它含有超过700亿条事实并为大约三分之一的谷歌搜索提供答案（Dong et al., 2014）。"
chap5_para1423,1,,10.2　类别与对象
chap5_para1424,1,,将对象组织为类别是知识表示的重要组成部分。
chap5_para1424,2,,尽管与世界的交互发生在单个对象的层面，但大多数推理发生在类别的层面。
chap5_para1424,3,,例如，购物者的目标通常是购买篮球，而非购买像BB9这样的某个特定的篮球。
chap5_para1424,4,,类别也能用于对已分类的对象进行预测。
chap5_para1424,5,,我们根据感知输入对某个对象是否存在进行推断，通过对对象属性的感知推断其类别，然后使用类别信息对该对象进行预测。
chap5_para1424,6,,例如，从黄色和绿色条纹的果皮、直径约30厘米、椭圆形的形状、红色的果肉、黑色的种子并位于超市水果区的特点来看，我们可以推断这个对象是一个西瓜；由此，我们推断它可以用于水果沙拉。
chap5_para1425,1,,用一阶逻辑表示类别有两种选择：谓词和对象。
chap5_para1425,2,,也就是说，我们可以使用谓词Basketballs(b)，也可以将类别物化[1]为对象Basketballs。
chap5_para1425,3,,"这样，我们就可以说Member(b, Basketballs)，我们将其缩写为，表示b是篮球类别中的成员。"
chap5_para1425,4,,"我们说Subset(Basketballs, Balls)，缩写为，表示篮球是球的子类别。"
chap5_para1425,5,,我们等价地使用子类别、子类和子集这3个词语。
chap5_para1427,1,,[1]　将命题转换对象称为物化（reification），来自拉丁语词语res，也就是物体。
chap5_para1427,2,,约翰•麦卡锡提出了术语“thingification”（物品化），但并未得以流行。
chap5_para1428,1,,类别通过继承组织知识。
chap5_para1428,2,,如果我们说食物类别下的所有实例都可以食用，且我们断言水果是食物的子类、苹果是水果的子类，则我们可以推得所有苹果都可以食用。
chap5_para1428,3,,我们可以说单个苹果继承了可食用性这个属性，这种继承在本例中源于其从属的食物类别。
chap5_para1429,1,,子类关系将类别组织为分类学层级（taxonomic hierarchy）或分类法（taxonomy）。
chap5_para1429,2,,分类法在技术领域已经被明确地使用了几百年。
chap5_para1429,3,,最大的这种分类法将大约一千万个现存或灭绝的物种组织为一个层次结构，其中包括许多种甲壳虫[2]；图书馆学为所有领域的知识开发了分类法，将其编码为杜威十进制系统；税务部门和其他政府部门也发展出了大量关于职业和商品的分类法。
chap5_para143,1,"All the local search techniques from Section 4.1 are candidates for application to CSPs, and some of those have proved especially effective. The landscape of a CSP under the min- conflicts heuristic usually has a series of plateaus. There may be millions of variable assignments that are only one conflict away from a solution. Plateau search—allowing sideways moves to another state with the same score—can help local search find its way off this plateau. This wandering on the plateau can be directed with a technique called tabu search: keeping a small list of recently visited states and forbidding the algorithm to return to those states. Simulated annealing can also be used to escape from plateaus.",如果程序事先知道游戏接下来的所有掷骰子结果，那么求解有骰子的游戏和求解没有骰子的游戏是一样的，即极小化极大算法的时间复杂度为O(bm)，其中b为分支因子，m为博弈树的最大深度。
chap5_para143,2,,因为期望极小化极大值还要考虑所有可能的掷骰子序列，它的时间复杂度为O(bmnm)，其中n是掷骰子的不同结果的数目。
chap5_para1431,1,,[2]　当被问及一个人通过研究自然能够对造物主有怎样的了解时，生物学家霍尔丹（J. B. S. Haldane）说：“他（造物主）是甲壳虫的超级爱好者。
chap5_para1431,2,,”
chap5_para1432,1,,一阶逻辑很易于陈述关于类别的事实，不论是通过把对象关联到类别还是对类别的成员进行量化。
chap5_para1432,2,,下面是一些事实的示例。
chap5_para1433,1,,● 一个对象是一个类别的成员。
chap5_para1434,1,,● 一个类别是另一个类别的子类。
chap5_para1435,1,,● 一个类别的所有成员都具有某种性质。
chap5_para1436,1,,● 一个类别的成员可以用某些性质来辨别。
chap5_para1437,1,,● 一个类别整体具有某些性质。
chap5_para1438,1,,注意，由于狗是一个类别，并且是驯化物种的一个成员，因此驯化物种必然是类别的类别。
chap5_para1438,2,,当然，上述的规则存在许多例外（瘪气的篮球不是圆的），我们稍后再处理这些例外。
chap5_para1439,1,,尽管子类和成员关系是类别中最重要的关系，我们也希望能够陈述类别之间的非从属关系。
chap5_para1439,2,,例如，如果我们只说了本科生和研究生是学生的子类，那么我们就没有表明一个本科生无法同时是研究生。
chap5_para1439,3,,如果两个或两个以上的类别没有共同的成员，则它们是不相交的（disjoint）。
chap5_para1439,4,,我们可能还想表明研究生和本科生类别构成了大学生的完全分解（exhaustive decomposition）。
chap5_para1439,5,,不相交集合的一种完全分解被称为一个划分（partition）。
chap5_para1439,6,,以下是上述概念的一些例子：
chap5_para144,1,Another technique called constraint weighting aims to concentrate the search on the important constraints.,即使将搜索深度限制在某个很小的值d内，与极小化极大算法相比，额外代价的存在也使得在大多数机会博弈中向前看很远是不现实的。
chap5_para144,2,"Each constraint is given a numeric weight, initially all 1.",在西洋双陆棋中，n是21，b通常是20左右，但在某些情况下，骰子数翻倍，b可能高达4000。
chap5_para144,3,"At each step of the search, the algorithm chooses a variable/value pair to change that will result in the lowest total weight of all violated constraints.",我们大概只能搜索3层。
chap5_para144,4,The weights are then adjusted by incrementing the weight of each constraint that is violated by the current assignment.,
chap5_para144,5,"This has two benefits: it adds topography to plateaus, making sure that it is possible to improve from the current state, and it also adds learning: over time the difficult constraints are assigned higher weights.",
chap5_para1440,1,,（注意，NorthAmericans的完全分解不是一个划分，因为一些人具有双重国籍。
chap5_para1440,2,,）上述3个谓词定义如下：
chap5_para1441,1,,类别也可以通过给出成员的充要条件来定义。
chap5_para1441,2,,例如，单身汉是未婚的成年男性：
chap5_para1442,1,,正如我们在本章关于自然类的附页中所讨论的，类别的严格逻辑定义通常只能用于人造的形式化概念，而非一般事物。
chap5_para1442,2,,但定义并不总是必要的。
chap5_para1443,1,,10.2.1　物理组成
chap5_para1444,1,,“一个对象是另一个对象的一部分”这样的概念并不陌生。
chap5_para1444,2,,一个人的鼻子是他脑袋的一部分，罗马尼亚是欧洲的一部分，本章是本书的一部分。
chap5_para1444,3,,我们使用一般的PartOf关系来表明一个事物是另一个事物的一部分。
chap5_para1444,4,,对象可以分组为PartOf层次结构，类似于子集层次结构：
chap5_para1445,1,,PartOf关系是传递和自反的，也就是：
chap5_para1446,1,,"因此，我们可以得出结论PartOf (Bucharest, Earth)。"
chap5_para1446,2,,复合对象（composite object）类别常被特征化为部分之间的结构关系。
chap5_para1446,3,,例如，一个两足动物是身体上恰好有两条腿的对象：
chap5_para1447,1,,“恰好有两条”的符号有点棘手，我们不得不表明存在两条腿，它们不是同一条腿，如果有人提出了第三条腿，则这条腿必然是其他两条腿中的一条。
chap5_para1447,2,,在10.5.2节，我们描述了一个被称为描述逻辑的形式体系，它能够较容易地表示类似“恰好有两条”的约束。
chap5_para1448,1,,我们可以类比类别的Partition关系，定义一个PartPartition关系。
chap5_para1448,2,,（见习题10.DECM。
chap5_para1448,3,,）一个对象由其PartPartition中的部分组成，并且可以被看作从这些部分中获得了某些性质。
chap5_para1448,4,,例如，复合对象的质量是其各部分质量的总和。
chap5_para1448,5,,注意，类别并不会出现这种情形，即使类别中的元素可能有质量，类别也没有质量。
chap5_para1449,1,,使用无特定结构的确切部分定义复合对象也是有用的。
chap5_para1449,2,,例如，我们可能想表明“袋子里的苹果重两磅”。
chap5_para1449,3,,将这个重量归入袋中苹果的集合似乎是自然的做法，但这实际上是错误的，因为集合是抽象的数学概念，它只有元素而没有重量。
chap5_para1449,4,,因此，我们需要一个新概念，我们称之为束（bunch）。
chap5_para1449,5,,例如，如果苹果是Apple1、Apple2和Apple3，则
chap5_para145,1,"Another advantage of local search is that it can be used in an online setting (see section 4.5) when the problem changes. Consider a scheduling problem for an airline’s weekly flights. The schedule may involve thousands of flights and tens of thousands of personnel assignments, but bad weather at one airport can render the schedule infeasible. We would like to repair the schedule with a minimum number of changes. This can be easily done with a local search algorithm starting from the current schedule. A backtracking search with the new set of constraints usually requires much more time and might find a solution with many changes from the current schedule.",换一种方式考虑这一问题：搜索的优势在于，在采取最佳玩法的情况下它忽略了那些未来不可能发生的情况。
chap5_para145,2,,因此，它将精力集中于可能发生的情况。
chap5_para145,3,,但在一个每次移动前都要掷两个骰子的游戏中，没有可能的移动序列，即使是最有可能的移动也只在2/36的情况下出现，因为执行移动的前提是，骰子点数是正确的组合从而使该移动合法。
chap5_para145,4,,这是不确定性下的一个普遍问题：可能性急剧增多，制定详细的动作规划变得毫无意义，因为世界可能不会朝你规划的方向发展。
chap5_para1450,1,,表示由3个苹果作为部分（而非元素）构成的对象。
chap5_para1450,2,,之后我们就可以将束作为普通的对象来使用了，尽管它是无结构的。
chap5_para1450,3,,注意。
chap5_para1450,4,,另外，BunchOf(Apples)是由所有苹果构成的复合对象，不要将它与所有苹果的集合或苹果类别搞混了。
chap5_para1451,1,,我们可以用PartOf关系来定义BunchOf。
chap5_para1451,2,,显然，s中的每个元素都是BunchOf (s)的部分：
chap5_para1452,1,,进一步地，BunchOf (s)是满足这个条件的最小对象。
chap5_para1452,2,,也就是说，BunchOf (s)必然是所有以s中全部元素为部分的对象的部分：
chap5_para1453,1,,这些公理属于一种叫作逻辑最小化的通用技术，意味着定义满足某些条件的最小对象。
chap5_para1455,1,,不论是在关于世界的科学理论中还是常识中，物体都有高度、质量、价格之类的性质。
chap5_para1455,2,,我们分配给这些性质的值叫作量度（measure）。
chap5_para1455,3,,普通的量化量度很容易表示。
chap5_para1455,4,,我们想象宇宙中有抽象的“量度对象”，例如这条线段的长度表示的长度。
chap5_para1455,5,,我们可以将这个长度称为1.5英寸或3.81厘米。
chap5_para1455,6,,也就是说，同样的长度在我们的语言中有不同的名字。
chap5_para1455,7,,我们使用以数字作为参数的单位函数（units function）表示长度。
chap5_para1455,8,,（习题10.ALTM探讨了另一种方法。
chap5_para1455,9,,）
chap5_para1456,1,,如果这条线段称为L1，我们可以写出
chap5_para1458,1,,使用从一种单位到另一种单位的等值倍数可以进行单位之间的转换：
chap5_para1459,1,,可以对磅和千克、秒和日、美元和美分写出类似的公理。
chap5_para1459,2,,量度可以以如下方式描述对象：
chap5_para146,1,5.,你可能会想到像剪枝这样的方法也可以应用于包含机会节点的博弈树。
chap5_para146,2,5The Structure of Problems,事实证明的确可以。
chap5_para146,3,,对min和max节点的分析不变，但可以用一点聪明才智对机会节点剪枝。
chap5_para146,4,,考虑图5-13中的机会节点C，以及在计算其子节点时它的值发生了什么变化。
chap5_para146,5,,在我们检查完C的所有子节点之前是否有可能找到C的上界？
chap5_para146,6,,（回想一下，这是剪枝剪除某个节点及其子树时需要的。
chap5_para146,7,,）
chap5_para1460,1,,注意，$(1)不是一美元钞票，而是价格。
chap5_para1460,2,,我们可以有两张一美元钞票，但只有一个名为$(1)对象。
chap5_para1460,3,,还需要注意的是，即使Inches(0)和Centimeters(0)都指代相同的零长度，但却不同于其他零量度，如Seconds(0)。
chap5_para1461,1,,简单且量化的量度很容易表示。
chap5_para1461,2,,其他量度则更难一些，因为它们的值没有公认的尺度。
chap5_para1461,3,,习题具有难度，甜点具有美味程度，诗歌有优美程度，而我们无法为这些量赋以数值。
chap5_para1461,4,,有人可能会完全从计算的角度出发，忽略这些性质，因为它们对于逻辑推断并没什么用处；而更糟糕的做法，则是企图为优美程度强加一个数值尺度——这是严重的错误，因为这样做完全没有必要。
chap5_para1461,5,,对量度来说，最重要的不是其特定的数值，而是它是可以被排序的。
chap5_para1462,1,,尽管量度不是数字，但我们还是可以用诸如“”之类的定序符号来比较它们。
chap5_para1462,2,,例如，我们可能都认为诺维格（Norvig）出的习题比罗素（Russell）出的习题难，而且解答难题的人得分更少：
chap5_para1463,1,,这就足以使人们决定要做哪些题，尽管其中根本没有用到难度值。
chap5_para1463,2,,（但他们必须要弄清楚每道习题是谁出的。
chap5_para1463,3,,）这种量度之间的单调关系构成了定性物理（qualitative physics）的基本要素——定性物理是人工智能的一个子领域，它研究在不使用具体方程和数值模拟的情况下如何推理物理系统。
chap5_para1463,4,,在本章的参考文献与历史注释部分，我们会讨论到定性物理。
chap5_para1465,1,,一些类别有严格的定义：一个对象是三角形，当且仅当它是有三条边的多边形。
chap5_para1465,2,,而真实世界中的大部分类别没有边界清晰的定义，它们被称为自然类（natural kind）类别。
chap5_para1465,3,,例如，番茄接近于暗红色，大致是圆形的，顶部有个原本长着藤蔓的凹坑，直径5～10厘米，有薄而硬的果皮，内部有果肉、种子和汁水。
chap5_para1465,4,,但也有例外：一些番茄是黄色或橙色的，未成熟的番茄是绿色的，一些番茄小于或大于其平均大小，而圣女果都非常小。
chap5_para1465,5,,我们没有番茄的完备定义，而是有一系列特征，它们能够用于识别一个明显是番茄的物体，但却无法明确地识别其他物体。
chap5_para1465,6,,（有没有一种像桃子一样毛茸茸的番茄？
chap5_para1465,7,,）
chap5_para1466,1,,这对逻辑智能体来说是个问题。
chap5_para1466,2,,智能体无法确定它感知到的物体是番茄，而且，即使它确定这个物体就是番茄，它也无法确定这个番茄具有哪些番茄应有的典型性质。
chap5_para1466,3,,这个问题是在部分可观测环境中运作的不可避免的结果。
chap5_para1467,1,,一种有用的方法是区分对一个类别中所有实例都为真的性质和仅对典型实例为真的性质。
chap5_para1467,2,,因此除了Tomatoes类别，我们还会有Typical(Tomatoes)类别。
chap5_para1467,3,,此处，Typical函数将类别映射到仅含有典型实例的子类：
chap5_para1468,1,,关于自然类的大部分知识实际上是关于其典型实例的：
chap5_para1469,1,,这样，我们就可以写出关于类别的有用事实而无须精确的定义。
chap5_para1469,2,,"维特根斯坦（Wittgenstein, 1953）深入解释了为大部分自然类别提供精确定义的难点。"
chap5_para1469,3,,他使用了游戏的例子来表明一个类别的成员具有“家族相似性”而非充分必要的特征：什么样的严格定义可以囊括国际象棋、木头人、单人纸牌和躲避球？
chap5_para147,1,"In this section, we examine ways in which the structure of the problem, as represented by the constraint graph, can be used to find solutions quickly.",乍一看，这似乎是不可能的，因为C的值是它子节点值的平均，为了计算一组数字的平均值，我们必须查看所有的数字。
chap5_para147,2,"Most of the approaches here also apply to other problems besides CSPs, such as probabilistic reasoning.",但如果限制效用函数的可能值的范围，那么就可以得到平均值的范围而不需要查看每一个数字。
chap5_para147,3,,例如，假设所有效用值都在−2和+2之间，那么叶节点的值是有界的，反过来，我们就可以在不检查所有子节点的情况下为机会节点的值设置上界。
chap5_para1470,1,,"奎因（Quine, 1953）也质疑了严格定义的概念的有用性。"
chap5_para1470,2,,他指出，就连将“单身汉”定义为未婚成年男性都是值得怀疑的。
chap5_para1470,3,,例如，一个人完全可以质疑诸如“教皇是单身汉”这样的陈述。
chap5_para1470,4,,尽管这种用法严格意义上并没有错，但这肯定是不妥当的，因为这会引起部分听众的无端猜忌。
chap5_para1470,5,,将用于内部知识表示的逻辑定义与更微妙的恰当措辞准则区分开来也许能够解决这种矛盾。
chap5_para1470,6,,后者可以通过“过滤”前者推得的断言得出。
chap5_para1470,7,,措辞的失误也可以用作修正内部定义的反馈，这样，过滤也就不再必要了。
chap5_para1471,1,,10.2.3　对象：事物和物质
chap5_para1472,1,,真实世界可以看作由基本对象（如原子粒子）和由其构建的复合对象组成的。
chap5_para1472,2,,通过在诸如苹果和汽车之类的大对象层面进行推理，我们可以避免逐个处理大量基本对象的麻烦。
chap5_para1472,3,,但现实中的很大一部分东西似乎不能被个体化（individuation），也就是将其细分为不同的组成对象。
chap5_para1472,4,,我们给这部分东西起名为物质。
chap5_para1472,5,,例如，假设我面前有一些黄油和一只食蚁兽。
chap5_para1472,6,,我们可以说这有一只食蚁兽，但却无法说出“黄油对象”的明确数量，因为一个黄油对象的任何一部分也是黄油对象——至少在我们将其分为极小的部分之前是这样。
chap5_para1472,7,,这是物质和事物的主要区别。
chap5_para1472,8,,如果我们将食蚁兽砍成两半，（很遗憾）我们并不能得到两只食蚁兽。
chap5_para1473,1,,英语能清晰地区分事物（thing）和物质（stuff）。
chap5_para1473,2,,我们说“一只食蚁兽”，但除了在加利福尼亚州那些故弄玄虚的餐馆里面，我们并不能说“一个黄油”。
chap5_para1473,3,,语言学家将食蚁兽、洞穴、定理之类的可数名词与黄油、水、能量之类的不可数名词区别开来。
chap5_para1473,4,,一些相互竞争的本体论都宣称它们能够处理这种区别。
chap5_para1473,5,,此处我们只描述其中一种，其他本体论则在本章的参考文献与历史注释部分讨论。
chap5_para1474,1,,要妥当地表示物质，我们从最浅显的情形开始。
chap5_para1474,2,,在我们的本体论中至少也要将“一块”物质作为对象，以便与之互动。
chap5_para1474,3,,例如，我们可能认得前一晚丢在桌上的那块黄油；我们可以把它捡起来，给它称重，或把它卖掉之类的。
chap5_para1474,4,,从这种意义上考虑，它就是与食蚁兽一样的对象。
chap5_para1474,5,,我们不妨称其为Butter3。
chap5_para1474,6,,我们还定义了Butter类别。
chap5_para1474,7,,非正式地，它的元素就是我们可能说“这是黄油”的东西，包括Butter3。
chap5_para1474,8,,在暂且忽略物质的极小部分的情况下，一个黄油对象的任何一部分也是黄油对象：
chap5_para1475,1,,现在我们就可以说黄油在大约30℃时融化：
chap5_para1476,1,,我们还可以说黄油是黄色的，密度比水小，在室温下是软的，含有很多脂肪，等等。
chap5_para1476,2,,另外，黄油没有特定的大小、形状或重量。
chap5_para1476,3,,我们可以为黄油定义更为专门的类别，如无盐黄油（UnsaltedButter），它也是一种物质。
chap5_para1476,4,,注意，一磅黄油（PoundOfButter）这个类别，它包含所有重量为一磅的黄油对象，却不是一种物质。
chap5_para1476,5,,很遗憾，我们将一磅黄油切成两半并不能得到两磅黄油。
chap5_para1477,1,,实际上，一些性质是固有的，它们属于对象的物质，而非对象这个整体。
chap5_para1477,2,,当你将一种具体的物质切成两半，这两半仍保留其固有性质，如其密度、沸点、味道、颜色、隶属关系等。
chap5_para1477,3,,而外在的性质，如重量、长度、形状之类的，在分割后并不能维持不变。
chap5_para1477,4,,因此，定义中只有固有性质的对象类别是物质，或不可数名词；而定义中含有任何外在性质的类别则是可数名词。
chap5_para1477,5,,物质和事物分别是最一般的物质类别和对象类别。
chap5_para1479,1,,在7.7.1节我们讨论了动作，它是可以发生的事情，如Shoott；我们还讨论了流，它是世界中变化的部分，如HaveArrowt。
chap5_para1479,2,,它们都用命题表示，我们使用了后继状态公理来表示如果时刻t的动作使一个流为真，或在时刻t这个流已经为真且此时的动作不使其为假的话，则这个流在时刻t+1为真。
chap5_para1479,3,,这是对动作是离散的、瞬时的、每个时刻只发生一次的，且只有一种实行方式（也就是说，只有一种射击动作，迅速射击、缓慢射击、紧张地射击之间没有区别）的世界而言的。
chap5_para148,1,"The only way we can possibly hope to deal with the vast real world is to decompose it into subproblems. Looking again at the constraint graph for Australia (Figure 5.1(b), repeated as Figure 5.12(a)), one fact stands out: Tasmania is not connected to the mainland.3 Intuitively, it is obvious that coloring Tasmania and coloring the mainland are independent subproblems—any solution for the mainland combined with any solution for Tasmania yields a solution for the whole map.",在机会节点分支因子较高的博弈中——考虑Yahtzee这样的游戏，即每回合掷5个骰子——你可能要考虑前向剪枝，即采样少数几个可能的机会分支。
chap5_para148,2,,或者，你可能想要完全避免使用评价函数，而选择蒙特卡罗树搜索，其中每次模拟都包含随机掷骰子。
chap5_para1480,1,,但当我们从简化的论域移步到真实世界中，要处理的动作和事件[3]范围就大得多了。
chap5_para1480,2,,考虑一个连续动作，如灌满浴缸。
chap5_para1480,3,,一条后继状态公理可以表明在动作前浴缸是空的，在动作完成后浴缸满了，但它无法讨论在动作进行中发生了什么。
chap5_para1480,4,,它也无法轻易地描述同时发生的两个动作——例如在等待浴缸灌满的时候刷牙。
chap5_para1480,5,,要处理这类情形，我们引入一种称为事件演算（event calculus）的方法。
chap5_para1482,1,,[3]　术语“事件”和“动作”可以互相代替——它们的意思都是 “可以发生的事情”。
chap5_para1483,1,,事件演算的对象是事件、流和时间点。
chap5_para1483,2,,"At(Shankar, Berkeley)是一个流，也就是指代Shankar在伯克利这个事实的对象。"
chap5_para1483,3,,Shankar从旧金山飞往华盛顿特区的事件E1描述为
chap5_para1484,1,,其中Flyings是所有飞行事件的类别。
chap5_para1484,2,,通过对事件进行物化，我们能够对事件添加任意数量的任意信息。
chap5_para1484,3,,例如，我们可以用Bumpy(E1)说明Shankar的航班很颠簸。
chap5_para1484,4,,在一个事件为n元谓词的本体论中，我们无法添加类似这样的额外信息——为此将本体论中的事件改为n+1元谓词并不是一个具有拓展性的解决方法。
chap5_para1485,1,,要断言在时刻t1某处开始延续到t2的流实际为真，我们使用谓词T，如 。
chap5_para1485,2,,类似地，我们使用来表明事件E1实际发生了，它从时刻t1开始，结束于t2。
chap5_para1485,3,,事件演算版本[4]的完整谓词集为
chap5_para1487,1,,"[4]　我们的版本基于（Shanahan, 1999），但做了一些改动。"
chap5_para1488,1,,我们可以将飞行事件的效果描述为
chap5_para1489,1,,我们假设一个特定事件Start，它通过表明在起始时刻时哪些流为真（用Initiates）哪些流为假（用Terminated）描述了初始状态。
chap5_para1489,2,,这样我们就可以用一对关于T和的、符合一般后继状态公理形式的公理描述哪个流在何时为真：假设一个事件在时刻t1和t3之间发生，而在该时段内的某时刻t2，该事件通过启动流（使其为真）或终止流（使其为假）改变了流f的值。
chap5_para1489,3,,则在未来的某个时刻t4，如果没有其他事件改变过流（不论是启动流还是终止流），流的值保持不变。
chap5_para1489,4,,形式上，这些公理是
chap5_para149,1,"Independence can be ascertained simply by finding connected components of the constraint graph. Each component corresponds to a subproblem CSPi. If assignment Si is a solution of CSPi, then ⋃iSi is a solution of ⋃iCSPi. Why is this important? Suppose each CSPi has c variables from the total of n variables, where c is a constant. Then there are n/c subproblems, each of which takes at most dc work to solve, where d is the size of the domain. Hence, the total work is O(dcn/c), which is linear in n; without the decomposition, the total work is O(dn), which is exponential in n. Let’s make this more concrete: dividing a Boolean CSP with 100 variables into four subproblems reduces the worst-case solution time from the lifetime of the universe down to less than a second.",5.6　部分可观测博弈
chap5_para1490,1,,其中Terminated和Initiates定义为
chap5_para1491,1,,我们可以拓展事件演算来表示同时发生的事件（例如玩跷跷板需要两人同时进行）、外因事件（例如风吹动物体）、连续事件（例如涨潮）、非确定性事件（例如抛硬币得到正面或反面）以及其他复杂事件。
chap5_para1493,1,,事件演算提供了表示时间点和时间间隔的可能性。
chap5_para1493,2,,我们考虑两种时间间隔：瞬间和延续间隔。
chap5_para1493,3,,它们的区别是，只有瞬间的持续时间为0：
chap5_para1494,1,,下面我们发明一种时间尺度，并将尺度上的点关联到瞬间，以确定绝对时间。
chap5_para1494,2,,时间尺度可以是任意的，我们选择用秒来度量，并指定格林尼治标准时1900年1月1日午夜瞬间为时间0。
chap5_para1494,3,,函数Begin和End输出一个间隔的最早瞬间和最晚瞬间，函数Time则将瞬间转换为时间尺度上的点。
chap5_para1494,4,,函数Duration给出开始时间和结束时间之间的差值。
chap5_para1495,1,,为利于读出数字，我们还引入了Date函数，它使用6个参数（小时、分钟、秒、日、月、年）并返回一个时间点：
chap5_para1496,1,,两个间隔中，如果第一个间隔的结束时间与第二个间隔的开始时间相等，则两个间隔相接（Meet）。
chap5_para1496,2,,"间隔关系的完整集合（Allen, 1983）如下（以及图10-2）："
chap5_para1497,1,,它们各自的含义都很直观，除了Overlap：我们倾向于认为重叠是对称的（如果i与j重叠，则j与i重叠），但根据其定义，仅在i早于j开始时为真。
chap5_para1497,2,,经验表明，这样定义对制定公理更加有用。
chap5_para1497,3,,要表明英国女王伊丽莎白二世（Elizabeth Ⅱ）的统治紧接着乔治六世（George Ⅵ）的统治，而猫王埃尔维斯（Elvis）主宰乐坛的时间与20世纪50年代重叠，我们可以将其写作
chap5_para1498,1,,图10-2　时间间隔的谓词
chap5_para1499,1,,10.3.2　流和对象
chap5_para15,1,Description The game tree has five rows of boxes.,我们将两个参与者[3]分别称为max和min，这么命名的原因稍后解释。
chap5_para15,2,Each box has nine squares arranged in three rows and three columns.,max先移动，然后两个参与者轮流移动，直到博弈结束。
chap5_para15,3,The first row is labeled MAX (x) and has one square box with nine empty squares.,博弈结束时，获胜者得分，而失败者受到惩罚。
chap5_para15,4,The second row is labeled MIN (o) and has nine boxes.,可以使用以下元素对博弈进行形式化定义。
chap5_para15,5,The boxes in the second row show the nine possible squares the x can be placed.,
chap5_para15,6,The third row is labeled MAX (x) and shows the possibilities of placing an o after placing the x in the top left square of the first box in the second row.,
chap5_para15,7,The first box in the third row has the x in the first column of the first row and an o in the second column.,
chap5_para15,8,"The other boxes in the third row show the other possible squares the o can be placed, given that an x is already placed in the top left square in each box.",
chap5_para15,9,The fourth row is labeled MIN (o) and shows the possibilities of placing an x after placing an x and o in the top left and top mid squares.,
chap5_para15,10,The first box in the fourth row has an x and an o in the first and second columns of the first row.,
chap5_para15,11,"The other boxes in the fourth row show the other possible squares the x can be placed, given that an x and an o are already placed in the top left and top mid squares in each box.",
chap5_para15,12,The rows continue this way and the last row is labeled TERMINAL.,
chap5_para15,13,The last row shows three boxes representing three possible ends.,
chap5_para15,14,The first box has a utility value of negative 1.,
chap5_para15,15,The first box is filled column-wise as follows.,
chap5_para15,16,"Column 1: x, blank, blank.",
chap5_para15,17,"Column 2: o, o, o.",
chap5_para15,18,"Column 3: x, x, blank.",
chap5_para15,19,The second box has a utility value of 0.,
chap5_para15,20,The second box is filled row-wise as follows.,
chap5_para15,21,"Row 1: x, o, x.",
chap5_para15,22,"Row 2: o, o, x.",
chap5_para15,23,"Row 3: x, x, o.",
chap5_para15,24,The third box has a utility value of positive 1.,
chap5_para15,25,The third box is filled row-wise as follows.,
chap5_para15,26,"Row 1: x, o, x.",
chap5_para15,27,"Row 2: blank, x, blank.",
chap5_para15,28,"Row 3: x, o, o.",
chap5_para150,1,"Completely independent subproblems are delicious, then, but rare.",博比·费希尔（Bobby Fischer）认为“国际象棋就是战争”，但国际象棋缺少真实战争的一个主要特征——部分可观测性。
chap5_para150,2,"Fortunately, some other graph structures are also easy to solve.",在《战争之雾》（Fog of War）游戏中，敌人的行踪往往是未知的，除非与他直接接触。
chap5_para150,3,"For example, a constraint graph is a tree when any two variables are connected by only one path.",因此，战争中常常使用侦察兵和间谍来收集信息，用隐匿处和虚张声势来迷惑敌人。
chap5_para150,4,We will show that any tree-structured CSP can be solved in time linear in the number of variables.,
chap5_para150,5,"4 The key is a new notion of consistency, called directional arc consistency or DAC.",
chap5_para150,6,"A CSP is defined to be directional arc-consistent under an ordering of variables X1,X2,.",
chap5_para150,7,.,
chap5_para150,8,.,
chap5_para150,9,",Xn if and only if every Xi is arc-consistent with each Xj for j > i.",
chap5_para1500,1,,从对象是一部分时空的角度来看，对象可以被看作一般化的事件。
chap5_para1500,2,,例如，美国（USA）可以被当成是一个事件，它从1776年开始，由起初13个州的联合发展为50个州的联合，并仍在持续发展。
chap5_para1500,3,,我们可以将美国的变化性质描述为状态流，例如Population(USA)。
chap5_para1500,4,,美国的一个每4年或8年变化一次的性质——不出意外的话——是它的总统。
chap5_para1500,5,,有人可能提出，President(USA)是一个在不同时间表示不同对象的逻辑项。
chap5_para1501,1,,遗憾的是，这根本不可能。
chap5_para1501,2,,因为在给定的模型结构中，一个项只能表示一个对象。
chap5_para1501,3,,"（根据t的值，President(USA, t)项可以表示不同的对象，但我们的本体论中时间与流是分离的。"
chap5_para1501,4,,）唯一的可能是President(USA)表示单个对象，这个对象在不同的时间由不同的人组成。
chap5_para1501,5,,这个对象从1789年至1797年是乔治·华盛顿，从1797年至1801年是约翰·亚当斯，以此类推，如图10-3所示。
chap5_para1501,6,,要表示乔治·华盛顿是整个1790年的总统，我们可以写作
chap5_para1502,1,,我们用函数符号Equals而非标准逻辑谓词=，因为我们无法以谓词作为T的参数，还因为正确的解释并不是GeorgeWashington和President(USA)在1790年逻辑等价——逻辑等价并不能随时间改变。
chap5_para1502,2,,实际情况是，1790年这个时段所定义的对象President(USA)的子事件和GeorgeWashington的子事件具有等价关系。
chap5_para1503,1,,图10-3　早期President(USA)对象示意图
chap5_para1504,1,,10.4　精神对象和模态逻辑
chap5_para1505,1,,我们目前为止所构建的智能体具有信念，且能够推导新信念。
chap5_para1505,2,,但它们都不具有关于信念或推导的知识。
chap5_para1505,3,,关于自身所具有的知识和推导过程的知识对控制推断非常有用。
chap5_para1505,4,,例如，假设甲问道“1764的平方根是多少”，而乙回答“我不知道”。
chap5_para1505,5,,如果甲坚持道“再想一想”，乙应当意识到通过进一步思考其实可以回答这个问题。
chap5_para1505,6,,但是，如果甲提出的问题是“总统现在是坐着还是站着？
chap5_para1505,7,,”那么乙应当明白再怎么思考都不太会有作用。
chap5_para1505,8,,知道其他智能体所具有的知识也很重要，乙应当意识到总统自己肯定知道答案。
chap5_para1506,1,,我们需要的是智能体大脑中（或知识库中）的精神对象和操纵这些精神对象的精神过程的模型。
chap5_para1506,2,,这个模型不需要非常具体。
chap5_para1506,3,,我们并不需要预测某个智能体进行推断需要多少毫秒，我们只需要能够得出“妈妈知道她自己是不是坐着”的结论就可以。
chap5_para1507,1,,我们从智能体对精神对象所具有的命题态度（propositional attitude）开始：类似于相信（Believes）、知道（Knows）、想要（Wants）、通知（Informs）这样的态度。
chap5_para1507,2,,难处在于，这些态度的行为与“普通”谓词不同。
chap5_para1507,3,,例如，假设我们试图断言露易丝知道超人会飞：
chap5_para1508,1,,这种说法的一个小毛病是，我们通常将CanFly(Superman)当作语句，但这里它是一个项。
chap5_para1508,2,,我们可以通过物化CanFly(Superman)来修补这个问题，也就是将它变成流。
chap5_para1508,3,,但更严重的问题是，如果超人是克拉克·肯特为真，那么我们只能得出露易丝知道克拉克会飞，而这是错误的，因为（在大多数版本的故事中）露易丝不知道克拉克就是超人。
chap5_para1508,4,,[5]
chap5_para151,1,"To solve a tree-structured CSP, first pick any variable to be the root of the tree, and choose an ordering of the variables such that each variable appears after its parent in the tree. Such an ordering is called a topological sort. Figure 5.10(a) shows a sample tree and (b) shows one possible ordering. Any tree with n nodes has n – 1 edges, so we can make this graph directed arc-consistent in O(n) steps, each of which must compare up to d possible domain values for two variables, for a total time of O(nd2). Once we have a directed arc-consistent graph, we can just march down the list of variables and choose any remaining value. Since each edge from a parent to its child is arc-consistent, we know that for any value we choose for the parent, there will be a valid value left to choose for the child. That means we won’t have to backtrack; we can move linearly through the variables. The complete algorithm is shown in Figure 5.11.",部分可观测游戏也具有这些特征，因此与前文提到的游戏有本质不同。
chap5_para151,2,,像《星际争霸》这样的电子游戏尤其具有挑战性，因为它是部分可观测、多智能体、非确定性、动态且未知的。
chap5_para1510,1,,[5]　超人（Superman）是美国漫画角色。
chap5_para1510,2,,根据漫画情节，超人出生于地外星球，具有超能力，在地球以记者克拉克•肯特（Clark Kent）的身份掩藏自己就是超人的事实。
chap5_para1510,3,,露易丝•莱恩（Lois Lane）是克拉克•肯特的记者同事，同时也是超人迷。
chap5_para1510,4,,在较早期的情节中，露易丝并不知道同事克拉克就是超人。
chap5_para1510,5,,——译者注
chap5_para1511,1,,这是构建在逻辑之中的等值推理的结论。
chap5_para1511,2,,通常这并不是一件坏事，如果我们的智能体知道2 + 2 = 4且4 5，我们就希望智能体知道2 + 2 5。
chap5_para1511,3,,这个性质称为指代透明性（referential transparency）——一种逻辑使用哪个项指代一个对象并不重要，重要的是这个项所指的对象。
chap5_para1511,4,,但对于像相信和知道这样的命题态度，我们需要指代不透明性——使用的项很重要，因为并非所有智能体都知道哪些项是指代同一个对象的。
chap5_para1512,1,,我们可以用进一步物化的方式修补这个问题：我们可以让一个对象表示作为超人的那个克拉克，另一个对象表示露易丝所认识的那个克拉克，我们还需要一个对象表示露易丝所认识的超人。
chap5_para1512,2,,但对象数量的激增意味着我们本来希望能快速写出的语句变得唠叨又笨拙。
chap5_para1513,1,,模态逻辑就是为解决这个问题而产生的。
chap5_para1513,2,,正规逻辑关注于单模态，真值模态使我们可以表示“P为真”或“P为假”。
chap5_para1513,3,,模态逻辑含有以语句（而非项）为参数的模态算子（modal operator）。
chap5_para1513,4,,例如，“A认识P”使用记法KAP表示，其中K是知识的模态算子。
chap5_para1513,5,,它使用两个参数，一个是智能体（以下标表示），另一个是语句。
chap5_para1513,6,,模态逻辑的语法与一阶逻辑基本相同，区别在于模态逻辑中的语句可以用模态算子构成。
chap5_para1514,1,,模态逻辑的语义更为复杂。
chap5_para1514,2,,在一阶逻辑中，一个模型含有一个对象集和将每个名称映射到正确的对象、关系或函数的解释。
chap5_para1514,3,,模态逻辑中，我们希望能够同时考虑到超人的秘密身份是克拉克的可能性和超人不是克拉克的可能性。
chap5_para1515,1,,因此，我们需要更为复杂的模型，它含有一系列可能世界（possible world），而非只有一个为真的世界。
chap5_para1515,2,,这些世界在一个图中以可达性关系（accessibility relation）连接，每个模态算子都对应一个这样的关系。
chap5_para1515,3,,如果w1中的一切都与A在w0中所知道的东西一致，我们就说从世界w0关于模态算子KA可达世界w1。
chap5_para1515,4,,举一个现实世界中的例子，布加勒斯特是罗马尼亚的首都，但对于不知道这一事实的智能体来说，罗马尼亚首都位于（例如）索非亚的世界就是可达的。
chap5_para1515,5,,但愿所有智能体都不可达2 + 2 = 5的世界。
chap5_para1516,1,,一般而言，一个知识原子KAP在世界w中为真，当且仅当在从w可达的所有世界中P都为真。
chap5_para1516,2,,更复杂的语句的真值是通过递归应用这条规则以及一阶逻辑的一般规则来推导的。
chap5_para1516,3,,这意味着模态逻辑可以用于推理嵌套知识语句：一个智能体对另一个智能体的知识知道多少。
chap5_para1516,4,,例如，我们可以说露易丝虽然不知道超人的秘密身份是否就是克拉克·肯特，但她知道克拉克本人知道超人的秘密身份是什么：
chap5_para1517,1,,模态逻辑解决了一些涉及量词和知识互相作用的麻烦问题。
chap5_para1517,2,,英语句子“Bond knows that someone is a spy”（邦德知道某个人是间谍）是有歧义的。
chap5_para1517,3,,第一种解读是邦德知道某个特定的人是间谍，我们可以将其写作
chap5_para1518,1,,这在模态逻辑中的意思是，存在一个x，在所有可达世界中邦德都知道这个x是间谍。
chap5_para1518,2,,第二种解读是，邦德只知道至少有一个间谍：
chap5_para1519,1,,它的模态逻辑解释是，在所有可达世界中，都有一个间谍x，但它在不同世界中未必是相同的x。
chap5_para152,1,"Description Two three-level binary trees are shown. Up and down triangles represent MAX and MIN nodes, respectively, and circles represent CHANCE nodes. Binary tree 1: The first level of the game tree is labeled MAX and a MAX node is present. The node connects to two nodes in the second level. The second level is labeled CHANCE and the two nodes are CHANCE nodes labeled 2.1 and 1.3. An arrow labeled “a” subscript 1 from the MAX node connects to node 2.1. A path labeled “a” subscript 2 from the MAX node connects to node 1.3. The two nodes in the CHANCE level each have two child nodes in the third level. The third level is labeled MIN and has four MIN nodes. The two child nodes of 2.1 are labeled 2 and 3. Paths labeled 0.9 and 0.1 from node 2.1 connect to nodes 2 and 3, respectively. The two child nodes of 1.3 are labeled 1 and 4. Paths labeled 0.9 and 0.1 from node 1.3 connect to nodes 1 and 4, respectively. The two child nodes of 1 are labeled 1 and 1. The two child nodes of 2 are labeled 2 and 2. The two child nodes of 3 are labeled 3 and 3. The two child nodes of 4 are labeled 4 and 4. Binary tree 2: The first level of the game tree is labeled MAX and a MAX node is present. The node connects to two nodes in the second level. The second level is labeled CHANCE and the two nodes are CHANCE nodes labeled 21 and 40.9. An arrow labeled “a” subscript 2 from the MAX node connects to node 40.9. A path labeled “a” subscript 1 from the MAX node connects to node 21. The two nodes in the CHANCE level each have two child nodes in the third level. The third level is labeled MIN and has four MIN nodes. The two child nodes of 21 are labeled 20 and 30. Paths labeled 0.9 and 0.1 from node 21 connect to nodes 20 and 30, respectively. The two child nodes of 40.9 are labeled 1 and 400. Paths labeled 0.9 and 0.1 from node 40.9 connect to nodes 1 and 400, respectively. The two child nodes of 1 are labeled 1 and 1. The two child nodes of 20 are labeled 20 and 20. The two child nodes of 30 are labeled 30 and 30. The two child nodes of 400 are labeled 400 and 400.",在确定性部分可观测博弈中，关于棋盘状态的不确定性完全来自无法获知对手做出的选择。
chap5_para152,2,,这类博弈包括Battleship（每个玩家战舰的放置位置都对敌人隐藏）和Stratego（棋子的位置已知，但种类隐藏）这样的儿童游戏。
chap5_para152,3,,我们考虑四国军棋（Kriegspiel）游戏，它是国际象棋的部分可观测变体，即完全看不到对方的棋子。
chap5_para152,4,,其他游戏也有部分可观测版本：幻影围棋、幻影井字棋和Screen Shogi。
chap5_para1520,1,,我们现在有了知识的模态算子，就可以为其写出公理。
chap5_para1520,2,,首先，我们可以说智能体能够进行推论：如果一个智能体知道P且知道P蕴涵Q，则该智能体知道Q：
chap5_para1521,1,,由此（以及其他一些关于逻辑等价性的规则）我们可以得出是重言式：所有智能体都知道每个命题P要么为真要么为假。
chap5_para1521,2,,但是，不是重言式；一般而言，对于很多命题，智能体既不知其为真，也不知其为假。
chap5_para1522,1,,人们说（以柏拉图最先提出）知识是确证为真的信念。
chap5_para1522,2,,也就是说，如果一个事物为真，如果你相信它为真，而且如果你有无法反驳的好理由来说明它为真，那么你就知道这个事物。
chap5_para1522,3,,这意味着如果你知道某事，那么它必然为真。
chap5_para1522,4,,据此我们有公理：
chap5_para1523,1,,进一步地，逻辑智能体（但并非所有人）都能够内省自己的知识。
chap5_para1523,2,,如果它们知道某事，则它们知道“它们知道这事”：
chap5_para1524,1,,我们可以为信念（通常用B表示）和其他模态定义类似的公理。
chap5_para1524,2,,但模态逻辑方法的一个问题是它假设了智能体的逻辑全知（logical omniscience）。
chap5_para1524,3,,也就是说，如果智能体知道一个公理集，则它知道这些公理的所有结论。
chap5_para1524,4,,即使对于知识的较为抽象的概念这个前提都相当不牢靠，更别提对于信念了，因为信念更常涉及在智能体中被实际表示出来的东西，而非仅仅是可推导的东西。
chap5_para1525,1,,有人尝试过为智能体定义某种有限理性形式——让智能体只能相信那些不超过k个推理步骤或不超过s秒计算就能推导出来的断言。
chap5_para1525,2,,这些尝试基本都不能令人满意。
chap5_para1527,1,,除了针对知识的模态逻辑，还有许多其他针对不同模态的模态逻辑被提出。
chap5_para1527,2,,一种提法是为可能性和必然性添加模态运算符：本书的某个作者现在可能是坐着的，而2 + 2 = 4必然为真。
chap5_para1528,1,,如8.1.2节所述，一些逻辑学家青睐于关于时间的模态。
chap5_para1528,2,,在线性时态逻辑（linear temporal logic）中，我们添加如下模态算子：
chap5_para1529,1,,● X P：“P在下一个时刻将为真”
chap5_para153,1,Figure 5.,5.6.1　四国军棋：部分可观测的国际象棋
chap5_para153,2,10(a) The constraint graph of a tree-structured CSP.,
chap5_para153,3,(b) A linear ordering of the variables consistent with the tree with A as the root.,
chap5_para153,4,This is known as a topological sort of the variables.,
chap5_para1530,1,,● F P：“P最终（Finally）将在未来某个时刻为真”
chap5_para1531,1,,● G P：“P始终（Globally）为真”
chap5_para1532,1,,● P U Q：“在Q发生前P保持为真”
chap5_para1533,1,,有时可以从这些算子推导出其他算子。
chap5_para1533,2,,增加这些模态算子使逻辑自身变得更为复杂（也就使逻辑推断算法更难找出证明）。
chap5_para1533,3,,但这些算子使我们能够更简洁地陈述某些事实（这使得逻辑推断更快）。
chap5_para1533,4,,选择要用哪种逻辑类似于选择要用哪种编程语言：选择适合你任务的那一个，选择你和你的合作者更熟悉的那一个，选择对你的目的足够有效的那一个。
chap5_para1534,1,,10.5　类别的推理系统
chap5_para1535,1,,类别是大规模知识表示系统最重要的构造模块。
chap5_para1535,2,,本节描述为类别的组织和推理专门设计的系统。
chap5_para1535,3,,有两类密切相关的系统：语义网络（semantic network）从图的角度为知识库的可视化提供辅助，并基于对象的类别从属为推断对象的属性提供高效算法；描述逻辑（description logic）为构建和合一类别的定义提供形式化语言，并为确定类别间的子集和超集关系提供高效算法。
chap5_para1536,1,,10.5.1　语义网络
chap5_para1537,1,,1909年，查尔斯·皮尔斯（Charles S. Peirce）提出了一种称为存在图（existential graph）的、由边和节点构成的图表示，他称之为“未来的逻辑”。
chap5_para1537,2,,由此开启了一场提倡“逻辑”者和提倡“语义网络”者之间的长期争论。
chap5_para1537,3,,遗憾的是，争论掩盖了语义网络也是一种逻辑的事实。
chap5_para1537,4,,语义网络为某些语句提供的记法往往更方便，但如果我们排除了“人类界面”的因素，其底层概念（即对象、关系、量化等）是相同的。
chap5_para1538,1,,语义网络有很多变种，但它们都能表示单个对象、对象的类别和对象之间的关系。
chap5_para1538,2,,典型的记法将对象名称显示于椭圆或方框中，并以带标签的连线连接它们。
chap5_para1538,3,,"例如，图10-4在Mary和FemalePersons之间有MemberOf连线，对应于逻辑断言；类似地，Mary和John之间的SisterOf连线对应于断言SisterOf(Mary, John)。"
chap5_para1538,4,,我们可以使用SubsetOf连线连接类别，以此类推。
chap5_para1538,5,,画出气泡和箭头很有趣，但不要忘乎所以。
chap5_para1538,6,,例如，我们知道，人的母亲是女性，但我们可以从Persons画一条HasMother连线连到FemalesPersons上吗？
chap5_para1538,7,,答案是不行，因为HasMother是人和其母亲之间的关系，而类别并没有母亲。
chap5_para1538,8,,[6]
chap5_para154,1,"Description Five reduced chess boards are shown. The chess boards are reduced to 4 by 4, with row labels “a” to d from left to right and column labels 1 to 4 from bottom to top. Board 1: The blacks are in the following positions. Kings, “a” 4, b 4, and c 4. The whites are in the following positions. King, d 2. Rook d 3. A line labeled K c 3 question mark from Board 1 connects to a circular node. An arrow labeled Illegal from the node points to board 2. Board 2: The blacks are in the following positions. Kings, b 4 and c 4. The whites are in the following positions. King, d 2. Rook d 3. A line labeled R c 3 connects Board 2 to a second circular node. An arrow labeled OK from the second node points to board 3. Board 3: A black is in the following position. King, b 4. The whites are in the following positions. King, d 2. Rook c 3. Another arrow labeled Check from the second node points to board 4. Board 4: A black is in the following position. King, b 4. The whites are in the following positions. King, d 2. Rook c 3. An arrow labeled OK from the first node points to board 5. Board 5: A black is in the following position. King, ""a"" 4. The whites are in the following positions. King, c 3. Rook d 3.",四国军棋的规则如下：白方和黑方各自只能看到自己一方的棋子。
chap5_para154,2,,裁判可以看到所有棋子，他对比赛进行判定并定期向双方宣布。
chap5_para154,3,,首先，白方向裁判提出合法移动（只要位置上没有黑方）。
chap5_para154,4,,如果该位置有黑方占位，裁判会宣布移动“非法”，白方不断向裁判提出下一步的走法，直到找到一个合法移动——在这个过程中也了解到了黑方的位置。
chap5_para1540,1,,[6]　一些早期的系统无法区分类别成员的属性和整个类别的属性。
chap5_para1540,2,,"这会直接引发不一致性，如德鲁•麦克德莫特（Drew McDermott）（McDermott, 1976）在文章“Artificial Intelligence Meets Natural Stupidity”所指出。"
chap5_para1540,3,,另一个常见的问题是对子集和成员关系都使用了IsA（是）连线，对应于英语用法“猫是哺乳动物”和“菲菲是猫”。
chap5_para1540,4,,见习题10.NATS了解更多关于这一主题的知识。
chap5_para1541,1,,因此，我们在图10-4中使用了双方框这样的特殊记法。
chap5_para1541,2,,这个连线断言了
chap5_para1542,1,,我们可能还想断言人有两条腿，也就是
chap5_para1543,1,,如前所述，我们需要当心，以免断言某个类别有两条腿；图10-4中的单方框用于断言一个类别中每个成员都具有的属性。
chap5_para1544,1,,语义网络的记法很便于进行10.2节介绍的继承推理。
chap5_para1544,2,,例如，作为一个人，玛丽继承了具有两条腿的属性。
chap5_para1544,3,,因此，要搞清楚玛丽有几条腿，继承算法追溯从Mary到其所属类别的MemberOf连线，然后跟着SubsetOf连线向上层移动，直到它找到连线是带方框的Legs的类别——本例中为Persons类别。
chap5_para1544,4,,对比于半可判定的逻辑定理证明，这种推断机制的简洁性和高效性是语义网络具有吸引力的主要原因之一。
chap5_para1545,1,,图10-4　具有4个对象（John、Mary、1和2）和4个类别的语义网络。
chap5_para1545,2,,关系使用带标签的连线表示
chap5_para1546,1,,当对象可以属于不止一个类别，或当类别可以是不止一个类别的子类时，继承就会变得较为复杂，这被称为多重继承（multiple inheritance）。
chap5_para1546,2,,这种情况下，继承算法可能会为查询找到两个甚至更多个互相冲突的值。
chap5_para1546,3,,因此，一些在类的层次结构中使用继承的面向对象编程（object-oriented programming，OOP）禁止多重继承，如Java。
chap5_para1546,4,,在语义网络中通常允许多重继承，但我们在10.6节再对其进行讨论。
chap5_para1547,1,,读者可能已经注意到了语义网络表示相比于一阶逻辑的一个明显的缺点：气泡之间的连线只能表示二元关系。
chap5_para1547,2,,"例如，语句Fly(Shankar, NewYork, NewDelhi, Yesterday)无法直接从语义网络中断言。"
chap5_para1547,3,,不过我们可以通过将命题自身物化为属于合适的事件类别的事件来得到n元断言的效果。
chap5_para1547,4,,图10-5展示了这个事件的语义网络结构。
chap5_para1547,5,,注意，二元关系的限制条件迫使网络创造出大量物化概念的本体论。
chap5_para1548,1,,"图10-5　一个语义网络的一部分，展示了对逻辑断言Fly(Shankar, NewYork, NewDelhi, Yesterday)的表示"
chap5_para1549,1,,命题的物化使得在语义网络记法中表示所有基本的、无函数的一阶逻辑原子语句成为可能。
chap5_para1549,2,,某些全称量化的语句可以使用反向连线并对类别使用单框或双框的箭头来断言，但这仍然远不及完整的一阶逻辑。
chap5_para1549,3,,否定、析取、嵌套函数符号和存在量词都无法表示。
chap5_para1549,4,,扩展记法使语义网络等价于一阶逻辑是可能的（如皮尔斯的存在图），但这样会损失语义网络的一个重要优点，也就是推断过程的简洁性和透明性。
chap5_para1549,5,,设计者可以构建很大的网络，同时仍然能够很好地了解哪些查询是高效的，因为（a）将推断过程行进的步骤可视化相当简单，（b）某些情况下查询语言非常简单，以至于无法提出高难度的查询。
chap5_para155,1,Figure 5.,一旦提出了一个合法移动，裁判会宣布以下一项或多项内容：如果在X处有吃子则宣布“在X上吃子”，如果黑王被将军，则宣布“被D将军”，其中D是将军的方向，可以是“马”“行”“列”“长对角线”或“短对角线”。
chap5_para155,2,11The TREE-CSP-SOLVER algorithm for solving tree-structured CSPs.,如果黑方被将死或陷入僵局，裁判也会宣布；否则，轮到黑方行棋。
chap5_para155,3,"If the CSP has a solution, we will find it in linear time; if not, we will detect a contradiction.",
chap5_para1550,1,,当表达能力确实太有限时，许多语义网络系统提供了过程式附件（procedural attachment）来弥补。
chap5_para1550,2,,过程式附件是一种技术，它使得涉及某些关系的查询（有时是断言）能够调用专用于处理这种关系的过程，而非一般的推断算法。
chap5_para1551,1,,语义网络很重要的一个方面是它具有表示类别的缺省值（default value）的能力。
chap5_para1551,2,,仔细考察图10-4，我们注意到约翰有一条腿，尽管他是一个人，而人都有两条腿。
chap5_para1551,3,,在严格的逻辑知识库中，这会导致矛盾，但在语义网络中，这种“人都有两条腿”的断言只是具有缺省状态，也就是说，我们预设人有两条腿，除非有与之矛盾的、更为确切的信息。
chap5_para1551,4,,很自然地，缺省语义由继承算法执行，因为它从对象自身（本例中为John）沿着连线向上运行，一旦找出一个值就停止运行。
chap5_para1551,5,,我们说缺省值被更确切的值覆盖（overridden）了。
chap5_para1551,6,,注意，我们也可以通过创建John所在的Persons类别的子类OneLeggedPerson（一条腿的人）来覆盖缺省的腿数量。
chap5_para1552,1,,如果我们表明了对Person的Legs断言在John这里有例外，就可以维持网络的严格逻辑语义：
chap5_para1553,1,,对于固定的网络，这样做在语义上没有问题，但如果例外太多的话，其简洁性就远不如网络记法。
chap5_para1553,2,,但对于需要用新断言更新的网络，这样做就不可行——我们实际想表明的是目前还不知道是谁的那些只有一条腿的人也是例外。
chap5_para1553,3,,10.6节更深入地探讨了这个话题，还探讨了一般的缺省推理。
chap5_para1554,1,,10.5.2　描述逻辑
chap5_para1555,1,,一阶逻辑的语法旨在简化对对象的描述。
chap5_para1555,2,,描述逻辑则是旨在简化对类别的定义和性质的描述的记法。
chap5_para1555,3,,描述逻辑系统是从语义网络演化而来的，目的是在维持分类结构作为组织原则的同时形式化网络的含义。
chap5_para1556,1,,描述逻辑的主要推断任务是包容（subsumption）（通过比较定义来检查一个类别是否是另一个类别的子集）和分类（classification）（检查一个对象是否属于某个类别）。
chap5_para1556,2,,一些系统还纳入了类别定义的一致性（consistency）——成为该类别成员的条件是否是逻辑可满足的。
chap5_para1557,1,,"Classic语言（Borgida et al., 1989）是典型的描述逻辑。"
chap5_para1557,2,,Classic描述的语法展示在图10-6中。
chap5_para1557,3,,[7]例如，要说单身汉是未婚成年男性，可以写作
chap5_para1559,1,,[7]　注意，这个语言不允许我们直接陈述一个概念或类别是另一个概念或类别的子集。
chap5_para1559,2,,这是刻意为之的：类别之间的包容关系必须可以由类别描述的某些方面推导得来。
chap5_para1559,3,,如果无法推导，说明描述不完整。
chap5_para156,1,"Now that we have an efficient algorithm for trees, we can consider whether more general constraint graphs can be reduced to trees somehow.",四国军棋看起来非常难处理，但人类可以很好地掌握它，计算机程序也开始迎头赶上。
chap5_para156,2,There are two ways to do this: by removing nodes (Section 5.,回顾4.4节和图4-14中介绍的信念状态的概念——在给定目前为止所有历史感知的情况下，所有逻辑可能的棋盘状态的集合。
chap5_para156,3,5.,初始时，白方的信念状态只有一个元素，因为黑方还没有移动。
chap5_para156,4,1) or by collapsing nodes together (Section 5.,白方下了一步且黑方做出应对后，白方的信念状态就包含了20种局面，因为黑方对白方的任意一种开局都存在20种回应。
chap5_para156,5,5.,
chap5_para156,6,2).,
chap5_para1560,1,,一阶逻辑中的等价形式为
chap5_para1561,1,,图10-6　Classic语言的一个子集中的描述语法
chap5_para1562,1,,注意，描述逻辑具有对谓词的代数运算，一阶逻辑中显然没有这种东西。
chap5_para1562,2,,Classic中的任何描述都可以翻译为等价的一阶逻辑语句，但一些描述在Classic中更为直接。
chap5_para1562,3,,例如，要描述这样一个男人的集合，其中每个男人至少有3个儿子，至多有2个女儿，这些儿子都无业且都娶了医生，这些女儿都是物理或数学系教授，我们可以将其写作
chap5_para1563,1,,将其翻译为一阶逻辑是我们的一道习题。
chap5_para1564,1,,也许描述逻辑最重要的一点是它对推断易处理性的强调。
chap5_para1564,2,,一个问题实例可以通过对其进行描述并查看它是否被几个可能的解类别所包容来求解。
chap5_para1564,3,,在标准的一阶逻辑中，往往不可能预测求解时长。
chap5_para1564,4,,用户经常需要修改表示方法，以避免那些可能导致系统花几个星期求解问题的语句集。
chap5_para1564,5,,而描述逻辑很棒的地方是它保证包容检测可以在描述规模的多项式时间内求解。
chap5_para1564,6,,[8]
chap5_para1566,1,,[8]　实际中，Classic提供了高效的包容检测，但其最坏情况运行时间是指数级的。
chap5_para1567,1,,这乍听起来不错，直到我们发觉它只会导致两个后果之一：要么完全无法陈述困难的问题，要么需要指数级的大规模描述！
chap5_para1567,2,,不过，易处理的结果指明了哪些构件引发了问题，也有助于使用者理解不同表示的行为。
chap5_para1567,3,,例如，描述逻辑通常缺乏否定和析取。
chap5_para1567,4,,它们都使一阶逻辑系统不得不进行潜在的指数级的情况分析来确保完备性。
chap5_para1567,5,,Classic仅在Fills和OneOf构件中使用有限的析取，它允许对显式枚举出的个体使用析取，而不能析取描述。
chap5_para1567,6,,如果有描述的析取的话，嵌套定义能轻易导致指数量级的、表示一个类别包容另一个类别的分支路径。
chap5_para1568,1,,10.6　用缺省信息推理
chap5_para1569,1,,在前一节中，我们见过一个使用缺省状态进行断言的简单例子：人有两条腿。
chap5_para1569,2,,这个缺省信息可以被更确切的信息覆盖，例如Long John Silver[9]只有一条腿。
chap5_para1569,3,,我们看到，语义网络的继承机制用简单自然的方式实现了对缺省信息的覆盖。
chap5_para1569,4,,本节我们用更一般化的方式研究缺省信息，以期理解缺省信息的语义，而非仅给出其过程性机制。
chap5_para157,1,5.,在游戏过程中跟踪信念状态正是状态评估问题，4.4.4节中的式（4-6）给出了更新步骤。
chap5_para157,2,5.,如果我们把对手看作不确定性的来源，那么可以把四国军棋的状态评估直接映射到4.4节的部分可观测的、非确定性的框架中；也就是说，白方所选移动的Results由白方自身移动带来的（可预测）结果和黑方回应给出的不可预测结果组成。
chap5_para157,3,1Cutset conditioning,[6]
chap5_para1571,1,,[9]　Long John Silver一般译作约翰•西尔弗，是英国小说家史蒂文森创作的著名小说《金银岛》中的海盗，他只有一条腿，在另一条腿处安装了木制假腿。
chap5_para1571,2,,——译者注
chap5_para1572,1,,10.6.1　限定与缺省逻辑
chap5_para1573,1,,我们已经见过两个违反了第7章证明的逻辑的单调性（Monotonicity）性质的推理程序。
chap5_para1573,2,,[10]本章我们看到，语义网络中一个类别所有成员都继承的性质可以被子类别更确切的信息覆盖。
chap5_para1573,3,,在9.4.4节，我们看到在封闭世界假设下，如果一个命题没有在KB中被提及，则，但。
chap5_para1575,1,,[10]　回想一下，单调性要求知识库中所有蕴含的语句在新语句被添加到知识库后仍然蕴含。
chap5_para1575,2,,也就是说，如果，则。
chap5_para1576,1,,简单的内省表明，常识推理往往不符合单调性。
chap5_para1576,2,,人类似乎总是“跳到结论”。
chap5_para1576,3,,例如，当有人看到停在路边的车，他往往愿意相信这辆车有4个轮子，尽管他只能看到3个轮子。
chap5_para1576,4,,概率论当然可以提供车大概率有4个轮子的结论，但对多数人来说，只有在新证据自动出现的情况下才会想到这辆车并非有4个轮子的可能性。
chap5_para1576,5,,这样看来，在没有理由怀疑的情况下，4个轮子的结论似乎是缺省地达成的。
chap5_para1576,6,,如果有了新的证据——例如，如果我们看到车主搬着一只轮胎，而且车被千斤顶顶起来了——则先前的结论可以被收回。
chap5_para1576,7,,可以说这种推理展示出了非单调性（nonmonotonicity），因为信念集在新证据到来时并不随之单调增长。
chap5_para1576,8,,非单调逻辑（nonmonotonic logic）修改了真值和蕴含的概念以刻画这种行为。
chap5_para1576,9,,我们将考察两种这样的逻辑，限定和缺省逻辑，它们都被大量研究过。
chap5_para1577,1,,限定（circumscription）可以被看作更为强大且精确的封闭世界假设。
chap5_para1577,2,,其思想是确定一个被假设为“尽可能假”的谓词，也就是，对所有对象都为假，除了那些我们已知为真的对象。
chap5_para1577,3,,例如，假设我们要断言缺省规则，鸟会飞。
chap5_para1577,4,,我们引入一个谓词，譬如，写出
chap5_para1578,1,,如果我们说被限定了，则限定推理器就有权假设，除非已知为真。
chap5_para1578,2,,这就使结论Flies(Tweety)可以从前提Bird(Tweety)中得出，但如果被断言，结论便不再成立。
chap5_para1579,1,,限定可以被看作一种模型偏好（model preference）逻辑。
chap5_para1579,2,,在这种逻辑中，如果语句在知识库的所有被偏好的模型中都为真，则语句（在缺省情况下）被蕴含，而无须像经典逻辑中要求在所有模型中都为真。
chap5_para1579,3,,对限定来说，如果一个模型的异常对象更少，则它比另一个模型更受偏好。
chap5_para1579,4,,[11]我们来看这种思想在语义网络的多重继承上下文中是如何运作的。
chap5_para1579,5,,多重继承问题的一个标准范例是“尼克松菱形”。
chap5_para1579,6,,我们观察到，理查德·尼克松既是基督教贵格会教徒（故而缺省为和平主义者），又是共和党党员（故而缺省为非和平主义者）。
chap5_para1579,7,,我们可以将其写作
chap5_para158,1,The first way to reduce a constraint graph to a tree involves assigning values to some variables so that the remaining variables form a tree.,
chap5_para158,2,"Consider the constraint graph for Australia, shown again in Figure 5.",
chap5_para158,3,12(a).,
chap5_para158,4,"Without South Australia, the graph would become a tree, as in (b).",
chap5_para158,5,"Fortunately, we can delete South Australia (in the graph, not the country) by fixing a value for SA and deleting from the domains of the other variables any values that are inconsistent with the value chosen for SA.",
chap5_para1581,1,,[11]　对于封闭世界假设，一个模型只要真原子比另一个模型少就受偏好，也就是说，偏好模型是最小模型。
chap5_para1581,2,,封闭世界假设和确定子句知识库密切相关，因为前向链接在确定子句知识库上到达的不动点是唯一的最小模型。
chap5_para1581,3,,见7.5.4节了解更多相关内容。
chap5_para1582,1,,如果我们限定Abnormal2和Abnormal3，就会有两个偏好模型，其中一个模型中Abnormal2(Nixon)和Pacifist(Nixon)为真，另一个模型中Abnormal3(Nixon)与为真。
chap5_para1582,2,,这样的话，限定推理器在尼克松到底是不是和平主义者这一问题上就完全是不可知论者。
chap5_para1582,3,,如果我们想另外断言宗教信仰优先于政治信仰，我们可以使用称为优先限定（prioritized circumscription）的形式体系来对Abnormal3最小化的模型增加偏好。
chap5_para1583,1,,缺省逻辑是可以用缺省规则生成逻辑偶然的非单调结论的形式体系。
chap5_para1583,2,,缺省规则类似下式：
chap5_para1584,1,,这条规则的意思是，如果Bird(x)为真，且如果Flies(x)与知识库一致，则可以得出缺省结论Flies(x)。
chap5_para1584,2,,一般而言，缺省规则的形式为
chap5_para1585,1,,其中，P称为先决条件，C是结论，Ji是论证——如果其中任何一条可以被证明为假，则无法得出结论。
chap5_para1585,2,,Ji或C中的所有变量都必须同时在P中。
chap5_para1585,3,,在缺省逻辑中，尼克松菱形的例子可以用一条事实和两条缺省规则表示：
chap5_para1586,1,,要翻译缺省规则的含义，我们将缺省理论的拓展定义为该理论结果的最大集合。
chap5_para1586,2,,也就是，一个拓展S含有原始已知事实和缺省规则得出的结论集，使得S中不再能得出其他结论，且S中的每个缺省结论的论证都与S一致。
chap5_para1586,3,,与限定中的偏好模型一样，对于尼克松菱形，我们有两种可能的拓展：在其中一种当中尼克松是和平主义者，在另一种当中他不是和平主义者。
chap5_para1586,4,,优先方法可以使某些缺省规则比另一些规则优先，以便解决某些歧义性问题。
chap5_para1587,1,,从1980年首次提出非单调性逻辑开始，对其数学性质的理解已经有了大量进展。
chap5_para1587,2,,但仍然有尚未解决的问题。
chap5_para1587,3,,例如，如果“汽车有4个轮子”为假，那么它在一个智能体的知识库中意味着什么？
chap5_para1587,4,,什么样的缺省规则集是好的规则集？
chap5_para1587,5,,如果我们无法确定每条规则是否属于我们的知识库，那么我们就要面临严重的非模块性问题。
chap5_para1587,6,,最后，具有缺省状态的信念如何用于决策？
chap5_para1587,7,,这很可能是缺省推理中最难的问题。
chap5_para1588,1,,决策往往需要权衡，因此我们需要比较对不同动作的结果的信念的强度，以及决策错误的代价。
chap5_para1588,2,,当重复进行相同决策时，或许可以将缺省规则解释为“阈值概率”。
chap5_para1588,3,,例如，缺省规则“我的刹车一直都很好”的实际含义是“在没有其他信息的前提下，我的刹车很好的概率足够高，因此我的最优决策是不用检查刹车就直接开车”。
chap5_para1588,4,,当决策上下文改变时——例如，当我们开着一辆重载卡车下陡坡时——缺省规则突然就变得不适宜了，即使并没有新证据表明刹车存在故障。
chap5_para1588,5,,这些思考促使研究者考虑如何将缺省推理嵌入概率论或效用理论当中。
chap5_para1589,1,,10.6.2　真值维护系统
chap5_para159,1,"Description The first level of game tree is labeled MAX and the node is labeled ""A"".",[6]　有时，信念状态会变得非常大以至于无法仅用棋盘状态列表表示，但我们将暂时忽略这个问题，第7章和第8章将介绍大型信念状态的紧凑表示方法。
chap5_para159,2,"Node ""A"" has two child nodes.",
chap5_para159,3,"Node ""A"" is represented by an up triangle.",
chap5_para159,4,The second level is labeled MIN and the two nodes are labeled 99 and 100.,
chap5_para159,5,The two nodes are represented by down triangles and each has four child nodes.,
chap5_para159,6,"The four child nodes of B are labeled 99, 1000, 1000, and 1000 and represented by up triangles.",
chap5_para159,7,"The four child nodes of 100 are labeled 100, 101, 102, and 103 and represented by up triangles.",
chap5_para1590,1,,我们已经见过许多知识表示系统得出的推断只是具有缺省状态，而非完全确定。
chap5_para1590,2,,不可避免地，在有新信息的情况下，许多推断出的事实最终将被证明是错误的，必须被收回。
chap5_para1590,3,,这个过程被称为信念修正（belief revision）。
chap5_para1590,4,,"[12]假设知识库KB含有语句P（可能是前向链接算法记录的缺省结论，也可能只是不正确的断言）且我们想执行Tell(KB, )。"
chap5_para1590,5,,"为避免导致矛盾，我们必须先执行Retract(KB, P)。"
chap5_para1590,6,,这听起来很简单。
chap5_para1590,7,,但如果其他语句是从P推断得出的，且在KB中断言了该语句，就会产生问题。
chap5_para1590,8,,例如，蕴涵式可能已经用于添加Q。
chap5_para1590,9,,显然的“解决方法”——收回由P得出的所有语句——无法使用，因为这种语句还有除P之外的其他论证。
chap5_para1590,10,,例如，如果R和也在KB中，则Q就根本不需要被移除。
chap5_para1590,11,,真值维护系统（truth maintenance system），或TMS，就是用于解决这类难题的。
chap5_para1592,1,,[12]　信念修正常与信念更新进行对比。
chap5_para1592,2,,当为了反映世界的变化而非固定世界的新信息而修改知识库时会出现信念更新。
chap5_para1592,3,,信念更新将信念修正与对时间和变化的推理进行结合，它还涉及第14章介绍的滤波。
chap5_para1593,1,,真值维护的一个简单方法是将语句编号为P1到Pn来记录它们被告知知识库的顺序。
chap5_para1593,2,,"当调用Retract(KB, Pi)时，系统恢复到Pi刚刚被添加前的状态，因而删除Pi和由Pi得出的所有推断。"
chap5_para1593,3,,语句Pi+1到Pn就可以被重新加入。
chap5_para1593,4,,这很简单，且确保了知识库的一致性，但收回Pi需要收回并重新断言n−1条语句，还要撤销并重做由这些语句得出的所有推断。
chap5_para1593,5,,对于添加了许多事实的系统（例如大型商业数据库）这不切实际。
chap5_para1594,1,,一个更为高效的方法是基于论证的真值维护系统，简称JTMS。
chap5_para1594,2,,在JTMS中，知识库中的每条语句都用一条论证（justification）标记，它含有推断出该语句的语句集。
chap5_para1594,3,,例如，如果一个知识库已经含有，则Tell(P)会使Q和附带的论证被加入。
chap5_para1594,4,,一般而言，一条语句的论证数量是无限制的。
chap5_para1594,5,,论证使收回语句变得高效。
chap5_para1594,6,,调用Retract(P)时，JTMS将删除每条论证都有P的所有语句。
chap5_para1594,7,,因此，如果语句Q的唯一论证为，它就会被删除；而如果Q有其他论证，则它会被保留。
chap5_para1594,8,,这样，收回P所需的时间就仅依赖于由P推得的语句数量，而非在P之后添加的语句数量。
chap5_para1595,1,,JTMS假设被考虑过一次的语句很可能会再次被考虑，因此当语句失去所有论证时，JTMS并不从知识库中完全删除该语句，而仅将语句标记为在知识库外。
chap5_para1595,2,,如果后续的断言重建了语句的某个论证，则语句被标记为在知识库内。
chap5_para1595,3,,如此，JTMS保留了它用到的所有推断链，当一个论证重新生效时便无须重新推导语句。
chap5_para1596,1,,除了收回错误信息，TMS还可以用于加速多重假设情形的分析。
chap5_para1596,2,,例如，假设罗马尼亚奥委会正在为2048年将在罗马尼亚举办的奥运会挑选游泳（swimming）、田径（athletics）和马术（equestrian）比赛的地点。
chap5_para1596,3,,"例如，令第一个假设为Site(Swimming, Pitesti)、Site(Athletics, Bucharest)和Site(Equestrian, Arad)。"
chap5_para1597,1,,我们随后必须进行大量推断来算出这种假设的后勤保障需要，也就是其合意程度。
chap5_para1597,2,,"如果我们想转而考虑Site(Athletics, Sibiu)，TMS会避免从头开始重新计算。"
chap5_para1597,3,,"相反，我们只需收回Site(Athletics, Bucharest)并断言Site(Athletics, Sibiu)，TMS就会进行必要的修正。"
chap5_para1597,4,,选择布加勒斯特（Bucharest）生成的推断链可以重新用在锡比乌（Sibiu）上——如果二者的结论相同的话。
chap5_para1598,1,,基于假设的真值维护系统简称ATMS，它能使这种在假设世界之间进行的转换特别高效。
chap5_para1598,2,,在JTMS中，维护论证使你可以用少量收回和断言就能从一个状态快速转换到另一个状态，但在任意时刻，它只能表示一种状态。
chap5_para1598,3,,ATMS则同时表示所有被考虑过的状态。
chap5_para1598,4,,JTMS只是将每条语句标记为在内或在外，而ATMS则记录每条语句在哪个假设中为真。
chap5_para1598,5,,也就是说，每条语句都有一个包含假设集的标签。
chap5_para1598,6,,语句仅在一个语句集的所有假设为真时为真。
chap5_para1599,1,,真值维护系统还提供了生成解释的机制。
chap5_para1599,2,,理论上，语句P的解释是语句集E，使得E蕴含P。
chap5_para1599,3,,如果E中的语句已知为真，则E只是提供了证明P的充分根据。
chap5_para1599,4,,但解释还可以包括假设——未知其为真，但如果为真的话就足以证明P的语句。
chap5_para1599,5,,例如，如果你的汽车无法启动，你很可能没有足够的信息来确定性地证明造成这个问题的原因。
chap5_para1599,6,,但一个合理的解释可能含有电瓶没电的假设。
chap5_para1599,7,,结合汽车工作原理的知识，这就能解释观测到的故障。
chap5_para1599,8,,在大多数情况下，我们倾向于最小的解释E，这意味着E不存在同样是解释的真子集。
chap5_para1599,9,,ATMS可以通过不分先后顺序的假设（如“汽车没油”或“电瓶没电”）来生成“汽车不启动”问题的解释，即使有些假设互相矛盾。
chap5_para1599,10,,然后我们查看语句“汽车不启动”的标签来读出可能能够论证该语句的假设集。
chap5_para16,1,Figure 5.,
chap5_para16,2,1(a) The principal states and territories of Australia.,
chap5_para16,3,Coloring this map can be viewed as a constraint satisfaction problem (CSP).,
chap5_para16,4,The goal is to assign colors to each region so that no neighboring regions have the same color.,
chap5_para16,5,(b) The map-coloring problem represented as a constraint graph.,
chap5_para160,1,Figure 5.,给定当前的信念状态，白方可能会问：“我能赢吗？
chap5_para160,2,12(a) The original constraint graph from Figure 5.,”对于部分可观测游戏，策略的概念会发生改变，我们不需要规定如何回应对手的每个可能移动，而是需要规定如何回应玩家可能接收到的每种可能感知序列。
chap5_para160,3,1.,
chap5_para160,4,"(b) After the removal of SA, the constraint graph becomes a forest of two trees.",
chap5_para1600,1,,真值维护系统的确切实现算法有些复杂，我们不在此赘述。
chap5_para1600,2,,真值维护系统的计算复杂度至少与命题推断一样大，也就是NP困难的。
chap5_para1600,3,,因此，你不能将真值维护当作灵丹妙药。
chap5_para1600,4,,但如果恰当使用的话，TMS能够极大增加逻辑系统处理复杂环境和假设的能力。
chap5_para1602,1,,我们希望通过研究如何表示各种知识，我们希望读者已经了解了如何构建真实的知识库，并体会到其中有趣的哲学问题。
chap5_para1602,2,,本章要点如下。
chap5_para1603,1,,● 大规模知识表示需要通用本体论来组织和结合各种特定论域的知识。
chap5_para1604,1,,● 通用本体论需要包含非常多样化的知识，且原则上应当能够处理所有论域。
chap5_para1605,1,,● 构建大型通用本体论是一项尚未被完全了解的重大挑战，尽管现有的框架似乎相当健壮。
chap5_para1606,1,,● 我们呈现了一个基于类别和事件演算的上层本体论。
chap5_para1606,2,,它包括类别、子类别、部分、结构化对象、量度、物质、事件、时间与空间、变化和信念等。
chap5_para1607,1,,● 自然类无法用逻辑来完全定义，但自然类的性质可以被表示。
chap5_para1608,1,,● 动作、事件和时间可以用事件演算来表示。
chap5_para1608,2,,这种表示使智能体能够构建动作序列并推断这些动作产生的结果。
chap5_para1609,1,,● 类似语义网络和描述逻辑的专用表示系统已经被设计用于组织类别层次结构。
chap5_para1609,2,,继承是重要的推断形式，它使得对象的性质可以从其类别从属关系中被推导出来。
chap5_para161,1,"Now, any solution for the CSP after SA and its constraints are removed will be consistent with the value chosen for SA.",对四国军棋来说，必胜策略或确保将死（guaranteed checkmate）是指，对于每种可能感知序列和当前信念状态中的每种可能棋盘状态，不管对手如何移动，该策略都会取胜。
chap5_para161,2,(This works for binary CSPs; the situation is more complicated with higher-order constraints.,在这种定义下，对手的信念状态无关紧要——即使对手能看到所有棋子，这一策略也必须奏效。
chap5_para161,3,") Therefore, we can solve the remaining tree with the algorithm given above and thus solve the whole problem.",这大大简化了计算。
chap5_para161,4,"Of course, in the general case (as opposed to map coloring), the value chosen for SA could be the wrong one, so we would need to try each possible value.",图5-15为KRK（王车对王）残局必胜策略的一部分。
chap5_para161,5,The general algorithm is as follows:,在这种情况下，黑方只有一个棋子（王），所以可以通过在单个棋盘上标记黑王的所有可能位置来表示白方的信念状态。
chap5_para1610,1,,● 逻辑程序中实现的封闭世界假设提供了简便的方法来免于被迫表明大量否定信息。
chap5_para1610,2,,将其翻译为能够被附加信息覆盖的缺省则是最优的。
chap5_para1611,1,,● 如限定和缺省逻辑这样的非单调逻辑旨在总体上刻画缺省推理。
chap5_para1612,1,,● 真值维护系统能高效处理知识更新和修正。
chap5_para1613,1,,● 人工构建大规模本体论很难，从文本中提取知识则能简化这项任务。
chap5_para1617,1,,在本章中，我们将看到智能体如何利用问题的结构来高效地构建复杂的动作计划。
chap5_para1618,1,,规划一系列动作是智能体的关键需求。
chap5_para1618,2,,正确表示的动作和状态以及正确的算法可以使规划变得更容易。
chap5_para1618,3,,在11.1节中，我们为规划问题引入一种通用的因子化表示语言，它可以自然而简洁地表示各种领域，可以高效地扩展到大型问题，并且无须对新领域特定的启发式。
chap5_para1618,4,,我们在11.2节介绍高效规划算法，在11.3节介绍启发式方法。
chap5_para1618,5,,11.4节拓展表示语言使其允许分层次动作，以使我们能够处理更复杂的问题。
chap5_para1618,6,,在11.5节中，我们考虑部分可观测和非确定性域。
chap5_para1618,7,,在11.6节中，我们再次扩展该语言，以解决资源约束下的调度问题。
chap5_para1618,8,,这让我们更接近于真实世界中用于规划和调度航天器、工厂以及军事战役运行的规划器。
chap5_para1618,9,,11.7节分析这些技术的有效性。
chap5_para1619,1,,11.1　经典规划的定义
chap5_para162,1,1.Choose a subset S of the CSP’s variables such that the constraint graph becomes a tree after removal of S. S is called a cycle cutset.,如4.4节中所述，可以将一般的与或搜索算法应用于信念状态空间来寻找必胜策略。
chap5_para162,2,,4.4.2节提到的增量信念状态算法通常能在中盘找到深度高达9的必胜策略——这远远超过了大多数人类棋手的能力。
chap5_para1620,1,,经典规划（classical planning）定义为在一个离散的、确定性的、静态的、完全可观测的环境中，找到完成目标的一系列动作的任务。
chap5_para1620,2,,我们已经见过两种完成这个任务的方法：第3章的问题求解智能体和第7章的混合命题逻辑智能体。
chap5_para1620,3,,它们都受到两个限制。
chap5_para1620,4,,首先，对于每个新领域，它们都需要特定的启发式方法：用于搜索的启发式评价函数和用于混合wumpus智能体的人工代码。
chap5_para1620,5,,其次，它们都需要明确地表示指数量级的状态空间。
chap5_para1620,6,,例如，在wumpus世界的命题逻辑模型中，向前移动一步的公理不得不在所有4个智能体朝向、T个时间步和n2个当前位置重复。
chap5_para1621,1,,针对这些限制，规划研究者使用PDDL语言研究出了因子化表示。
chap5_para1621,2,,"PDDL语言全称是规划领域定义语言（Planning Domain Definition Language）（Ghallab et al., 1998），它利用单个动作模式可以表示4Tn2个动作，且不需要特定的领域知识。"
chap5_para1621,3,,基本的PDDL可以处理经典规划领域，而扩展的PDDL则可以处理连续的、部分可观测的、并发的和多智能体的非经典领域。
chap5_para1621,4,,PDDL的语法基于Lisp，但是我们会将它转换成与本书中使用的表示法相符的形式。
chap5_para1622,1,,在PDDL中，一个状态表示为基本原子流的合取。
chap5_para1622,2,,回想一下，“基本”表示不含变量，“流”表示世界的一个方面随时间而变化，“基本原子”表示它只有一个谓词，而如果它含有参数，则这些参数必然是常量。
chap5_para1622,3,,例如，可能表示一个倒霉的智能体的状态，可能表示包裹投递问题中的一个状态。
chap5_para1622,4,,PDDL使用数据库语义：封闭世界假设意味着没有提到的任何流都是假的，唯一名称假设意味着Truck1和Truck2是不同的。
chap5_para1623,1,,"在状态中不允许使用下列流：At(x, y)（因为它含有变量）、（因为它是否定的），At(Spouse(Ali), Sydney)（因为它使用了一个函数符号Spouse）。"
chap5_para1623,2,,方便的时候，我们可以把流的合取看作流的集合。
chap5_para1624,1,,一个动作模式（action schema）表示一组基本动作。
chap5_para1624,2,,例如，下面是一个使飞机从一个位置飞到另一个位置的动作模式：
chap5_para1625,1,,模式由动作名称、模式中使用的所有变量的列表、前提（precondition）和效果（effect）组成。
chap5_para1625,2,,前提和效果都是文字的合取（肯定或否定的原子句）。
chap5_para1625,3,,我们可以选择常量来实例化变量，产生一个基本（无变量）动作：
chap5_para1626,1,,如果状态s蕴含基本动作a的前提，也就是说，前提中的每一个正文字都在s中，且每一个负文字都不在s中，则动作a适用于状态s。
chap5_para1627,1,,在状态s中执行适用动作a的结果被定义为状态s'，状态s'的形成方式是从s出发，移除动作效果中以负文字形式出现的流，［我们称之为删除列表（delete list）或Del(a)］，并添加在动作效果中以正文字形式出现的流［我们称之为添加列表（add list）或Add(a)］：
chap5_para1629,1,,"例如，采取动作Fly(P1, SFO, JFK)，我们移除流At(P1, SFO)并且添加流At(P1, JFK)。"
chap5_para163,1,2.,除确保将死之外，四国军棋还存在一个在完全可观测游戏中毫无意义的全新概念：概率将死（probabilistic checkmate）。
chap5_para163,2,"For each possible assignment to the variables in S that satisfies all constraints on S,",在信念状态中的每一种棋盘状态下，这种将死都要奏效，而概率一词则来源于获胜玩家移动的随机性。
chap5_para163,3,,要了解它的基本思想，可以考虑只用白王来捉住黑王的问题。
chap5_para163,4,,通过简单地随机移动，白王最终一定会吃掉黑王，这是因为，即使黑王总是设法逃跑，它也不可能永远都猜对正确的逃跑方向。
chap5_para163,5,,在概率论的术语中，这一事件以概率1发生。
chap5_para1630,1,,一组动作模式是规划领域的一个定义。
chap5_para1630,2,,领域中的特定问题是通过添加初始状态和目标来定义的。
chap5_para1630,3,,初始状态是基本流的合取（在图11-1中使用关键字Init引入）。
chap5_para1630,4,,由于对所有状态都使用了封闭世界假设，这意味着任何没有被提及的原子都是假的。
chap5_para1630,5,,目标（使用Goal引入）和前提类似，它是可以含有变量的文字（正文字或负文字）合取式。
chap5_para1630,6,,例如，目标指的是满足货物C1位于SFO而货物C2不位于此地，且SFO有一架飞机的所有状态。
chap5_para1631,1,,11.1.1　范例领域：航空货物运输
chap5_para1632,1,,图11-1展示了一个航空货物运输问题，它涉及货物的装载、卸载和从一个地点飞到另一个地点。
chap5_para1632,2,,这个问题可以用3个动作定义：Load（装载）、Unload（卸载）、和Fly（飞行）。
chap5_para1632,3,,"这些动作影响到两个谓词：In(c, p)表示货物c在飞机p里，At(x, a)表示对象x（飞机或货物）在机场a。"
chap5_para1632,4,,注意，必须仔细确保对At谓词的正确维护。
chap5_para1632,5,,当一架飞机从一个机场飞到另一个机场时，飞机内的所有货物都会跟着它一起飞过去。
chap5_para1632,6,,在一阶逻辑中，很容易对飞机内的所有对象进行量化。
chap5_para1632,7,,但是PDDL没有全称量词，所以我们需要用到其他方法。
chap5_para1632,8,,我们使用的方法是，当一件货物在飞机里（In）时，它就不会在（At）其他地方；货物只有在被卸载后才会在（At）新机场。
chap5_para1632,9,,所以At的真正含义是“在（At）给定地点才可以使用”。
chap5_para1632,10,,下面的规划是这个问题的一个解：
chap5_para1633,1,,图11-1　航空货物运输规划问题的PDDL描述
chap5_para1634,1,,11.1.2　范例领域：备用轮胎问题
chap5_para1635,1,,考虑更换瘪气轮胎的问题（图11-2）。
chap5_para1635,2,,其目标是在车轴上正确安装一只备用轮胎，而初始状态是车轴上有一只瘪气轮胎，后备箱里有一只备用轮胎。
chap5_para1635,3,,为简单起见，我们对这个问题的描述是抽象的，不考虑难拧的螺母之类的复杂问题。
chap5_para1635,4,,问题只有4种动作：从后备箱取出备用轮胎、从车轴上卸下瘪气轮胎、把备用轮胎装在车轴上、把汽车留下整夜无人看管。
chap5_para1635,5,,我们假设汽车停在一个特别糟糕的街区，因此把汽车留下整夜无人看管的效果是轮胎不见了。
chap5_para1635,6,,是问题的一个解。
chap5_para1636,1,,图11-2　简单的备用轮胎问题
chap5_para1637,1,,11.1.3　范例领域：积木世界
chap5_para1638,1,,最著名的规划领域之一是积木世界。
chap5_para1638,2,,这个领域由一组立方体形状的积木组成，积木放在一张任意大的桌子上。
chap5_para1638,3,,[1]积木可以堆叠，但只有一块积木可以直接放在另一个上面。
chap5_para1638,4,,机械臂可以拿起一块积木并将其放到到另一个位置，可以是放在桌子上，也可以放在另一块积木上。
chap5_para1638,5,,机械臂一次只能拿一块积木，因此它无法拿起上面有另一块积木的积木。
chap5_para1638,6,,一个典型的目标是使积木A在积木B上，并且积木B在积木C上（见图11-3）。
chap5_para164,1,"(a)remove from the domains of the remaining variables any values that are inconsistent with the assignment for S, and",在这种意义上，KBNK残局——王、象、马对王——一定会赢，白方为黑方提供一个无限的随机选择序列，黑方总是会猜错其中一个，因此暴露自己的位置，然后被将死。
chap5_para164,2,,另外，KBBK残局的获胜概率是。
chap5_para164,3,,白方要想获胜，只能移动象（此时这个象不受保护）。
chap5_para164,4,,如果黑方碰巧在正确的位置上并吃掉了象（如果象是受保护的，那么这步棋就是非法的），游戏就会变成平局。
chap5_para164,5,,白方可以在一段很长的序列中随机选择一点来走这步险棋，这样会使减小到一个任意小的常数，但无法将减小到零。
chap5_para1640,1,,[1]　规划研究中使用的积木世界通常比Shrdlu的版本（1.2.3节）简单得多。
chap5_para1641,1,,图11-3　图11-4的积木世界问题的示意图
chap5_para1642,1,,"我们用On(b, x)表示积木b在x上，其中x要么是另一块积木，要么是桌子。"
chap5_para1642,2,,"将积木b从x上移动到y上的动作是Move(b, x, y)。"
chap5_para1642,3,,现在，移动b的前提之一是它上面没有其他积木。
chap5_para1642,4,,在一阶逻辑中，这可以表示为或。
chap5_para1642,5,,基本版PDDL中没有量词，因此我们引入一个谓词Clear(x)，当x上没有任何东西时其为真。
chap5_para1642,6,,（完整的问题描述如图11-4所示。
chap5_para1642,7,,）
chap5_para1643,1,,图11-4　积木世界中的一个规划问题：建造一个3块积木构成的塔。
chap5_para1643,2,,一个解是序列
chap5_para1644,1,,如果b和y的上面都没有东西，动作Move可以将积木b从x移动到y。
chap5_para1644,2,,移动后，Clear(b)为真，而Clear(y)为假。
chap5_para1644,3,,第一次写出的Move模式是
chap5_para1645,1,,遗憾的是，当x或y是桌子时，这种模式无法正确维持Clear。
chap5_para1645,2,,当x=Table时，该动作的效果是Clear(Table)，但桌子上并非没有东西；当y=Table时，它的前提变为Clear(Table)，但桌子上有东西并不妨碍我们把积木放在桌子上。
chap5_para1645,3,,我们做如下两件事来解决这个问题。
chap5_para1645,4,,首先，我们引入另一个动作来将积木b从x移动到桌子上：
chap5_para1646,1,,其次，我们将Clear(x)解释为“在x上有一个容纳积木的空间”。
chap5_para1646,2,,在这种解释下，Clear(Table)会始终为真。
chap5_para1646,3,,"唯一的问题是我们无法阻止规划器用Move(b, x, Table)而非MoveToTable(b, x)。"
chap5_para1646,4,,我们可以不管这个问题——这会导致搜索空间的非必要增大，但不会导致错误的答案——或者，我们可以引入谓词Block并在Move的前提中添加Block(b) ∧ Block(y)，如图11-4所示。
chap5_para1647,1,,11.2　经典规划的算法
chap5_para1648,1,,规划问题的描述显然提供了一种从初始状态出发，在状态空间中搜索目标的方法。
chap5_para1648,2,,动作模式的陈述式表示的一个突出的优点是，我们还可以从目标反向搜索，寻找初始状态（图11-5比较了前向搜索和反向搜索）。
chap5_para1648,3,,此外，还有一种可能性是将问题描述转化为一组逻辑语句，我们可以应用逻辑推断算法寻找解。
chap5_para1649,1,,图11-5　搜索规划的两种方法。
chap5_para1649,2,,（a）在基本状态空间中前向（递进）搜索，从初始状态开始，利用问题的动作向前搜索目标状态集合中的一个成员。
chap5_para1649,3,,（b）通过状态描述进行反向（回归）搜索，从目标开始，用逆动作反向搜索初始状态
chap5_para165,1,"(b)if the remaining CSP has a solution, return it together with the assignment for S.",有时将死策略只对当前信念状态中的某些棋盘状态有效，而对其他状态无效。
chap5_para165,2,,尝试这种策略可能会成功，导致意外将死（accidental checkmate）。
chap5_para165,3,,这里的意外是指，如果黑方刚好在特定的位置，白方不会知道自己将会将死对方。
chap5_para165,4,,（在人类博弈中，大多数将死都是偶然的。
chap5_para165,5,,）这个想法自然引出了一个问题，给定策略有多大可能获胜，这又引出了一个问题，当前信念状态中的每种棋盘状态有多大可能是真正的棋盘状态。
chap5_para1650,1,,11.2.1　规划的前向状态空间搜索
chap5_para1651,1,,我们可以使用第3章或第4章中的任意启发式搜索算法来求解规划问题。
chap5_para1651,2,,搜索状态空间中的状态是基本状态，其中每个流要么为真要么为假。
chap5_para1651,3,,目标是一个状态，它含有该问题的目标中的所有正流而不含负流。
chap5_para1651,4,,一个状态中的适用动作Action(s)是动作模式的基本实例，也就是所有变量都被常量代替的动作。
chap5_para1652,1,,为了确定适用的动作，我们将当前状态与当每个动作模式的前提合一。
chap5_para1652,2,,对于每个成功产生置换的合一，我们将该置换应用于动作模式来产生不含变量的基本动作。
chap5_para1652,3,,（动作模式的要求是，效果中的所有变量必须也出现在前提中，这样，我们可以保证在置换后没有遗漏任何变量。
chap5_para1652,4,,）
chap5_para1653,1,,每个模式可能有多种合一方式。
chap5_para1653,2,,"在备用轮胎范例（11.1.2节）中，Remove动作有一个前提At(obj, loc)，它匹配初始状态的方式有两种，进而产生两个置换和；应用这些置换会产生两个基本状态。"
chap5_para1653,3,,如果一个动作的前提中有多个文字，那么每个文字都可能以多种方式与当前状态进行匹配。
chap5_para1654,1,,乍看起来，对许多问题来说，状态空间似乎都太大了。
chap5_para1654,2,,考虑一个有10个机场的航空货物运输问题，其中每个机场有5架飞机和20件货物。
chap5_para1654,3,,目标是将所有在A机场的货物运送到B机场。
chap5_para1654,4,,这个问题的一个解有41步：将20件货物装入A机场的一架飞机上，飞到B机场，然后卸载这20件货物。
chap5_para1655,1,,找到这种显然且直接的解可能很困难，因为平均分支因子非常大：50架飞机中的每一架都可以飞到9个其他机场，200件包裹中每一件都可以被卸载（如果已被装载）或装载（如果它已被卸载）到机场的任意飞机上。
chap5_para1655,2,,所以在任何状态中，都至少有450种动作（当所有包裹所在的机场都没有飞机时），最多则有10 450种动作（当所有包裹和飞机都在同一个机场时）。
chap5_para1655,3,,平均而言，假设每个状态大约有2000种可能的动作，深度最多为41步的搜索图就会有大约200041个节点。
chap5_para1656,1,,显然，如果没有精确的启发式方法，即使是求解这种规模很小的问题案例都令人非常绝望。
chap5_para1656,2,,尽管规划的许多真实世界的应用都依赖于领域特定的启发式，但实际上（正如我们将在11.3节中看到的），强大的领域无关的启发式方法可以由自动推导得来，使得前向搜索成为一种可行的方法。
chap5_para1657,1,,11.2.2　规划的反向状态空间搜索
chap5_para1658,1,,在反向搜索［也称为回归搜索（regression search）］中，我们从目标开始反向应用动作，直到找出到达初始状态的步骤序列。
chap5_para1658,2,,在每一步中，我们考虑相关动作（relevant action）（与前向搜索不同，前向搜索考虑的是适用动作）。
chap5_para1658,3,,这极大地减少了分支因子，特别是在有许多可能动作的领域。
chap5_para1659,1,,相关动作是其效果能够与目标中的一个文字合一的动作，但这个效果不否定目标的任何部分的行动。
chap5_para1659,2,,例如，对目标，效果仅为Famous的动作是相关动作，而效果为的动作则不相关：尽管这个动作可能在规划过程中的某处用到（来构建Famous），它却不能在规划的这个地方出现，因为这样会使Poor出现在最终状态中。
chap5_para166,1,"If the cycle cutset has size c, then the total run time is O(dc · (n – c)d2): we have to try each of the dc combinations of values for the variables in S, and for each combination we must solve a tree problem of size n – c. If the graph is “nearly a tree,” then c will be small and the savings over straight backtracking will be huge—for our 100-Boolean-variable example, if we could find a cutset of size c = 20, this would get us down from the lifetime of the Universe to a few minutes. In the worst case, however, c can be as large as (n – 2). Finding the smallest cycle cutset is NP-hard, but several efficient approximation algorithms are known. The overall algorithmic approach is called cutset conditioning; it comes up again in Chapter 13, where it is used for reasoning about probabilities.",图5-15　KRK残局必胜策略的一部分，图中为缩减后的棋盘。
chap5_para166,2,,在初始信念状态中，黑王位于3种可能位置之一。
chap5_para166,3,,通过一系列探索移动，该策略将黑王的范围缩小到其中一种。
chap5_para166,4,,将死策略的剩余部分留作习题
chap5_para1660,1,,在反方向应用一个动作是什么意思？
chap5_para1660,2,,给定一个目标g和一个动作a，从g通过a的回归（regression）会给出一个状态描述g'，其正负文字由下式给出：
chap5_para1661,1,,也就是说，前提在之前必须成立，否则动作就无法被执行，但由该动作添加或删除的正负文字在之前不必为真。
chap5_para1662,1,,这些等式对基本文字来说很简单直接，但当在g和a中存在变量时，就需要小心了。
chap5_para1662,2,,例如，假设目标是向SFO投递一件特定的货物：。
chap5_para1662,3,,"Unload动作模式的效果是At(c, a)。"
chap5_para1662,4,,当我们把它与目标进行合一，得到置换；将这个置换应用到模式中，我们就得到了一个新的模式，它刻画了使用位于SFO的任意一架飞机的概念：
chap5_para1663,1,,这里我们用一个名为p'的新变量来取代p。
chap5_para1663,2,,这是变量名的标准化分离的实例，以防不同变量因具有相同名称而发生冲突（见9.2.1节）。
chap5_para1663,3,,回归后的状态描述给出了一个新目标：
chap5_para1664,1,,再举一个例子，考虑目标为拥有一本特定ISBN号的书：Own(9780134610993)。
chap5_para1664,2,,给定1万亿个13位数字的ISBN号和单个动作模式A：
chap5_para1665,1,,不含启发式的前向搜索将不得不开始枚举那1万亿[2]个基本的Buy动作。
chap5_para1665,2,,但如果采用反向搜索，我们可以将目标Own(9780134610993)与效果Own(i')合一，产生置换。
chap5_para1665,3,,然后，我们在动作上回归，产生前驱状态描述ISBN(9780134610993)。
chap5_para1665,4,,这是初始状态的一部分，因而我们得到一个解并完成了任务，其中只考虑了一个动作而不是1万亿个动作。
chap5_para1667,1,,[2]　此处原书为“10 billion”（100亿），但根据上下文，此处应为1万亿。
chap5_para1667,2,,——译者注
chap5_para1668,1,,更形式化地说，假设一个目标描述g包含一个目标文字gi和一个动作模式A。
chap5_para1668,2,,如果A有一个效果文字，其中，并且我们定义，如果A'的效果不含对g中文字的否定，则A'是对g的一个相关动作。
chap5_para1669,1,,对大多数问题域而言，反向搜索的分支因子小于前向搜索。
chap5_para1669,2,,但由于反向搜索使用了含有变量的状态而非基本状态，因此难以找到好的启发式方法。
chap5_para1669,3,,这是目前大多数系统倾向于使用前向搜索的主要原因。
chap5_para167,1,5.,人们的第一倾向可能认为当前信念状态中的所有棋盘状态都是等可能的——但这是错误的。
chap5_para167,2,5.,例如，考虑黑方走第一步棋后白方的信念状态。
chap5_para167,3,2Tree decomposition,根据定义（假设黑方遵循最优策略），黑方一定采取了最优移动，所以由次优移动产生的所有棋盘状态的概率应该为零。
chap5_para1670,1,,11.2.3　使用布尔可满足性规划
chap5_para1671,1,,在7.7.4节中，我们展示了一些巧妙的公理重写如何将wumpus世界问题转换为可以由高效可满足性求解器求解的命题逻辑可满足性问题。
chap5_para1671,2,,基于SAT的规划器SATPlan通过将PDDL问题描述翻译为命题形式来工作。
chap5_para1671,3,,这种翻译含有下面一系列步骤。
chap5_para1672,1,,● 将动作命题化：对于每个动作模式，用常量置换每个变量形成基本命题。
chap5_para1672,2,,"因此我们不能仅用模式Unload(c, p, a)，而是必须将动作命题分为每个货物、飞机和机场的组合（此处用下标表示），以及每个时间步（此处用上标表示）。"
chap5_para1673,1,,● 添加动作排除公理来表明两个动作不能同时发生，例如。
chap5_para1674,1,,● 添加前提公理：对于每个基本动作At，添加公理，也就是说，如果在时刻t采取动作，那么前提必须已经为真，例如。
chap5_para1675,1,,● 定义初始状态：在问题初始状态中对每个流F断言F0，并对每个初始状态中未提及的流断言。
chap5_para1676,1,,● 将目标命题化：目标变为它的所有基本实例的析取式，其中变量被常量替代。
chap5_para1676,2,,例如，目标是在一个具有对象A、B和C的世界中，使积木A位于另一块积木之上，也就是，它将被以下目标替换：
chap5_para1677,1,,● 添加后继状态公理：对于每个流F，添加一个形式如下的公理：
chap5_para1678,1,,其中ActionCausesF代表所有添加F的基本动作的析取式，而ActionCausesNotF代表所有删除F的基本动作的析取式。
chap5_para1679,1,,翻译的结果通常比原始的PDDL大得多，但现代SAT求解器的效率通常足以弥补这一点。
chap5_para168,1,"The second way to reduce a constraint graph to a tree is based on constructing a tree decomposition of the constraint graph: a transformation of the original graph into a tree where each node in the tree consists of a set of variables, as in Figure 5.",这一论点也不完全正确，因为每个玩家的目标不仅仅是将棋子移动到正确的方格中，还需要最小化对手能掌握的关于自己位置的信息。
chap5_para168,2,13.,遵循任何可预测的“最优”策略都能为对手提供信息。
chap5_para168,3,A tree decomposition must satisfy these three requirements:,因此，在部分可观测博弈中，最佳玩法需要一定随机性。
chap5_para168,4,,（这也是餐厅卫生检查员进行随机检查的原因。
chap5_para168,5,,）这意味着他们偶尔要选择一些“本质上”较差的移动——但他们能从不可预测性上获益，因为对手不大可能为防御这些移动做好准备。
chap5_para1680,1,,11.2.4　其他经典规划方法
chap5_para1681,1,,在自动规划50年的历史上，并非只存在上述3种方法。
chap5_para1681,2,,我们在这里简要介绍一些其他方法。
chap5_para1682,1,,一种称为Graphplan的方法使用一种专门的数据结构——规划图（planning graph）来编码约束以规定动作与其前提和效果的关系以及哪些事物互相排斥。
chap5_para1683,1,,情景演算（situation calculus）是一种用一阶逻辑描述规划问题的方法。
chap5_para1683,2,,这种方法像SATPlan一样使用后继状态公理，但一阶逻辑允许更灵活简洁的公理形式。
chap5_para1683,3,,总的来说，该方法有助于我们对规划的理论理解，却没有在实际应用中产生重大影响，可能是因为一阶证明器不如命题可满足性程序发展得好。
chap5_para1684,1,,我们可以将有界规划问题（也就是寻找长度为k的规划）编码为约束满足问题（constraint satisfaction problem，CSP）。
chap5_para1684,2,,这种编码方式类似于编码为SAT问题（11.2.3节），但它有一个重要的简化：在每个时间步，我们只需要一个变量Actiont，它的定义域是可能的动作集。
chap5_para1684,3,,我们不再需要为每个动作分配变量，也不需要动作排除公理。
chap5_para1685,1,,到目前为止，我们看到的所有方法都构建了由严格的线性动作序列组成的全序规划。
chap5_para1685,2,,但如果一个航空货物运输问题有30个包裹被装载到一架飞机上，50个包裹被装载到另一架飞机上，那么对这80个装载动作制定一个特定的线性顺序似乎毫无意义。
chap5_para1686,1,,还有一种称为偏序规划（partial-order planning）的方法用图而不是用线性序列来表示规划：每个动作是图中的一个节点，每个动作的前提都有一条来自另一个动作的边（或来自初始状态），表明形成这一前提的前驱动作。
chap5_para1686,2,,"因此，我们可以用偏序规划表示动作Remove(Spare, Trunk)和Remove(Flat, Axle)必须在PutOn(Spare, Axle)之前进行，而无须说明应该先执行这两个Remove动作中的哪一个。"
chap5_para1686,3,,我们在规划空间而非世界状态空间中搜索，通过插入动作来满足条件。
chap5_para1687,1,,在20世纪80和90年代，偏序规划被认为是处理具有独立子问题的规划问题的最佳方法。
chap5_para1687,2,,到2000年，前向搜索规划器发展出了优秀的启发式方法，这使得它们能够有效地发现偏序规划所擅长处理的独立子问题。
chap5_para1687,3,,此外，SATPlan能够利用摩尔定律：在1980年还大得吓人的命题化问题现在看起来微不足道，因为现在计算机的内存增加了1万倍。
chap5_para1687,4,,因此，在完全自动化的经典规划问题上，偏序规划没什么竞争力。
chap5_para1688,1,,尽管如此，偏序规划仍然是该领域的重要组成部分。
chap5_para1688,2,,对于某些特定的任务，如作业调度，采用领域特定的启发式方法的偏序规划依然是可以选用的技术。
chap5_para1688,3,,许多这种系统使用高层规划库，如11.4节所述。
chap5_para1689,1,,偏序规划也常用于那些需要人类理解其规划的领域。
chap5_para1689,2,,例如，用于航天器和火星车的作业规划通过偏序规划器生成，在将规划上传到这些装备并执行前会经过人类操作员的检查。
chap5_para1689,3,,规划精细化方法使得人类易于理解规划算法做了什么事情，并在规划被执行前验证其正确性。
chap5_para169,1,Figure 5.,从这些考虑来看，似乎只有在给定最优随机策略的情况下，才能计算出当前信念状态中各种棋盘状态的概率；反过来，计算这一策略似乎需要知道棋盘可能处于的各种状态的概率。
chap5_para169,2,13A tree decomposition of the constraint graph in Figure 5.,这个难题可以利用博弈论中均衡解的概念解决，我们将在第17章中进一步探讨。
chap5_para169,3,12(a).,均衡为每个玩家指定了一个最优随机策略。
chap5_para169,4,,对四国军棋来说，计算均衡的代价太昂贵了。
chap5_para169,5,,目前，一般四国军棋游戏的有效算法设计是一个开放的研究课题。
chap5_para169,6,,大多数系统在自己的信念状态空间中执行有限深度的前瞻搜索，而不考虑对手的信念状态。
chap5_para169,7,,评价函数与完全可观测博弈的评价函数类似，但包含一个新的组成部分，信念状态大小——越小越好！
chap5_para169,8,,我们将在18.2节的博弈论主题下重新讨论部分可观测博弈。
chap5_para1690,1,,11.3　规划的启发式方法
chap5_para1691,1,,如果没有好的启发式函数，前向搜索和反向搜索都是低效的。
chap5_para1691,2,,回想在第3章中，一个启发式函数h(s)估计了从状态s到目标的距离，如果我们能推导出这个距离的可容许的启发式方法，也就是不会高估的方法，那么我们就可以使用A*搜索来找到最优解。
chap5_para1692,1,,根据定义，能够分析原子状态的方法是不存在的。
chap5_para1692,2,,因此，为含有原子状态的搜索问题定义良好的领域特定启发式方法需要分析师（通常是人）的聪明才智。
chap5_para1692,3,,但是规划使用状态和动作的因子化表示，就使得找出良好的、领域无关的启发式方法成为可能。
chap5_para1693,1,,回想一下，可以通过定义一个更容易求解的松弛问题推导出一个可容许的启发式方法。
chap5_para1693,2,,求解这个简单问题的确切代价就变为寻找原问题的启发式。
chap5_para1693,3,,搜索问题是一个节点为状态、边为动作的图。
chap5_para1693,4,,问题是找到一条连接初始状态和目标状态的路径。
chap5_para1693,5,,我们有两种主要的方法来松弛这个问题，使它变得更容易：通过在图中添加更多的边，使找到一条路径更容易，或者通过将多个节点分为一组，形成一个具有更少状态的状态空间的抽象，因而更容易搜索。
chap5_para1694,1,,我们首先看看向图中添加边的启发式方法。
chap5_para1694,2,,最简单的方法大概是忽略前提启发式方法（ignore-preconditions heuristic），它从动作中去掉所有的前提。
chap5_para1694,3,,每一个动作都适用于所有状态，任何单个目标流都可以在一步之内完成（如果存在适用动作的话。
chap5_para1694,4,,如果没有适用动作，这个问题就是无解的）。
chap5_para1694,5,,这几乎意味着，求解松弛问题所需的步骤数量等于未满足的目标数量——几乎但不完全等于，因为（1）一些动作可能实现多个目标，（2）一些动作可能抵消了其他动作的效果。
chap5_para1695,1,,对于许多问题，精确的启发式是通过考虑（1）且忽略（2）得到的。
chap5_para1695,2,,首先，我们通过移除所有前提和效果（含有目标中的文字的效果除外）来松弛动作。
chap5_para1695,3,,然后我们计算为了满足目标所要求的效果而需要合一的动作的最小数量。
chap5_para1695,4,,这是一个集合覆盖问题（set-cover problem）。
chap5_para1695,5,,有一个小麻烦：集合覆盖问题是NP困难的。
chap5_para1695,6,,幸运的是，有一种简单的贪心算法能够确保返回一个集合的覆盖，其大小不超过实际最小覆盖的logn倍，其中n是目标中的文字的数量。
chap5_para1695,7,,遗憾的是，这种贪心算法无法保证可容许性。
chap5_para1696,1,,只忽略被选定的动作的前提也是可以的。
chap5_para1696,2,,考虑3.2节中的滑块问题(8数码问题或15数码问题）。
chap5_para1696,3,,我们可以将其编码为一个规划问题，其滑块只有Slide一个模式：
chap5_para1697,1,,正如我们在3.6节中所看到的，如果我们移除前提，那么在一次动作中，所有滑块都可以移动到任意位置，我们就得到了错放的滑块数量的启发式。
chap5_para1697,2,,如果只移除前提Blank(s2)，我们就得到了曼哈顿距离启发式。
chap5_para1697,3,,很容易看出这些启发式是如何从动作模式的描述中自动推导出来的。
chap5_para1697,4,,与搜索问题的原子表示相比，规划问题的因子化表示的最大优点是易于操作动作模式。
chap5_para1698,1,,另一种可能性是忽略删除列表启发式方法（ignore-delete-lists heuristic）。
chap5_para1698,2,,暂且假设所有目标和前提只包含正文字。
chap5_para1698,3,,[3]我们想要创建一个原问题的更容易求解的松弛版本，并且将其解的长度用作很好的启发式函数。
chap5_para1698,4,,我们可以通过从所有动作中移除删除列表（例如，从效果中移除所有负文字）来实现。
chap5_para1698,5,,这使得向着目标单调前进成为可能——任何动作都不会抵消另一个动作所取得的进展。
chap5_para1698,6,,虽然找到松弛问题的最优解仍然是NP困难的，但可以通过爬山搜索算法在多项式时间内找到近似解。
chap5_para17,1,"The domain of every variable is the set Di = {red, green, blue}.",[3]　一些作者对此进行了区分，用“不完美信息博弈”指扑克之类的游戏，其中玩家将获得其他玩家没有的关于自己手牌的私人信息，而用“部分可观测博弈”指《星际争霸II》之类的游戏，其中每个玩家可以看到其附近的环境，但看不到远处的环境。
chap5_para17,2,The constraints require neighboring regions to have distinct colors.,
chap5_para17,3,"Since there are nine places where regions border, there are nine constraints:",
chap5_para170,1,•Every variable in the original problem appears in at least one of the tree nodes.,5.6.2　纸牌游戏
chap5_para1700,1,,[3]　许多问题都采用这种惯例记法。
chap5_para1700,2,,对于没有使用这种记法的问题，将所有目标或前提中的负文字用新的正文字P'替换，并相应地修改初始状态和动作效果即可。
chap5_para1701,1,,图11-6画出了使用忽略删除列表启发式方法的两个规划问题的部分状态空间，其中点代表状态，边代表动作，每个点离底面的高度代表启发式函数的值。
chap5_para1701,2,,在底部平面上的状态就是解。
chap5_para1701,3,,两个问题都有通往目标的宽阔路径。
chap5_para1701,4,,因为没有死路，也就没有回溯的必要，简单的爬山搜索就可以轻松求解这些问题（尽管它可能不是最优解）。
chap5_para1702,1,,图11-6　使用忽略删除列表启发式方法的规划问题的两个状态空间。
chap5_para1702,2,,底部平面以上的高度是一个状态的启发式得分；底部平面的状态是目标。
chap5_para1702,3,,由于不存在局部极小值，所以搜索目标很简单直接。
chap5_para1702,4,,"图片来自（Hoffmann, 2005）"
chap5_para1703,1,,11.3.1　领域无关剪枝
chap5_para1704,1,,因子化表示中很容易就能看出许多状态只是其他状态的变体。
chap5_para1704,2,,例如，假设桌子上有12块积木，我们的目标是让积木A位于3块积木的积木塔的顶部。
chap5_para1704,3,,一个解的第一步就是将某块积木x放到积木y的上面（其中x、y和A都是不同的）。
chap5_para1704,4,,然后，我们把A放在x上面就可以了。
chap5_para1704,5,,x有11种选择，而给定x的话，y有10种选择，因此有110种状态需要考虑。
chap5_para1704,6,,但所有这些状态都是对称的：选择这一个而非那一个并没有什么区别，因此规划器应当只考虑其中一种。
chap5_para1704,7,,这就是对称约简（symmetry reduction）的原理：我们修剪掉搜索树中的所有对称分支而不予考虑，只保留其中一个。
chap5_para1704,8,,对许多领域来说，这会使问题从难以求解变为高效求解。
chap5_para1705,1,,另一种做法是进行前向剪枝，为了将搜索集中于有希望的分支，我们需要承担可能会剪掉最优解的风险。
chap5_para1705,2,,可以定义一个如下的优先动作（preferred action）：首先，定义问题的一个松弛版本，然后求解它，得到一个松弛规划。
chap5_para1705,3,,如此，优先动作要么是松弛规划中的一步，要么能够满足松弛规划的某个前提。
chap5_para1706,1,,有时通过找出可以被剔除的负相互作用也可以高效求解问题。
chap5_para1706,2,,如果问题中存在子目标的某种顺序，使得规划器按照这个顺序完成子目标时不会撤销已完成的子目标，则这个问题具有可序列化子目标（serializable subgoal）。
chap5_para1706,3,,例如，在积木世界里，如果我们的目标是建造一座塔（例如，积木A在B上，B在C上，C在桌子上，如图11-3所示），则子目标是自底向上可序列化的：如果我们先让积木C在桌子上，则当完成其他的子目标时我们就不需要撤销它。
chap5_para1706,4,,一个使用自底向上技术的规划器可以无须回溯地求解积木世界中的任何问题（尽管它并不总能找到最短的规划）。
chap5_para1706,5,,再举个例子，如果一个房间有n个电灯开关，每个开关控制一盏灯，而我们的目标是让这些灯都亮着，那么就不需要考虑开灯的顺序，可以任意指定规划的开灯顺序，如使用升序。
chap5_para1707,1,,对控制美国国家航空航天局“深空一号”航天器的“远程智能体”规划器来说，控制航天器所涉及的命题被设定为是可序列化的。
chap5_para1707,2,,这也许并不是很奇怪，因为航天器是被工程师设计为尽量容易操纵的（同时也受到其他因素限制）。
chap5_para1707,3,,利用目标的序列化顺序，“远程智能体”规划器能够消除大部分搜索。
chap5_para1707,4,,这意味着它的速度快到足以实时控制航天器，这在以前被认为是不可能做到的。
chap5_para1708,1,,11.3.2　规划中的状态抽象
chap5_para1709,1,,松弛化问题给出一个仅用于计算启发式函数的值的简化规划问题。
chap5_para1709,2,,许多规划问题有10100个或更多的状态，松弛这些动作并不能减少状态的数量，这意味着计算启发式的代价仍然很高。
chap5_para1709,3,,因此，我们现在来看通过构造状态抽象（state abstraction）以减少状态数量的松弛化方法——从问题的基本表示到抽象表示的多对一映射。
chap5_para171,1,"•If two variables are connected by a constraint in the original problem, they must appear together (along with the constraint) in at least one of the tree nodes.",桥牌、惠斯特牌、红心大战和扑克等纸牌游戏都具有随机的部分可观测性，即无法观测的信息是由随机发牌产生的。
chap5_para1710,1,,状态抽象最简单的形式是忽略一些流。
chap5_para1710,2,,例如，考虑一个有10个机场、50架飞机和200件货物的航空货物运输问题。
chap5_para1710,3,,每架飞机可以位于10个机场中的一个，每件包裹可以在其中一架飞机上，或已卸载到其中一个机场。
chap5_para1710,4,,所以有个状态。
chap5_para1710,5,,现在考虑该领域中的一个特定问题，在这个问题中，所有的包裹刚好只在5个机场中，且在给定机场中的所有包裹的目的地都相同。
chap5_para1710,6,,这样，对这个问题的一个有用的抽象是去掉所有At流，除了那些涉及在这5个机场中的包裹和飞机的流。
chap5_para1710,7,,现在只有个状态。
chap5_para1710,8,,在这个抽象状态空间中的解要比原始空间中的解短（因此它是一个可容许的启发式），而且抽象解可以轻易扩展为原问题的解（通过添加额外的Load和Unload动作）。
chap5_para1711,1,,定义启发式的一个关键思想是分解（decomposition）：将问题分解为多个部分，独立求解各个部分，然后将这些部分组合起来。
chap5_para1711,2,,子目标独立（subgoal independence）假设是，求解一系列子目标的代价近似于独立求解每个子目标的成本之和。
chap5_para1711,3,,子目标独立性假设可以是乐观的，也可以是悲观的。
chap5_para1711,4,,当每个子目标的子规划之间存在负相互作用时，它就是乐观的——例如，当一个子规划中的动作删除了了另一个子规划完成的目标时。
chap5_para1711,5,,当子规划包含冗余的动作时，它是悲观的、不可容许的，例如，两个动作在合一后的规划中被替换为一个动作。
chap5_para1712,1,,"假设目标是一组流的集合G，我们将其分成不相交的子集G1, …, Gn。"
chap5_para1712,2,,"随后找到各个子目标的最优解P1, …, Pn。"
chap5_para1712,3,,实现整个G的规划的代价大概是多少？
chap5_para1712,4,,我们可以把每个Cost(Pi)想作一个启发式估计，而且如果我们通过取它们当中的最大值的来进行总体估计，我们就能得到一个可容许的启发式。
chap5_para1712,5,,因此，maxiCost(Pi)是可容许的，而且有时它是完全准确的，例如当P1偶然地实现了所有Gi。
chap5_para1712,6,,但通常这个估计是过低的。
chap5_para1712,7,,我们可以把代价加起来吗？
chap5_para1712,8,,对许多问题来说这是一个合理的估计，但它是不可容许的。
chap5_para1712,9,,最好的情况是Gi和Gj是独立的，也就是对其中一个目标的规划不能减少另一个规划的代价。
chap5_para1712,10,,这种情况下，估计Cost(Pi) + Cost(Pj)是可容许的，并且比最大估计更准确。
chap5_para1713,1,,很明显，通过抽象来减少搜索空间有很大的潜力。
chap5_para1713,2,,诀窍在于选择适当的抽象，并使其总代价——定义抽象、进行抽象搜索、将抽象映射回原问题——小于求解原问题的代价。
chap5_para1713,3,,在3.6.3节中的模式数据库技术可以派上用场，因为创建模式数据库的代价可以分摊到多种问题案例上。
chap5_para1714,1,,"利用了高效启发式的系统有FF，或称FastForward（Hoffmann, 2005），这是一个使用了忽略删除列表启发式方法的前向状态空间搜索器，它使用规划图估计启发式。"
chap5_para1714,2,,FF随后使用该启发式进行爬山搜索（修改版，以便于记录规划）来寻找解。
chap5_para1714,3,,FF的爬山算法是非标准的：它通过在当前状态运行广度优先搜索来避免局部极大值，直到找到更好的状态。
chap5_para1714,4,,如果没有找到结果，FF就会切换到贪心最佳优先搜索。
chap5_para1716,1,,前几章的问题求解和规划方法都只使用固定的原子动作集。
chap5_para1716,2,,动作可以连在一起，而最新的算法可以生成包含数千个动作的解。
chap5_para1716,3,,如果我们正在规划假期，而动作仅仅是在“从旧金山飞到火奴鲁鲁”的层次，这样做没什么问题；但在“左膝弯曲5度”的电动机控制层次，我们需要连接几百万到几十亿个动作，而不止是几千个。
chap5_para1717,1,,弥合这一差距需要在更高的抽象层次上进行规划。
chap5_para1717,2,,一个高层级的夏威夷度假规划可能是“前往旧金山机场；乘坐飞往火奴鲁鲁的HA 11号航班；游玩两个星期；乘坐HA 12飞机回旧金山；回家”。
chap5_para1717,3,,给定这样的规划，“前往旧金山机场”这一动作本身就可以被视为一项规划任务，它的解包括“选择送机服务；预订一辆车；乘车前往机场”。
chap5_para1717,4,,每个动作都可以被进一步分解，直到我们达到低层级的电动机控制动作，就像钉扣机一样。
chap5_para1718,1,,在这个例子中，规划和行动是交替的。
chap5_para1718,2,,例如，我们可以把从路边到大门的步行规划问题推迟到下车之后再说。
chap5_para1718,3,,因此，在执行阶段之前，该动作仍然处于抽象层级。
chap5_para1718,4,,我们在11.5节再讨论这个话题。
chap5_para1718,5,,此处，我们专注于层次分解（hierarchical decomposition）的概念，几乎在控制复杂性的所有尝试中都可以见到这种概念。
chap5_para1718,6,,例如，复杂软件是基于子程序和类的层次性而创建的，军队、政府和企业都有层次化的组织结构。
chap5_para1718,7,,分层结构的主要益处是，分层的每一层级都将一个计算任务、军事行动或行政职能减少为下一层次的少量活动，因此找出为当前问题安排这些活动的正确方法的计算代价很小。
chap5_para1719,1,,11.4.1　高层动作
chap5_para172,1,"•If a variable appears in two nodes in the tree, it must appear in every node along the path connecting those nodes.",乍一看，这些纸牌游戏似乎很像掷骰子：纸牌是随机分配的，并且决定了每个玩家的可能移动，但所有的“掷骰子”都发生在游戏的开始！
chap5_para172,2,,尽管将纸牌游戏类比为掷骰子是错误的，但它提出了一种算法：将游戏的开始视为一个机会节点，每一种可能的发牌视为一个结果，然后使用Expectiminimax公式选择最佳移动。
chap5_para172,3,,注意，在这种方法中，唯一的机会节点是根节点；在那之后，游戏则是完全可观测的。
chap5_para172,4,,这种方法有时被称为观测力平均，因为它假设，一旦发牌实际发生，游戏对双方都是完全可观测的。
chap5_para172,5,,尽管这种策略在直观上具有吸引力，但有可能让人误入歧途。
chap5_para172,6,,考虑下面这个故事。
chap5_para1720,1,,用于理解层次分解的基本形式体系来自分层任务网络（hierarchical task network，HTN）领域规划。
chap5_para1720,2,,目前，我们假设完全可观测性和确定性，以及一组动作，称为基元动作（primitive action），它具有标准的前提-效果模式。
chap5_para1720,3,,另外一个重要的概念是高层动作（high-level action）或称HLA——例如，“前往旧金山机场”动作。
chap5_para1720,4,,每个HLA都有一个或多个可能的细化（refinement）来形成一个动作序列，其中的每个动作可能是一个HLA或一个基元动作。
chap5_para1720,5,,"例如，动作“前往旧金山机场”，其形式化表示为Go(Home, SFO)，它可以有两个可能的细化，如图11-7所示。"
chap5_para1720,6,,图11-7还展示了在真空吸尘器世界中导航的递归细化：要到达目的地，我们先走一步，然后再前往目的地。
chap5_para1721,1,,图11-7　两个高层动作——前往旧金山机场和在真空吸尘器世界中导航——的可能细化的定义。
chap5_para1721,2,,注意真空吸尘器世界中细化的递归特性和对前提的使用
chap5_para1722,1,,这些例子表明，高层动作及其细化体现了关于如何做事的知识。
chap5_para1722,2,,"例如，Go(Home, SFO)的细化表明你可以开车或叫车去机场；买牛奶、坐下来、将马移动到e4方格等动作是无须考虑的。"
chap5_para1723,1,,只包含基元动作的HLA细化称为这个HLA的一个实现（implementation）。
chap5_para1723,2,,"在网格世界中，序列[Right, Right, Down]和[Down, Right, Right]都实现了HLA Navigate([1, 3], [3, 2])。"
chap5_para1723,3,,一个高层规划（HLA序列）的实现就是连接序列中每个HLA的实现。
chap5_para1723,4,,给定每个基元动作的前提-效果的定义，很容易确定高层规划的任意给定实现是否达成了目标。
chap5_para1724,1,,因此，我们可以说，如果一个高层规划至少有一个实现从给定状态达成了目标，则该高层规划从该给定状态达成了目标。
chap5_para1724,2,,这个定义中，“至少有一个”是至关重要的，并非所有实现都需要达成目标，因为智能体会想办法决定它要执行哪个实现。
chap5_para1724,3,,因此，HTN规划中的可能实现的集合——其中各个实现的结果可能不同——与非确定性规划中可能结果的集合不同。
chap5_para1724,4,,在非确定性规划中，我们需要一个对所有结果都有效的规划，因为智能体不能选择结果，产生何种结果是自然因素导致的。
chap5_para1725,1,,最简单的情况是只有一个实现的HLA。
chap5_para1725,2,,在这种情况下，我们可以从实现的前提和效果中计算HLA的前提和效果（见习题11.HLAU），然后将HLA本身完全视为一个基元动作。
chap5_para1725,3,,可以证明，一组正确的HLA可以将盲目搜索的时间复杂性从解深度的指数量级降到解深度的线性量级，虽然设计出这样的一组HLA并非易事。
chap5_para1725,4,,当HLA有多个可能的实现时，有两种选择：一种是在所有实现中搜索出一个有效的实现，如11.4.2节所述；另一种是直接对HLA进行推理——不管存在多少种实现，如11.4.3节所述。
chap5_para1725,5,,后一种方法可以导出可证明为正确的抽象规划，而无须考虑它们的实现。
chap5_para1726,1,,11.4.2　搜索基元解
chap5_para1727,1,,HTN规划通常是由一个称为Act的“顶层”动作制定的，其目标是找到能达成目标的Act的实现。
chap5_para1727,2,,这种方法是完全通用的。
chap5_para1727,3,,"例如，经典的规划问题可以定义为：对于每个基元动作ai，给出一个带有步骤[ai, Act]的Act的细化。"
chap5_para1727,4,,这就创建了一个让我们添加动作的Act的递归定义。
chap5_para1727,5,,但我们需要某种方法来停止递归。
chap5_para1727,6,,为此，我们为Act提供了另一条细化，其中包含一个空步骤列表，并且前提等于问题的目标。
chap5_para1727,7,,这就是说，如果目标已经实现了，那么正确的实现就是什么也不做。
chap5_para1728,1,,该方法引出了一个简单的算法：在当前规划中反复选择一个HLA，并将其替换为它的一个细化，直到规划达成目标。
chap5_para1728,2,,图11-8展示了一种基于广度优先树搜索的实现。
chap5_para1728,3,,规划的考虑顺序是细化嵌套的深度，而非基元步骤的数量。
chap5_para1728,4,,设计该算法的图搜索版本、深度优先版本或迭代加深版本很简单。
chap5_para1729,1,,本质上，这种分层搜索的形式探索了一个序列空间，它符合HLA库中关于如何做事的知识。
chap5_para1729,2,,每个细化确定的动作序列和细化的前提都可以编码大量知识。
chap5_para1729,3,,对于一些领域，HTN规划器已经能够用少量搜索生成大型规划。
chap5_para1729,4,,"例如，O-Plan（Bell and Tate, 1985）将HTN规划与调度结合起来，已经被用于为日立制定生产规划。"
chap5_para1729,5,,一个典型的问题中包含一条制造350种产品、有35台装配机和2000多种不同操作的生产线。
chap5_para1729,6,,这个规划器生成了一个30天的进度计划，每天进行3次8小时换班，涉及数千万个步骤。
chap5_para1729,7,,另一个重要方面是，根据定义，HTN规划是分层结构的，这通常更利于人类理解。
chap5_para173,1,The first two conditions ensure that all the variables and constraints are represented in the tree decomposition.,第一天：道路A通向一桶金子，道路B通向一个岔路口。
chap5_para173,2,"The third condition seems rather technical, but allows us to say that any variable from the original problem must have the same value wherever it appears: the constraints in the tree say that a variable in one node of the tree must have the same value as the corresponding variable in the adjacent node in the tree.",你可以看到，岔路口左转是两桶金子，右转则会撞上一辆公共汽车。
chap5_para173,3,"For example, SA appears in all four of the connected nodes in Figure 5.",
chap5_para173,4,"13, so each edge in the tree decomposition therefore includes the constraint that the value of SA in one node must be the same as the value of SA in the next.",
chap5_para173,5,You can verify from Figure 5.,
chap5_para173,6,12 that this decomposition makes sense.,
chap5_para1730,1,,图11-8　分层前向规划搜索的广度优先实现。
chap5_para1730,2,,最初提供给算法的规划是[Act]。
chap5_para1730,3,,Refinements函数返回一个动作序列集， HLA的每个由状态outcome满足其前提的细化都对应其中一个动作序列
chap5_para1731,1,,分层搜索的计算优势可以从一个理想化的案例中看出。
chap5_para1731,2,,假设一个规划问题的解有d个基元动作。
chap5_para1731,3,,对于一个每个状态有b个可用动作的非分层前向状态空间规划器，其代价是O(bd)，如第3章所述。
chap5_para1731,4,,对于一个HTN规划，我们假设一个非常规则的细化结构：每个非基元动作有r个可能的细化，每个细化到在下一层次有k个动作。
chap5_para1731,5,,我们想知道这个结构有多少种不同的细化树。
chap5_para1731,6,,现在，如果在基元层有d个动作，根节点下面的层次数量是logk d，所以内部细化节点的数量是。
chap5_para1731,7,,每个内部节点有r个可能的细化，因此能构造个可能的分解树。
chap5_para1732,1,,仔细查看这个公式，我们可以看到使r较小而k较大会减少大量开销：如果b和r是可比较的，我们取非分层代价的k次方根。
chap5_para1732,2,,较小的r和较大的k意味着一个HLA的库只有少量的细化，每个细化都产生一个较长的动作序列。
chap5_para1732,3,,但这并不总是可能的：可用于广泛问题的长动作序列极为少见。
chap5_para1733,1,,HTN规划的关键是含有用于实现复杂的高层动作的已知方法的规划库。
chap5_para1733,2,,建立库的方法之一是从问题求解的经验中学习。
chap5_para1733,3,,在从零开始痛苦地构建好规划之后，智能体就可以将规划保存在库中，作为实现由任务定义的高层动作的方法。
chap5_para1733,4,,这样，随着时间的推移，用旧方法逐渐构建了新方法，智能体的能力越来越强大。
chap5_para1733,5,,这个学习过程的一个重要方面是对所构建方法进行泛化的能力，消除针对特定问题的细节（例如，建筑商的名字或地块的地址），只保留规划的关键元素。
chap5_para1733,6,,我们相信，人类的强大能力中也有类似这样的机制。
chap5_para1734,1,,11.4.3　搜索抽象解
chap5_para1735,1,,11.4.2节中的分层搜索算法将HLA细化为基元动作序列，以确定一个规划是否切实可行。
chap5_para1735,2,,这有些违反常识：我们应该能够确定有两个HLA高层规划
chap5_para1736,1,,能够将人送到机场，而无须确定准确的路线、要使用的停车场等。
chap5_para1736,2,,解决方案是写出HLA的前提-效果描述，就像我们对基元动作所做的那样。
chap5_para1736,3,,从描述中，应该很容易证明高层规划实现了目标。
chap5_para1736,4,,这称得上是分层规划终极理想，因为如果我们通过搜索高层动作的较小搜索空间得到一个可证明能达成目标的高层规划，然后我们就可以专注于这个规划，只需要继续细化规划的每个步骤就行了。
chap5_para1736,5,,这样，我们就节省了指数级的开销。
chap5_para1737,1,,这只在一种情况下是可行的，即每个“声称”能达成目标的高层规划（根据其步骤的描述）确实能够达成目标。
chap5_para1737,2,,根据上文所述的定义，这个规划必须至少有一个能达成目标的实现。
chap5_para1737,3,,这个性质被称为HLA描述的向下细化性质。
chap5_para1738,1,,从理论上说，写出满足向下细化性质的HLA描述是容易的：只要描述是真的，那么所有宣称能达成目标的高层规划实际上都可以达成目标——否则，描述就对HLA的行为进行了假的描述。
chap5_para1738,2,,我们已经见过如何为只有一个实现的HLA编写真描述（习题11.HLAU），但当HLA有多个实现时就会出现问题。
chap5_para1738,3,,我们如何描述一个能够以许多不同方式实现的动作的效果？
chap5_para1739,1,,一个（至少对所有前提和目标都为正的问题来说）安全的答案是只包括HLA中所有实现都能完成的正效果和某个实现的负效果。
chap5_para1739,2,,这就能满足向下细化性质。
chap5_para1739,3,,可惜的是，这种语法对HLA来说过于保守了。
chap5_para174,1,"Once we have a tree-structured graph, we can apply TREE-CSP-SOLVER to get a solution in O(nd2) time, where n is the number of tree nodes and d is the size of the largest domain.",第二天：道路A通向一桶金子，道路B通向一个岔路口。
chap5_para174,2,"But note that in the tree, a domain is a set of tuples of values, not just individual values.",你可以看到，岔路口右转是两桶金子，左转则会撞上一辆公共汽车。
chap5_para1740,1,,"重新考虑一下HLA Go(Home, SFO)，它有两个细化。"
chap5_para1740,2,,为了便于讨论，假设在一个简单的世界中，人们永远能够开车到机场并找到停车位，但打车需要以Cash（现金）作为前提。
chap5_para1740,3,,"在这种情况下，Go(Home, SFO)并不总是能把你带到机场。"
chap5_para1740,4,,"特别是，如果Cash为假，我们就无法断言At(Agent, SFO)为这个HLA的效果。"
chap5_para1740,5,,但这并没有道理，因为如果智能体没有现金，它就会自己开车。
chap5_para1740,6,,要求效果对所有实现都成立，就相当于假设其他人——一个对手——会选择这个实现。
chap5_para1740,7,,它对待HLA的多个结果的方式就好像HLA是一个非确定性的动作一样，如4.3节所述。
chap5_para1740,8,,但我们的情况是，智能体自己会选择要采取的实现。
chap5_para1741,1,,编程语言社区为对手进行选择的情况创造了恶魔非确定论（demonic nondeterminism）这个术语，来对比于智能体自己进行选择的天使非确定论（angelic nondeterminism）。
chap5_para1741,2,,我们借用这个术语来定义HLA描述中的天使语义（angelic semantics）。
chap5_para1741,3,,"理解天使语义所需的基本概念是HLA的可达集（reachable set）：给定一个状态s，HLA h的可达集写作Reach(s, h)，是所有HLA实现都可以到达的状态集合。"
chap5_para1742,1,,关键思想是，当智能体执行HLA时，它可以选择最后要到达可达集中的哪个元素。
chap5_para1742,2,,因此，一个具有多个细化的HLA比具有较少细化的相同HLA更“强大”。
chap5_para1742,3,,我们可以定义HLA序列的可达集。
chap5_para1742,4,,"例如，序列[h1, h2]的可达集是在h1的可达集的每个状态下应用h2所得到的所有可达集的并集："
chap5_para1743,1,,给定这些定义，一个高层规划——一个HLA序列——达成了目标，如果其可达集与目标状态集相交。
chap5_para1743,2,,（作为对比，恶魔语义的条件更为严格，其可达集中的所有成员都必须是一个目标状态。
chap5_para1743,3,,）相反地，如果可达集没有与目标相交，那么规划肯定行不通。
chap5_para1743,4,,图11-9展示了这些概念。
chap5_para1744,1,,图11-9　可达集的语义示例。
chap5_para1744,2,,目标状态集用紫色阴影表示。
chap5_para1744,3,,黑色和红色箭头分别表示h1和h2的可能实现。
chap5_para1744,4,,（a）在状态s中HLA h1的可达集。
chap5_para1744,5,,"（b）序列[h1, h2]的可达集。"
chap5_para1744,6,,因为它与目标集相交，所以序列实现了目标
chap5_para1745,1,,可达集的概念产生了一个简单的算法：在高层规划中搜索，寻找可达集与目标相交的规划。
chap5_para1745,2,,一旦找到这种规划，算法就知道这个抽象规划可行，并专注于它，然后致力于进一步细化该规划。
chap5_para1745,3,,我们稍后再回到算法话题，现在先考虑如何表示HLA的效果——每个可能的初始状态的可达集。
chap5_para1745,4,,基元动作可以将流设为真（true）、假（false）或未更改（unchanged）。
chap5_para1745,5,,对有条件的效果（见11.5.1节），还有第四种可能性：即将变量设为其相反量。
chap5_para1746,1,,天使语义下的HLA能做的事情更多：它可以控制流的值，根据选择了哪个实现来将流设置为真或假。
chap5_para1746,2,,这意味着HLA可以对流产生9种不同的效果：如果变量一开始为真，它可以始终保持为真、始终设为假或者有选择权；如果流一开始为假，它可以一直保持为假、一直设为真或者有选择权。
chap5_para1746,3,,这两种情况的3个选项可以任意组合，得到9种效果。
chap5_para1747,1,,这在记法上有点困难。
chap5_para1747,2,,我们将使用添加列表和删除列表（而不是真/假流）的语言，用~符号来表示“有可能，如果智能体做出了这样的选择”。
chap5_para1747,3,,因此，效果~+意味着“可能添加A”，也就是说，要么保持A不变，要么使它为真。
chap5_para1747,4,,同样，~—表示“可能删除A”，~±表示“可能添加或删除A”。
chap5_para1747,5,,"例如，HLA Go(Home, SFO)，有两个图11-7所示的细化，可能删除Cash（如果智能体决定打车），因此它应当具有效果~—Cash。"
chap5_para1747,6,,这样，我们看到HLA的描述是可以从对其细化的描述中推导出来的。
chap5_para1747,7,,现在，假设我们有HLA h1和h2的以下动作模式：
chap5_para1748,1,,也就是说，h1添加A并可能删除B，而h2可能添加A并可以完全控制C。
chap5_para1748,2,,"现在，只要初始状态B为真且目标是A∧C，那么序列[h1, h2]实现了目标：我们选择h1的使B为假的实现，然后选择h2的保持A为真且使C为真的实现。"
chap5_para1749,1,,前面的讨论假设，一个HLA的效果——对任意给定初始状态的可达集——可以通过描述每个流的效果而被精确描述。
chap5_para1749,2,,如果这总是正确的就太好了——在很多情况下，我们只能近似这些效果，因为一个HLA可能有无穷多种实现，可能产生随意弯曲的可达集，就像7.7.3节的图7-21所示的弯曲信念状态问题。
chap5_para1749,3,,"例如，我们说Go(Home, SFO)可能删除Cash，它也可能添加At(Car, SFOLongTermParking)，但它不能同时做这两件事——事实上它必须只做一件事。"
chap5_para1749,4,,与信念状态一样，我们可能需要写出近似描述。
chap5_para1749,5,,"我们将使用两种近似：HLA h的乐观描述（optimistic description）Reach+(s, h)可能夸大了可达集，而悲观描述（pessimistic description）Reach−(s, h)可能低估了可达集。"
chap5_para1749,6,,因此，我们有
chap5_para175,1,"For example, the top left node in Figure 5.13 represents, at the level of the original problem, a subproblem with variables {WA, NT, SA}, domain {red, green, blue}, and constraints WA ≠ NT, SA ≠ NT, WA ≠ SA. At the level of the tree, the node represents a single variable, which we can call SANTWA, whose value must be a three-tuple of colors, such as (red, green, blue), but not (red, red, blue), because that would violate the constraint SA ≠ NT from the original problem. We can then move from that node to the adjacent one, with the variable we can call SANTQ, and find that there is only one tuple, (red, green, blue), that is consistent with the choice for SANTWA. The exact same process is repeated for the next two nodes, and independently we can make any choice for T.",第三天：道路A通向一桶金子，道路B通向一个岔路口。
chap5_para175,2,,你知道岔路口的一个分支通向两桶金子，另一个分支会撞上一辆公共汽车。
chap5_para175,3,,遗憾地是，你不知道哪个分支通向金子。
chap5_para1750,1,,"例如，对Go(Home, SFO)的乐观描述称，它可能会删除Cash，并可能添加At(Car, SFOLongTermParking)。"
chap5_para1750,2,,另一个很好的例子出现在8数码问题中，不论从哪种给定的状态出发，都有一半的状态是不可达的（见习题11.PART）：对Act的乐观描述很可能包括整个状态空间，因为确切的可达集是非常弯曲的。
chap5_para1751,1,,使用近似描述需要稍微修改一下规划是否达成目标的测试。
chap5_para1751,2,,如果规划的乐观可达集与目标不相交，那么规划就行不通；如果悲观可达集与目标相交，则规划有效（图11-10a）。
chap5_para1751,3,,使用精确描述的话，规划要么有效要么无效，但使用近似的描述时，存在一个中间地带：如果乐观集与目标相交而悲观集不相交，那么我们就无法判断规划是否有效（图11-10b）。
chap5_para1751,4,,当这种情况出现时，可以通过细化规划来解决不确定性。
chap5_para1751,5,,这是人类推理中很常见的情况。
chap5_para1751,6,,例如，在规划前面提到的两周的夏威夷度假时，有人可能会提议在7个岛上各呆两天。
chap5_para1751,7,,而谨慎起见的话，这一雄心勃勃的规划需要细化到考虑岛间交通方式的程度。
chap5_para1752,1,,图11-10　具有近似描述的高层规划的目标达成。
chap5_para1752,2,,目标状态集用紫色阴影表示。
chap5_para1752,3,,对于每个规划将显示悲观（实线，浅蓝色）和乐观（虚线，浅绿色）可达集。
chap5_para1752,4,,（a）黑色箭头所指的规划的确达成了目标，而红色箭头所指的规划完全没有达成目标。
chap5_para1752,5,,（b）可能达成目标（乐观可达集相交的目标）但未必会达成目标（悲观可达集与目标不相交）的规划。
chap5_para1752,6,,该规划需要进一步细化，以确定它是否真的达成了目标
chap5_para1753,1,,图11-11展示了一个具有近似天使描述的分层规划算法。
chap5_para1753,2,,为简单起见，我们保留了先前在图11-8中使用的相同的总体方案，即在细化空间中进行广度优先搜索。
chap5_para1753,3,,如前所述，该算法可以通过检查乐观可达集和悲观可达集与目标的交集来检测规划是否可行。
chap5_para1753,4,,（习题11. HLAP中详细介绍了给定每一步的近似描述后如何计算规划的可达集。
chap5_para1753,5,,）
chap5_para1754,1,,图11-11　一个分层规划算法，它使用天使语义来识别并执行可行的高层规划，避免不可行高层规划。
chap5_para1754,2,,谓词Making-Progress检查并确保我们不会陷入细化的无限回归中。
chap5_para1754,3,,在顶层，以[Act]作为initialPlan调用Angelic-Search
chap5_para1755,1,,当找到一个可行的抽象规划时，该算法将原问题分解为子问题，规划的每步对应一个子问题。
chap5_para1755,2,,每个子问题的初始状态和目标是通过对规划的每一步用动作模式回归一个确保可达的目标状态获得的。
chap5_para1755,3,,（见11.2.2节了解回归的原理。
chap5_para1755,4,,）图11-9b阐明了其基本概念：右边圈中的状态是确保可达的目标状态，左边圈中的状态是通过用最终动作回归目标得到的中间目标。
chap5_para1756,1,,执行或拒绝高层规划的能力可以使Angelic-Search比Hierarchical-Search有显著的计算优势，而Hierarchical-Search又可能比传统的Breadth-First-Search有很大的优势。
chap5_para1756,2,,例如，考虑打扫一个很大的由狭窄走廊连接的房间组成的真空吸尘器世界，其中每个房间都是w×h的长方形。
chap5_para1756,3,,真空吸尘器的HLA有导航（Navigate，如图11-7所示）和清理整个房间（CleanWholeRoom）的动作是很有意义的。
chap5_para1756,4,,（清理房间可以通过重复应用另一个用于清理每行区域的HLA实现。
chap5_para1756,5,,）因为有5个基元动作，所以Breadth-First-Search的代价增长为5d，其中d是最短解的长度（大约是房间总方格数的两倍）；该算法甚至无法处理两个3×3的房间。
chap5_para1756,6,,Hierarchical-Search更高效，但仍然会受指数增长的困扰，因为它会尝试所有与分层一致的清理方法。
chap5_para1756,7,,而Angelic-Search的规模增加几乎随方格数量线性增长——它专注于一个良好的房间清理高层序列和导航步骤，并且会剪去其他选择。
chap5_para1757,1,,通过依次打扫每个房间来打扫一组房间并不是什么高深的科学：这种任务的分层结构对人类来说很容易。
chap5_para1757,2,,考虑到人类在求解像8数码这样的小谜题时并不容易，可以看出人类求解复杂问题的能力似乎不是来自排列组合学，而是来自能够消除组合的问题抽象和分解能力。
chap5_para1758,1,,通过推广可达集的概念，天使方法可以推广到找出最小代价的解。
chap5_para1758,2,,状态不再是可达与否的，而是每个状态都有一个最高效抵达该状态的代价。
chap5_para1758,3,,（对于不可达状态，代价是无穷大。
chap5_para1758,4,,）乐观和悲观描述分别为代价的上下界。
chap5_para1758,5,,这样，天使搜索可以找到可证明为最优的抽象规划，而不必考虑其实现。
chap5_para1758,6,,同样的方法可以用于得到在线搜索的有效分层前瞻（hierarchical look-ahead）算法，类似于LRTA*（4.5.3节）。
chap5_para1759,1,,这些算法在某种程度上反映了人类在完成类似规划夏威夷度假这样的任务时的深思熟虑——对其他规划的考虑一开始是在抽象层次和很长的时间尺度上完成的。
chap5_para1759,2,,规划的某些部分在执行之前都相当抽象，例如如何在莫洛凯岛度过悠闲的两天，而其他部分是详细规划，例如要乘坐的航班、要预订的旅馆，没有这些细化就无法确保这个规划的可行性。
chap5_para176,1,"We can solve any tree decomposition problem in O(nd2) time with TREE-CSP-SOLVER, which will be efficient as long as d remains small.",观测力平均会得出以下推论：第一天，B是正确选择；第二天，B也是正确选择；第三天，情况和第一天或第二天一样，所以B仍然是正确选择。
chap5_para176,2,"Going back to our example with 100 Boolean variables, if each node has 10 variables, then d = 210 and we should be able to solve the problem in seconds.",
chap5_para176,3,"But if there is a node with 30 variables, it would take centuries.",
chap5_para1760,1,,11.5　非确定性域的规划和行动
chap5_para1761,1,,本节，我们将规划扩展到处理部分可观测的、非确定性的和未知的环境中。
chap5_para1761,2,,其基本概念与第4章的概念类似，区别在于它使用了因子化表示而非原子表示。
chap5_para1761,3,,这影响了我们表示智能体动作和观测能力的方式，以及我们表示部分可观测环境的信念状态——智能体可能处于的具体状态集——的方式。
chap5_para1761,4,,我们还可以利用11.3节中给出的许多种领域无关的方法来计算搜索启发式。
chap5_para1762,1,,我们将介绍在没有观测的环境中的无传感器规划（也称为一致性规划）、部分可观测的和非确定性环境中的应变规划，以及在未知环境中的在线规划和重规划。
chap5_para1762,2,,这使我们能够求解相当大的实际问题。
chap5_para1763,1,,考虑一下这个问题：给定一把椅子和一张桌子，我们的目标是让它们匹配——具有相同的颜色。
chap5_para1763,2,,在初始状态下，我们有两罐油漆，但油漆和家具的颜色是未知的。
chap5_para1763,3,,最初只有桌子在智能体的视野范围内：
chap5_para1764,1,,有两个动作，即取下油漆罐的盖子和用打开罐子里的油漆粉刷对象：
chap5_para1765,1,,动作模式很简单，但有一个例外：前提和效果现在可能包含不属于动作的变量列表的变量。
chap5_para1765,2,,"也就是说，Paint(x, can)没有提到表示罐子中油漆颜色的变量c。"
chap5_para1765,3,,"在完全可观测的情况下，这是不允许的——我们必须将动作命名为Paint(x, can, c)。"
chap5_para1765,4,,但在部分可观测的情况下，我们可能知道也可能不知道油漆罐里是什么颜色。
chap5_para1766,1,,为了求解部分可观测的问题，智能体需要对它在执行规划时获得的感知进行推理。
chap5_para1766,2,,当智能体实际行动时其传感器会提供感知，但当它进行规划时，则需要其传感器模型。
chap5_para1766,3,,在第4章中，这个模型以函数Percept(s)给出。
chap5_para1766,4,,对于规划，我们对PDDL增加一种新的模式——感知模式（percept schema）：
chap5_para1767,1,,"第一个模式表明，当对象在视野中时，智能体将感知到对象的颜色（也就是说，对于对象x，智能体将学习Color(x, c)对所有c的真值）。"
chap5_para1767,2,,第二个模式表明，如果视野中有打开的罐子，智能体将感知罐中油漆的颜色。
chap5_para1767,3,,由于世界中没有外因事件，即使对象的颜色没有被感知到，也会保持不变，直到智能体执行动作改变了它的颜色。
chap5_para1767,4,,当然，智能体将需要一个动作使对象（每次一个）进入视野：
chap5_para1768,1,,对于一个完全可观测的环境，每个流都会有一个没有前提的感知模式。
chap5_para1768,2,,而无传感器智能体则根本没有感知模式。
chap5_para1768,3,,注意，即使是无传感器智能体也可以解决刷漆问题。
chap5_para1768,4,,一种办法是打开任意一罐油漆，并粉刷椅子和桌子，从而强制地使它们的颜色相同（即便智能体不知道这是什么颜色）。
chap5_para1769,1,,具有传感器的应变规划智能体可以生成更好的规划。
chap5_para1769,2,,首先，它观察桌子和椅子，获得它们的颜色，如果颜色相同，规划就完成了；如果颜色不同，就观察油漆罐，如果罐子里的油漆与其中一件家具的颜色相同，就把油漆刷到另一件家具上；否则就用任意颜色给这两件家具刷漆。
chap5_para177,1,"A given graph admits many tree decompositions; in choosing a decomposition, the aim is to make the subproblems as small as possible.",现在我们可以看出观测力平均为什么会失败：它没有考虑智能体执行行动后所处的信念状态。
chap5_para177,2,"(Putting all the variables into one node is technically a tree, but is not helpful.",完全忽略信念状态是不可取的，特别是当其中一种可能性是必死时。
chap5_para177,3,) The tree width of a tree decomposition of a graph is one less than the size of the largest node; the tree width of the graph itself is defined to be the minimum width among all its tree decompositions.,因为它假设每种未来状态都自动成为一个完美知识，观测力方法从不选择那些收集信息的行动（例如图5-15中的第一个移动），也不会选择那些向对手隐藏信息或向同伴提供信息的行动，因为它假定对方已经知道这些信息。
chap5_para177,4,If a graph has tree width w then the problem can be solved in O(ndw+1) time given the corresponding tree decomposition.,在扑克游戏中，它永远不会虚张声势（bluff）[7]，因为它假设对手知道自己的牌。
chap5_para177,5,"Hence, CSPs with constraint graphs of bounded tree width are solvable in polynomial time.",在第17章中，我们将介绍如何构造算法解决真正的部分可观测决策问题，得到最优均衡策略（见18.2节）。
chap5_para1770,1,,最后，在线规划智能体可能先生成一个分支更少的应变规划——也许是忽略了没有油漆罐能匹配任何家具的可能性——然后通过重规划来处理出现的问题。
chap5_para1770,2,,它还可以处理其动作模式中的错误。
chap5_para1770,3,,应变规划器简单地假设一个动作效果总是能成功的——给椅子刷漆就能刷好漆——而重规划智能体会检查结果并制定一个额外的规划来求解意料之外的失败，例如没刷到油漆的区域或刷得太薄透出了底色。
chap5_para1771,1,,在真实世界中，智能体使用多种方法的组合。
chap5_para1771,2,,汽车制造商出售备用轮胎和安全气囊来处理瘪胎和撞车，这是应变规划分支的实际体现。
chap5_para1771,3,,但是，大多数司机从不考虑这些可能性，当问题出现时，他们像重规划智能体一样进行反应。
chap5_para1771,4,,一般来说，智能体只为那些具有严重后果和发生概率不可忽略的事件进行规划。
chap5_para1771,5,,因此，规划穿越撒哈拉沙漠的司机应该为故障制定明确的应变规划，而开车去超市则不太需要提前规划。
chap5_para1771,6,,我们接下来详细考察这3种方法。
chap5_para1772,1,,11.5.1　无传感器规划
chap5_para1773,1,,4.4.1节介绍了在信念-状态空间中搜索以求解无传感器问题的基本概念。
chap5_para1773,2,,将无传感器规划问题转换为信念-状态规划问题的工作方式与4.4.1节所述大致相同，主要差异是其背后的物理转移模型由动作模式集合来表示，信念状态用逻辑公式表示而非显式地枚举状态集。
chap5_para1773,3,,我们假设其中的规划问题是确定性的。
chap5_para1774,1,,无传感器刷漆问题的初始信念状态可以忽略InView流，因为智能体没有传感器。
chap5_para1774,2,,此外，默认了固定的事实，因为它们在所有信念状态中都成立。
chap5_para1774,3,,智能体不知道罐内油漆或对象的颜色，也不知道油漆罐子是不是打开的，但它知道对象和油漆有颜色：。
chap5_para1774,4,,在斯科伦化（见9.5.1节）后，我们得到初始信念状态：
chap5_para1775,1,,在封闭世界假设下的经典规划中，我们假设状态未提及的流为假，但在无传感器（和部分可观测）规划中我们必须转为开放世界假设，其中的状态同时包含正流和负流，如果一个流没有出现，它的值就是未知的。
chap5_para1775,2,,因此，信念状态严格对应于满足公式的可能世界的集合。
chap5_para1775,3,,给定这个初始信念状态，下面的动作序列是一个解：
chap5_para1776,1,,我们现在展示如何通过动作序列来推进信念状态，以证明最终信念状态将满足目标。
chap5_para1777,1,,首先要注意，在给定的信念状态b中，智能体可以考虑前提被b满足的任何动作。
chap5_para1777,2,,（不能使用其他动作，因为转移模型没有定义前提可能未被满足的动作的效果。
chap5_para1777,3,,）根据式（4-4），在确定性世界中给定适用动作a时，更新信念状态b的一般公式如下：
chap5_para1778,1,,其中ResultP定义物理转换模型。
chap5_para1778,2,,目前，我们假设初始信念状态始终是文字的合取，即一个1-CNF公式。
chap5_para1778,3,,为构建新的信念状态b'，我们必须考虑当应用动作a时，b中的每个物理状态s的每个文字会发生什么。
chap5_para1778,4,,对于在b中已知真值的文字，其在b'中的真值是由当前值和动作的添加列表和删除列表算出的。
chap5_para1778,5,,（例如，如果在动作的删除列表中，则被添加到b'。
chap5_para1778,6,,）如果在b中的文字真值未知呢？
chap5_para1778,7,,有如下3种情况。
chap5_para1779,1,,（1）如果动作添加，则在b'中为真，不论其初始值为何。
chap5_para178,1,"Unfortunately, finding the decomposition with minimal tree width is NP-hard, but there are heuristic methods that work well in practice. Which is better: the cutset decomposition with time O(dc · (n — c)d2), or the tree decomposition with time O(ndw+1)? Whenever you have a cycle-cutset of size c, there is also a tree width of size w < c + 1, and it may be far smaller in some cases. So time consideration favors tree decomposition, but the advantage of the cycle-cutset approach is that it can be executed in linear memory, while tree decomposition requires memory exponential in w.",
chap5_para1780,1,,（2）如果动作删除，则在b'中为假，不论其初始值为何。
chap5_para1781,1,,（3）如果动作不影响，则将保持其初始值（也就是未知）且不会出现在b'中。
chap5_para1782,1,,因此，我们看到b'的计算几乎与11.1节的式（11-1）所述的可观测情况相同：
chap5_para1783,1,,我们其实不能使用集合语义，因为（1）我们必须确保b'不同时包含和，（2）原子可能包含未绑定的变量。
chap5_para1783,2,,"但是，Result(b, a)的计算仍然是从b开始，将出现在Del(a)中的所有原子设为假，将出现在Add(a)中的所有原子设为真。"
chap5_para1783,3,,例如，如果我们对初始信念状态b0应用RemoveLid(Can1)，得到
chap5_para1784,1,,当我们应用动作时，前提被使用了绑定的文字所满足，新的信念状态为
chap5_para1785,1,,最后，我们应用动作得到
chap5_para1786,1,,通过将变量c绑定到，最终的信念状态满足目标。
chap5_para1787,1,,前面对更新规则的分析表明一个非常重要的事实：以文字合取定义的信念状态族在PDDL动作模式定义的更新下是闭的。
chap5_para1787,2,,也就是说，如果信念状态以文字的合取开始，那么任何更新都将产生文字的合取。
chap5_para1787,3,,这意味着在一个有n个流的世界里，任何信念状态都可以用规模为O(n)的合取来表示。
chap5_para1787,4,,考虑到这个世界中有2n种状态，这是一个非常令人欣慰的结果。
chap5_para1787,5,,这表明我们可以简洁地表示我们所需的2n个状态的所有子集。
chap5_para1787,6,,此外，检查先前访问过的信念状态的子集或超集也是很容易的，至少在命题的情形下如此。
chap5_para1788,1,,美中不足之处在于，它只适用于对所有满足其前提的状态具有相同效果的动作模式。
chap5_para1788,2,,正是这个性质使1-CNF的信念状态表示得以保留。
chap5_para1788,3,,一旦效果依赖于状态，就引入流之间的依赖关系，1-CNF性质就会丢失。
chap5_para1789,1,,例如，考虑3.2.1节中定义的简单真空吸尘器世界。
chap5_para1789,2,,用AtL和AtR表示机器人的位置，用CleanL和CleanR表示方格的状态。
chap5_para1789,3,,根据问题的定义，Suck动作没有前提——它总是可以完成的。
chap5_para1789,4,,困难在于，它的效果取决于机器人的位置：当机器人是AtL时，结果是CleanL，但当它是AtR时，结果是CleanR。
chap5_para1789,5,,对于这样的动作，我们的动作模式需要一些新的东西：条件效果（conditional effect）。
chap5_para1789,6,,它们具有语法“when condition: effect”，其中condition是要与当前状态相比较的逻辑公式，而effect是描述结果状态的公式。
chap5_para1789,7,,对于真空吸尘器世界：
chap5_para179,1,5.,[7]　虚张声势——即使自己的手牌很差，也要装作很好——是扑克策略的核心部分。
chap5_para179,2,5.,
chap5_para179,3,3Value symmetry,
chap5_para1790,1,,当应用于初始信念状态True时，得到的信念状态为，它不再在1-CNF中。
chap5_para1790,2,,（这个转换见图4-14。
chap5_para1790,3,,）一般情况下，条件效果会导致信念状态中的流之间的任意依赖关系，在最坏的情况下会导致指数规模的信念状态。
chap5_para1791,1,,理解前提和条件效果之间的区别是很重要的。
chap5_para1791,2,,所有条件被满足的条件效果都会应用其效果以产生结果信念状态；如果没有被满足，则结果状态不会被改变。
chap5_para1791,3,,但是，如果一个前提没有被满足，那么动作就不适用，导致的结果状态是未定义的。
chap5_para1791,4,,从无传感器规划的角度来看，条件效果比不适用动作更好。
chap5_para1791,5,,例如，我们可以将Suck分成如下两个无条件效果的动作：
chap5_para1792,1,,现在我们只有无条件模式，所以信念状态都在1-CNF中。
chap5_para1792,2,,遗憾的是，我们无法确定SuckL和SuckR在初始信念状态下的适用性。
chap5_para1793,1,,因此，一些重要的问题似乎不可避免地会涉及弯曲的信念状态，就像我们在考虑wumpus世界的状态估计问题时遇到的那样（见图7-21）。
chap5_para1793,2,,当时建议的解决方案是使用确切信念状态的保守近似。
chap5_para1793,3,,例如，如果信念状态包含真值可以确定的所有文字，并视其他文字为未知，则它可以维持在1-CNF中。
chap5_para1793,4,,虽然这种方法是可靠的，因为它永远不会产生一个不正确的规划，但它是不完备的，因为它可能无法找到涉及文字之间的交互的问题的解。
chap5_para1793,5,,举个简单的例子，如果机器人的目标是位于一个干净的方格中，则[Suck]就是一个解，但坚持1-CNF信念状态的无传感器智能体无法找到这个解。
chap5_para1794,1,,也许更好的解决方案是寻找能够让信念状态尽可能简单的动作序列。
chap5_para1794,2,,"在无传感器真空吸尘器世界中，动作序列[Right, Suck, Left, Suck]会生成以下信念状态序列："
chap5_para1795,1,,也就是说，智能体可以在保持1-CNF信念状态的情况下求解问题，即使一些序列（例如以Suck开头的序列）在1-CNF之外。
chap5_para1795,2,,人类也有这样的经验：我们总是在做一些小的动作（查看时间、拍拍口袋以确定我们拿了车钥匙、在城市里穿行时查看路标）来消除不确定性，保持我们的信念状态可控。
chap5_para1796,1,,还有另一种完全不同的方法来求解难以控制的弯曲的信念状态问题：完全不去费力地计算它们。
chap5_para1796,2,,假设初始信念状态为b0，我们想知道由动作序列产生的信念状态。
chap5_para1796,3,,我们不计算其结果，而是将其表示为“”。
chap5_para1796,4,,这是信念状态的一种偷懒但没有歧义的表示，而且它非常简洁，其复杂度仅为O(n+m)，其中n是初始信念状态的大小（假设为1-CNF），m是动作序列的最大长度。
chap5_para1796,5,,然而，作为一种信念状态表示，它有一个缺点：确定目标是否被满足，或者一个动作是否适用，可能需要大量的计算。
chap5_para1797,1,,计算可以实现为一个蕴含测试：如果Am代表定义动作发生所需的后继状态公理的集合（如11.2.3节对SATPlan的解释中所述），Gm断言在m步后目标为真，如果，也就是说，如果是不可满足的，则规划达成目标。
chap5_para1797,2,,使用现代的SAT求解器，对它进行计算可能会比计算完整的信念状态快得多。
chap5_para1797,3,,例如，如果序列中的所有动作在其添加列表中都没有特定的目标流，求解器将立即检测到这一点。
chap5_para1797,4,,这也有助于缓存关于信念状态的部分结果（例如，已知为真或假的流）以简化后续计算。
chap5_para1798,1,,无传感器规划难题的最后一部分是引导搜索的启发式函数。
chap5_para1798,2,,启发式函数的意义与经典规划相同：从给定信念状态达成目标的代价估计（也许是可容许的）。
chap5_para1798,3,,对于信念状态，我们还需要一条事实，即求解信念状态的任何子集都必然比求解信念状态更容易：
chap5_para1799,1,,因此，算出的对子集的任意可容许的启发式函数也是信念状态自身的可容许的启发式函数。
chap5_para1799,2,,最明显的候选者是单元素子集，即单个物理状态。
chap5_para1799,3,,"我们可以取信念状态b中任意状态s1, …, sN的集合，应用任何可容许的启发式函数h，并返回"
chap5_para18,1,"Here we are using abbreviations; SA ≠ WA is a shortcut for 〈(SA, WA), SA ≠ WA〉, where SA ≠ WA can be fully enumerated in turn as",● S0：初始状态，指定博弈开始时如何设置。
chap5_para180,1,"So far, we have looked at the structure of the constraint graph.",尽管存在上述缺陷，观测力平均仍是一个有效策略，通过一些技巧可以使其更好地发挥作用。
chap5_para180,2,"There can also be important structure in the values of variables, or in the structure of the constraint relations themselves.",在大多数纸牌游戏中，可能的发牌结果数量都相当大。
chap5_para180,3,Consider the map-coloring problem with d colors.,例如，在桥牌中，每个玩家只能看到四手牌中的两手，剩余两手各包含13张牌，所以可能的发牌结果有= 10 400 600种。
chap5_para180,4,"For every consistent solution, there is actually a set of d!",即使求解一种发牌结果也是相当困难的，所以求解1000万种更是不可能的。
chap5_para180,5,solutions formed by permuting the color names.,处理这样巨大数目的一种方法是抽象（abstraction）：将相似的手牌视为相同手牌。
chap5_para180,6,"For example, on the Australia map we know that WA, NT, and SA must all have different colors, but there are 3!",例如，手牌中的A和K非常重要，但是4或5就不那么重要了，可以将其抽象。
chap5_para180,7,= 6 ways to assign three colors to three regions.,
chap5_para180,8,This is called value symmetry.,
chap5_para180,9,We would like to reduce the search space by a factor of d!,
chap5_para180,10,by breaking the symmetry in assignments.,
chap5_para180,11,We do this by introducing a symmetry-breaking constraint.,
chap5_para180,12,"For our example, we might impose an arbitrary ordering constraint, NT < SA < WA, that requires the three values to be in alphabetical order.",
chap5_para180,13,This constraint ensures that only one of the d!,
chap5_para180,14,"solutions is possible: {NT = blue, SA = green, WA = red}.",
chap5_para1800,1,,作为求解b的启发式估计。
chap5_para1800,2,,我们也可以使用不可容许的启发式函数，如忽略删除列表启发式方法（11.3节），它在实际中的表现似乎也相当好。
chap5_para1801,1,,11.5.2　应变规划
chap5_para1802,1,,我们在第4章中看到，应变规划——基于感知的条件分支生成规划——适用于部分可观测的、非确定性的或两者兼有的环境。
chap5_para1802,2,,对于前面给出的部分可观测刷漆问题和感知模式，一个可能的条件解如下：
chap5_para1803,1,,该规划中的变量应当看作是存在量化的；第二行表示，如果存在某种颜色c是桌子和椅子的颜色，那么智能体不需要做任何事情来达成目标。
chap5_para1803,2,,当执行该规划时，应变规划智能体可以将其信念状态维持为逻辑公式，并通过确定信念状态是否包含条件公式或其否定来评估每个分支条件。
chap5_para1803,3,,（这取决于应变规划算法，以确保智能体永远不会陷入条件公式真值未知的信念状态。
chap5_para1803,4,,）注意，在一阶逻辑条件下，满足公式的方式不止一种。
chap5_para1803,5,,例如，条件可能被和满足，如果两个罐子里的颜色都与桌子的颜色相同的话。
chap5_para1803,6,,在这种情况下，智能体可以选择任何满足的置换来应用到规划的其余部分。
chap5_para1804,1,,如4.4.2节所述，在执行动作a并获取新感知后分两个阶段计算新的信念状态。
chap5_para1804,2,,第一阶段计算动作后的信念状态，就像无传感器智能体一样：
chap5_para1805,1,,和之前一样，我们假设其中的信念状态表示为文字的合取。
chap5_para1805,2,,第二阶段则有点棘手。
chap5_para1805,3,,假设接收到感知文字，有人可能会认为我们仅需把这些东西加入信念状态；事实上，我们也可以推断出感知的前提是满足的。
chap5_para1805,4,,现在，如果一个感知p只有一个感知模式，其中c是文字的合取，这些常量可以与p一起加入信念状态。
chap5_para1805,5,,另外，如果p有多个感知模式，根据预测的信念状态，其前提可能成立，则我们必须加入前提的析取。
chap5_para1805,6,,显然，这将使信念状态不为1-CNF，并带来了与条件效果相同的复杂性，以及基本相似的解。
chap5_para1806,1,,给定一种计算精确或近似信念状态的机制，我们可以对4.4节使用过的信念状态使用扩展的与或前向搜索来生成应变规划。
chap5_para1806,2,,具有非确定性效果的动作——通过在动作模式的Effect中使用析取式来简单地定义——可以通过稍加改动用于计算信念状态更新，且无须改变搜索算法。
chap5_para1806,3,,[4]对于启发式函数，为无传感器规划提出的许多方法也适用于部分可观测的、非确定性的情况。
chap5_para1808,1,,"[4]　如果一个非确定性问题需要循环解，那么必须将与或搜索推广为循环版本，如LAO*（Hansen and Zilberstein, 2001）。"
chap5_para1809,1,,11.5.3　在线规划
chap5_para181,1,"For map coloring, it was easy to find a constraint that eliminates the symmetry.",另一种处理方法是前向剪枝：只考虑一个小随机样本（样本数为N），再次计算Expectiminimax得分。
chap5_para181,2,"In general it is NP-hard to eliminate all symmetry, but breaking value symmetry has proved to be important and effective on a wide range of problems.",即使是相当小的N （例如100～1000），这种方法也能提供很好的近似值。
chap5_para181,3,,它也可以应用于确定性博弈，例如四国军棋（在四国军棋中，我们对游戏的可能的状态进行采样，而不是可能的发牌），只要我们有方法估计每个状态的可能性。
chap5_para181,4,,除了搜索整个博弈树，使用深度截断进行启发式搜索也很有帮助。
chap5_para1810,1,,想象一下在汽车工厂里观察一个点焊机器人。
chap5_para1810,2,,当每辆车通过这条流水线时，机器人快速、准确的动作就会一遍又一遍地重复。
chap5_para1810,3,,尽管这个机器人在技术上令人印象深刻，但它可能看起来一点也不智能，因为它的动作是固定的、预先编程的序列。
chap5_para1810,4,,从任何意义上来看，机器都显然“不知道自己在做什么”。
chap5_para1810,5,,现在假设在机器人准备进行点焊时，一扇连接不牢的门从车上掉了下来，机器人迅速将焊接执行器替换为一个机械手，捡起车门，检查是否有划痕，将其重新安装到汽车上，然后向楼层主管发送电子邮件，切换回焊接执行器，重新开始工作。
chap5_para1810,6,,出乎意料地，机器人的行为似乎是有目的的，而不是教条的。
chap5_para1810,7,,我们假设它不是来自一个庞大的、预先计算好的应变规划，而是来自一个在线重规划过程——这意味着机器人确实需要知道它在尝试做什么。
chap5_para1811,1,,重规划预先假设了某种执行监控（execution monitoring），以确定新规划的必要性。
chap5_para1811,2,,当应变规划智能体厌倦了为每一个微小的意外事件做规划时，就会产生这样的需求，例如天是否会塌下来。
chap5_para1811,3,,[5]这意味着应变规划是不完整的。
chap5_para1811,4,,例如，部分构建的应变规划的一些分支可以只需要写出“重规划”这样的语句。
chap5_para1811,5,,如果在执行期间到达了这样的分支，智能体将返回到规划模式。
chap5_para1811,6,,正如我们前面提到的，关于需要预先求解多少问题、需要重规划多少问题的决定涉及在具有不同成本和发生概率的可能事件之间的取舍。
chap5_para1811,7,,没有人希望当车坏在撒哈拉沙漠腹地时才想到没带够水。
chap5_para1813,1,,[5]　1954年，住在亚拉巴马州的霍奇斯夫人的房子被陨石砸穿了屋顶。
chap5_para1813,2,,"1992年，一块坠落在乌干达姆巴莱（Mbale）村的陨石碎片击中了一个小男孩的头部，幸运的是，香蕉叶减缓了它的下降速度（Jeniskens et al.,1994）。"
chap5_para1813,3,,2009年，一名德国男孩声称自己的手被豌豆大小的陨石击中。
chap5_para1813,4,,这些事件都没有造成严重的伤害，这表明对这种意外情况进行预先规划的必要性有时被夸大了。
chap5_para1814,1,,如果智能体的世界模型不正确，就需要重规划。
chap5_para1814,2,,一个动作的模型可能缺失前提（missing precondition），例如，智能体可能不知道打开油漆罐的盖子通常需要螺丝刀。
chap5_para1814,3,,模型可能会缺失效果（missing effect），给一个物体刷漆可能会把油漆弄到地板上。
chap5_para1814,4,,模型也可能缺失流（missing fluent），流完全没有出现在表示中，例如，前面给出的模型没有关于罐中油漆的量、动作如何影响油漆量或油漆量的需要不得为0的概念。
chap5_para1814,5,,模型还可能缺乏对外因事件（exogenous events）的准备，例如有人打翻了油漆罐。
chap5_para1814,6,,外因事件还可以包括目标的改变，例如增加了桌子和椅子不能被漆成黑色的要求。
chap5_para1814,7,,如果依赖于模型的绝对正确性，而没有监视和重规划的能力，智能体的行为很可能是脆弱的。
chap5_para1815,1,,在线智能体（至少）可以选择3种不同的方式在规划执行中监视环境。
chap5_para1816,1,,● 动作监视（action monitoring）：在执行动作之前，智能体验证所有的前提仍然成立。
chap5_para1817,1,,● 规划监视（plan monitoring）：在执行动作之前，智能体验证剩余规划是否仍然会成功。
chap5_para1818,1,,● 目标监视（goal monitoring）：在执行动作之前，智能体检查是否有一组更好的目标可以尝试实现。
chap5_para1819,1,,在图11-12中，我们看到了动作监视的原理图。
chap5_para1819,2,,智能体跟踪其原始规划（用整体规划标示）和规划中尚未执行的部分，（用规划标示）。
chap5_para1819,3,,在执行规划的前几个步骤之后，智能体预计进入了状态E。
chap5_para1819,4,,但是智能体观测到自己实际上处于状态O。
chap5_para1819,5,,因此它需要通过找到原始规划中可以返回的某个状态P来修复规划。
chap5_para1819,6,,（P可能是目标状态G）智能体试图最小化规划的总代价：修复部分（从O到P）加上继续部分（从P到G）。
chap5_para182,1,• Constraint satisfaction problems (CSPs) represent a state with a set of variable/value pairs and represent the conditions for a solution by a set of constraints on the variables. Many important real-world problems can be described as CSPs.,到目前为止，我们假设每种发牌结果的可能性相等。
chap5_para182,2,,对于惠斯特牌和红心大战，这样的假设是有意义的。
chap5_para182,3,,但是对于桥牌，比赛之前为叫牌阶段，在这个阶段中，每支队伍都会表明它要赢多少。
chap5_para182,4,,由于玩家是根据自己持有的牌出价，因此其他玩家可以了解到每种发牌结果的概率P(s)。
chap5_para182,5,,在决定如何玩这手牌时考虑这一点是很难的，原因就像我们在四国军棋的描述中所提到的：玩家在出价时，可能会尽量最小化传达给对手的信息。
chap5_para1820,1,,图11-12　首先，我们希望用“整体规划”序列使智能体从S移动到G。
chap5_para1820,2,,智能体执行规划的各个步骤，直到它预计处于状态E，但观测到自己实际上处于状态O。
chap5_para1820,3,,然后，智能体重规划最小修复，并加上继续，以到达G
chap5_para1821,1,,现在让我们回到实现椅子和桌子颜色匹配的示例问题。
chap5_para1821,2,,假设智能体提出了规划：
chap5_para1822,1,,现在智能体已经准备好执行规划。
chap5_para1822,2,,智能体观测到桌子和油漆是白色的，而椅子是黑色的。
chap5_para1822,3,,"然后执行Paint(Chair, Can1)。"
chap5_para1822,4,,这时，一个经典的规划器会宣告胜利，规划已经被执行。
chap5_para1822,5,,但是在线执行监视智能体需要检查动作是否成功。
chap5_para1823,1,,假设智能体感知到椅子因为黑色油漆透了出来而呈现斑驳的灰色。
chap5_para1823,2,,然后，智能体需要找到规划中要作为目标的恢复位置和为了到达该位置要采取的修复动作序列。
chap5_para1823,3,,"智能体注意到当前状态与Paint(Chair, Can1)动作之前的前提相同，因此智能体选择空序列进行修复，并使其规划与刚才尝试过的[Paint]序列相同。"
chap5_para1823,4,,有了这个新规划，执行监视继续进行，并且重试Paint动作。
chap5_para1823,5,,这种行为不断循环，直到感知到椅子被完全刷好了漆。
chap5_para1823,6,,但是要注意，这个循环是由规划-执行-重规划的过程创建的，而不是由规划中的显式循环创建的。
chap5_para1823,7,,还需要注意，最初的规划并不需要涵盖所有的意外情况。
chap5_para1823,8,,如果智能体到达了标记为Replan的步骤，那么它可以生成一个新的规划（可能涉及Can2）。
chap5_para1824,1,,动作监视是执行监视的一种简单方法，但它有时会导致不那么智能的行为。
chap5_para1824,2,,例如，假设没有黑色或白色的油漆，智能体构建了一个规划，通过将椅子和桌子都刷成红色来求解油漆问题。
chap5_para1824,3,,假设红色油漆只够刷椅子。
chap5_para1824,4,,在动作监视下，智能体将继续将椅子漆成红色，然后才注意到油漆用完了而不能刷桌子，此时它将重规划一个修复，也许是把椅子和桌子都漆成绿色。
chap5_para1824,5,,而规划监视智能体在当前状态无法使规划继续适用时就可以检测到错误，这样它就不会浪费时间把椅子涂成红色。
chap5_para1825,1,,规划监视通过检查使剩余规划成功的前提来实现这一点，也就是检查规划中的每个步骤的前提，除了那些需要在剩余规划中的某一步达成的前提。
chap5_para1825,2,,规划监视会尽快中断那些注定会出错的规划的执行，而不是一直固执己见直到真的出现错误。
chap5_para1825,3,,[6]规划监视也允许意外收获，也就是偶然的成功。
chap5_para1825,4,,如果在智能体把椅子涂成红色的同时，有人过来把桌子涂成红色，那么最终规划的前提就满足了（目标已经实现），智能体就可以提前回家了。
chap5_para1827,1,,[6]　规划监视意味着在整整10章之后我们终于有了一个比粪甲虫（2.2.3节）聪明的智能体了。
chap5_para1827,2,,规划监视智能体会注意到粪球脱手了，会重规划找一个新的粪球堵在洞口。
chap5_para1828,1,,可以简单修改规划算法使得规划中的每个动作都用动作的前提标记，从而实现动作监视。
chap5_para1828,2,,使用规划监视则稍微复杂一些。
chap5_para1828,3,,偏序规划器的优势在于它已经建立了包含规划监视所需关系的结构。
chap5_para1828,4,,扩充了必要标记的状态空间规划器可以通过目标流在规划中回归时进行仔细记录来完成。
chap5_para1829,1,,既然我们已经描述了一种监视和重规划的方法，我们需要问，“它是否有效？
chap5_para1829,2,,”这是一个非常棘手的问题。
chap5_para1829,3,,如果我们的意思是，“我们能保证智能体总是可以达成目标吗？
chap5_para1829,4,,”则答案是否定的，因为智能体可能会无意中进入一个无法修复的死胡同。
chap5_para1829,5,,例如，真空吸尘器智能体本身可能有一个错误的模型，它不知道自己的电池会没电。
chap5_para1829,6,,如果电池没电，就无法修复任何规划。
chap5_para1829,7,,如果我们排除了死胡同——假设存在一个从环境中所有状态出发都可到达目标的规划，并假设环境是相当非确定性的，也就是这样的规划在任何给定的执行尝试下总是有一些成功的机会，那么智能体将最终达成目标。
chap5_para183,1,"•A number of inference techniques use the constraints to rule out certain variable assignments. These include node, arc, path, and k-consistency.",计算机在扑克牌上的表现已经超出了人类水平。
chap5_para183,2,,在为期20天的无限注德州扑克比赛中，扑克程序Libratus与4位世界顶尖的扑克玩家展开较量，并果断地将他们全部击败。
chap5_para183,3,,因为在扑克中存在很多可能状态，Libratus使用抽象法减少状态空间：它可能会认为手牌AAA72和AAA64是等价的（它们都是“3个A和一些小牌”），并且可能认为赌200美元与赌201美元是一样的。
chap5_para183,4,,但是Libratus也会监视其他玩家，如果它发现他们正在使用抽象法，它会立即做一些额外的计算填补这个漏洞。
chap5_para183,5,,总的来说，它在超级计算机上耗费了2500万CPU小时才取得胜利。
chap5_para1830,1,,当一个看似非确定性的动作实际上并不是随机的，而是依赖于智能体所不知道的前提时，就会出现问题。
chap5_para1830,2,,例如，有时油漆罐可能是空的，所以用那罐油漆刷漆没有效果，再多的尝试也改变不了这一点。
chap5_para1830,3,,[7]一种解决方案是从一系列可能的修复规划中随机选择，而不是每次都尝试相同的方案。
chap5_para1830,4,,在这种情况下，打开另一罐油漆的修复规划可能会有效。
chap5_para1830,5,,更好的方法是学习一个更好的模型。
chap5_para1830,6,,每次预测失败都是一次学习的机会；一个智能体应该能够修改它的世界模型以符合其感知。
chap5_para1830,7,,之后，重规划器就可以想出一个根本性解决问题的修复方案，而不是依靠运气来选出好的修复方案。
chap5_para1832,1,,[7]　徒劳重复的修复规划正是掘土黄蜂所表现出的行为（2.2.3节）。
chap5_para1833,1,,11.6　时间、调度和资源
chap5_para1834,1,,经典的规划讨论的是要做什么、以什么顺序，但不讨论时间：动作需要多长时间以及何时发生。
chap5_para1834,2,,例如，在机场领域，我们可以生成一份规划，说明哪些飞机要去哪里、携带什么，但不能指定起飞和到达时间。
chap5_para1834,3,,这就是调度（scheduling）所讨论的主题。
chap5_para1835,1,,真实世界还存在资源约束（resource constraint）：航空公司的员工数量有限，一名乘务员不能同时执飞两个航班。
chap5_para1835,2,,本节介绍了资源约束下解决规划和调度问题的技术。
chap5_para1836,1,,我们采取的方法是“先规划，后调度”：整个问题划分成在顺序约束下选择动作以达到问题目标的规划阶段，和之后为规划添加时间信息来确保它符合资源和截止时间约束的调度阶段。
chap5_para1836,2,,这种方法在真实世界的制造业和物流场景中很常见，其中规划阶段有时是自动化的，而有时由人类专家进行。
chap5_para1837,1,,11.6.1　时间约束和资源约束的表示
chap5_para1838,1,,典型的作业车间调度问题（job-shop scheduling problem）（见6.1.2节）由一组作业（job）组成，每个作业都有一组动作，这些动作之间有顺序约束。
chap5_para1838,2,,每个动作都有一个持续时间和一组动作所需的资源约束。
chap5_para1838,3,,约束指定资源的类型（例如螺钉、扳手或飞行员）、所需资源的数量、资源是否是消耗型的（例如，螺钉不可再用）或可复用的（例如，一个飞行员飞行期间没有空，但在飞行结束后再次可用）。
chap5_para1838,4,,动作也可以产生资源（例如，制造动作和再供应动作）。
chap5_para1839,1,,作业车间调度问题的解决方案指定了每个动作的开始时间，并且必须满足所有的时间顺序约束和资源约束。
chap5_para1839,2,,与搜索和规划问题一样，解决方案可以根据代价函数进行评估，这可能非常复杂，存在非线性资源成本、依赖于时间的延迟成本等。
chap5_para1839,3,,为简单起见，我们假设成本函数就是规划的总持续时间，称为最大完工时间（makespan）。
chap5_para184,1,"•Backtracking search, a form of depth-first search, is commonly used for solving CSPs. Inference can be interwoven with search.",Libratus的计算开销（以及AlphaZero和其他系统的开销）表明，预算有限的研究人员可能无法达到世界冠军水平。
chap5_para184,2,,从某种程度上来说，这是正确的：就像你不能指望在你的车库里用零部件组装出一辆F1冠军赛车一样，拥有超级计算机或专业硬件（如TPU）是有优势的。
chap5_para184,3,,训练一个系统时尤其如此，但训练也可以通过众包完成。
chap5_para184,4,,例如，开源LeelaZero系统是AlphaZero的复现，它通过志愿参与者计算机上的自我对弈进行训练。
chap5_para184,5,,一旦训练完成，实际比赛中的计算需求是适中的。
chap5_para184,6,,AlphaStar在使用单个GPU的商用台式计算机上赢得了《星际争霸II》比赛，而AlphaZero也可以在这种模式下运行。
chap5_para1840,1,,图11-13展示了一个简单的例子：一个涉及两辆汽车装配的问题。
chap5_para1840,2,,"该问题由两个作业组成，每个作业的形式为[AddEngine, AddWheels, Inspect]。"
chap5_para1840,3,,然后，Resources语句声明有4种类型的资源，并在开始时给出每种类型可用的数量：1个发动机吊车、1个车轮安装站、2个检查员和500个凸耳螺母。
chap5_para1840,4,,动作模式给出了每个动作的持续时间和资源需求。
chap5_para1840,5,,当车轮被装到汽车上时，凸耳螺母被消耗掉，而其他资源在动作开始时被“借来”，在动作结束时被释放。
chap5_para1841,1,,图11-13　装配两辆汽车的作业车间的调度问题，带有资源约束。
chap5_para1841,2,,符号A≺B表示动作A必须在动作B之前
chap5_para1842,1,,将资源表示为数值数量，如Inspectors(2)，而不是有名实体，如Inspectors(I1)和Inspectors(I2)，这是聚合（aggregation）的示例：当对象无法区分时，将单个对象分组为数量。
chap5_para1842,2,,在我们的装配问题中，由哪个质检员来检验汽车并不重要，所以没有必要做区分。
chap5_para1842,3,,聚合对于降低复杂性至关重要。
chap5_para1842,4,,考虑一下，当提出的时间表有10个并发的Inspectors动作，但只有9个质检员可用时，会发生什么。
chap5_para1842,5,,以数量表示质检员，算法就可以立即检测到错误，之后算法就可以回溯去尝试另一个调度。
chap5_para1842,6,,如果质检员表示为个体，那么在发现所有的动作都不起作用之前，算法将尝试分配质检员的所有9!种方式。
chap5_para1843,1,,11.6.2　解决调度问题
chap5_para1844,1,,我们从忽略资源约束，只考虑时间调度问题开始。
chap5_para1844,2,,为了最小化最大完工时间（规划持续时间），我们必须找到与问题提供的顺序约束一致的所有动作的最早开始时间。
chap5_para1844,3,,将这些顺序约束视为与动作相关的有向图是很有帮助的，如图11-14所示。
chap5_para1844,4,,我们可以将关键路径方法（critical path method，CPM）应用到这个图中，以确定每个动作可能的开始时间和结束时间。
chap5_para1844,5,,图中表示偏序规划的路径是一个以Start开始、以Finish结束的线性顺序的动作序列。
chap5_para1844,6,,（例如，图11-14中的偏序规划中有两条路径。
chap5_para1844,7,,）
chap5_para1845,1,,图11-14　（a）图11-13中作业车间调度问题的时间约束表示。
chap5_para1845,2,,每个动作的持续时间显示于每个矩形的底部。
chap5_para1845,3,,"在求解这个问题时，我们计算最早开始时间和最晚开始时间[ES, LS]，显示在左上方。"
chap5_para1845,4,,这两个数字的差是动作的松弛。
chap5_para1845,5,,零松弛的动作在关键路径上，用粗箭头显示。
chap5_para1845,6,,（b）以时间线展示的相同的解。
chap5_para1845,7,,蓝色矩形表示在遵守顺序约束的前提下执行动作的时间间隔。
chap5_para1845,8,,蓝色矩形中未被占用的部分表示松弛
chap5_para1846,1,,关键路径是总持续时间最长的路径，这条路径是“关键的”，因为它决定了整体规划的持续时间——缩短其他路径并不会缩短整体规划，但是延迟关键路径上的任何动作的开始时间都会减慢整体规划的进度。
chap5_para1846,2,,不在关键路径上的动作有一个执行时间窗口。
chap5_para1846,3,,窗口由最早可能开始时间ES和最晚可能开始时间LS指定。
chap5_para1846,4,,LS − ES的量称为动作的松弛（slack）。
chap5_para1846,5,,我们可以在图11-14中看到，整体规划将花费85分钟，顶部作业中的每个动作都有15分钟的松弛，关键路径上的每个动作（根据定义）都没有松弛。
chap5_para1846,6,,所有动作的ES和LS时间一起构成了问题的调度。
chap5_para1847,1,,下面的公式定义了ES和LS，并构成了计算它们的动态规划算法。
chap5_para1847,2,,A和B都是动作，A ≺ B表示A在B之前：
chap5_para1848,1,,思路是首先将ES(Start)赋值为0。
chap5_para1848,2,,然后，一旦我们得到了之前的所有动作都被赋过ES值的动作B，立刻就将ES(B)设置为那些在B之前的动作中最早完成时间的最大值，其中最早完成时间定义为最早开始时间加上持续时间。
chap5_para1848,3,,这个过程重复进行，直到每个动作都被赋予ES值。
chap5_para1848,4,,LS值以类似的方式，从Finish动作反向计算。
chap5_para1849,1,,关键路径算法的复杂度仅为O(Nb)，其中N为动作的数量，b为进入或退出动作的最大分支因子。
chap5_para1849,2,,（要弄懂这点，注意，每个动作LS和ES只计算一次，并且每次计算最多在b个其他动作上重复。
chap5_para1849,3,,）因此，给定动作的偏序且没有资源约束时，找出最小持续时间调度是相当容易的。
chap5_para185,1,•The minimum-remaining-values and degree heuristics are domain-independent methods for deciding which variable to choose next in a backtracking search. The least-constraining-value heuristic helps in deciding which value to try first for a given variable. Backtracking occurs when no legal assignment can be found for a variable. Conflict-directed backjumping backtracks directly to the source of the problem. Constraint learning records the conflicts as they are encountered during search in order to avoid the same conflict later in the search.,5.7　博弈搜索算法的局限性
chap5_para1850,1,,从数学上讲，关键路径问题很容易求解，因为它们被定义为在开始时间和结束时间上的线性不等式的合取。
chap5_para1850,2,,当我们引入资源约束时，在开始时间和结束时间上产生的约束将变得更加复杂。
chap5_para1850,3,,例如，在图11-14中同时开始的AddEngine动作需要同一个EngineHoist，因此不能重叠。
chap5_para1850,4,,“不可重叠”约束是两个线性不等式的析取，每个不等式对应一个可能的顺序。
chap5_para1850,5,,析取的引入使得有资源约束的调度变为NP困难问题。
chap5_para1851,1,,图11-15给出了最快完成时间为115分钟的解。
chap5_para1851,2,,这比没有资源约束的规划所需的85分钟长30分钟。
chap5_para1851,3,,注意，没有同时需要两名质检员的时间段，所以我们可以立即将其中一名质检员转到更有生产力的地方。
chap5_para1852,1,,图11-15　考虑资源约束时，图11-13的作业车间调度问题的解。
chap5_para1852,2,,左侧边列出了3个可复用的资源，动作与它们所使用的资源水平对齐。
chap5_para1852,3,,有两个可能的调度，取决于哪个装配首先使用发动机吊车；我们展示了持续时间最短的解，它需要115分钟
chap5_para1853,1,,关于最优调度的研究由来已久。
chap5_para1853,2,,"1963年提出的一个具有挑战性的问题——为一个只有10台机器和10个作业（每个作业有100个动作）的问题找到最优调度——在23年的时间里没有得到解决（Lawler et al., 1993）。"
chap5_para1853,3,,为求解这一问题已经尝试了许多方法，包括分支定界法、模拟退火法、禁忌搜索法和约束满足法。
chap5_para1853,4,,一种流行的方法是最小松弛（minimum slack）启发式：在每次迭代中，在尚未被调度的动作中调度尽可能早开始的动作，这个动作的前驱动作均已被调度并且有最小的松弛时间，然后更新每个受影响动作的ES和LS时间并重复。
chap5_para1853,5,,这种贪婪启发式类似于约束满足中的最小剩余值（MRV）启发式。
chap5_para1853,6,,它通常在实际中表现很好，但它对于我们的装配问题给出了一个130分钟的解决方案，而不是图11-15中的115分钟的解决方案。
chap5_para1854,1,,到目前为止，我们已经假设动作集和顺序约束是固定的。
chap5_para1854,2,,在这些假设下，每个调度问题都可以通过可避免所有资源冲突的不重叠序列来求解，只要每个动作本身是可行的。
chap5_para1854,3,,然而，如果一个调度问题被证明是非常困难的，那么以这种方式求解可能不是一个好主意，更好的方法是重新考虑动作和约束，也许会产生一个简单得多的调度问题。
chap5_para1854,4,,因此，通过在规划的构建过程中考虑持续时间和重叠部分来整合规划和调度是有意义的。
chap5_para1854,5,,11.2节中的几个规划算法可以被扩展用于处理这些信息。
chap5_para1855,1,,11.7　规划方法分析
chap5_para1856,1,,规划结合了人工智能的两个主要领域：搜索和逻辑。
chap5_para1856,2,,一个规划器可以被看作一个搜索解的程序，或者是一个（构造性地）证明解存在的程序。
chap5_para1856,3,,这两个领域的思想相互渗透，使规划器能够从动作和状态数量为十几个的玩具问题扩展到具有数百万状态和数千动作的实际工业应用。
chap5_para1857,1,,规划首先是一种控制组合爆炸的方法。
chap5_para1857,2,,如果一个领域中有n个命题，那么就有2n个状态。
chap5_para1857,3,,为应对这种悲观情况，找出独立子问题可能是一个强大的武器。
chap5_para1857,4,,最好情况下——问题完全可分解——我们得到指数级的加速。
chap5_para1857,5,,然而，动作之间的负相互作用破坏了可分解性。
chap5_para1857,6,,SATPlan可以编码子问题之间的逻辑关系。
chap5_para1857,7,,前向搜索通过尝试寻找能概括独立子问题的模式（命题的子集）来启发式地求解问题。
chap5_para1857,8,,由于这种方法是启发式的，即使子问题不完全独立它也有效。
chap5_para1858,1,,遗憾的是，我们还没有清楚地了解哪种技术对哪种类型的问题最有效。
chap5_para1858,2,,新技术很可能还会出现，也许会提供一种具有高度表现力的一阶表示和层次表示的整合，并具有当今占主导地位的高效因子化表示和命题化表示。
chap5_para1858,3,,我们可以看到一些组合（portfolio）规划系统正在出现，它们的算法集可用来求解任意给定的问题。
chap5_para1858,4,,这既可以是选择性的（系统对每个新问题进行分类以选择最佳算法），也可以是并行的（所有算法都同时运行在不同的CPU上），或者根据调度轮流运行算法。
chap5_para186,1,•Local search using the min-conflicts heuristic has also been applied to constraint satisfaction problems with great success.,计算复杂博弈中的最优决策是非常困难的，因此所有算法都必须做出一些假设和近似。
chap5_para186,2,,搜索使用启发式评价函数作为近似，而蒙特卡罗搜索计算随机选择的模拟的近似平均值。
chap5_para186,3,,选择哪种算法在一定程度上取决于每种博弈的特征：当分支因子较高或评价函数难以定义时，首选蒙特卡罗搜索。
chap5_para186,4,,但这两种算法都存在其基本的局限性。
chap5_para1860,1,,本章我们描述了经典规划问题和扩展规划问题的PDDL表示，并提出了几种求解的算法。
chap5_para1860,2,,本章需要记住以下要点。
chap5_para1861,1,,● 规划系统是在状态和动作的显式因子化表示下运作的求解算法。
chap5_para1861,2,,这些表示使得推导有效的领域无关的启发式和开发强大且灵活的问题求解算法成为可能。
chap5_para1862,1,,● 规划领域定义语言PDDL用文字的合取描述初始状态和目标状态，用行动的前提和效果描述行动。
chap5_para1862,2,,扩展表示时间、资源、感知、应变规划和分层规划。
chap5_para1863,1,,● 状态空间搜索可以前向（递归）或反向（回归）运行。
chap5_para1863,2,,有效的启发式可以通过子目标独立假设和规划问题的各种松弛来得到。
chap5_para1864,1,,● 其他方法包括将规划问题编码为布尔可满足性问题或约束满足问题，以及显式地搜索偏序规划空间。
chap5_para1865,1,,● 分层任务网络（HTN）规划允许智能体以高层动作（HLA）的形式从领域设计者那里获得建议，这些高层动作可以通过低层动作序列以各种方式实现。
chap5_para1865,2,,HLA的效果可以用天使语义来定义，它可以在不考虑低层实现的情况下导出可证明为正确的高层规划。
chap5_para1865,3,,HTN方法可以创建许多实际应用所需的大规模规划。
chap5_para1866,1,,● 应变规划允许智能体在执行过程中感知世界，以决定遵循规划的哪个分支。
chap5_para1866,2,,在某些情况下，可以使用无传感器规划或一致性规划来构建不需要感知就能运行的规划。
chap5_para1866,3,,通过对信念状态空间的搜索，可以构建一致性规划和应变规划。
chap5_para1866,4,,信念状态的高效表示或计算是关键问题。
chap5_para1867,1,,● 在线规划智能体根据需要使用执行监视和重返出错点的修复来从意外状况中恢复，这些意外情况可能是由于非确定性动作、外因事件或错误的环境模型造成的。
chap5_para1868,1,,● 许多动作消耗资源，如金钱、汽油或原料。
chap5_para1868,2,,将这些资源看作资源池中的数值而不试图去推理世界中的每枚硬币或钞票是更为方便的做法。
chap5_para1868,3,,时间是最重要的资源之一。
chap5_para1868,4,,它可以通过专门的调度算法来处理，也可以将调度与规划结合起来。
chap5_para1869,1,,● 本章扩展了经典的规划，以囊括非确定性环境（其中的动作结果是不确定的），但它并非规划的终章。
chap5_para1869,2,,第17章描述了用于随机环境的技术（在这种环境中，动作的结果具有相关的概率）：马尔可夫决策过程、部分可观测的马尔可夫决策过程和博弈论。
chap5_para1869,3,,在第22章中，我们展示了强化学习，它允许一个智能体从过去的成功和失败中学习如何行动。
chap5_para187,1,•The complexity of solving a CSP is strongly related to the structure of its constraint graph. Tree-structured problems can be solved in linear time. Cutset conditioning can reduce a general CSP to a tree-structured one and is quite efficient (requiring only linear memory) if a small cutset can be found. Tree decomposition techniques transform the CSP into a tree of subproblems and are efficient if the tree width of the constraint graph is small; however they need memory exponential in the tree width of the constraint graph. Combining cutset conditioning with tree decomposition can allow a better tradeoff of memory versus time.,搜索的一个局限性是它容易受到启发式函数的近似误差的影响。
chap5_para187,2,,图5-16为一个二层博弈树，极小化极大搜索会选择右边的分支，因为100 99。
chap5_para187,3,,如果所有的评估值都是精确的，那么这就是正确的选择。
chap5_para187,4,,但假设每个节点的评估值都有一个独立于其他节点的随机分布的误差，其标准差为s。
chap5_para187,5,,当s = 5时，实际上71%的情况下是左侧分支更好，当s = 2时，58%的情况下左侧分支更好（因为在这些情况下，右侧分支的4个叶节点之一可能小于99）。
chap5_para187,6,,如果评价函数中的误差不是独立的，那么发生错误的可能性更大。
chap5_para187,7,,这是很难避免的，因为我们没有一个很好的兄弟节点值之间依赖关系的模型。
chap5_para1872,1,,第四部分　不确定知识和不确定推理
chap5_para1873,1,,第12章　不确定性的量化
chap5_para1874,1,,在本章中，我们将看到智能体如何利用数值信念度来控制不确定性。
chap5_para1875,1,,12.1　不确定性下的动作
chap5_para1876,1,,由于部分可观测性、非确定性和对抗者的存在，真实世界中的智能体需要处理不确定性（uncertainty）。
chap5_para1876,2,,智能体可能永远都无法确切地知道它现在所处的状态，也无法知道一系列动作之后结束的位置。
chap5_para1877,1,,我们已经看到问题求解与逻辑智能体通过追踪信念状态（belief state）——所有它可能处于的世界状态的集合的表示——和生成应变规划（处理在执行期间传感器报告的每种可能的意外情况）来处理不确定性。
chap5_para1877,2,,这种方法适用于简单问题，它有如下缺点。
chap5_para1878,1,,● 无论可能性多么低，智能体都必须考虑传感器观测到的每种可能解释。
chap5_para1878,2,,这导致信念状态中可能存有大量不太可能发生的情况，进而导致信念状态非常庞大。
chap5_para1879,1,,● 一个要处理每种情况的恰当的应变规划必须考虑任何不太可能的情况，因此最终可能变得任意大。
chap5_para188,1,Bibliographical and Historical Notes,图5-16　启发式极小化极大算法可能出错的二层博弈树
chap5_para1880,1,,● 有时，可以保证达成目标的规划可能并不存在，但智能体必须行动。
chap5_para1880,2,,因此智能体必须有某种方式比较这些规划的优劣。
chap5_para1881,1,,例如，假定一辆自动驾驶出租车的目标是将乘客按时送到机场。
chap5_para1881,2,,该出租车制订了一个规划A90：在飞机起飞前90分钟出门，以合理的速度驶向机场。
chap5_para1881,3,,但即使距离机场仅8公里，逻辑智能体也不能完全确定地得出“A90规划能将我们及时送到机场”的结论。
chap5_para1881,4,,相反，这会得出某些较弱的结论：只要汽车不抛锚，没有被卷入交通事故，道路没有封闭，没有陨石砸中汽车等，A90规划就能将我们及时送到机场。
chap5_para1881,5,,这些条件都是不确定的，所以我们无法推断规划能否成功。
chap5_para1881,6,,这是逻辑资格问题（见7.7.1节），到目前为止我们还没有发现这一问题真正的解决方案。
chap5_para1882,1,,尽管如此，从某种意义上说，A90仍是正确的选择。
chap5_para1882,2,,这是什么意思呢？
chap5_para1882,3,,正如我们在第2章中讨论的那样，这里所说正确选择的含义是，在所有可执行的规划中，A90被期望能够最大化智能体的性能度量（这里的期望与智能体对环境的知识有关）。
chap5_para1882,4,,性能度量包括及时到达机场并赶上飞机、避免在机场漫长而徒劳的等待、避免路上的超速罚单。
chap5_para1882,5,,智能体的知识不能保证A90取得这些结果，但可以为取得这些结果提供一定程度的信念。
chap5_para1882,6,,A180等其他规划可能可以增加智能体对准时到达机场的信念，但它们同时也会增加漫长而无聊的等待的可能性。
chap5_para1882,7,,因此，正确的动作——理性决策（rational decision），既依赖各种目标的相对重要性，也依赖它们实现的可能性和程度。
chap5_para1882,8,,本节的其余部分将细化这些思想，为本章及后续章节中介绍的不确定推理和理性决策的一般理论做准备。
chap5_para1883,1,,12.1.1　不确定性概述
chap5_para1884,1,,让我们考虑一个不确定推理的例子：诊断一名牙科病人的牙痛（toothache）。
chap5_para1884,2,,无论是医疗、汽车修理，还是其他领域的诊断，几乎总是涉及不确定性。
chap5_para1884,3,,让我们尝试用命题逻辑为牙科诊断写一些规则，以便查看逻辑方法是如何失效的。
chap5_para1884,4,,考虑下面的简单规则：
chap5_para1885,1,,显然，这条规则是错的。
chap5_para1885,2,,不是所有牙痛患者的病因都是蛀牙（cavity）；也可能是因为牙龈炎（gum disease）、脓肿（abscess）或其他问题：
chap5_para1886,1,,遗憾的是，为了使这条规则正确，我们必须给出一个几乎无限长的可能问题的列表。
chap5_para1886,2,,我们可以把这条规则转换成一条因果规则：
chap5_para1887,1,,但这条规则也不正确，并非所有蛀牙都会引起牙痛。
chap5_para1887,2,,修正这条规则的唯一方式是在逻辑上穷举：在规则的左边加上蛀牙引发牙痛的所有所需条件。
chap5_para1887,3,,因此，试图用逻辑去处理医疗诊断这样的领域的问题是失败的，主要有3个原因。
chap5_para1888,1,,● 惰性（laziness）：为确保规则没有例外情况，所需列出的完整前提和结论的工作量太大，并且这样的规则也难以使用。
chap5_para1889,1,,● 理论无知（theoretical ignorance）：医学在这个领域没有完备的理论。
chap5_para189,1,"The Greek mathematician Diophantus (c. 200–284) presented and solved problems involving algebraic constraints on equations, although he didn’t develop a generalized methodology. We now call equations over integer domains Diophantine equations. The Indian mathematician Brahmagupta (c. 650) was the first to show a general solution over the domain of integers for the equation ax + by = c. Systematic methods for solving linear equations by variable elimination were studied by Gauss (1829); the solution of linear inequality constraints goes back to Fourier (1827).",搜索和蒙特卡罗搜索的第二个局限性是，它们都是设计用于计算合法移动的（边界）值的。
chap5_para189,2,,但有时其中一种移动显然是最佳的（例如，合法移动只有一种），在这种情况下，浪费时间计算它的值是没有意义的——最好是直接选择该移动。
chap5_para189,3,,更好的搜索算法应该使用节点扩展的效用值的思想，选择效用值高的节点扩展，所谓高效用值的节点是指，有可能导致算法发现一个明显更好的移动。
chap5_para189,4,,如果没有一个节点扩展的效用值高于它的代价（从时间上考虑），那么算法应该停止搜索并执行一个移动。
chap5_para189,5,,这不仅适用于存在明显更好移动的情况，也适用于对称情况，在这种情况下，再多的搜索也无法证明一种移动比另一种更好。
chap5_para1890,1,,● 实践无知（practical ignorance）：即使我们知道所有的规则，对于特定的病人，我们可能也无法得到确定的结论，因为不是所有需要的检测都已经完成或者能够被完成。
chap5_para1891,1,,牙痛和蛀牙之间的联系在任一方向都不是一个严格的逻辑结论。
chap5_para1891,2,,这是在医学领域的典型情况，法律、商业、设计、汽车修理、园艺、年代推断等大多数其他判断领域也是如此。
chap5_para1891,3,,智能体的知识至多只能提供对相关语句的信念度（degree of belief）。
chap5_para1891,4,,我们处理信念度的主要工具是概率论（probability theory）。
chap5_para1891,5,,用8.1节中的术语来说，逻辑和概率论的本体论承诺是相同的——世界是由在特定情况下成立或不成立的事实构成的，但是认识论承诺是不同的——逻辑智能体相信每个命题或对或错或不做评价，而概率智能体有着0（语句必定为假）和1（语句必定为真）之间的数值信念度。
chap5_para1892,1,,概率论提供了一种概括因我们的惰性与无知而产生的不确定性的方式，从而解决了资格问题。
chap5_para1892,2,,我们可能不能确定是什么病因在折磨着某个病人，但我们可以认为，以80%的机会，即0.8的概率，该牙痛患者存在蛀牙。
chap5_para1892,3,,也就是说，我们预计在所有和我们当前所知的情况无法区分的情况中，80%的病人有蛀牙。
chap5_para1892,4,,这种信念可以从统计数据中得到——到目前为止80%的牙痛病人有蛀牙——也可以从一些一般性的牙科知识或从不同来源的证据的整合中得到。
chap5_para1893,1,,令人困惑的是，在我们诊断的时候，真实世界中并没有不确定性：病人或是有蛀牙或是没有。
chap5_para1893,2,,所以蛀牙的概率是0.8是什么意思呢？
chap5_para1893,3,,难道不应该是非0即1吗？
chap5_para1893,4,,这个问题的答案是，概率陈述是根据知识状态而不是根据真实世界做出的。
chap5_para1893,5,,一开始，我们可以说：“假如病人牙痛，她有蛀牙的概率是0.8。
chap5_para1893,6,,”如果我们在后续过程中得知病人有牙龈炎史，我们可以做出不同的陈述：“假如病人牙痛并且有牙龈炎史，她有蛀牙的概率是0.4。
chap5_para1893,7,,”如果我们得到了进一步不支持蛀牙的确凿证据，我们可以说：“根据我们所掌握的知识，病人有蛀牙的概率几乎是0。
chap5_para1893,8,,”注意，这些陈述并不相互矛盾，它们是关于不同知识状态的单独断言。
chap5_para1894,1,,12.1.2　不确定性与理性决策
chap5_para1895,1,,让我们再次考虑前往机场的规划A90。
chap5_para1895,2,,假设它给了我们97%的机会赶上飞机，这意味着它是一个理性的选择吗？
chap5_para1895,3,,未必，可能其他规划有着更高的概率，例如A180。
chap5_para1895,4,,如果赶上飞机至关重要，那么冒着在机场等待更久的风险是值得的。
chap5_para1895,5,,那A1440，一个提前24小时离家的规划呢？
chap5_para1895,6,,在大多数情况下，这并不是一个好的选择，因为它尽管几乎保证了准时到达机场，但等待24小时实在是难以忍受——更不用说机场食物可能又贵又难吃。
chap5_para1896,1,,为了做出这样的选择，智能体必须首先在各种规划的不同可能结果（outcome）中有所偏好（preference）。
chap5_para1896,2,,结果是一个完全指定的状态，包括智能体是否按时到达和在机场等候的时间等因素。
chap5_para1896,3,,我们使用效用理论（utility theory）来表示偏好，并用它们进行定量推理。
chap5_para1896,4,,（这里utility是“有用的量”的意思，而非电力公司或者自来水厂等公共事业。
chap5_para1896,5,,）效用理论认为每个状态（或者状态序列）对智能体有一定程度的有用性，也就是效用，智能体偏好效用更高的状态。
chap5_para1897,1,,状态的效用是相对于智能体来说的。
chap5_para1897,2,,例如，在国际象棋游戏中，白棋将死黑棋的状态对执白棋的智能体的效用明显更高，但是对于执黑棋的智能体效用较低。
chap5_para1897,3,,但我们不能严格地按照国际象棋锦标赛规定的1、1/2和0分给效用赋值——一些棋手（包括本书作者）可能因与世界冠军平局而激动，而其他棋手（包括前世界冠军）可能并不会。
chap5_para1897,4,,口味和偏好是无法解释的：你可能认为一个偏好墨西哥胡椒泡泡糖冰激凌而非巧克力碎的智能体是古怪的，但我们不能说它是不理性的。
chap5_para1897,5,,效用函数可以解释任意偏好集合——奇特或典型、高贵或任性。
chap5_para1897,6,,注意，只要将他人的福利看作一个因素，效用就可以解释利他主义。
chap5_para1898,1,,在被称为决策论（decision theory）的理性决策的通用理论中，由效用表示的偏好与概率相结合：
chap5_para1899,1,,决策论 = 概率论 + 效用理论
chap5_para19,1,"There are many possible solutions to this problem, such as",● To-Move(s)：在状态s下，轮到其移动的参与者。
chap5_para190,1,"Finite-domain constraint satisfaction problems also have a long history. For example, graph coloring (of which map coloring is a special case) is an old problem in mathematics. The four-color conjecture (that every planar graph can be colored with four or fewer colors) was first made by Francis Guthrie, a student of De Morgan, in 1852. It resisted solution—despite several published claims to the contrary—until a proof was devised by Appel and Haken (1977) (see the book Four Colors Suffice (Wilson, 2004)). Purists were disappointed that part of the proof relied on a computer, so Georges Gonthier (2008), using the COQ theorem prover, derived a formal proof that Appel and Haken’s proof program was correct.",这种关于计算该做什么的推理叫作元推理（metareasoning）（关于推理的推理）。
chap5_para190,2,,它不仅适用于博弈，也适用于任意一种推理。
chap5_para190,3,,所有计算都是为了做出更好的决策，所有计算都有代价，并且都有可能导致决策质量的一定程度上的改进。
chap5_para190,4,,蒙特卡罗搜索的确尝试进行元推理，将资源分配给树中最重要的部分，但不是以最优方式。
chap5_para1900,1,,决策论的基本思想是，智能体是理性的当且仅当它选择平均所有可能结果后生成最高期望效用的动作。
chap5_para1900,2,,这被称为最大期望效用（maximum expected utility，MEU）原则。
chap5_para1900,3,,这里“期望”指使用结果的概率进行加权得到的结果效用的“平均”或者“统计平均”。
chap5_para1900,4,,我们在第5章中简略介绍过的西洋双陆棋的最优决策就是一个采用这一原则的具体例子。
chap5_para1900,5,,事实上，这是单智能体决策的一个完全通用的原则。
chap5_para1901,1,,图12-1概述了使用决策论来选择动作的智能体的结构。
chap5_para1901,2,,在抽象的层面上，这个智能体与在第4章和第7章中描述的维持反映迄今为止的感知历史的信念状态的智能体是相同的。
chap5_para1901,3,,主要的区别是决策论智能体的信念状态不仅表示世界状态的可能性，还表示了它们的概率。
chap5_para1901,4,,在给定信念状态和对动作结果的一些知识的情况下，智能体可以对动作结果进行概率预测，进而选择具有最高期望效用的动作。
chap5_para1902,1,,图12-1　选择理性动作的决策论智能体
chap5_para1903,1,,本章和第13章主要关注概率信息的表示与计算。
chap5_para1903,2,,第14章将讨论随着时间的推移表示和更新信念状态以及预测结果的方法。
chap5_para1903,3,,第15章将探讨将概率论与富有表达能力的形式语言（如一阶逻辑和通用编程语言）相结合的方法。
chap5_para1903,4,,第16章将更深入地介绍效用理论，第17章将详尽阐述随机环境下规划动作序列的算法。
chap5_para1903,5,,第18章将涵盖这些想法在多智能体环境下的扩展。
chap5_para1904,1,,12.2　基本概率记号
chap5_para1905,1,,为了让智能体能够表示和使用概率信息，我们需要一种形式语言。
chap5_para1905,2,,概率论语言实际上是非形式化的，它是由一些人类数学家写给另一些人类数学家的语言。
chap5_para1905,3,,附录A简单介绍了概率论的基本内容；这里我们采用了一种更适合人工智能需求的方式，并把它和形式逻辑的概念相联系。
chap5_para1906,1,,12.2.1　概率是关于什么的
chap5_para1907,1,,像逻辑断言一样，概率断言是关于可能世界的断言。
chap5_para1907,2,,逻辑断言讨论的是哪些可能世界被严格排除在外（所有那些逻辑断言为假的世界），而概率断言讨论的是各种世界的可能性有多大。
chap5_para1907,3,,在概率论中，所有可能世界的集合称为样本空间。
chap5_para1907,4,,这些可能世界是互斥的和穷举的——两个可能世界不能相同，每个可能世界都应考虑在内。
chap5_para1907,5,,"例如，如果我们掷两个（可区分的）骰子，一共需要考虑36个可能世界：(1, 1)、(1, 2)……(6, 6)。"
chap5_para1907,6,,希腊字母（大写omega）用来表示样本空间，（小写omega）用来表示空间中的元素，即特定的可能世界。
chap5_para1908,1,,一个完全指定的概率模型为每个可能世界赋予一个数值概率。
chap5_para1908,2,,[1]概率论基本公理规定每个可能世界具有一个0到1之间的概率，并且样本空间中的可能世界的总概率为1：
chap5_para191,1,Specific classes of constraint satisfaction problems occur throughout the history of computer science.,第三个局限性是搜索和蒙特卡罗搜索都是在单步移动的层级上进行所有推理的。
chap5_para191,2,"One of the most influential early examples was SKETCHPAD (Sutherland, 1963), which solved geometric constraints in diagrams and was the forerunner of modern drawing programs and CAD tools.",显然，这与人类玩游戏的方式不同：人类可以在更抽象的层级上进行推理，会考虑更高层级的目标（例如，诱捕对方的后），并使用该目标有选择地生成看似合理的规划。
chap5_para191,3,The identification of CSPs as a general class is due to Ugo Montanari (1974).,在第11章中，我们将学习这种类型的规划，在11.4节中，我们将介绍如何用从抽象表示到具体表示的层次结构进行规划。
chap5_para191,4,The reduction of higher-order CSPs to purely binary CSPs with auxiliary variables (see Exercise 5.,
chap5_para191,5,NARY) is due originally to the 19th-century logician Charles Sanders Peirce.,
chap5_para191,6,It was introduced into the CSP literature by Dechter (1990b) and was elaborated by Bacchus and van Beek (1998).,
chap5_para191,7,CSPs with preferences among solutions are studied widely in the optimization literature; see Bistarelli et al.,
chap5_para191,8,(1997) for a generalization of the CSP framework to allow for preferences.,
chap5_para1910,1,,[1]　现在我们假设一个离散可数的世界集合。
chap5_para1910,2,,对连续情况的适当处理会带来一些复杂的问题，这些问题与人工智能的大部分用途都不太相关。
chap5_para1912,1,,"例如，如果我们假设每个骰子是公平的且骰子间不会相互干扰，则每个可能世界(1, 1)、(1, 2)……(6, 6)的概率是1/36。"
chap5_para1912,2,,如果骰子是非公平的，则一些世界拥有更高的概率，一些世界的概率更低，但它们的和仍然为1。
chap5_para1913,1,,概率断言和查询往往不是关于某个特定可能世界的，而是关于它们的集合的。
chap5_para1913,2,,例如，我们可能询问两个骰子点数之和等于11的概率、点数相同的概率等。
chap5_para1913,3,,在概率论中，这些集合被称为事件——此处的“事件”与在第10章中被广泛使用的“事件”在概念上是不同的。
chap5_para1913,4,,在逻辑学中，一组世界的集合对应形式语言中的一个命题（proposition）；具体来说，对于每个命题，对应的集合只包含该命题成立的可能世界。
chap5_para1913,5,,（因此，“事件”和“命题”在这个背景下意思大体相同，只不过命题是用形式语言表达的。
chap5_para1913,6,,）命题的概率被定义为使它成立的世界的概率之和：
chap5_para1915,1,,"例如，当掷公平的骰子时，我们有P(Total = 11) = P((5, 6)) + P((6, 5)) = 1/36 + 1/36 = 1/18。"
chap5_para1915,2,,注意，概率论并不要求我们知道每个可能世界的概率的完整知识。
chap5_para1915,3,,例如，如果我们相信骰子合谋产生相同的数字，我们可能会断言P(doubles) = 1/4，而无须知道它们倾向于产生两个6还是两个2。
chap5_para1915,4,,就像逻辑断言一样，这个断言在没有完全确定底层概率模型的情况下对其做出了约束。
chap5_para1916,1,,像P(Total = 11)和P(doubles)这样的概率被称为无条件概率（unconditional probability）或者先验概率（prior probability，在英文中有时简写成priors）；它们指无任何其他信息下命题的信念度。
chap5_para1916,2,,但大多数情况下，我们会有一些已经透露的信息，通常称为证据（evidence）。
chap5_para1916,3,,例如，第一个骰子结果已经是5时，我们在屏息等待另一个骰子停下来。
chap5_para1916,4,,在这种情况下，我们感兴趣的不是两个骰子点数相同的无条件概率，而是给定第一个骰子是5的前提下两个骰子点数相同的条件概率（conditional probability）或者后验概率（posterior probability，在英文中有时简写成posteriors）。
chap5_para1916,5,,这个概率写作，这里“|”读作“给定”。
chap5_para1916,6,,[2]
chap5_para1918,1,,[2]　注意，“|”的优先级是：任何P(…|…)形式的表达式总是指P((…)|(…))。
chap5_para1919,1,,相似地，如果要去牙医那里做定期检查，则先验概率P(cavity) = 0.2可能是医生感兴趣的；如果是因为牙痛而去牙医那里，条件概率则更重要。
chap5_para192,1,"Constraint propagation methods were popularized by Waltz’s (1975) success on polyhedral line-labeling problems for computer vision. Waltz showed that in many problems, propagation completely eliminates the need for backtracking. Montanari (1974) introduced the notion of constraint graphs and propagation by path consistency. Alan Mackworth (1977) proposed the AC-3 algorithm for enforcing arc consistency as well as the general idea of combining backtracking with some degree of consistency enforcement. AC-4, a more efficient arc-consistency algorithm developed by Mohr and Henderson (1986), runs in O(cd2) worst-case time but can be slower than AC-3 on average cases. The PC-2 algorithm (Mackworth, 1977) achieves path consistency in much the same way that AC-3 achieves arc consistency.",第四个问题是能否将机器学习融入博弈搜索过程。
chap5_para192,2,,早期的游戏程序依靠人类的专业知识人为制定评价函数、开局库、搜索策略和高效技巧。
chap5_para192,3,,"我们才刚刚开始看到像AlphaZero这样的程序（Silver et al., 2018），它依赖于自我对弈的机器学习，而非人类在特定游戏上的专业知识。"
chap5_para192,4,,我们将从第19章开始深入探讨机器学习。
chap5_para1920,1,,理解在观测到牙痛后仍然有效是很重要的；只不过它不是特别有用。
chap5_para1920,2,,在做决策时，智能体需要依据所有已经观测到的证据。
chap5_para1920,3,,理解条件蕴涵和逻辑蕴涵的区别也很重要。
chap5_para1920,4,,断言 并不意味着“只要牙痛为真，则蛀牙为真的概率是0.6”，而是意味着“只要牙痛为真，而且我们没有进一步的信息，则蛀牙为真的概率是0.6”。
chap5_para1920,5,,额外的条件很重要；例如，如果我们有进一步的信息——牙医没有发现蛀牙，我们肯定不会得出蛀牙为真的概率是0.6，这时反而需要使用。
chap5_para1921,1,,在数学上，条件概率是利用如下无条件概率定义的：对任意命题a和b，
chap5_para1924,1,,如果记住“观测到b排除了所有其他b为假的可能世界，只留下总概率为P(b)的集合”，那么这个定义是很容易理解的。
chap5_para1924,2,,这个集合中，a为真的世界必须满足a∧b且在集合中所占的比例为P(a∧b) / P(b)。
chap5_para1925,1,,条件概率的定义，式（12-3）可以写成乘积法则（product rule）形式：
chap5_para1927,1,,乘积法则或许更容易记忆：为了a和b都为真，我们需要b为真，也需要在给定b的前提下a也为真。
chap5_para1928,1,,12.2.2　概率断言中的命题语言
chap5_para1929,1,,在本章和第13章中，描述可能世界集合的命题通常使用结合了命题逻辑元素和约束满足记号的记号来表示。
chap5_para1929,2,,在2.4.7节的术语中，这是因子化表示（factored representation），其中可能世界由“变量/值”对的集合来表示。
chap5_para1929,3,,如第15章所示，一种更富表达能力的结构化表示（structured representation）也是可能的。
chap5_para193,1,"Soon after Mackworth’s paper appeared, researchers began experimenting with the tradeoff between the cost of consistency enforcement and the benefits in terms of search reduction. Haralick and Elliott (1980) favored the minimal forward-checking algorithm described by McGregor (1979), whereas Gaschnig (1979) suggested full arc-consistency checking after each variable assignment—an algorithm later called MAC by Sabin and Freuder (1994). The latter paper provides somewhat convincing evidence that on harder CSPs, full arc-consistency checking pays off. Freuder (1978, 1982) investigated the notion of k-consistency and its relationship to the complexity of solving CSPs. Dechter and Dechter (1987) introduced directional arc consistency. Apt (1999) describes a generic algorithmic framework within which consistency propagation algorithms can be analyzed, and surveys are given by Bessière (2006) and Barták et al. (2010).",
chap5_para1930,1,,概率论中的变量被称为随机变量（random variable），它们的名字首字母大写。
chap5_para1930,2,,因此，在掷骰子的例子中，Total和Die1是随机变量。
chap5_para1930,3,,每个随机变量是从可能世界的定义域映射到值域（range）——可能的值的集合——的函数。
chap5_para1930,4,,两个骰子的Total的值域是集合，Die1的值域是。
chap5_para1930,5,,值的名字总是小写的，我们用表示X所有可能的值的概率之和。
chap5_para1930,6,,布尔随机变量的值域是。
chap5_para1930,7,,例如，两个骰子点数相同的命题可以写作Doubles = true。
chap5_para1930,8,,"［布尔变量的另一种值域是集合{0, 1}，这种情况下变量被称为具有伯努利（Bernoulli）分布］。"
chap5_para1930,9,,按照惯例，A = true形式的命题简写成a，A = false简写成。
chap5_para1930,10,,（12.2.1节中doubles、cavity和toothache使用的都是这种形式的缩写）。
chap5_para1931,1,,值域可以是任何符号的集合。
chap5_para1931,2,,我们可以把Age的值域设为集合，Weather的值域可能是。
chap5_para1931,3,,在没有歧义的情况下，通常使用值本身表示一个特定随机变量取该值的命题。
chap5_para1931,4,,因此，sun可以表示Weather = sun。
chap5_para1931,5,,[3]
chap5_para1933,1,,[3]　在对布尔变量的值a求和时，这些惯例的共同使用导致记号上的潜在歧义：P(a)是A成立的概率，然而在表达式 ∑aP(a)中它只指代A取一个值a的概率。
chap5_para1934,1,,在前面的例子中，我们都考虑值域有限的情形。
chap5_para1934,2,,变量也可以有离散（如整数）或连续（如实数）的无限值域。
chap5_para1934,3,,对于任何具有有序值域的变量，我们可以用不等式表示序关系，例如。
chap5_para1935,1,,最后，我们可以使用命题逻辑的联结词将这类基本命题（包括布尔变量的缩写形式）组合起来。
chap5_para1935,2,,例如，我们可以将“假设病人是一个没有牙痛的青少年，则她有蛀牙的概率是0.1”表述如下：
chap5_para1936,1,,在概率记号中，使用逗号表示合取也很常见，所以也可以写成。
chap5_para1937,1,,有时要讨论一个随机变量的所有可能的值，我们可以写作
chap5_para1939,1,,"这里粗斜体P表示结果是一个由数值组成的向量，并且我们在Weather值域上预先定义了顺序〈sun, rain, cloud, snow〉。"
chap5_para1939,2,,我们称P为随机变量Weather定义了一个概率分布（probability distribution），也就是为随机变量的每个可能的值分配了一个概率。
chap5_para1939,3,,［在有限离散值域的情况下，这个分布被称作分类分布（categorical distribution）］。
chap5_para1939,4,,"记号P也被用于条件分布：为每对可能的i, j给出的值。"
chap5_para194,1,Special methods for handling higher-order or global constraints were developed first within the context of constraint logic programming.,我们探讨了各种各样的博弈，以理解什么是最佳玩法以及如何在实际中玩好游戏，还了解了智能体在任意类型的对抗性环境中应该如何行动。
chap5_para194,2,Marriott and Stuckey (1998) provide excellent coverage of research in this area.,最重要的思想如下。
chap5_para194,3,"The Alldiff constraint was studied by Regin (1994), Stergiou and Walsh (1999), and van Hoeve (2001).",
chap5_para194,4,"There are more complex inference algorithms for Alldiff (see van Hoeve and Katriel, 2006) that propagate more constraints but are more computationally expensive to run.",
chap5_para194,5,Bounds constraints were incorporated into constraint logic programming by Van Hentenryck et al.,
chap5_para194,6,(1998).,
chap5_para194,7,A survey of global constraints is provided by van Hoeve and Katriel (2006).,
chap5_para1940,1,,对于连续变量，因为有无限多的值，不可能把整个分布写成向量。
chap5_para1940,2,,然而，我们可以定义随机变量的取值x的概率为以x为参数的函数，它通常被称为概率密度函数（probability density function，有时简写为pdf）。
chap5_para1940,3,,例如：
chap5_para1941,1,,表示中午的温度均匀地分布在18～26℃的信念。
chap5_para1942,1,,概率密度函数在意义上不同于离散分布。
chap5_para1942,2,,概率密度均匀分布在18～26℃意味着温度值落在这个8℃宽的区域内的某一点的机会是100%，落在任一个4℃宽的子区域内的机会是50%，以此类推。
chap5_para1942,3,,我们把连续随机变量X在x处的概率密度写作或P(x)。
chap5_para1943,1,,P(x)的直观定义是X落在以x起始的任意小区间内的概率除以区间宽度：
chap5_para1944,1,,对NoonTemp我们有
chap5_para1945,1,,这里C代表摄氏度（不是常数）。
chap5_para1945,2,,注意，在中，不是概率，而是概率密度。
chap5_para1945,3,,NoonTemp恰好为20.18C的概率是0，因为20.18C是宽度为0的区间。
chap5_para1945,4,,一些作者使用不同的符号表示离散概率和概率密度，我们使用P表示特定的概率值，而使用P表示两种情况中的数值的向量，因为很少出现混淆，公式通常是一样的。
chap5_para1945,5,,注意，概率是无单位数值，
chap5_para1946,1,,而密度函数是带单位度量的，这个例子中的单位是，即摄氏度的倒数。
chap5_para1946,2,,如果使用华氏度来表示相同的温度区间，它的宽度是14.4华氏度，密度是1/14.4F。
chap5_para1947,1,,除单变量的分布外，我们还需要多变量分布的记号。
chap5_para1947,2,,这里使用逗号来分隔不同变量。
chap5_para1947,3,,"例如，P(Weather, Cavity)表示Weather和Cavity所有组合值的概率。"
chap5_para1947,4,,这是一个4 × 2的概率表，称为Weather和Cavity的联合概率分布（joint probability distribution）。
chap5_para1947,5,,"我们也可以混合使用变量和具体值，如P(sun, Cavity)是一个二元向量，给出晴天时有蛀牙的概率和晴天时无蛀牙的概率。"
chap5_para1948,1,,记号P让某些表达式比一般符号更简洁。
chap5_para1948,2,,例如，Weather和Cavity所有可能值的乘积法则［式（12-4）］可以用一个等式表达：
chap5_para1949,1,,而不必写成如下的4×2 = 8个等式（此处使用缩写W和C）：
chap5_para195,1,Sudoku has become the most widely known CSP and was described as such by Simonis (2005). Agerbeck and Hansen (2008) describe some of the strategies and show that Sudoku on an n2 × n 2 board is in the class of NP-hard problems.,● 博弈可以由初始状态（棋盘如何设置）、每个状态下的合法动作、每个动作的结果、终止测试（说明什么时候博弈结束）以及应用于终止状态表明输赢和最终比分的效用函数定义。
chap5_para1950,1,,"作为退化情况，P(sun, cavity)没有变量，因此是一个零维向量，我们可以认为是标量。"
chap5_para1951,1,,现在我们已经定义了命题和概率断言的语法，给出了部分语义：式（12-2）把命题的概率定义为它成立的所有世界的概率之和。
chap5_para1951,2,,为了补全语义，我们需要说明世界是什么，如何确定一个世界中一个命题是否成立。
chap5_para1951,3,,我们直接从命题逻辑的语义中借鉴这一部分，如下所示。
chap5_para1951,4,,一个可能世界定义为所有考虑之中的随机变量的一种赋值。
chap5_para1952,1,,容易发现，这个定义满足可能世界互斥和穷举的基本要求（习题12.EXEX）。
chap5_para1952,2,,例如，如果随机变量是Cavity、Toothache和Weather，则有2×2×4 = 16个可能世界。
chap5_para1952,3,,此外，在这样的世界中，任何给定命题的真值都可以很容易地通过我们在命题逻辑中使用的递归真值计算来确定（见7.4节）。
chap5_para1953,1,,注意，有些随机变量可能是冗余的，因为在所有情况下它们的值都可以通过其他变量获得。
chap5_para1953,2,,例如，在两个骰子世界里，当Die1 = Die2时，变量Doubles恰好为真。
chap5_para1953,3,,除Die1和Die2外，增加Doubles作为一个随机变量似乎将可能世界的数量从36增加到72，但这72个中的一半在逻辑上是不可能的，概率为0。
chap5_para196,1,"In 1850, C. F. Gauss described a recursive backtracking algorithm for solving the 8- queens problem, which had been published in the German chess magazine Schachzeitung in 1848. Gauss called his method Tatonniren, derived from the French word tâtonner—to grope around, as if in the dark.",● 在具有完美信息的离散、确定性、轮流的双人零和博弈中，极小化极大算法可以通过对博弈树的深度优先枚举选出最优移动。
chap5_para197,1,"According to Donald Knuth (personal communication), R.",● 搜索算法可以计算出与极小化极大算法相同的最优移动，通过消除可证明与结果无关的子树来提高效率。
chap5_para197,2,J.,
chap5_para197,3,Walker introduced the term backtrack in the 1950s.,
chap5_para197,4,Walker (1960) described the basic backtracking algorithm and used it to find all solutions to the 13-queens problem.,
chap5_para197,5,"Golomb and Baumert (1965) formulated, with examples, the general class of combinatorial problems to which backtracking can be applied, and introduced what we call the MRV heuristic.",
chap5_para197,6,Bitner and Reingold (1975) provided an influential survey of backtracking techniques.,
chap5_para197,7,Brelaz (1979) used the degree heuristic as a tiebreaker after applying the MRV heuristic.,
chap5_para197,8,"The resulting algorithm, despite its simplicity, is still the best method for k-coloring arbitrary graphs.",
chap5_para197,9,Haralick and Elliott (1980) proposed the least-constraining-value heuristic.,
chap5_para198,1,"The basic backjumping method is due to John Gaschnig (1977, 1979).",● 通常，考虑整个博弈树是不可行的（即使是搜索），所以我们需要在某个点截断搜索，然后应用启发式评价函数估计状态的效用值。
chap5_para198,2,Kondrak and van Beek (1997) showed that this algorithm is essentially subsumed by forward checking.,
chap5_para198,3,Conflict-directed backjumping was devised by Prosser (1993).,
chap5_para198,4,"Dechter (1990a) introduced graph-based backjumping, which bounds the complexity of backjumping-based algorithms as a function of the constraint graph (Dechter and Frost, 2002).",
chap5_para199,1,A very general form of intelligent backtracking was developed early on by Stallman and Sussman (1977).,● 蒙特卡罗树搜索（MCTS）则是另一种方法，它不是通过应用启发式函数来评估状态，而是通过将游戏模拟到结束使用游戏规则来判断输赢。
chap5_para199,2,"Their technique of dependency-directed backtracking combines back-jumping with no-good learning (McAllester, 1990) and led to the development of truth maintenance systems (Doyle, 1979), which we discuss in Section 10.",因为在模拟过程中选择的移动可能不是最优移动，所以这个过程需要重复多次，对结果求平均值作为评估值。
chap5_para199,3,6.,
chap5_para199,4,2.,
chap5_para199,5,The connection between the two areas is analyzed by de Kleer (1989).,
chap5_para2,1,In which we see how treating states as more than just little black boxes leads to new search methods and a deeper understanding of problem structure.,在本章中，我们将讨论竞争环境（competitive environment），在这种环境中，两个或两个以上的智能体具有互相冲突的目标，这引出了对抗搜索（adversarial search）问题。
chap5_para2,2,,我们将专注于讨论博弈[1]，如国际象棋、围棋和扑克，而不是处理真实世界中的混乱冲突。
chap5_para2,3,,对人工智能研究人员来说，这些博弈的简化特性是一个优势：博弈状态很容易表示，智能体通常仅能执行少数几个动作，而且动作的效果由明确的规则定义。
chap5_para2,4,,对于体育比赛（如槌球和冰球），描述更加复杂，可能动作的范围更大，而且定义动作合法性的规则也不够明确。
chap5_para2,5,,除足球机器人外，体育比赛并没有引起人工智能社区的很大兴趣。
chap5_para20,1,"It can be helpful to visualize a CSP as a constraint graph, as shown in Figure 5.",● Actions(s)：在状态s下，全体合法移动的集合
chap5_para20,2,1(b).,
chap5_para20,3,"The nodes of the graph correspond to variables of the problem, and an edge connects any two variables that participate in a constraint.",
chap5_para200,1,"The work of Stallman and Sussman also introduced the idea of constraint learning, in which partial results obtained by search can be saved and reused later in the search.",● 许多游戏程序会预先计算开局和残局的最佳移动表，这样它们就可以直接查表而不用搜索。
chap5_para200,2,The idea was formalized by Dechter (1990a).,
chap5_para200,3,"Backmarking (Gaschnig, 1979) is a particularly simple method in which consistent and inconsistent pairwise assignments are saved and used to avoid rechecking constraints.",
chap5_para200,4,Backmarking can be combined with conflict-directed back-jumping; Kondrak and van Beek (1997) present a hybrid algorithm that provably subsumes either method taken separately.,
chap5_para201,1,"The method of dynamic backtracking (Ginsberg, 1993) retains successful partial assignments from later subsets of variables when backtracking over an earlier choice that does not invalidate the later success.",● 机会博弈可以通过期望极小化极大算法（极小化极大算法的扩展）来处理，该算法通过计算所有子节点的平均效用值并按每个子节点的概率加权来估计机会节点的平均效用值。
chap5_para201,2,Moskewicz et al.,
chap5_para201,3,(2001) show how these techniques and others are used to create an efficient SAT solver.,
chap5_para201,4,Empirical studies of several randomized backtracking methods were done by Gomes et al.,
chap5_para201,5,(2000) and Gomes and Selman (2001).,
chap5_para201,6,Van Beek (2006) surveys backtracking.,
chap5_para202,1,"Local search in constraint satisfaction problems was popularized by the work of Kirkpatrick et al. (1983) on simulated annealing (see Chapter 4), which is widely used for VLSI layout and scheduling problems. Beck et al. (2011) give an overview of recent work on jobshop scheduling. The min-conflicts heuristic was first proposed by Gu (1989) and was developed independently by Minton et al. (1992). Sosic and Gu (1994) showed how it could be applied to solve the 3,000,000 queens problem in less than a minute. The astounding success of local search using min-conflicts on the n-queens problem led to a reappraisal of the nature and prevalence of “easy” and “hard” problems. Peter Cheeseman et al. (1991) explored the difficulty of randomly generated CSPs and discovered that almost all such problems either are trivially easy or have no solutions. Only if the parameters of the problem generator are set in a certain narrow range, within which roughly half of the problems are solvable, do we find “hard” problem instances. We discuss this phenomenon further in Chapter 7.",● 在不完美信息博弈中，例如四国军棋和扑克，最佳玩法需要对每个玩家当前和将来的信念状态进行推理。
chap5_para202,2,,可以通过对缺失信息的每种可能配置上的动作值取平均得到一个简单的近似。
chap5_para203,1,"Konolige (1994) showed that local search is inferior to backtracking search on problems with a certain degree of local structure; this led to work that combined local search and inference, such as that by Pinkas and Dechter (1995). Hoos and Tsang (2006) provide a survey of local search techniques, and textbooks are offered by Hoos and Stützle (2004) and Aarts and Lenstra (2003).",● 在国际象棋、跳棋、黑白棋、围棋、扑克及许多其他游戏中，程序已经彻底击败了人类冠军选手。
chap5_para203,2,,在一些不完美信息博弈中人类仍然保持优势，如桥牌和四国军棋。
chap5_para203,3,,在像《星际争霸》和《刀塔2》这样的电子游戏中，程序可以与人类专家媲美，但它们的成功可能一部分要归功于它们可以快速执行许多动作的能力。
chap5_para204,1,"Work relating the structure and complexity of CSPs originates with Freuder (1985) and Mackworth and Freuder (1985), who showed that search on arc-consistent trees works without any backtracking.",
chap5_para204,2,"A similar result, with extensions to acyclic hypergraphs, was developed in the database community (Beeri et al.",
chap5_para204,3,", 1983).",
chap5_para204,4,Bayardo and Miranker (1994) present an algorithm for tree-structured CSPs that runs in linear time without any preprocessing.,
chap5_para204,5,Dechter (1990a) describes the cycle-cutset approach.,
chap5_para205,1,"Since those papers were published, there has been a great deal of progress in developing more general results relating the complexity of solving a CSP to the structure of its constraint graph.",微信扫码关注【异步社区】微信公众号，回复“e59810”获取本书配套资源以及异步社区15天VIP会员卡，近千本电子书免费畅读。
chap5_para205,2,The notion of tree width was introduced by the graph theorists Robertson and Seymour (1986).,
chap5_para205,3,"Dechter and Pearl (1987, 1989), building on the work of Freuder, applied a related notion (which they called induced width but is identical to tree width) to constraint satisfaction problems and developed the tree decomposition approach sketched in Section 5.",
chap5_para205,4,5.,
chap5_para206,1,"Drawing on this work and on results from database theory, Gottlob et al. (1999a, 1999b) developed a notion, hypertree width, that is based on the characterization of the CSP as a hypergraph. In addition to showing that any CSP with hypertree width w can be solved in time O(nw+1 log n), they also showed that hypertree width subsumes all previously defined measures of “width” in the sense that there are cases where the hypertree width is bounded and the other measures are unbounded.",第6章　约束满足问题
chap5_para207,1,The RELSAT algorithm of Bayardo and Schrag (1997) combined constraint learning and backjumping and was shown to outperform many other algorithms of the time.,在本章中，我们不把状态仅仅当作小黑盒，从而导出新的搜索方法和对问题结构的更深入理解。
chap5_para207,2,"This led to AND-OR search algorithms applicable to both CSPs and probabilistic reasoning (Dechter and Mateescu, 2007).",
chap5_para207,3,Brown et al.,
chap5_para207,4,"(1988) introduce the idea of symmetry breaking in CSPs, and Gent et al.",
chap5_para207,5,(2006) give a survey.,
chap5_para208,1,"The field of distributed constraint satisfaction looks at solving CSPs when there is a collection of agents, each of which controls a subset of the constraint variables.",第3章和第4章讨论了通过搜索状态空间进行问题求解的思想：状态空间是一个由节点表示状态，边表示动作的图。
chap5_para208,2,"There have been annual workshops on this problem since 2000, and good coverage elsewhere (Collin et al.",我们看到，领域特定的启发式算法可以估计从给定状态到达目标的代价，但从搜索算法的角度来看，每个状态都是原子的，即不可分割的——一个没有内部结构的黑盒。
chap5_para208,3,", 1999; Pearce et al.",对于每个问题，我们需要领域特定的代码来描述状态之间的转移。
chap5_para208,4,", 2008).",
chap5_para209,1,"Comparing CSP algorithms is mostly an empirical science: few theoretical results show that one algorithm dominates another on all problems; instead, we need to run experiments to see which algorithms perform better on typical instances of problems. As Hooker (1995) points out, we need to be careful to distinguish between competitive testing—as occurs in competitions among algorithms based on run time—and scientific testing, whose goal is to identify the properties of an algorithm that determine its efficacy on a class of problems.",在本章中，我们通过对每个状态使用因子化表示（factored representation）来打破黑盒：因子化表示为一组变量，每个变量都有自己的值。
chap5_para209,2,,当每个变量的值都满足对该变量的所有约束时，问题就解决了。
chap5_para209,3,,以上述方式描述的问题称为约束满足问题（constraint satisfaction problem，CSP）。
chap5_para21,1,Why formulate a problem as a CSP?,"● Result(s, a)：转移模型，定义状态s下执行动作a所产生的结果状态。"
chap5_para21,2,One reason is that the CSPs yield a natural representation for a wide variety of problems; it is often easy to formulate a problem as a CSP.,
chap5_para21,3,Another is that years of development work have gone into making CSP solvers fast and efficient.,
chap5_para21,4,A third is that a CSP solver can quickly prune large swathes of the search space that an atomic state-space searcher cannot.,
chap5_para21,5,"For example, once we have chosen {SA = blue} in the Australia problem, we can conclude that none of the five neighboring variables can take on the value blue.",
chap5_para21,6,"A search procedure that does not use constraints would have to consider 35 = 243 assignments for the five neighboring variables; with constraints we have only 25 = 32 assignments to consider, a reduction of 87%.",
chap5_para210,1,"The textbooks by Apt (2003), Dechter (2003), Tsang (1993), and Lecoutre (2009), and the collection by Rossi et al. (2006), are excellent resources on constraint processing. There are several good survey articles, including those by Dechter and Frost (2002), and Barták et al. (2010). Carbonnel and Cooper (2016) survey tractable classes of CSPs. Kondrak and van Beek (1997) give an analytical survey of backtracking search algorithms, and Bacchus and van Run (1995) give a more empirical survey. Constraint programming is covered in the books by Apt (2003) and Fruhwirth and Abdennadher (2003). Papers on constraint satisfaction appear regularly in Artificial Intelligence and in the specialist journal Constraints; the latest SAT solvers are described in the annual International SAT Competition. The primary conference venue is the International Conference on Principles and Practice of Constraint Programming, often called CP.",CSP搜索算法利用了状态结构的优势，并且使用通用的而不是领域特定的启发式算法来求解复杂问题。
chap5_para210,2,,其主要思想是，通过识别违反约束的变量/值组合来一次性消除大部分搜索空间。
chap5_para210,3,,CSP的另一个优势是可以从问题描述中推导出行动和转移模型。
chap5_para211,1,"1We have been using the term “edge” rather than “arc,” so it would make more sense to call this “edge-consistent,” but the name “arc-consistent” is historical.",6.1　定义约束满足问题
chap5_para212,1,2Local search can easily be extended to constrained optimization problems (COPs).,约束满足问题由3个部分组成，即X、D和C。
chap5_para212,2,"In that case, all the techniques for hill climbing and simulated annealing can be applied to optimize the objective function.",
chap5_para213,1,"3A careful cartographer or patriotic Tasmanian might object that Tasmania should not be colored the same as its nearest mainland neighbor, to avoid the impression that it might be part of that state.",
chap5_para214,1,"4Sadly, very few regions of the world have tree-structured maps, although Sulawesi comes close.",● D是域集合，，每个变量有一个域。
chap5_para215,1,,● C是约束集合，用来规定允许的值的组合。
chap5_para216,1,,域Di，由变量Xi的一组允许的值组成。
chap5_para216,2,,例如，布尔变量的域为。
chap5_para216,3,,不同变量可以有不同大小的域。
chap5_para216,4,,每个约束Cj由对组成，其中scope是该约束中的变量元组，而rel定义了这些值应该满足的关系（relation）。
chap5_para216,5,,关系可以表示为满足约束的所有元组值的显式集合，或者表示为判断一个元组是否为关系成员的函数。
chap5_para216,6,,"例如，如果X1和X2的域都是{1, 2, 3}，那么约束“X1必须大于X2”可以表示为或。"
chap5_para217,1,,CSP要处理变量赋值（assignment）问题，即。
chap5_para217,2,,不违反任何约束的赋值称为一致（consistent）或合法赋值。
chap5_para217,3,,完整赋值（complete assignment）是指每个变量都已被赋值；CSP的解（solution）是一致完整赋值。
chap5_para217,4,,部分赋值（partial assignment）是指某些变量还未赋值，而部分解（partial solution）是一致部分赋值。
chap5_para217,5,,一般来说，CSP求解是NP完全问题，尽管CSP的一些重要子类已经可以非常高效地求解。
chap5_para218,1,,6.1.1　问题示例：地图着色
chap5_para219,1,,也许你已经逛够了罗马尼亚，现在来看看澳大利亚地图（如图6-1a所示）[1]，地图显示了澳大利亚的州和地区，分别是：西澳大利亚州（Western Australia）、北部地区（North Territory）、昆士兰州（Queensland）、新南威尔士州（New South Wales）、维多利亚州（Victoria）、南澳大利亚州（South Australia）、塔斯马尼亚州（Tasmania）、澳大利亚首都直辖区（Australia Capital Territory）。
chap5_para219,2,,我们的任务是给每个区域涂上红色、绿色或蓝色，要求相邻的两个区域颜色不能相同。
chap5_para219,3,,[2]为了将其形式化为CSP，我们将图中的区域定义为变量，变量名为各区域的英文名缩写：
chap5_para22,1,"In atomic state-space search we can only ask: is this specific state a goal? No? What about this one? With CSPs, once we find out that a partial assignment violates a constraint, we can immediately discard further refinements of the partial assignment. Furthermore, we can see why the assignment is not a solution—we see which variables violate a constraint—so we can focus attention on the variables that matter. As a result, many problems that are intractable for atomic state-space search can be solved quickly when formulated as a CSP.",● Is-Terminal(s)：终止测试（terminal test），博弈结束时返回真，否则返回假。
chap5_para22,2,,博弈结束时的状态称为终止状态（terminal state）。
chap5_para221,1,,[1]　本图系原书原图。
chap5_para222,1,,[2]　本书未将澳大利亚首都直辖区作为一个待着色区域，这使该地图着色问题更简洁明晰。
chap5_para222,2,,——编者注
chap5_para223,1,,每个变量的域为集合。
chap5_para223,2,,约束要求相邻区域颜色不同。
chap5_para223,3,,由于相邻区域的边界线有9段，所以有9个约束：
chap5_para224,1,,这里我们使用缩写。
chap5_para224,2,,是的缩写，其中可以依次完整枚举为：
chap5_para225,1,,这个问题有很多可能的解，例如：
chap5_para226,1,,将CSP可视化为约束图（constraint graph）非常有用，如图6-1b所示。
chap5_para226,2,,图的节点对应于问题的变量，图的边连接同一约束中的任意两个变量。
chap5_para227,1,,为什么要将问题形式化为CSP呢？
chap5_para227,2,,第一个原因是CSP可以自然地表示各种问题，将一个问题形式化为CSP通常很容易；第二个原因是多年的研究工作使得CSP求解器快速而高效；第三个原因是相比于原子的状态空间搜索器，CSP求解器可以快速消除大面积搜索空间。
chap5_para227,3,,例如，一旦我们在澳大利亚问题中选择了，就可以得出结论，它的5个相邻变量都不能取值为blue。
chap5_para227,4,,不使用约束的搜索过程必须考虑这5个相邻变量的35 = 243种赋值；有了约束，我们只需考虑25 = 32种赋值，计算量减少了87%。
chap5_para228,1,,图6-1　（a）澳大利亚的州和地区。
chap5_para228,2,,对该地图着色可以看作约束满足问题（CSP）。
chap5_para228,3,,目标是为每个区域分配颜色，使得相邻区域颜色不同。
chap5_para228,4,,（b）用约束图表示地图着色问题
chap5_para229,1,,在原子的状态空间搜索中，我们只能问：这个特定状态是目标状态吗？
chap5_para229,2,,不是？
chap5_para229,3,,那么这一个呢？
chap5_para229,4,,使用CSP，一旦发现某个部分赋值违反了约束，我们可以马上放弃对该部分赋值的进一步改进。
chap5_para229,5,,此外，我们可以看出为什么某个赋值不是解——可以看出哪些变量违反了约束——从而把注意力集中在关键变量上。
chap5_para229,6,,因此，许多原子状态空间搜索难以求解的问题形式化为CSP后都可以快速求解。
chap5_para23,1,5.,"● Utility(s, p)：效用函数（也称为目标函数或收益函数），定义博弈结束时终止状态s下参与者p得到的最终的数值收益。"
chap5_para23,2,1.,在国际象棋中，结果为赢、输或平局，收益分别为1、0或1/2。
chap5_para23,3,2Example problem: Job-shop scheduling,[4]一些博弈存在更大范围的可能结果，例如，西洋双陆棋的收益范围为0～192。
chap5_para230,1,,6.1.2　问题示例：车间作业调度
chap5_para231,1,,工厂有很多日常工作调度问题，要满足各种约束。
chap5_para231,2,,在实践中，使用CSP技术可以求解很多这样的问题。
chap5_para231,3,,考虑汽车装配调度问题。
chap5_para231,4,,整个作业由不同任务组成，我们可以将每个任务建模成一个变量，其中每个变量的值为任务开始时间，由整数分钟数表示。
chap5_para231,5,,约束为“一个任务必须在另一个任务之前完成”（例如，安装车轮必须在安装轮毂盖之前完成）和“一次只能同时执行一定数量的任务”等断言。
chap5_para231,6,,约束还可以指定任务完成所需的时间。
chap5_para232,1,,我们考虑汽车装配的一小部分环节，包括15个任务：安装轮轴（axle）（前、后），固定4个车轮（wheel）（左和右、前和后），拧紧每个车轮的螺母（nuts），固定轮毂盖（cap），并检查（inspect）最终装配。
chap5_para232,2,,我们可以将任务表示为15个变量：
chap5_para233,1,,接着，我们需要表示各个任务间的优先约束（precedence constraint）。
chap5_para233,2,,当任务T1必须在T2之前完成且任务T1所需时间为d1时，我们将添加一个如下形式的算术约束：
chap5_para234,1,,在这个示例中，轮轴必须在车轮安装前到位，安装一个轮轴需要10分钟，所以有
chap5_para235,1,,接下来，我们必须固定每个车轮（需要1分钟），拧紧螺母（2分钟），最后安装轮毂盖（1分钟，但暂未表示）：
chap5_para236,1,,假设有4个工人来安装车轮，但他们必须共用一个工具来辅助安装轮轴。
chap5_para236,2,,此时我们需要一个析取约束（disjunctive constraint）表示AxleF和AxleB在时间上不能重叠：要么先做AxleF，要么先做AxleB：
chap5_para237,1,,这一约束看起来更加复杂，结合了算术约束和逻辑约束。
chap5_para237,2,,但它仍可以简化为AxleF和AxleB可以取的一组值。
chap5_para238,1,,我们还需要说明，检查是最后一项任务，需要3分钟。
chap5_para238,2,,对于除Inspect外的每个变量，我们都需要添加一个形式的约束。
chap5_para238,3,,最后，假设我们需要在30分钟内完成整个装配任务。
chap5_para238,4,,因此，所有变量的域被限制为
chap5_para239,1,,这一特定问题的求解非常琐碎，但CSP已经成功地应用于此类具有几千个变量的车间作业调度问题。
chap5_para24,1,"Factories have the problem of scheduling a day’s worth of jobs, subject to various constraints. In practice, many of these problems are solved with CSP techniques. Consider the problem of scheduling the assembly of a car. The whole job is composed of tasks, and we can model each task as a variable, where the value of each variable is the time that the task starts, expressed as an integer number of minutes. Constraints can assert that one task must occur before another—for example, a wheel must be installed before the hubcap is put on—and that only so many tasks can go on at once. Constraints can also specify that a task takes a certain amount of time to complete.",
chap5_para240,1,,6.1.3　CSP形式体系的变体
chap5_para241,1,,"最简单的CSP所涉及的变量具有离散有限域（discrete, finite domain）。"
chap5_para241,2,,地图着色问题和带有时间限制的调度问题都属于这类问题。
chap5_para241,3,,8皇后问题（图4-3）也可以看作是一个有限域CSP，其中变量对应第1～8列中的皇后，每个变量的域为该列皇后可能的行号，。
chap5_para241,4,,约束为不允许两个皇后在同一行或同一对角线上。
chap5_para242,1,,离散域也可以是无限的（infinite），例如整数集或字符串集。
chap5_para242,2,,（如果我们不对作业调度问题设置截止时间，那么每个变量的开始时间构成的域将是无限的。
chap5_para242,3,,）对于无限域，我们必须使用类似这样的隐式约束，而不是显式的值元组。
chap5_para242,4,,对于整数变量的线性约束（linear constraint）（像刚刚给出的约束一样，每个变量都只以线性形式出现）存在特殊的求解算法（在这里不讨论）。
chap5_para242,5,,可以证明，不存在求解整数变量上一般非线性约束（nonlinear constraint）的算法——这个问题是不可判定的。
chap5_para243,1,,连续域（continuous domain）约束满足问题是真实世界中的常见问题，在运筹学领域得到了广泛研究。
chap5_para243,2,,例如，哈勃太空望远镜的实验调度需要非常精确的观测时间，每次观测和机动的开始时间、结束时间都是连续值变量，必须服从各种天文的、优先级的和电力的约束。
chap5_para243,3,,最著名的一类连续域CSP是线性规划问题，其约束必须为线性等式或不等式。
chap5_para243,4,,线性规划（linear programming）问题可以在关于变量个数的多项式时间内求解。
chap5_para243,5,,此外人们还研究了具有不同类型约束和目标函数的问题——二次规划、二阶锥规划等。
chap5_para243,6,,这些问题构成了应用数学的一个重要领域。
chap5_para244,1,,除了检查CSP中变量的类型以外，检查约束的类型也是很有用。
chap5_para244,2,,最简单的类型是一元约束（unary constraint），它限制单个变量的值。
chap5_para244,3,,例如，在地图着色问题中，南澳大利亚州人可能不喜欢绿色，我们可以用一元约束表示。
chap5_para244,4,,（变量的域的初始说明也可以看作一元约束。
chap5_para244,5,,）
chap5_para245,1,,二元约束（binary constraint）关系到两个变量。
chap5_para245,2,,例如，是一个二元约束。
chap5_para245,3,,二元CSP（binary CSP）只存在一元约束和二元约束，可以用如图6-1b所示的约束图表示。
chap5_para246,1,,我们也可以定义高阶约束。
chap5_para246,2,,"例如，三元约束Between(X, Y, Z)可以定义为。"
chap5_para247,1,,包含任意个数变量的约束称为全局约束（global constraint）。
chap5_para247,2,,（这个名称很传统，但容易混淆，因为它不需要包含问题中的所有变量）。
chap5_para247,3,,最常见的全局约束之一是Alldiff，它表示约束中涉及的所有变量必须具有不同的值。
chap5_para247,4,,在数独问题中（见6.2.6节），一行、一列或3×3框中的所有变量必须满足Alldiff约束。
chap5_para248,1,,另一个例子是密码算术（cryptarithmetic）谜题（图6-2a）。
chap5_para248,2,,密码算术谜题中的每个字母代表一个不同数字。
chap5_para248,3,,"图6-2a中的情况，将表示为全局约束Alldiff(F, T, U, W, R, O)。"
chap5_para248,4,,4列上的加法约束可以写成如下n元约束：
chap5_para249,1,,其中C1、C2和C3为辅助变量，表示十位、百位或千位上的进位数。
chap5_para249,2,,这些约束可以用约束超图（constraint hypergraph）表示，如图6-2b所示。
chap5_para249,3,,超图由普通节点（图中的圆圈）和表示n元约束的超节点（正方形）组成，n元约束为包含n个变量的约束。
chap5_para25,1,"We consider a small part of the car assembly, consisting of 15 tasks: install axles (front and back), affix all four wheels (right and left, front and back), tighten nuts for each wheel, affix hubcaps, and inspect the final assembly.",[4]　国际象棋被认为是一种“零和”游戏，尽管两个选手每局游戏的结果之和为+1，而不是0。
chap5_para25,2,We can represent the tasks with 15 variables:,“常量和”是一个更准确的术语，但“零和”更传统，你可以将其看作每个选手被收取了1/2的入场费。
chap5_para250,1,,图6-2　（a）密码算术问题。
chap5_para250,2,,不同字母表示不同数字，目的是找到使加法算式成立的代替字母的数字，附加约束为不允许前导零。
chap5_para250,3,,（b）密码算术问题的约束超图，用来表示Alldiff约束（最上面的方框）以及每列的加法约束（中间的4个方框）。
chap5_para250,4,,变量C1、C2和C3表示从右到左3列的进位数
chap5_para251,1,,或者，正如习题6.NARY需要你证明的，如果引入足够多的辅助变量，每个有限域约束都可以简化为一组二元约束。
chap5_para251,2,,这意味着我们可以将任意一个CSP转换为只有二元约束的CSP，这将使算法设计变得更加简单。
chap5_para251,3,,将n元CSP转换为二元CSP的另一种方式是对偶图（dual graph）变换：创建一个新图，原图中的每个约束用新图中的一个变量表示，原图中的每对共享变量的约束用新图中的一个二元约束表示。
chap5_para252,1,,例如，考虑变量为的CSP，每个变量的域为，带有两个约束和。
chap5_para252,2,,对偶图的变量则为，对偶图中C1变量的域为原问题C1约束中的元组的集合，同样地，C2的域是元组的集合。
chap5_para252,3,,对偶图具有二元约束，其中R1是定义C1和C2之间约束的新关系。
chap5_para252,4,,在这种情况下，。
chap5_para253,1,,然而，我们可能更喜欢Alldiff这样的全局约束，而不是一组二元约束，这有两个原因。
chap5_para253,2,,首先，使用Alldiff描述问题更简单而且更不容易出错。
chap5_para253,3,,其次，可以为全局约束设计相比于基元约束更有效的专用推理算法。
chap5_para253,4,,我们将在6.2.5节介绍这些推理算法。
chap5_para254,1,,到目前为止，我们所描述的约束都是绝对约束，违反这些约束的可能解将被排除。
chap5_para254,2,,许多真实世界的CSP包含偏好约束（preference constraint），偏好约束规定哪些解是首选的。
chap5_para254,3,,例如，在大学排课问题中，存在绝对约束，如一个教授不可以同时上两门课。
chap5_para254,4,,但也可能存在偏好约束：R教授可能更喜欢在上午上课，而N教授更喜欢在下午上课。
chap5_para254,5,,让R教授在下午2点上课仍是一个可行解（除非R教授碰巧是系主任），但不是最优解。
chap5_para255,1,,偏好约束通常可以编码为个别变量赋值的代价。
chap5_para255,2,,例如，为R教授分配一个下午时段相对于总体目标函数的代价为2分，而分配上午时段的代价为1分。
chap5_para255,3,,通过这样的形式化，带偏好约束的CSP可以用基于路径的或局部的优化搜索方法求解。
chap5_para255,4,,我们称这样的问题为约束优化问题（constrained optimization problem，COP）。
chap5_para255,5,,线性规划是一类COP。
chap5_para256,1,,6.2　约束传播：CSP中的推断
chap5_para257,1,,原子的状态空间搜索算法只有一种方式：通过扩展节点来访问后继节点。
chap5_para257,2,,CSP算法有不同选择。
chap5_para257,3,,它可以通过选择一个新的变量赋值来生成后继，或者执行一种称为约束传播（constraint propagation）的特定类型推断：使用约束减少一个变量的合法值的数量，这反过来又可以减少另一个变量的合法值，以此类推。
chap5_para257,4,,其思想是，通过这一过程，当我们选择下一个变量赋值时，需要考虑的选项会减少。
chap5_para257,5,,约束传播可以与搜索交替进行，也可以作为搜索开始前的预处理步骤。
chap5_para257,6,,有时这种预处理就可以求解整个问题，所以根本不需要搜索。
chap5_para258,1,,约束传播的核心思想是局部一致性（local consistency）。
chap5_para258,2,,如果我们将每个变量看作图中的一个节点（见图6-1b），将每个二元约束看作一条边，则增强图中每一部分局部一致性的过程会导致整个图中不一致的值被删除。
chap5_para258,3,,局部一致性有几种不同类型，我们现在依次介绍。
chap5_para259,1,,6.2.1　节点一致性
chap5_para26,1,"Next, we represent precedence constraints between individual tasks.",同第3章一样，初始状态、Actions函数和Result函数定义了状态空间图（state space graph）——在图中，顶点表示状态，边表示移动，一个状态可以通过多条路径到达。
chap5_para26,2,"Whenever a task T1 must occur before task T2, and task T1 takes duration d1 to complete, we add an arithmetic constraint of the form",如第3章所述，我们可以在图的一部分上叠加搜索树（search tree）以确定下一步移动。
chap5_para26,3,,我们将完整的博弈树（game tree）定义为搜索树，它会记录每个一直到终止状态的移动序列。
chap5_para26,4,,如果状态空间本身是无界的，或者博弈规则允许局面可以无限次重复，那么博弈树可能是无限的。
chap5_para260,1,,如果单个变量的域中的所有值都满足该变量的一元约束，则该变量（对应于CSP图中的某个节点）是节点一致的。
chap5_para260,2,,例如，在澳大利亚地图着色问题（图6-1）的变体中，南澳大利亚州人不喜欢绿色，变量SA的初始域为，可以通过删除green使其保持节点一致，SA的域缩减为。
chap5_para260,3,,如果图中的每个变量都是节点一致的，那么整个图是节点一致的。
chap5_para261,1,,在求解过程开始时，通过缩减具有一元约束的变量的域，可以很容易地消除CSP中的所有一元约束。
chap5_para261,2,,如前文所述，还可以将所有n元约束转换为二元约束。
chap5_para261,3,,因此，一些CSP求解器只处理二元约束，要求用户提前消除其他约束。
chap5_para261,4,,除非特别说明，本章的剩余部分都基于这一假设。
chap5_para262,1,,6.2.2　弧一致性
chap5_para263,1,,如果CSP中某一变量的域内的所有值都满足该变量的二元约束，那么该变量就是弧一致的（arc consistent）[3]。
chap5_para263,2,,"更正式地说，对于变量Xi、Xj，如果对于当前域Di中的每个值，Dj中都存在一些值满足弧(Xi, Xj)上的二元约束，则称Xi相对于Xj是弧一致的。"
chap5_para263,3,,如果每个变量相对所有其他变量都是弧一致的，那么这个图就是弧一致的。
chap5_para263,4,,例如，考虑约束Y = X2，其中X和Y的域都是十进制数字。
chap5_para263,5,,我们可以将这一约束显式地写为。
chap5_para263,6,,"为了使X相对于Y弧一致，我们将X的域缩减为{0, 1, 2, 3}。"
chap5_para263,7,,"如果要使Y相对于X弧一致，那么Y的域为{0, 1, 4, 9}，此时整个CSP是弧一致的。"
chap5_para263,8,,但是，弧一致性对澳大利亚地图着色问题没有任何帮助。
chap5_para263,9,,"考虑(SA, WA)的如下不同色约束："
chap5_para265,1,,[3]　我们一直使用的术语是“边”而不是“弧”，所以将其称为“边一致”会更合适，但历史上使用的术语是“弧一致”。
chap5_para266,1,,无论为SA（或WA）选择哪个值，另一变量都存在一个有效值。
chap5_para266,2,,所以应用弧一致性对两个变量的域都没有影响。
chap5_para267,1,,最流行的增强弧一致性的算法为AC-3（见图6-3）。
chap5_para267,2,,为了使每个变量保持弧一致，AC-3算法将维护一个弧队列。
chap5_para267,3,,初始时，队列包含CSP中的所有弧。
chap5_para267,4,,（每个二元约束都有两条弧，每个方向各一条。
chap5_para267,5,,"）然后AC-3从队列中弹出任意一条弧(Xi, Xj)并使Xi相对于Xj弧一致。"
chap5_para267,6,,如果Di保持不变，算法就会处理下一条弧。
chap5_para267,7,,"但是如果Di得以修正（域变小），那么我们将所有的弧(Xk, Xi)添加到队列中，其中Xk是Xi的邻居。"
chap5_para267,8,,这样做的原因是，即使之前已经处理过Xk，Di的变化也可能会进一步缩减Dk。
chap5_para267,9,,如果Di变为空集，那么表示整个CSP不存在一致解，AC-3可以马上返回失败。
chap5_para267,10,,否则，我们继续检查，不断尝试缩减变量的域，直到队列中没有弧。
chap5_para267,11,,此时，我们得到了一个与原始CSP等价的CSP（它们的解相同），但弧一致CSP搜索起来会更快，因为它的变量的域更小。
chap5_para267,12,,在某些情况下，它可以完全求解问题（通过将每个域的大小缩减为1），而在其他情况下，它可以证明解不存在（通过将某些域的大小缩减为0）。
chap5_para268,1,,图6-3　弧一致性算法AC-3。
chap5_para268,2,,应用AC-3算法后，要么每条弧都是弧一致的，要么某些变量的域为空集，说明该CSP无解。
chap5_para268,3,,"“AC-3”这个名字来源于算法的发明者（Mackworth, 1977），因为他论文中用到的算法是开发的第三个版本"
chap5_para269,1,,AC-3的算法复杂性可以如下分析。
chap5_para269,2,,假设CSP有n个变量，每个变量的域大小不超过d，带有c个二元约束（弧）。
chap5_para269,3,,"每个弧(Xk, Xi)最多只能插入队列d次，因为Xi最多有d个值要删除。"
chap5_para269,4,,对弧一致性的检查可以在O(d2)时间内完成，因此最坏情况下的时间复杂性为O(cd3)。
chap5_para27,1,"In our example, the axles have to be in place before the wheels are put on, and it takes 10 minutes to install an axle, so we write",图5-1为井字棋（圈叉游戏tic-tac-toe）的部分博弈树。
chap5_para27,2,,从初始状态开始，max有9种可能的移动。
chap5_para27,3,,游戏交替进行，max放x，min放o，直到到达对应于终止状态的叶节点，即一个玩家占据某一行，或者所有方格都被填满。
chap5_para27,4,,每个叶节点上的数字是对max来说该终止状态的效用值，值越高对max越有利，对min越不利（这也是玩家名字的由来）。
chap5_para270,1,,6.2.3　路径一致性
chap5_para271,1,,假设我们要给澳大利亚地图涂上两种颜色，红色和蓝色。
chap5_para271,2,,此时弧一致性不起作用，因为将弧的一端涂成红色，另一端涂成蓝色可以分别满足每个约束。
chap5_para271,3,,但显然这个问题是无解的：因为西澳大利亚州、北领地和南澳大利亚州彼此相邻，仅仅是它们就需要至少3种颜色。
chap5_para272,1,,弧一致性利用弧（二元约束）将域（一元约束）收紧。
chap5_para272,2,,为了求解地图着色等问题，我们需要更强的一致性概念。
chap5_para272,3,,路径一致性（path consistency）使用隐式约束（通过观测变量的三元组推断）将二元约束收紧。
chap5_para273,1,,考虑两个变量的集合和第三个变量Xm，如果对于每个满足上约束（如果有的话）的赋值，都存在Xm的一个赋值满足和上的约束，则称相对于Xm是路径一致的。
chap5_para273,2,,这一名称是指从Xi途经Xm到Xj的路径的整体一致性。
chap5_para274,1,,让我们考虑用两种颜色为澳大利亚地图着色时的路径一致性。
chap5_para274,2,,我们要使集合相对于NT路径一致。
chap5_para274,3,,首先枚举集合的一致赋值。
chap5_para274,4,,在这种情况下，只有两个一致赋值：和。
chap5_para274,5,,可以看到，对于这两种赋值，NT不能是红色或蓝色（因为它会与WA或SA发生冲突）。
chap5_para274,6,,因为NT不存在有效选择，所以我们消除了这两种赋值，最终不存在有效赋值。
chap5_para274,7,,因此，我们知道了这个问题是无解的。
chap5_para275,1,,6.2.4　k一致性
chap5_para276,1,,可以用k一致性（k-consistency）的概念定义更强的传播形式。
chap5_para276,2,,如果对于CSP的任意(k −1)个变量的集合以及这些变量的任意一致赋值，任意第k个变量都存在一个一致赋值，则称该CSP是k一致的。
chap5_para276,3,,1一致性表示，给定空集，我们可以使任何单变量集合满足一致性，这就是我们所说的节点一致性。
chap5_para276,4,,2一致性等价于弧一致性。
chap5_para276,5,,对于二元约束图，3一致性等价于路径一致性。
chap5_para277,1,,如果一个CSP是k一致的，也是(k −1)一致的，(k −2)一致的……一直到1一致的，则称它是强k一致的（strongly k-consistent）。
chap5_para277,2,,现在假设我们有一个包含n个节点的CSP，并且是强n一致的(即当k = n时，强k一致)，那么可以这样求解该问题：首先，为X1选择一个一致值。
chap5_para277,3,,然后因为图是2一致的，所以保证能为X2选出一个一致值，因为它是3一致的，所以能为X3选出一个值，以此类推。
chap5_para277,4,,"对于每个变量Xi，我们只需在它的域的d个值中搜索，就可以找到一个与X1, …, Xi−1一致的值。"
chap5_para277,5,,总运行时间只有O(n2d)。
chap5_para278,1,,当然，世界上没有免费的午餐：约束满足问题通常是NP完全的，任何建立n一致性的算法在最坏情况下的时间复杂性都是n的指数级。
chap5_para278,2,,更糟的是，n一致性所需的空间复杂性也是n的指数级。
chap5_para278,3,,在实践中，确定适当的一致性检查层级基本上是一门经验科学。
chap5_para278,4,,比较常见的是计算2一致性，其次是计算3一致性。
chap5_para279,1,,6.2.5　全局约束
chap5_para28,1,"Next we say that for each wheel, we must affix the wheel (which takes 1 minute), then tighten the nuts (2 minutes), and finally attach the hubcap (1 minute, but not represented yet):",对井字棋来说，博弈树相对较小——不超过9!= 362 880个终止节点（只有5478个不同状态）。
chap5_para28,2,,但是对国际象棋来说，节点数超过1040，所以博弈树被认为是一个在物理世界中无法实现的理论结构。
chap5_para280,1,,前文提到，全局约束涉及任意个数的变量（但不一定是所有变量）。
chap5_para280,2,,实际问题中经常出现全局约束，可以通过专用算法处理这些约束，这些算法比目前介绍的一般方法更加高效。
chap5_para280,3,,例如，Alldiff约束规定所有相关变量必须取不同的值（如上文的密码算术问题和下文的数独问题）。
chap5_para280,4,,对Alldiff约束进行不一致性检测的一种简单形式如下所示：如果约束中涉及m个变量，而且它们一共具有n个可能的不同值，且，那么约束不可能满足。
chap5_para281,1,,这将导出以下简单算法。
chap5_para281,2,,首先，删除约束中任意一个单值变量（域中只有一个值的变量），并且从其余变量的域中删除该变量的值。
chap5_para281,3,,只要还存在单值变量，就重复上述过程。
chap5_para281,4,,如果在任一点上产生了空集，或者存在比剩余取值数更多的变量，则检测到了不一致性。
chap5_para282,1,,上述方法可以检测图6-1中赋值的不一致性。
chap5_para282,2,,注意，变量SA、NT和Q是通过Alldiff约束有效连接的，因为每对都必须取两种不同颜色。
chap5_para282,3,,将AC-3应用于这个部分赋值后，SA、NT和Q的域都缩减为。
chap5_para282,4,,也就是说，我们有3个变量，但只有两种颜色，这违反了Alldiff约束。
chap5_para282,5,,因此，对高阶约束进行简单一致性处理有时比对等价的二元约束集应用弧一致性更高效。
chap5_para283,1,,另一种重要的高阶约束是资源约束（resource constraint），有时也称为Atmost约束。
chap5_para283,2,,"例如，在一个调度问题中，设P1, …, P4分别表示分配给4个任务的人数。"
chap5_para283,3,,分配总人数不超过10的约束写为。
chap5_para283,4,,通过检验当前域的最小值之和可以检测不一致性。
chap5_para283,5,,"例如，如果每个变量的域都是{3, 4, 5, 6}，则不可能满足Atmost约束。"
chap5_para283,6,,另一个例子是，如果当前某个变量的域中的最大值加上所有其他变量的域的最小值超过约束，则可以通过删除该最大值来保持一致性。
chap5_para283,7,,"因此，如果示例中的每个变量的域都是{2, 3, 4, 5, 6}，那么可以从每个域中删除5和6。"
chap5_para284,1,,对于大规模的、具有整数值的资源有限问题（例如用几百辆车运送几千人的物流问题）将每个变量的域表示为一个大的整数集然后通过一致性检查方法逐渐缩减这个集合通常是不可能的。
chap5_para284,2,,相反，域由上界和下界表示，通过边界传播（bound propagation）处理。
chap5_para284,3,,例如，在航班调度问题中，假设存在两趟航班，F1和F2，其中飞机的容量分别为165和385。
chap5_para284,4,,F1和F2航班上乘客数量的初始域为
chap5_para286,1,,现在假设我们有附加约束，两趟航班所搭载的总乘客数必须是420：。
chap5_para286,2,,通过传播边界约束，我们将域缩减为
chap5_para288,1,,如果对于任意变量X和它的上下界值，任意变量Y，都存在满足X和Y之间约束的Y的值，则称CSP是边界一致的（bounds-consistent）。
chap5_para288,2,,这种边界传播在实际的约束问题中得到了广泛应用。
chap5_para29,1,"Suppose we have four workers to install wheels, but they have to share one tool that helps put the axle in place.",图5-1　井字棋的（部分）博弈树。
chap5_para29,2,We need a disjunctive constraint to say that AxleF and AxleB must not overlap in time; either one comes first or the other does:,最上面的节点是初始状态，max先移动，在某个空位上放一个x。
chap5_para29,3,,我们展示了树的一部分，给出min(o)和max(x)的交替移动，直到最终到达终止状态，根据博弈规则为终止状态分配效用值
chap5_para290,1,,数独（Sudoku）游戏非常流行，它将数百万人引入了约束满足问题，尽管他们可能没有意识到这一点。
chap5_para290,2,,数独棋盘由81个方格组成，有些方格预先填有1到9的数字。
chap5_para290,3,,谜题是将所有剩余方格填满，并且任意一行、一列或3×3方框中不存在相同数字（见图6-4）。
chap5_para290,4,,一行、一列或一个方框称为一个单元（unit）。
chap5_para291,1,,图6-4　（a）一个数独问题。
chap5_para291,2,,（b）它的解
chap5_para292,1,,报纸和益智书籍上的数独游戏都有一个特点，即有且只有一个解。
chap5_para292,2,,尽管有些问题手动求解很难，需要花费几十分钟，但CSP求解器每秒可以处理几千个问题。
chap5_para293,1,,可以将数独游戏看作含有81个变量的CSP，每个变量对应一个方格。
chap5_para293,2,,用变量名A1到A9表示第一行（从左到右），I1到I9表示最后一行。
chap5_para293,3,,"空方格的域为{1, 2, 3, 4, 5, 6, 7, 8, 9}，预先填好的方格的域只有一个值。"
chap5_para293,4,,此外，还有27个不同的Alldiff约束，每个单元（行、列和含有9个方格的方框）各有一个Alldiff约束：
chap5_para294,1,,"Alldiff (A1, A2, A3, A4, A5, A6, A7, A8, A9)"
chap5_para295,1,,"Alldiff (B1, B2, B3, B4, B5, B6, B7, B8, B9)"
chap5_para297,1,,"Alldiff (A1, B1, C1, D1, E1, F1, G1, H1, I1)"
chap5_para298,1,,"Alldiff (A2, B2, C2, D2, E2, F2, G2, H2, I2)"
chap5_para3,1,"Chapters 3 and 4 explored the idea that problems can be solved by searching the state space: a graph where the nodes are states and the edges between them are actions. We saw that domain-specific heuristics could estimate the cost of reaching the goal from a given state, but that from the point of view of the search algorithm, each state is atomic, or indivisible—a black box with no internal structure. For each problem we need domain-specific code to describe the transitions between states.",
chap5_para30,1,"This looks like a more complicated constraint, combining arithmetic and logic.",5.2　博弈中的优化决策
chap5_para30,2,But it still reduces to a set of pairs of values that AxleF and AxleB can take on.,
chap5_para300,1,,"Alldiff (A1, A2, A3, B1, B2, B3, C1, C2, C3)"
chap5_para301,1,,"Alldiff (A4, A5, A6, B4, B5, B6, C4, C5, C6)"
chap5_para303,1,,让我们看看弧一致性能带我们走多远。
chap5_para303,2,,假设Alldiff约束已被扩展为二元约束（例如A1 A2），这样我们就可以直接应用AC-3算法。
chap5_para303,3,,考虑图6-4a中的变量E6——正中间方框中2、8之间的空格。
chap5_para303,4,,按照方框的约束，我们可以从E6的域中删除1、2、7和8。
chap5_para303,5,,按照它所在列的约束，我们可以删除5、6、2、8、9和3（尽管2和8已经被删除）。
chap5_para303,6,,此时E6的域是{4}；换句话说，我们知道了E6的解。
chap5_para303,7,,现在考虑变量I6——最后一行中间方框中被1、3、3包围的空格。
chap5_para303,8,,在它所在列应用弧一致性，可以删除5、6、2、4（因为我们现在知道E6一定是4）、8、9和3。
chap5_para303,9,,我们利用它和I5的弧一致性删除1，此时I6的域中只剩下7。
chap5_para303,10,,现在第6列中有8个已知值，所以根据弧一致性可以推出A6一定是1。
chap5_para303,11,,沿着这样的思路继续推断，最终AC-3可以求解整个问题——所有变量的域都缩减为单个值，如图6-4b所示。
chap5_para304,1,,当然，如果每个数独问题都可以通过机械地应用AC-3求解，那么它很快就会失去吸引力，实际上AC-3只适用于最简单的数独问题。
chap5_para304,2,,稍微困难一点的问题可以用PC-2求解，但需要花费更大的计算代价：在一个数独问题中，需要考虑255 960个不同的路径约束。
chap5_para304,3,,为了求解最困难的数独问题并取得高效进展，我们必须更聪明一些。
chap5_para305,1,,事实上，数独对人类解谜者的吸引力在于，他们需要足智多谋地应用更复杂的推理策略。
chap5_para305,2,,数独爱好者给这些策略取了各种有趣的名字，如“三链数删减法”。
chap5_para305,3,,它的工作原理如下：在任一单元（行、列或方框）中，找到3个方格，它们的域包含相同的3个数字或这3个数字的子集。
chap5_para305,4,,例如，这3个域可能是、和。
chap5_para305,5,,我们并不知道哪个方格是1、3或8，但我们知道这3个数字一定分布在这3个方格中。
chap5_para305,6,,因此，我们可以将1、3和8从该单元中所有其他方格的域中删除。
chap5_para306,1,,有趣的是，这些方法并不只是专用于数独。
chap5_para306,2,,对于数独，我们确实必须说它有81个变量，域是数字1～9，有27个Alldiff约束。
chap5_para306,3,,但除此之外，所有策略（弧一致性、路径一致性等）普遍适用于所有CSP，而不仅仅是数独问题。
chap5_para306,4,,即使是三链数删减法，也是一种加强Alldiff约束一致性的策略，而不是特定于数独本身。
chap5_para306,5,,这就是CSP形式体系的作用：对于每个新问题域，我们只需按照约束定义问题，然后就可以使用一般的约束求解机制。
chap5_para307,1,,6.3　CSP的回溯搜索
chap5_para308,1,,有时我们完成约束传播过程后仍存在具有多个可能值的变量。
chap5_para308,2,,在这种情况下，我们必须通过搜索来求解问题。
chap5_para308,3,,本节中我们将介绍用于部分赋值的回溯搜索算法，6.4节中我们将介绍用于完整赋值的局部搜索算法。
chap5_para309,1,,考虑标准的深度受限搜索（第3章）是如何求解CSP的。
chap5_para309,2,,状态可能是一个部分赋值，而动作将对该赋值进行扩展，例如，在澳大利亚地图着色问题中，添加赋值NSW = red或SA = blue。
chap5_para309,3,,对于具有n个变量，域大小为d的CSP，我们最终将得到一个搜索树，所有的完整赋值（因此所有的解）都是深度为n的叶节点。
chap5_para309,4,,但要注意，第一层的分支因子为nd，因为n个变量中的任意变量都可以取d个值中的任意值。
chap5_para309,5,,下一层的分支因子是(n −1)d，以此类推n层。
chap5_para309,6,,所以树总共有n! · dn个叶节点，即使可能的完整赋值只有dn种！
chap5_para31,1,"We also need to assert that the inspection comes last and takes 3 minutes. For every variable except Inspect we add a constraint of the form X + dX ≤ Inspect. Finally, suppose there is a requirement to get the whole assembly done in 30 minutes. We can achieve that by limiting the domain of all variables:",max想要找到通往胜利的动作序列，但min不希望max获胜。
chap5_para31,2,,这意味着max的策略必须是一个条件规划——一个随机应变策略，指定对min的每个可能移动的响应。
chap5_para31,3,,在具有二元结果（赢或输）的博弈中，我们可以使用与或搜索（4.3.2节）生成条件规划。
chap5_para31,4,,事实上，对于这类博弈，博弈的获胜策略的定义与非确定性规划问题的解的定义相同：在这两种情况下，无论“另一方”做什么，都必须保证己方能获得理想结果。
chap5_para31,5,,对于具有多个结果分数的博弈，我们需要一种更一般的算法，即极小化极大搜索。
chap5_para310,1,,如果意识到CSP具有的一个关键性质：可交换性（commutativity），我们就可以消去因子n!。
chap5_para310,2,,如果任意给定的动作集合的应用顺序对结果没有影响，则称该问题是可交换的。
chap5_para310,3,,在CSP中，不管我们先赋值NSW = red，再赋值SA = blue，还是交换顺序，都没有区别。
chap5_para310,4,,因此，我们只需考虑搜索树中每个节点上的单个变量。
chap5_para310,5,,在根节点上，我们可能需要在SA = red、SA = green和SA = blue之间做出选择，但我们永远不需要在NSW = red和SA = blue之间做出选择。
chap5_para310,6,,在这一限制下，叶节点的数量减少到dn，这正是我们所希望的。
chap5_para310,7,,在树的每一层中，我们都必须选择要处理哪个变量，但我们永远不需要回溯这一选择。
chap5_para311,1,,图6-5为CSP的回溯搜索过程。
chap5_para311,2,,它不断选择未赋值变量，然后依次尝试该变量的域中的所有值，试图通过递归调用将每个值扩展为一个解。
chap5_para311,3,,如果调用成功，则返回解，如果调用失败，则将赋值恢复到前一状态，然后尝试下一个值。
chap5_para311,4,,如果所有值都不成功，则返回失败。
chap5_para311,5,,澳大利亚地图着色问题的部分搜索树如图6-6所示，其中我们按照WA、 NT、Q……的顺序为变量赋值。
chap5_para312,1,,图6-5　约束满足问题的简单回溯算法。
chap5_para312,2,,该算法以第3章的递归深度优先搜索为模型。
chap5_para312,3,,函数Select-Unassigned- Variable和Order-Domain-Values实现了6.3.1节中讨论的通用启发式算法。
chap5_para312,4,,函数Inference可以根据需要选择性地使用弧一致性、路径一致性或k一致性检测。
chap5_para312,5,,如果一个赋值导致了失败（无论是在Inference还是在Backtrack中），那么该赋值（包括从Inference得到的值）将被撤销，然后重新尝试一个新的赋值
chap5_para313,1,,图6-6　图6-1中地图着色问题的部分搜索树
chap5_para314,1,,注意，Backtracking-Search只维护状态（赋值）的单个表示，然后对它进行修改，而不是创建一个新的表示（见3.4.3节）。
chap5_para315,1,,第3章的无信息搜索算法只能通过提供领域特定的启发式算法来改进，然而，事实证明，回溯搜索可以使用领域无关的启发式算法进行改进，这些算法利用了CSP的因子化表示。
chap5_para315,2,,在接下来的4节中，我们将介绍如何做到这一点。
chap5_para316,1,,● （6.3.1节）下一步应该给哪个变量赋值（Select-Unassigned-Variable），以及应该以什么顺序尝试它的值（Order-Domain-Values）？
chap5_para317,1,,● （6.3.2节）在每步搜索中应该执行怎样的推断（Inference）？
chap5_para318,1,,● （6.3.3节）我们能在适当的时候回溯（Backtrack）不止一步吗？
chap5_para319,1,,● （6.3.4节）我们可以保存和复用搜索的部分结果吗？
chap5_para32,1,"This particular problem is trivial to solve, but CSPs have been successfully applied to jobshop scheduling problems like this with thousands of variables.",考虑图5-2中的简单博弈。
chap5_para32,2,,根节点上max的可能移动被标记为a1、a2和a3。
chap5_para32,3,,min对a1的可能响应为b1、b2、b3等。
chap5_para32,4,,这个特殊游戏在max和min各移动一次后结束。
chap5_para32,5,,（注意，在某些游戏中，“move”一词意味着双方都执行了一次移动，因此，ply一词被用来明确表示一个玩家的一次移动，即我们在博弈树中又深入了一层。
chap5_para32,6,,）博弈中终止状态的效用值范围为2～14。
chap5_para320,1,,6.3.1　变量排序和值排序
chap5_para321,1,,回溯算法中包含这样一行：
chap5_para322,1,,Select-Unassigned-Variable的最简单的策略是使用静态排序：按列表顺序选择变量。
chap5_para322,2,,第二简单的策略是随机选择。
chap5_para322,3,,这两种策略都不是最优的。
chap5_para322,4,,例如，图6-6中，进行WA = red和NT = green赋值后，SA只有一个可能的值，因此接下来应该对SA赋值SA = blue而不是对Q赋值：事实上，对SA赋值后，Q、NSW和V的取值都是确定的。
chap5_para323,1,,这种直观的想法——选择“合法”值最少的变量——称为最少剩余值（minimum-remaining-value，MRV）启发式算法，也被称为“最受约束变量”或“失败优先”启发式算法，后一个名字是因为它选择了最有可能马上导致失败的变量，从而可以对搜索树剪枝。
chap5_para323,2,,如果某一变量X没有剩余合法值，那么MRV启发式算法将优先选择X然后马上检测到失败——避免遍历其他变量进行无意义地搜索。
chap5_para323,3,,MRV启发式算法通常比随机或静态排序表现得更好，有时会带来数量级上的效率差异，尽管结果可能因问题而异。
chap5_para324,1,,在选择澳大利亚地图的第一个着色区域时，MRV启发式算法完全不起作用，因为初始时每个区域都有3种合法颜色。
chap5_para324,2,,在这种情况下，度启发式（degree heuristic）算法就派上用场了。
chap5_para324,3,,它通过选择与其他未赋值变量的约束最多的变量来降低未来选择的分支因子。
chap5_para324,4,,在图6-1中，SA的度最大，为5；除了变量T的度为0，其他变量的度为2或3。
chap5_para324,5,,如果先赋值SA，我们就可以按顺时针或逆时针顺序访问5个陆地区域，并为每个区域赋予不同于SA和前一个区域的颜色。
chap5_para324,6,,最少剩余值启发式算法通常效果更好，但度启发式算法可以打破僵局。
chap5_para325,1,,一旦选择了一个变量，算法必须决定按什么顺序检验它的值。
chap5_para325,2,,最少约束值（least-constraining-value）启发式算法对此非常有效。
chap5_para325,3,,它优先选择那些为约束图中相邻变量留下最多选择的值。
chap5_para325,4,,例如，假设在图6-1中，我们已经生成了部分赋值WA = red和NT = green，并且下一步是为Q选择赋值。
chap5_para325,5,,此时蓝色是一个糟糕的选择，因为它消除了Q的邻居SA的最后一个可选的合法值。
chap5_para325,6,,因此，最少约束值启发式算法会优先选择红色而不是蓝色。
chap5_para325,7,,一般来说，启发式算法试图为后续变量赋值留下最大的灵活性。
chap5_para326,1,,为什么变量选择是失败优先，而值选择是失败延后呢？
chap5_para326,2,,每个变量最终都必须被赋值，因此通过选择那些有可能最先失败的变量，在统计意义上，需要通过回溯才能找到的成功赋值就会更少。
chap5_para326,3,,对于值排序，关键在于我们只需要找到一个解；因此，先寻找最有可能的值是有意义的。
chap5_para326,4,,如果我们的目标是枚举所有的解而不只是找到一个解，那么值排序就无关紧要了。
chap5_para327,1,,6.3.2　交替进行搜索和推理
chap5_para328,1,,我们已经讨论了AC-3算法如何在搜索前缩减变量的域。
chap5_para328,2,,但在搜索过程中，推断的作用可能更大：每次我们为某个变量选择某个值时，都有一个全新的机会推断其相邻变量的新的域缩减。
chap5_para329,1,,推断的最简单形式之一是前向检验（forward checking）。
chap5_para329,2,,当变量X被赋值时，前向检验过程为其建立弧一致性：对于每个通过约束与X连接的未赋值变量Y，从它的域中删除与X的取值不一致的值。
chap5_para33,1,5.,图5-2　二层博弈树。
chap5_para33,2,1.,△节点为“max节点”，即轮到max移动，节点为“min节点”。
chap5_para33,3,3Variations on the CSP formalism,终止节点显示max的效用值，其他节点标记有它们的极小化极大值。
chap5_para33,4,,max在根节点的最佳移动是a1，因为它指向极小化极大值最高的状态，而min的最佳响应是b1，因为它指向极小化极大值最低的状态
chap5_para330,1,,图6-7为在澳大利亚地图CSP上使用前向检验进行回溯搜索的过程。
chap5_para330,2,,关于这一示例，有两点需要注意。
chap5_para330,3,,首先，需要注意，在赋值WA = red和Q = green后，NT和SA的域缩减为单个值；通过从WA和Q传播信息，我们可以完全消除这些变量上的分支。
chap5_para330,4,,其次，需要注意，赋值V= blue后，SA的域为空集。
chap5_para330,5,,因此，前向检验检测到部分赋值与问题的约束不一致，算法立即回溯。
chap5_para331,1,,图6-7　带前向检验的地图着色搜索过程。
chap5_para331,2,,首先赋值WA = red；然后前向检验从其相邻变量NT和SA的域中删除red。
chap5_para331,3,,赋值Q = green后，从NT、SA和NSW的域中删除green。
chap5_para331,4,,赋值V = blue后，从NSW和SA的域中删除blue，此时SA没有合法值
chap5_para332,1,,对许多问题来说，将MRV启发式算法与前向检验相结合，可以使搜索更有效。
chap5_para332,2,,考虑图6-7中的赋值。
chap5_para332,3,,直观上，这一赋值似乎对它的相邻变量NT和SA有所约束，所以接下来应该先处理这些变量，然后是所有其他变量。
chap5_para332,4,,MRV正是这么做的：NT和SA各有两个值，所以先选择其中一个，接着是另一个，然后依次是Q、NSW和V。
chap5_para332,5,,最后T仍然有3个可能的值，任意一个都是有效的。
chap5_para332,6,,我们可以将前向检验看作一种以增量方式计算MRV启发式算法完成其工作所需信息的有效途径。
chap5_para333,1,,尽管前向检验能够检测出许多不一致，但它无法检测到所有的不一致。
chap5_para333,2,,问题在于，它向前看得不够远。
chap5_para333,3,,例如，考虑图6-7中的Q = green一行。
chap5_para333,4,,我们已经使WA和Q弧一致，但此时NT和SA的唯一可能的值都是蓝色，这违反了一致性，因为它们是相邻变量，相邻变量不能取相同的值。
chap5_para334,1,,维护弧一致性（maintaining arc consistency，MAC）算法能检测出这类不一致性。
chap5_para334,2,,"当变量Xi被赋值后，Inference程序调用AC-3，但我们开始时只考虑所有与Xi相邻的未赋值变量Xj的弧(Xj, Xi)，而不是CSP中的所有弧。"
chap5_para334,3,,从这出发，AC-3以通常的方式进行约束传播，如果任何变量的域缩减为空集，则AC-3调用失败，并立即回溯。
chap5_para334,4,,我们可以看到，MAC严格来说比前向检验更强大，因为前向检验所做的事情与MAC对其队列的初始弧所做的相同；但与MAC不同的是，当变量的域发生变化时，前向检验不会递归地传播约束。
chap5_para335,1,,6.3.3　智能回溯：向后看
chap5_para336,1,,当搜索的一个分支失败时，图6-5中的Backtracking-Search算法将采取一种非常简单的策略：退回到上一个变量，并为其尝试一个不同的值。
chap5_para336,2,,这称为时序回溯（chronological backtracking），因为时间上最近的决策点会被重新访问。
chap5_para336,3,,在本节中，我们考虑更好的可能策略。
chap5_para337,1,,考虑一下，当我们按照固定的变量顺序Q、NSW、V、 T、SA、WA、NT应用图6-1中的简单回溯时会发生什么。
chap5_para337,2,,假设我们已经生成了部分赋值。
chap5_para337,3,,当我们尝试下一个变量SA时，发现所有值都违反了约束。
chap5_para337,4,,我们退回到T，为塔斯马尼亚州尝试一种新颜色！
chap5_para337,5,,显然，这种做法是愚蠢的——重新给塔斯马尼亚州着色并不能解决南澳大利亚州的问题。
chap5_para338,1,,一种更智能的方法是回溯到有可能求解这一问题的变量——导致SA的某个可能值变成不可能值的变量。
chap5_para338,2,,为此，我们将记录与SA的某些值冲突的赋值集合。
chap5_para338,3,,该集合（在本例中为）称为SA的冲突集（conflict set）。
chap5_para338,4,,回跳（backjumping）方法将回溯到冲突集中最近的赋值，在本例中，回跳将越过塔斯马尼亚州，为V尝试一个新的值。
chap5_para338,5,,通过修改Backtrack算法，可以很容易地实现上述方法，即在检验合法值时，同时维护冲突集。
chap5_para338,6,,如果找不到合法值，算法应该返回失败指示和冲突集中最近的元素。
chap5_para339,1,,眼尖的读者可能已经注意到，前向检验不需要额外工作就能提供冲突集：当前向检验根据赋值X = x从Y的域中删除一个值时，它应该将X = x添加到Y的冲突集中。
chap5_para339,2,,如果Y的域中的最后一个值也被删除，那么Y的冲突集中的赋值也要被添加到X的冲突集中。
chap5_para339,3,,也就是说，我们现在知道X = x导致了（Y中的）矛盾，因此应该为X尝试不同赋值。
chap5_para34,1,"The simplest kind of CSP involves variables that have discrete, finite domains.",给定博弈树，可以通过计算树中每个状态的极小化极大值（minimax value）确定最优策略，记为Minimax(s)。
chap5_para34,2,Map-coloring problems and scheduling with time limits are both of this kind.,某一状态的极小化极大值是指，假设从该状态到博弈结束两个参与者都以最优策略行动，到达的终止状态对于max的效用值。
chap5_para34,3,The 8-queens problem (Figure 4.,终止状态的极小化极大值就是它的效用值。
chap5_para34,4,"3) can also be viewed as a finite-domain CSP, where the variables Q1,.",在非终止状态下，轮到max移动时，max倾向于移动到极小化极大值最大的状态，而min倾向于移动到极小化极大值最小的状态（对max来说值最小，因此对min来说值最大）。
chap5_para34,5,.,所以有：
chap5_para34,6,.,
chap5_para34,7,",Q8 correspond to the queens in columns 1 to 8, and the domain of each variable specifies the possible row numbers for the queen in that column, Di = {1,2,3,4,5,6,7,8}.",
chap5_para34,8,The constraints say that no two queens can be in the same row or diagonal.,
chap5_para340,1,,有眼力的读者可能已经注意到一些奇怪的事情：当域中的每个值都与当前赋值冲突时就会发生回跳，但前向检验能检测出这个事件并阻止搜索到达这样的节点！
chap5_para340,2,,事实上，可以证明，每个被回跳剪除的分支也会被前向检验剪枝。
chap5_para340,3,,因此，在前向检验搜索中，或者在使用更强一致性检验的搜索（如MAC）中，简单的回跳是多余的——你只需执行其中一项。
chap5_para341,1,,尽管存在上一段中的观测结果，回跳背后的思想仍然值得借鉴：基于失败原因进行回溯。
chap5_para341,2,,当变量的域变为空集时，回跳发现失败，但在许多情况下，在很早之前分支就注定要失败。
chap5_para341,3,,再次考虑部分赋值（从我们前面的讨论来看，它是不一致的）。
chap5_para341,4,,假设我们下一步尝试T = red，然后对NT、Q、V和SA赋值。
chap5_para341,5,,我们知道，最后这4个变量不存在有效赋值，所以最终在NT处终止。
chap5_para341,6,,现在，问题是，回溯到哪儿？
chap5_para341,7,,回跳是不可行的，因为NT确实存在与前面赋值过的变量一致的值——NT没有导致失败的前面变量的完整冲突集。
chap5_para341,8,,然而，我们知道，NT、Q、V和SA这4个变量放在一起会失败，是因为前面的一组变量一定与这4个变量有直接冲突。
chap5_para342,1,,这引出了（对于NT这样的变量的）一种不同的、更深层次的冲突集概念：正是前面一组变量共同导致了NT连同任何后续变量都不存在一致解。
chap5_para342,2,,在本例中，该集合是WA和NSW，所以算法应该跳过塔斯马尼亚州回溯到NSW。
chap5_para342,3,,使用以这种方式定义的冲突集的回跳算法称为冲突导向回跳（conflict-directed backjumping）。
chap5_para343,1,,现在我们必须解释如何计算这些新的冲突集。
chap5_para343,2,,方法其实很简单。
chap5_para343,3,,搜索分支的“终端”失败总是因为某个变量的域变为空集，该变量对应一个标准冲突集。
chap5_para343,4,,在我们的例子中，SA失败，它的冲突集是（例如）。
chap5_para343,5,,我们回溯到Q，Q将SA的冲突集（当然要减去Q本身）吸收到它自己的直接冲突集，新的冲突集是。
chap5_para343,6,,也就是说，给定前面对的赋值，从Q向前是没有解的。
chap5_para343,7,,因此，我们回溯到最近的变量NT。
chap5_para343,8,,NT将吸收到它自己的直接冲突集中，得到（如上一段所述）。
chap5_para343,9,,现在算法回跳到NSW，这正是我们所希望的。
chap5_para343,10,,总结一下：设Xj表示当前变量，conf(Xj)表示它的冲突集。
chap5_para343,11,,如果Xj的每个可能值都失败了，则回跳到conf(Xj)中最近的变量Xi，并使用下列公式重新计算Xi的冲突集：
chap5_para344,1,,6.3.4　约束学习
chap5_para345,1,,当我们遇到矛盾时，回跳可以告诉我们要退回多远，这样我们就不会浪费时间去改变那些无法求解问题的变量。
chap5_para345,2,,但我们也希望不要再遇到同样的问题。
chap5_para345,3,,当搜索得出一个矛盾时，我们知道这是冲突集的某个子集引起的。
chap5_para345,4,,约束学习（constraint learning）的思想是从冲突集中找出引起问题的最小变量集。
chap5_para345,5,,这组变量及其相应值称为无用赋值（no-good）。
chap5_para345,6,,如果想要记录无用赋值，要么通过向CSP中添加一个新的约束禁止这种赋值组合，要么通过维护一个单独的缓存。
chap5_para346,1,,例如，考虑图6-6最下面一行中的状态。
chap5_para346,2,,前向检验告诉我们这个状态是一个无用赋值，因为SA不存在有效赋值。
chap5_para346,3,,在这种特定情况下，记录该无用赋值是没有意义的，因为一旦从搜索树中剪掉了这一分支，我们再也不会遇到这种组合。
chap5_para346,4,,但假设图6-6中的搜索树实际上是更大的搜索树的一部分，该搜索树是从V和T的赋值开始的。
chap5_para346,5,,那么将记录为无用赋值是有意义的，因为对于V和T的每一组可能赋值，我们都会再次遇到同样的问题。
chap5_para347,1,,前向检验或回跳可以有效地利用无用赋值。
chap5_para347,2,,约束学习是现代CSP求解器用以提高复杂问题求解效率的最重要技术之一。
chap5_para348,1,,6.4　CSP的局部搜索
chap5_para349,1,,局部搜索算法（见4.1节）对于许多CSP的求解都非常有效。
chap5_para349,2,,它们使用完整状态形式（见4.1.1节），即每一状态为所有变量赋值，搜索一次改变一个变量的值。
chap5_para349,3,,例如，考虑6.1.3节中定义为CSP的8皇后问题。
chap5_para349,4,,在图6-8中，我们从左边开始，对8个变量进行了完整赋值，通常该赋值会违反一些约束。
chap5_para349,5,,然后我们随机选择一个发生冲突的变量，在此是最右边一列的Q8。
chap5_para349,6,,我们希望改变它的值，从而更接近问题的解。
chap5_para349,7,,最明显的方法是选择与其他变量冲突数最少的值——最少冲突（min-conflict）启发式算法。
chap5_para35,1,"A discrete domain can be infinite, such as the set of integers or strings. (If we didn’t put a deadline on the job-scheduling problem, there would be an infinite number of start times for each variable.) With infinite domains, we must use implicit constraints like T1 + d1 ≤ T2 rather than explicit tuples of values. Special solution algorithms (which we do not discuss here) exist for linear constraints on integer variables—that is, constraints, such as the one just given, in which each variable appears only in linear form. It can be shown that no algorithm exists for solving general nonlinear constraints on integer variables—the problem is undecidable.",让我们将上述定义应用于图5-2中的博弈树。
chap5_para35,2,,底层的终止节点从Utility函数中获取它们的效用值。
chap5_para35,3,,第一个min节点，标记为B，存在3个后继状态，值分别为3、12和8，因此它的极小化极大值为3。
chap5_para35,4,,类似地，另外两个min节点的极小化极大值都为2。
chap5_para35,5,,根节点为max节点，它的后继状态的极小化极大值分别为3、2和2，因此，它的极小化极大值为3。
chap5_para35,6,,我们还可以在根节点处确定极小化极大决策（minimax decision）：动作a1是max的最优选择，因为它指向极小化极大值最大的状态。
chap5_para350,1,,图6-8　使用最少冲突法求解8皇后问题的示例。
chap5_para350,2,,每步选择一个皇后，在其所在列重新分配位置。
chap5_para350,3,,每个方格标有冲突数（在本例中是互相攻击的皇后个数）。
chap5_para350,4,,算法随机选择发生冲突的皇后，将皇后移动到冲突最少的方格
chap5_para351,1,,在图6-8中，我们看到有两行都只违反了一个约束，我们选择让Q8 = 3（也就是说，我们将皇后移动到第8列、第3行）。
chap5_para351,2,,下一次迭代，在图6-8的中间棋盘上，我们选择Q6作为要改变的变量，然后发现将该皇后移动到第8行不会发生冲突。
chap5_para351,3,,此时不再有发生冲突的变量，所以我们找到了一个解。
chap5_para351,4,,最少冲突算法如图6-9所示。
chap5_para351,5,,[4]
chap5_para353,1,,[4]　局部搜索可以很容易地扩展到约束优化问题（COP）。
chap5_para353,2,,在这种情况下，爬山法和模拟退火的所有技术都可以用于优化目标函数。
chap5_para354,1,,图6-9　CSP的Min-Conflicts局部搜索算法。
chap5_para354,2,,初始状态可以随机选择，也可以通过基于贪心法的赋值过程依次为每个变量选择最少冲突值。
chap5_para354,3,,在给定当前赋值的其余部分后，Conflicts函数统计特定值违反约束的数量
chap5_para355,1,,对许多CSP来说，最少冲突法都相当有效。
chap5_para355,2,,神奇的是，在n皇后问题上，如果不计入皇后的初始布局，最少冲突法的运行时间基本上与问题规模无关。
chap5_para355,3,,它甚至可以在（初始赋值后）平均50步内求解百万皇后问题。
chap5_para355,4,,这一不同寻常的现象是20世纪90年代大量研究局部搜索和难易问题间区别的动力，我们将在7.6.3节中讨论这些问题。
chap5_para355,5,,粗略地说，用局部搜索求解n皇后问题非常简单，因为解密集地分布在整个状态空间上。
chap5_para355,6,,最少冲突法也适用于困难问题。
chap5_para355,7,,例如，它已经被用于哈勃太空望远镜的观测调度，安排一周的观测调度所花费的时间可以从3周减少到大约10分钟。
chap5_para356,1,,4.1节中的所有局部搜索技术都可以应用于CSP，有些技术已被证实相当有效。
chap5_para356,2,,最少冲突启发式算法下的CSP地形图通常存在一系列平台区。
chap5_para356,3,,可能有数百万个变量赋值都只存在一个冲突。
chap5_para356,4,,平台区搜索——允许横向移动到另一个得分相同的状态——可以帮助局部搜索走出平台区。
chap5_para356,5,,这种在平台区的漫游可以由一种叫作禁忌搜索的技术导引：维护一个最近访问过的状态的列表，并禁止算法返回那些状态。
chap5_para356,6,,模拟退火也可以用于逃离平台区。
chap5_para357,1,,另一种技术称为约束加权（constraint weighting），旨在集中搜索重要约束。
chap5_para357,2,,每个约束都有一个数值权重，初始时都为1。
chap5_para357,3,,在每步搜索中，算法找出使其所违反的约束的总权重最低的变量，并修改其值。
chap5_para357,4,,然后，增加当前赋值所违反的每个约束的权重。
chap5_para357,5,,这种做法有两个好处：它为平台区增加了地形因素，确保从当前状态进行改进是有可能的；它还引入了学习策略，随着时间推移，难以求解的约束会被分配更高的权重。
chap5_para358,1,,局部搜索的另一个优点是，当问题发生变化时，它可以用于在线设定的问题（见4.5节）。
chap5_para358,2,,考虑一个航空公司每周航班调度问题。
chap5_para358,3,,它可能涉及上千趟航班和上万名人员的分配，但机场的恶劣天气可能会打乱这一调度。
chap5_para358,4,,我们希望以最少的改动修正日程表。
chap5_para358,5,,这可以通过从当前调度开始的局部搜索算法轻松完成。
chap5_para358,6,,使用新约束集的回溯搜索通常要花费更多时间，而且找到的解可能要对当前调度进行很多改动。
chap5_para36,1,"Constraint satisfaction problems with continuous domains are common in the real world and are widely studied in the field of operations research. For example, the scheduling of experiments on the Hubble Space Telescope requires very precise timing of observations; the start and finish of each observation and maneuver are continuous-valued variables that must obey a variety of astronomical, precedence, and power constraints. The best-known category of continuous-domain CSPs is that of linear programming problems, where constraints must be linear equalities or inequalities. Linear programming problems can be solved in time polynomial in the number of variables. Problems with different types of constraints and objective functions have also been studied—quadratic programming, second-order conic programming, and so on. These problems constitute an important area of applied mathematics.",max的最优策略假设min也是按照最优策略动作。
chap5_para36,2,,如果min不按照最优策略动作呢？
chap5_para36,3,,那么max至少会表现得与它面对最优对手时一样好，甚至可能更好。
chap5_para36,4,,然而，这并不意味着，面对次优对手时选择极小化极大最优移动总是最好的。
chap5_para36,5,,考虑这样一种情况，双方均按照最优策略行动，结果为平局，但max有一种冒险的走法，在这种走法导致的状态下，min有10种可能的响应，这些响应似乎都是合理的，但其中9种都会使min输掉游戏，只有1种会使max输掉游戏。
chap5_para36,6,,如果max认为min没有足够的计算能力找到最优移动，那么max可能会尝试这种冒险的走法，因为9/10的获胜机会要比一个确定的平局好。
chap5_para360,1,,在这一节中，我们将研究如何利用由约束图表示的问题的结构来快速找到解。
chap5_para360,2,,这里的大多数方法也适用于CSP之外的其他问题，例如概率推理。
chap5_para361,1,,处理复杂的真实世界问题的唯一可能方法是将其分解为若干子问题。
chap5_para361,2,,回顾澳大利亚问题的约束图（图6-1b和图6-12a），可以发现一个问题：塔斯马尼亚州和大陆不相连。
chap5_para361,3,,[5]直观上看，对塔斯马尼亚州着色和对大陆着色显然是两个独立子问题（independent subproblem）——任何对大陆着色的解和任何对塔斯马尼亚州着色的解相结合都能得到整个地图的解。
chap5_para363,1,,[5]　细心的制图师或热爱塔斯马尼亚州的塔斯马尼亚人可能会反对将塔斯马尼亚州和离它最近的大陆邻域涂上相同的颜色，以免给人留下它可能是那个州的一部分的印象。
chap5_para364,1,,可以简单地通过寻找约束图的连通分量（connected component）来确定独立性。
chap5_para364,2,,每个连通分量对应一个子问题CSPi。
chap5_para364,3,,如果赋值Si是CSPi的解，那么就是的解。
chap5_para364,4,,为什么这很重要？
chap5_para364,5,,假设每个CSPi具有所有n个变量中的c个变量，其中c是一个常数。
chap5_para364,6,,那么共有n/c个子问题，求解每个子问题最多需要d c工作量，其中d是域的大小。
chap5_para364,7,,因此，总的工作量为O(dcn/c)，关于n是线性的；如果不进行问题分解，总的工作量为O(d n)，关于n是指数级的。
chap5_para364,8,,让我们更具体地说：将一个具有100个变量的布尔CSP分解为4个子问题，那么最坏情况下的求解时间将从宇宙生命周期减少到不到1秒。
chap5_para365,1,,完全独立的子问题很好，但很少见。
chap5_para365,2,,幸运的是，其他一些图结构也很容易求解。
chap5_para365,3,,例如，当任意两个变量都只由一条路径连接时，约束图是一棵树。
chap5_para365,4,,我们将证明任何树状结构的CSP都可以在变量个数的线性时间内求解。
chap5_para365,5,,[6]这里的关键是一种新的一致性概念——定向弧一致性（directional arc consistency）或DAC。
chap5_para365,6,,"变量顺序为X1, X2, …, Xn的CSP称为定向弧一致的，当且仅当，时，每个Xi相对于每个Xj都是弧一致的。"
chap5_para367,1,,[6]　遗憾的是，除了苏拉威西岛（Sulawesi）的地图比较接近树状外，世界上几乎没有一个地区是树状结构的地图。
chap5_para368,1,,为了求解树状结构的CSP，首先选择任一变量作为树的根节点，然后选择变量顺序，每个变量必须在其父节点之后。
chap5_para368,2,,这种排序称为拓扑排序（topological sort）。
chap5_para368,3,,图6-10a为一棵树，图6-10b为一种可能的排序。
chap5_para368,4,,任何有n个节点的树都有n−1条边，所以可以在O(n)步内使得该图具有定向弧一致性，每一步都必须比较两个变量的最多d个可能的值，总时间为O(nd2)。
chap5_para368,5,,一旦我们有了一个定向弧一致的图，就可以沿着变量列表选择任意剩余值。
chap5_para368,6,,因为从父节点到其子节点的每条边都是弧一致的，所以，对于父节点选择的任何值，子节点都存在一个可选的有效值。
chap5_para368,7,,这意味着我们不必回溯，可以沿着变量线性移动。
chap5_para368,8,,完整算法如图6-11所示。
chap5_para369,1,,图6-10　（a）树状结构CSP的约束图。
chap5_para369,2,,（b）与以A为根节点的树一致的变量的线性排序。
chap5_para369,3,,这称为变量的拓扑排序
chap5_para37,1,"In addition to examining the types of variables that can appear in CSPs, it is useful to look at the types of constraints. The simplest type is the unary constraint, which restricts the value of a single variable. For example, in the map-coloring problem it could be the case that South Australians won’t tolerate the color green; we can express that with the unary constraint 〈(SA), SA ≠ green〉. (The initial specification of the domain of a variable can also be seen as a unary constraint.)",5.2.1　极小化极大搜索算法
chap5_para370,1,,既然我们有了关于树的高效算法，可以考虑更一般的约束图是否可以以某种方式简化为树结构。
chap5_para370,2,,有两种方法可以做到这一点：删除节点（6.5.1节）或合并节点（6.5.2节）。
chap5_para371,1,,图6-11　用于求解树状结构CSP的Tree-CSP-Solver算法。
chap5_para371,2,,如果CSP有解，我们可以在线性时间内找到它；如果无解，将检测到矛盾
chap5_para372,1,,6.5.1　割集调整
chap5_para373,1,,将约束图简化为树的第一种方法是为部分变量赋值使得剩余变量能够形成一棵树。
chap5_para373,2,,考虑澳大利亚问题的约束图，如图6-12a所示。
chap5_para373,3,,如果没有南澳大利亚州，这个图就会变成如图6-12b所示的一棵树。
chap5_para373,4,,幸运的是，我们可以通过将SA固定为某个值并从其他变量的域中删除任何与SA取值不一致的值来从图中删除南澳大利亚州。
chap5_para374,1,,图6-12　（a）图6-1中的原始约束图。
chap5_para374,2,,（b）除去SA后，约束图变成由两棵树组成的森林
chap5_para375,1,,现在，删除SA及其约束后，CSP的任意一个解都与SA的值一致。
chap5_para375,2,,（这适用于二元CSP，在高阶约束下，情况会更加复杂。
chap5_para375,3,,）因此，我们可以用上面给出的算法求解剩余的树，从而求解整个问题。
chap5_para375,4,,当然，在一般情况下（与地图着色不同），为SA选择的值可能是错误的，因此我们需要尝试每个可能的值。
chap5_para375,5,,一般算法如下。
chap5_para376,1,,（1）选择CSP变量的一个子集S，使得约束图在删除S后成为一棵树。
chap5_para376,2,,S称为环割集（cycle cutset）。
chap5_para377,1,,（2）对于满足S上所有约束的S中变量的每种可能赋值，
chap5_para378,1,,a. 从剩余变量的域中删除任何与S赋值不一致的值，并且
chap5_para379,1,,b. 如果剩余的CSP存在一个解，那么将其连同S的赋值一起返回。
chap5_para38,1,"A binary constraint relates two variables. For example, SA ≠ NSW is a binary constraint. A binary CSP is one with only unary and binary constraints; it can be represented as a constraint graph, as in Figure 5.1(b).",现在我们来计算Minimax(s)，我们可以将其转化为一个搜索算法，即尝试所有动作然后选择其结果状态的Minimax值最大的动作作为max的最佳移动。
chap5_para38,2,,算法如图5-3所示。
chap5_para38,3,,这是一种递归算法，它一直向下进行到叶节点，然后随着递归的展开通过搜索树倒推极小化极大值。
chap5_para38,4,,例如，图5-2中的算法，首先递归到左下角的3个节点，并对它们调用Utility函数，发现它们的值分别为3、12和8。
chap5_para38,5,,然后选择其中的最小值，3，并将其返回，作为节点B的倒推值。
chap5_para38,6,,同理可得，C和D的倒推值都为2。
chap5_para38,7,,最后，我们选择3、2和2中的最大值3作为根节点的倒推值。
chap5_para380,1,,如果环割集的大小为c，那么总运行时间为：我们需要尝试S中变量的值的所有d c种组合，对于每种组合，我们需要求解一个大小为(n −c)的树问题。
chap5_para380,2,,如果约束图“几乎是一棵树”，那么c将会非常小，相比于直接使用回溯法，将省掉巨大的开销——对100个布尔变量的示例来说，如果我们能找到一个大小为c = 20的割集，时间开销可以从宇宙生命周期缩短到几分钟。
chap5_para380,3,,然而，在最坏情况下，c可能高达(n −2)。
chap5_para380,4,,寻找最小环割集问题是NP困难的，但有一些高效的近似算法。
chap5_para380,5,,算法的总体过程称为割集调整（cutset conditioning），我们将在第13章详细讨论，在那里它将用于概率推理。
chap5_para382,1,,将约束图简化为树的第二种方法基于构建约束图的树分解（tree decomposition）：将原始图转换为树，树中的每个节点由一组变量组成，如图6-13所示。
chap5_para382,2,,树分解必须满足以下3个要求。
chap5_para383,1,,● 原始问题中的每个变量必须至少出现在一个树节点中。
chap5_para384,1,,● 如果两个变量在原始问题中由一个约束连接，那么它们必须同时出现（连同约束）在至少一个树节点中。
chap5_para385,1,,● 如果一个变量出现在两个树节点中，那么它必须出现在连接这两个节点的路径上的所有节点中。
chap5_para386,1,,前两个条件保证了所有变量和约束在树分解中都有表示。
chap5_para386,2,,第三个条件似乎更具技术性，但保证了原始问题的任何变量无论在哪出现都具有相同的值：树中的约束表明一个树节点中的变量必须与其相邻节点中的相应变量具有相同的值。
chap5_para386,3,,例如，图6-13中SA出现在相连的所有4个节点中，因此树分解中的每条边都包含一个约束，一个节点中SA的值必须与下个节点中SA的值相同。
chap5_para386,4,,你可以从图6-12中验证这种分解是有意义的。
chap5_para387,1,,图6-13　图6-12a中约束图的一个树分解
chap5_para388,1,,一旦我们有了一个树状结构图，我们可以应用Tree-CSP-Solver在O(nd 2)时间内得到解，其中n是树节点的个数，d是最大域的大小。
chap5_para388,2,,但是要注意，在树中，域是一组值元组，而不只是单个值。
chap5_para389,1,,例如，图6-13中的左上节点表示在原始问题层级上，变量为，域为，约束为、和的子问题。
chap5_para389,2,,"而在树的层级上，节点表示单个变量，我们可以将其称为SANTWA，它的值必须是一个由颜色组成的三元组，如(red, green, blue)，但不能是(red, red, blue)，因为违反了原始问题中的约束。"
chap5_para389,3,,"然后我们可以从这个节点移动到相邻节点，其变量为SANTQ，此时只有一个元组(red, green, blue)与SANTWA的选择一致。"
chap5_para389,4,,对后两个节点重复完全相同的过程，但可以独立地为T作出任何选择。
chap5_para39,1,"We can also define higher-order constraints. The ternary constraint Between(X, Y, Z), for example, can be defined as 〈(X, Y, Z), X < Y < Z or X > Y > Z〉.",极小化极大算法对博弈树进行完整的深度优先探索。
chap5_para39,2,,如果树的最大深度为m，并且在每个点都有b种合法移动，那么极小化极大算法的时间复杂度为O(bm)。
chap5_para39,3,,对于一次生成所有动作的算法，空间复杂度为O(bm)，对于一次只生成一个动作的算法，空间复杂度为O(m)（见3.4.3节）。
chap5_para39,4,,指数级的复杂度使得Minimax无法应用于复杂博弈。
chap5_para39,5,,例如，国际象棋的分支因子约为35，平均深度约为80层，搜索个状态显然是不可行的。
chap5_para39,6,,然而，Minimax确实是对博弈进行数学分析的基础。
chap5_para39,7,,通过以各种方式近似极小化极大分析，我们可以推导出更实用的算法。
chap5_para390,1,,使用Tree-CSP-Solver算法可以在O(nd2)时间内求解任何树分解问题，只要d保持较小值，它都是高效的。
chap5_para390,2,,回到100个布尔变量的示例，如果每个节点有10个变量，那么d = 210，我们可以在几秒内找到解。
chap5_para390,3,,但如果有一个节点包含30个变量，则需要几个世纪的时间。
chap5_para391,1,,一个给定的图允许多种树分解，在选择分解时，目标是使子问题尽可能小。
chap5_para391,2,,（将所有变量放在同一个节点中在技术上也是一棵树，但对求解问题没有帮助。
chap5_para391,3,,）图的树分解的树宽（tree width）为最大节点的大小减1，图本身的树宽定义为其所有树分解的最小宽度。
chap5_para391,4,,如果一个图的树宽为w，那么给定相应的树分解，该问题可以在O(ndw+1)时间内求解。
chap5_para391,5,,因此，如果CSP的约束图树宽有界，则该CSP在多项式时间内是可解的。
chap5_para392,1,,遗憾的是，找出树宽最小的分解是 一个NP困难问题，但有一些启发式方法在实践中效果很好。
chap5_para392,2,,时间为的割集分解和时间为O(ndw+1)的树分解哪个更好？
chap5_para392,3,,每当有一个大小为c的环割集时，也会有一个大小为的树宽，并且在某些情况下它可能要小得多。
chap5_para392,4,,所以从时间上考虑，应该选择树分解，但环割集方法的优点是，它可以在线性内存中执行，而树分解需要关于w的指数级内存。
chap5_para394,1,,到目前为止，我们已经讨论了约束图的结构。
chap5_para394,2,,在变量的值中，或在约束关系本身的结构中，也可能存在重要的结构。
chap5_para394,3,,考虑有d种颜色的地图着色问题。
chap5_para394,4,,对于每个一致解，实际上都有一组通过排列颜色名形成的d!个解。
chap5_para394,5,,例如，在澳大利亚地图中，我们知道WA、NT和SA肯定具有不同颜色，但实际上，将3种颜色分配给3个区域有3! = 6种方法。
chap5_para394,6,,这称为值对称（value symmetry）。
chap5_para394,7,,我们希望通过打破这种赋值对称性将搜索空间缩小d!倍。
chap5_para394,8,,可以通过引入对称性破缺约束（symmetry-breaking constraint）做到这一点。
chap5_para394,9,,对于我们的例子，可以施加一个任意的排序约束，，即要求3个值按字母顺序排列。
chap5_para394,10,,这个约束保证了d!个解中只有一个是可能解：。
chap5_para395,1,,对于地图着色问题，很容易找到一个消除对称性的约束。
chap5_para395,2,,一般来说，要消除所有的对称性是NP困难的，但打破值对称已被证明在许多问题上都是重要和有效的。
chap5_para397,1,,● 约束满足问题（CSP）的状态为一组变量/值对，解的条件为一组变量约束。
chap5_para397,2,,许多重要的真实问题都可以用CSP描述。
chap5_para398,1,,● 许多推断技术利用约束排除某些变量赋值。
chap5_para398,2,,这些约束包括节点一致性、弧一致性、路径一致性和k一致性。
chap5_para399,1,,● 回溯搜索是深度优先搜索的一种形式，通常用于求解CSP。
chap5_para399,2,,推断可以与搜索交替进行。
chap5_para4,1,"In this chapter we break open the black box by using a factored representation for each state: a set of variables, each of which has a value.",[1]　对应英文game在博弈论中译为“博弈”，但在本书中不同语境下会根据具体情况使用博弈、游戏、比赛等。
chap5_para4,2,A problem is solved when each variable has a value that satisfies all the constraints on the variable.,——译者注
chap5_para4,3,"A problem described this way is called a constraint satisfaction problem, or CSP.",
chap5_para40,1,"A constraint involving an arbitrary number of variables is called a global constraint. (The name is traditional but confusing because a global constraint need not involve all the variables in a problem). One of the most common global constraints is Alldiff, which says that all of the variables involved in the constraint must have different values. In Sudoku problems (see Section 5.2.6), all variables in a row, column, or 3 × 3 box must satisfy an Alldiff constraint.",图5-3　使用极小化极大计算最优移动的算法。
chap5_para40,2,,最优移动是指，在假定对手移动是为了使效用值最小的前提下，使终止状态效用值最大的移动。
chap5_para40,3,,函数Max-Value和Min-Value遍历整个博弈树直到叶节点，以确定每个状态的倒推值以及如何移动以到达该状态
chap5_para400,1,,● 最少剩余值启发式算法和度启发式算法是领域无关的方法，用于决定在回溯搜索中下一步选择哪个变量。
chap5_para400,2,,最少约束值启发式算法有助于决定对于给定变量首先尝试哪个值。
chap5_para400,3,,回溯发生在某个变量找不到合法赋值时。
chap5_para400,4,,冲突导向回跳直接回溯到问题的根源。
chap5_para400,5,,约束学习记录在搜索过程中遇到的冲突，以免在以后的搜索中出现相同的冲突。
chap5_para401,1,,● 使用最少冲突启发式算法的局部搜索也已成功地应用于约束满足问题。
chap5_para402,1,,● CSP求解的复杂性与其约束图的结构密切相关。
chap5_para402,2,,树状结构问题可以在线性时间内求解。
chap5_para402,3,,割集调整可以将一般的CSP简化为树状结构的CSP，如果能找到一个较小的割集，算法会非常高效（只需线性内存）。
chap5_para402,4,,树分解技术将CSP转化为由子问题构成的树，当约束图的树宽较小时，算法是高效的；然而，它们需要约束图树宽的指数级的内存。
chap5_para402,5,,将割集调整和树分解相结合可以更好地权衡所需内存和时间。
chap5_para405,1,,第三部分　知识、推理和规划
chap5_para407,1,,在本章中，我们设计能够表示复杂世界的智能体，它使用推断过程来获取关于这个世界的新表示，并使用这种表示来推导下一步该怎么做。
chap5_para408,1,,人类似乎具有知识，人类的知识能够帮助他们做事。
chap5_para408,2,,在人工智能中，基于知识的智能体（knowledge-based agent）对知识的内部表示（representation）进行推理（reasoning）来确定要采取的动作。
chap5_para409,1,,第3章和第4章的问题求解智能体具有知识，但这种知识是非常有限且死板的。
chap5_para409,2,,它们知道可以采取哪些动作，也知道在某个状态采取某个动作将得到哪种结果，但它们不知道一般事实。
chap5_para409,3,,例如，寻路智能体不知道一条路的长度不可能是负数公里，而8数码智能体也不知道两块瓷砖无法放置在同一个空格当中。
chap5_para409,4,,问题求解智能体具有的知识对寻找从起点到终点的路径这种问题非常有用，但也仅限于此。
chap5_para41,1,Another example is provided by cryptarithmetic puzzles (Figure 5.,5.2.2　多人博弈中的最优决策
chap5_para41,2,2(a)).,
chap5_para41,3,Each letter in a cryptarithmetic puzzle represents a different digit.,
chap5_para41,4,For the case in Figure 5.,
chap5_para41,5,"2(a), this would be represented as the global constraint Alldiff (F, T, U, W, R, O).",
chap5_para41,6,The addition constraints on the four columns of the puzzle can be written as the following n-ary constraints:,
chap5_para410,1,,问题求解智能体所使用的原子表示也有很大的局限性。
chap5_para410,2,,例如，在部分可观测的环境中，问题求解智能体表示它对当前状态的了解的唯一选项是列出所有可能的具体状态。
chap5_para410,3,,我可以让一个人驱车前往一个人口不超过1万的美国小镇，但如果要让问题求解智能体来做这件事，我只能明确地将目标描述为大约1.6万个符合条件的小镇的集合。
chap5_para411,1,,第6章引入了我们的第一个因子化表示，其中状态被表示为对变量的赋值。
chap5_para411,2,,这是朝正确方向前进的一步，它能使智能体的某些部分以与领域无关的方式运作，并支持更高效的算法。
chap5_para411,3,,在本章中，我们将这一步延伸到它的逻辑结论，可以说，我们将逻辑扩展为一类通用的表示，以支持基于知识的智能体。
chap5_para411,4,,这些智能体可以组合或重组信息以适应各种用途。
chap5_para411,5,,它可以与我们当下的需要毫不相关，就像数学家证明定理或天文学家计算地球的预期寿命一样。
chap5_para411,6,,基于知识的智能体能够接受明确描述的目标作为任务，能够通过主动学习或被告知关于环境的新知识快速地获得完成任务的能力，也能够通过更新相关知识适应环境的变化。
chap5_para412,1,,我们在7.1节开始介绍智能体的总体设计。
chap5_para412,2,,7.2节新引入了一个名为wumpus世界的简单环境，以便在不涉及任何技术细节的前提下，阐明基于知识的智能体的运作方式。
chap5_para412,3,,随后我们在7.3节解释逻辑的一般原理，在7.4节介绍命题逻辑的具体细节。
chap5_para412,4,,命题逻辑是一种因子化表示，尽管它的表达能力不如一阶逻辑（第8章）这种标准的结构化表示，但却能够阐明逻辑的所有基本概念。
chap5_para412,5,,命题逻辑还具有丰富的推断方法，我们将在7.5节和7.6节中描述这些内容。
chap5_para412,6,,最后，7.7节将基于知识的智能体的概念与命题逻辑的技术结合起来，为wumpus世界构建了一个简单的智能体。
chap5_para413,1,,7.1　基于知识的智能体
chap5_para414,1,,基于知识的智能体的核心部件是它的知识库（knowledge base，KB）。
chap5_para414,2,,知识库是一个语句集。
chap5_para414,3,,（此处“语句”是一个术语。
chap5_para414,4,,它与英语或其他自然语言的语句类似，但不完全相同。
chap5_para414,5,,）这些语句用知识表示语言（knowledge representation language）表达，代表了关于世界的某种断言。
chap5_para414,6,,如果一条语句是直接给出的，而不是从其他语句推导而来的，我们就称它为公理（axiom）。
chap5_para415,1,,向知识库添加新语句以及从知识库查询已知语句的方法是必不可少的。
chap5_para415,2,,这些操作的标准名称分别是Tell（告知）和Ask（询问）。
chap5_para415,3,,这两个操作都可能涉及推断（inference），也就是从原有语句中推导出新语句。
chap5_para415,4,,推断必须符合以下要求：当向知识库询问（Ask）时，答案应当遵循先前已经告知（Tell）知识库的内容而生成。
chap5_para415,5,,我们将在本章后续部分仔细讲解何为“遵循”。
chap5_para415,6,,现在，我们暂且将其理解为在推断过程中不能进行捏造。
chap5_para416,1,,图7-1展示了基于知识的智能体程序。
chap5_para416,2,,与所有的智能体一样，基于知识的智能体以一个感知作为输入，返回一个动作。
chap5_para416,3,,该智能体维护一个知识库KB，这个知识库最初可能包括一些背景知识（background knowledge）。
chap5_para417,1,,图7-1　通用的基于知识的智能体。
chap5_para417,2,,给定一个感知，智能体将这一感知添加进知识库，向知识库询问最优动作，并告知知识库它已经采取了这一动作
chap5_para418,1,,每次调用智能体程序时，程序会做3件事。
chap5_para418,2,,首先，它告知知识库它所感知到的东西。
chap5_para418,3,,然后，它询问知识库它应当采取什么动作。
chap5_para418,4,,在回答这一查询时，可能会对关于世界的当前状态、可能的动作序列的执行结果等进行大量推理。
chap5_para418,5,,最后，智能体程序告知知识库它选择的动作，并返回这一动作以便执行。
chap5_para419,1,,表示语言的细节隐藏在3个函数中，这3个函数一方面实现了传感器与执行器之间的接口，另一方面又实现了核心表示与推理系统的接口。
chap5_para419,2,,Make-Percept-Sentence构建了一个语句，断言智能体在给定时间接收到给定的感知。
chap5_para419,3,,Make-Action-Query构建了一个语句，询问当前时刻应当采取何种动作。
chap5_para419,4,,最后，Make-Action-Sentence构建了一个语句，断言选定的动作已经执行。
chap5_para419,5,,推断机制的细节隐藏在Tell与Ask中。
chap5_para419,6,,后续章节将阐明这些细节。
chap5_para42,1,"Description Up and down triangles represent MAX and MIN nodes, respectively. The first level of the game tree is labeled MAX and the MAX node is labeled ""A"". Node ""A"" is marked 3 and has three child nodes. The second level is labeled MIN and the three child nodes are MIN nodes that are labeled B, C, and D. An arrow labeled “a” subscript 1 from node “a” points to node B. Paths labeled “a” subscript 2 and “a” subscript 3 from node “a” connect to nodes C and D, respectively. The three nodes each have three child nodes that are MAX nodes. Node B is marked 3, C is marked 2, and D is marked 2. The three child nodes of B are marked 3, 12, and 8. Paths labeled b subscript 1, b subscript 2, and b subscript 3 connect node B to nodes 3, 12, and 8, respectively. The three child nodes of C are marked 2, 4, and 6. Paths labeled c subscript 1, c subscript 2, and c subscript 3 connect node C to nodes 2, 4, and 6, respectively. The three child nodes of D are marked 14, 5, and 2. Paths labeled d subscript 1, d subscript 2, and d subscript 3 connect node D to nodes 14, 5, and 2, respectively.",许多流行游戏都允许多个玩家参与。
chap5_para42,2,,让我们来看看如何将极小化极大思想推广到多人博弈中。
chap5_para42,3,,从技术角度来看，这很自然，但是也产生了一些有趣的新的概念上的问题。
chap5_para420,1,,图7-1所示的基于知识的智能体看起来与第2章所述的具有内部状态的智能体非常相似。
chap5_para420,2,,而由于Tell和Ask的定义，基于知识的智能体并不仅是普通的用来计算动作的程序。
chap5_para420,3,,它受到位于知识层面（knowledge level）的描述的操控，我们只需要在知识层面明确智能体所具有的知识和它的目标，就可以决定它的行为。
chap5_para421,1,,例如，一辆自动驾驶出租车的任务是将一名乘客从旧金山送往马林县，它或许知道金门大桥是两地间的唯一通路。
chap5_para421,2,,因此，我们可以猜测出租车将驶过金门大桥，因为它知道这样能达成目标。
chap5_para421,3,,注意，这一分析与出租车在实现层面（implementation level）的工作原理毫无关系。
chap5_para421,4,,不论它是用链表或点阵图来实现地理知识，还是通过操纵寄存器中的符号串或在神经元网络中传递有噪声的信号来进行推理，都与我们的分析无关。
chap5_para422,1,,我们可以仅通过告知智能体必需的知识来构建基于知识的智能体。
chap5_para422,2,,智能体设计者可以从空知识库开始，逐条告知智能体语句，直到它明白如何在它的环境中运作。
chap5_para422,3,,我们称之为陈述性（declarative）系统构建方法。
chap5_para422,4,,相对地，过程性（procedural）方法将所需的行为直接编码为程序代码。
chap5_para422,5,,在20世纪70年代和80年代，两种方法的提倡者进行了激烈的辩论。
chap5_para422,6,,我们现在明白，成功的智能体在设计中常常需要将陈述性和过程性这两种方法的元素结合起来，而陈述性的知识也往往能够被编译成更有效的过程性代码。
chap5_para423,1,,我们还可以给基于知识的智能体赋予自主学习的机制，我们将在第19章讲解的这些机制。
chap5_para423,2,,智能体能够利用这些机制从一系列感知中创建关于环境的一般知识。
chap5_para423,3,,进行学习的智能体可以是完全自主的。
chap5_para424,1,,7.2　wumpus世界
chap5_para425,1,,本节我们将描述一个能够体现基于知识的智能体的价值的环境。
chap5_para425,2,,wumpus世界（wumpus world）是一个洞穴，其中有许多房间，房间之间有走廊连接。
chap5_para425,3,,在洞穴的某处潜伏着可怕的wumpus，这是一只会吃掉任何进入其房间的人的怪兽。
chap5_para425,4,,智能体可以射杀wumpus，但智能体只有一支箭。
chap5_para425,5,,一些房间有无底洞，能困住任何漫游到这些房间中的人（wumpus除外，它体型大得无法落入无底洞）。
chap5_para425,6,,这个阴森环境的唯一回报是可能找到的金块。
chap5_para425,7,,尽管以现代电子游戏的眼光来看，wumpus世界相当乏味，但它却能展示出智能的一些重要属性。
chap5_para426,1,,图7-2展示了一个简单的wumpus世界示例。
chap5_para426,2,,任务环境的精确定义用2.3节所述的PEAS描述法给出。
chap5_para427,1,,图7-2　一个典型的wumpus世界。
chap5_para427,2,,智能体位于左下角，面朝东（向右）
chap5_para428,1,,● 性能度量：带着金块从洞穴爬出+1000，跌入无底洞或被wumpus吞食−1000，每采取一个动作−1，用尽箭支−10。
chap5_para428,2,,如果智能体死亡或爬出洞穴，游戏结束。
chap5_para429,1,,● 环境：一个4×4的房间网格，网格四周环绕着围墙。
chap5_para429,2,,"智能体始终从标为[1, 1]的方格开始，面向东方。"
chap5_para429,3,,金块和wumpus的位置是根据均匀分布从除了起始方格的所有方格中随机选定的。
chap5_para429,4,,另外，除起始方格外的每个方格都可能是无底洞，出现的概率为0.2。
chap5_para43,1,Figure 5.,首先，我们需要将每个节点的单一值替换为值向量。
chap5_para43,2,2 (a) A cryptarithmetic problem.,例如，在玩家A、B和C参与的3人博弈中，每个节点都与一个向量相关联。
chap5_para43,3,"Each letter stands for a distinct digit; the aim is to find a substitution of digits for letters such that the resulting sum is arithmetically correct, with the added restriction that no leading zeroes are allowed.",对于终止状态，这一向量表示每个玩家各自在该状态得到的效用值。
chap5_para43,4,"(b) The constraint hypergraph for the cryptarithmetic problem, showing the Alldiff constraint (square box at the top) as well as the column addition constraints (four square boxes in the middle).",（在双人零和博弈中，二元向量可以简化为一个值，因为两个值总是互为相反数。
chap5_para43,5,"The variables C1, C2, and C3 represent the carry digits for the three columns from right to left.",）最简单的实现方法是让Utility函数返回效用值向量。
chap5_para430,1,,● 执行器：智能体可以向前（Forward）、左转（TurnLeft）90°和右转（TurnRight）90°。
chap5_para430,2,,如果智能体进入有活着的wumpus或者有无底洞的方格，它将悲惨地死去。
chap5_para430,3,,（但进入有死掉的wumpus的方格是安全的，尽管气味会很臭。
chap5_para430,4,,）如果智能体试图前进并撞到墙，则智能体会原地不动。
chap5_para430,5,,如果智能体与金块在同一个方格，抓取（Grab）动作可以用于捡起金块。
chap5_para430,6,,射击（Shoot）动作可以用于向智能体面对的方向笔直地发射一支箭，这支箭会一直飞行，直到它命中wumpus（此时wumpus将被杀死）或击中墙壁。
chap5_para430,7,,智能体只有一支箭，因此只有第一次射击动作有效。
chap5_para430,8,,"最后，攀爬（Climb）动作可以用于爬出洞穴，但智能体仅能从方格[1, 1]爬出。"
chap5_para431,1,,● 传感器：该智能体有5个传感器，每个传感器给出一个单一信息。
chap5_para432,1,,❏ 在与wumpus直接（非对角）相邻的方格中，智能体会感知到臭味（Stench）。
chap5_para432,2,,[1]
chap5_para434,1,,[1]　wumpus所在的方格恐怕也有臭味，但任何进入该方格的智能体在能够进行感知前就会被吞食。
chap5_para435,1,,❏ 在与无底洞直接相邻的方格中，智能体会感知到微风（Breeze）。
chap5_para436,1,,❏ 在金块所在的方格中，智能体会感知到闪光（Glitter）。
chap5_para437,1,,❏ 智能体走向墙壁会感知到碰撞（Bump）。
chap5_para438,1,,❏ 如果wumpus被杀死，它将发出惨叫（Scream），智能体可以在洞穴的任意位置感知到。
chap5_para439,1,,感知将以由5个符号组成的列表的形式传给智能体程序。
chap5_para439,2,,"例如，如果有臭味和微风，但没有闪光、碰撞和惨叫，智能体程序将收到[Stench, Breeze, None, None, None]。"
chap5_para44,1,"where C1, C2, and C3 are auxiliary variables representing the digit carried over into the tens, hundreds, or thousands column. These constraints can be represented in a constraint hypergraph, such as the one shown in Figure 5.2(b). A hypergraph consists of ordinary nodes (the circles in the figure) and hypernodes (the squares), which represent n-ary constraints—constraints involving n variables.",现在我们要考虑非终止状态。
chap5_para44,2,,考虑图5-4的博弈树中标为X的节点。
chap5_para44,3,,此时，轮到玩家C选择如何移动。
chap5_para44,4,,两种选择产生了效用值向量分别为和的两种终止状态，因为6大于3，所以C应该选择第一种移动。
chap5_para44,5,,这意味着，如果到达状态X，后续的博弈将产生效用值为的终止状态。
chap5_para44,6,,因此，这个向量就是X的倒推值。
chap5_para44,7,,一般地，节点n的倒推值是对在该点进行选择的玩家来说效用值最大的后继状态的效用值向量。
chap5_para440,1,,我们可以在第2章所述的多个维度上描述wumpus环境。
chap5_para440,2,,显然，它是确定性的、离散的、静态的且单智能体的。
chap5_para440,3,,（好在wumpus不移动。
chap5_para440,4,,）它是序贯的，因为只有采取很多动作后才可能得到奖励。
chap5_para440,5,,它是部分可观测的，因为状态的一些方面是无法直接感知到的，如智能体的位置、wumpus的健康状况以及是否还有箭支可用。
chap5_para440,6,,对于无底洞和wumpus的位置，我们可以将其看作状态中没有观测到的部分，在这种情况下，环境的转移模型是完全已知的，找出无底洞和wumpus的位置就能补全智能体对状态的知识；抑或，我们也可以说转移模型本身是未知的，因为智能体不知道哪些向前动作是致命的，在这种情况下，找出无底洞和wumpus的位置能够补全智能体对于转移模型的知识。
chap5_para441,1,,对于环境中的智能体，主要的挑战是它起初并不知道环境的配置。
chap5_para441,2,,克服这种无知似乎需要逻辑推理。
chap5_para441,3,,在wumpus世界的大多数情况中，智能体是有可能安全地拾取金块的。
chap5_para441,4,,但智能体偶尔也需要在空手而归和冒死寻宝之间做出选择。
chap5_para441,5,,大约21%的环境是极不公平的，因为这时金块位于无底洞中，或被无底洞包围。
chap5_para442,1,,我们来看一个基于知识的智能体是如何探索图7-2所示的wumpus世界的环境的。
chap5_para442,2,,此处使用一种非形式化的知识表示语言，在网格中写下符号来表示（如图7-3和图7-4所示）。
chap5_para443,1,,图7-3　智能体在wumpus世界迈出的第一步。
chap5_para443,2,,"（a）在感知到[None, None, None, None, None]后的初始状态。"
chap5_para443,3,,"（b）在移动到[2, 1]后感知到[None, Breeze, None, None, None]"
chap5_para444,1,,智能体的初始知识库包括前述的环境规则。
chap5_para444,2,,"具体来说，智能体知道自己位于[1, 1]且[1, 1]是安全的方格。"
chap5_para444,3,,"我们在方格[1, 1]中用“A”和“OK”分别进行表示。"
chap5_para445,1,,"第一个感知是[None, None, None, None, None]，据此智能体可以认定它的相邻方格[1, 2]和[2, 1]是安全的——它们是“OK”的。"
chap5_para445,2,,图7-3a展示了此时智能体的知识状态。
chap5_para446,1,,图7-4　智能体运作时的两个后续状态。
chap5_para446,2,,"（a）回到[1, 1]再移动到[1, 2]后，感知到[Stench, None, None, None, None]。"
chap5_para446,3,,"（b）来到[2, 2]再移动到[2, 3]，感知到[Stench, Breeze, Glitter, None, None]"
chap5_para447,1,,一个谨慎的智能体只会移动到它所知的OK方格。
chap5_para447,2,,"我们假设智能体决定前进到[2, 1]。"
chap5_para447,3,,"这个智能体在[2, 1]感受到微风（用“B”表示），因此在相邻方格中必然存在无底洞。"
chap5_para447,4,,"根据游戏规则，无底洞不可能在[1, 1]，因此[2, 2]和[3, 1]其中之一必然有无底洞或二者都有。"
chap5_para447,5,,图7-3b中的记号“P?”表示这些方格中可能存在无底洞。
chap5_para447,6,,此时，仅有一个已知的且未访问过的“OK”方格。
chap5_para447,7,,"因此这个心思缜密的智能体将扭头，回到[1, 1]，然后移步[1, 2]。"
chap5_para448,1,,"智能体在[1, 2]感知到臭味，导致知识状态变为图7-4a所示的状况。"
chap5_para448,2,,"[1, 2]有臭味表明附近肯定有wumpus。"
chap5_para448,3,,"但根据游戏规则wumpus不可能在[1, 1]，也不在[2, 2]（否则智能体先前在[2, 1]时会探测到臭味）。"
chap5_para448,4,,"因此，智能体可以推断出wumpus在[1, 3]。"
chap5_para448,5,,记号“W!”表示这一推断。
chap5_para448,6,,"而[1, 2]没有微风表明[2, 2]没有无底洞。"
chap5_para448,7,,"考虑到智能体先前已经推断出[2, 2]或[3, 1]中必然有无底洞，因此无底洞必然位于[3, 1]。"
chap5_para448,8,,这是一次相当复杂的推断，因为它结合了在不同时间、不同地点获取的信息，并在缺乏感知的情况下迈出了关键的一步。
chap5_para449,1,,"现在智能体已经证明了[2, 2]中既没有无底洞也没有wumpus，因此可以移动到那里。"
chap5_para449,2,,"我们没有展示智能体在[2, 2]的知识状态，姑且假设智能体转向并移动到[2,3]，形成了图7-4b所示的情况。"
chap5_para449,3,,"在[2, 3]中，智能体探测到闪光，因此它应该抓取金块然后回家。"
chap5_para45,1,"Alternatively, as Exercise 5.NARY asks you to prove, every finite-domain constraint can be reduced to a set of binary constraints if enough auxiliary variables are introduced. This means that we could transform any CSP into one with only binary constraints—which certainly makes the life of the algorithm designer simpler. Another way to convert an n-ary CSP to a binary one is the dual graph transformation: create a new graph in which there will be one variable for each constraint in the original graph, and one binary constraint for each pair of constraints in the original graph that share variables.",任何参与多人博弈（如Diplomacy或Settlers of Catan游戏）的参与者都会很快意识到，比起双人博弈，多人博弈要复杂得多。
chap5_para45,2,,多人博弈通常涉及参与者之间的正式或非正式联盟（alliance）。
chap5_para45,3,,联盟会随着博弈的发展建立和瓦解。
chap5_para45,4,,我们如何理解这种行为？
chap5_para45,5,,联盟是多人博弈中每个参与者都按照最优策略行动的自然结果吗？
chap5_para45,6,,事实证明的确如此。
chap5_para450,1,,注意，在智能体从可用信息中得出结论的每个情形下，如果可用信息是正确的，则可以保证结论都是正确的。
chap5_para450,2,,这是逻辑推理的一个重要性质。
chap5_para450,3,,本章剩余部分将描述如何构建能够表示信息并得出类似前述的结论的逻辑智能体。
chap5_para452,1,,本节综述逻辑表示和推理的基本概念。
chap5_para452,2,,这些漂亮的想法独立于逻辑的具体形式。
chap5_para452,3,,因此，我们将形式的技术细节推后到7.4节介绍，本节代之以熟悉的普通算术问题作为示例。
chap5_para453,1,,在7.1节，我们说过知识库由语句组成。
chap5_para453,2,,这些语句是根据表示语言的语法（syntax）表达的，语法规定了所有的合规语句。
chap5_para453,3,,用简单的算术就能清晰地说明语法这个概念：“x + y = 4”是合规的语句，而“x4y+=”不是。
chap5_para454,1,,一种逻辑还必须定义语句的语义，或者说语句的含义。
chap5_para454,2,,语义定义每条语句在每个可能世界中的真值。
chap5_para454,3,,例如，算术的语义指明“x + y = 4”在一个x为2且y为2的世界为真，但在一个x为1且y为1的世界中为假。
chap5_para454,4,,在标准的逻辑学中，每个可能世界中的每条语句要么为真，要么为假——没有中间地带。
chap5_para454,5,,[2]
chap5_para456,1,,[2]　第13章讨论的模糊逻辑（fuzzy logic）允许存在不同程度的真值。
chap5_para457,1,,当需要精确描述时，我们用模型来代替“可能世界”。
chap5_para457,2,,可能世界可以被认为是（潜在的）真实环境，智能体可能在也可能不在其中，而模型是数学抽象，对于每个相关的语句，每个模型都有固定的真值（真或假）。
chap5_para457,3,,非正式地举个例子：我们可以认为一个可能世界是让x个男士和y个女士坐在一张桌子边上玩桥牌，如果总共有4个人，则语句x+y=4为真。
chap5_para457,4,,正式地说，可能的模型是对变量x和y进行非负整数赋值的所有可能。
chap5_para457,5,,每个这样的赋值都确定了任何一个变量为x和y的算术语句的真值。
chap5_para457,6,,如果语句在模型m中为真，我们说m满足，有时也可以说m是的一个模型。
chap5_para457,7,,我们使用记号来代表的所有模型的集合。
chap5_para458,1,,有了真值的概念，我们就可以讨论逻辑推理了。
chap5_para458,2,,这涉及语句之间的逻辑蕴含（entailment），即一个语句逻辑上引发另一语句。
chap5_para458,3,,数学上，我们用
chap5_para459,1,,来表示语句蕴含语句。
chap5_para459,2,,蕴含的形式化定义是：当且仅当在为真的每个模型中也为真。
chap5_para459,3,,用刚才介绍的记法，我们可以将其写作
chap5_para46,1,"For example, consider a CSP with the variables χ = {X, Y, Z}, each with the domain {1,2,3,4,5}, and with the two constraints C1: 〈(X ,Y, Z), X + Y = Z〉 and C2: 〈(X, Y), X +1 = Y〉. Then the dual graph would have the variables χ = {C1, C2}, where the domain of the C1 variable in the dual graph is the set of {(xi, yj, zk)} tuples from the C1 constraint in the original problem, and similarly the domain of C2 is the set of {(xi, yj)} tuples. The dual graph has the binary constraint 〈(C1, C2), R1〉, where R1 is a new relation that defines the constraint between C1 and C2; in this case it would be R1 = {((1,2,3), (1,2)), ((2,3,5), (2,3))}.",例如，假设现在A和B处于弱势，而C处于强势。
chap5_para46,2,,那么，对A和B来说，最理想的做法往往是一起攻击C，而不是彼此攻击，以免C对它们逐个消灭。
chap5_para46,3,,这样的话，合作其实产生于纯粹的自私行为。
chap5_para46,4,,当然，一旦C在联合攻击下被削弱，联盟就失去了价值，A或B都有可能违反协议。
chap5_para461,1,,（注意此处⊆的方向：若，则是比更强的断言，它排除了更多的可能世界。
chap5_para461,2,,）蕴含关系用算术来说明会更为亲切一些：我们很容易理解语句x=0蕴含语句xy=0。
chap5_para461,3,,显然，在任一x为0的模型中，xy也必然为0（而无论y的值是多少）。
chap5_para462,1,,我们可以将同样的分析应用于7.2节所述的wumpus世界推理的例子。
chap5_para462,2,,"考虑图7-3b所示的情形：智能体在[1, 1]中什么都没有探测到，在[2, 1]中探测到微风。"
chap5_para462,3,,这些感知与智能体所具有的wumpus世界规则的知识一同构成了知识库。
chap5_para462,4,,"智能体所感兴趣的是相邻的方格[1, 2]、[2, 2]和[3, 1]是否有无底洞。"
chap5_para462,5,,这3个方格中的每一个都可能有或没有无底洞，因此（暂且忽略这个世界的其他方面），总共有23=8个可能的模型。
chap5_para462,6,,图7-5展示了这8个模型。
chap5_para462,7,,[3]
chap5_para464,1,,"[3]　尽管该图用部分wumpus世界来表示模型，但模型实际上只是对类似“[1, 2]中有无底洞”这样的语句进行真或假的赋值。"
chap5_para464,2,,从数学的角度来看，模型中并不需要有可怕的长毛wumpus。
chap5_para465,1,,"图7-5　方格[1, 2]、[2, 2]和[3, 1]中无底洞存在性的可能的模型。"
chap5_para465,2,,"在[1, 1]中没有观测到任何东西且在[2, 1]中观测到微风的知识库用实线表示。"
chap5_para465,3,,"（a）虚线表示的模型（[1, 2]中没有无底洞）。"
chap5_para465,4,,"（b）虚线表示的模型（[2, 2]中没有无底洞）"
chap5_para466,1,,KB可以理解为一个语句的集合，或断言了所有单个语句的单个语句。
chap5_para466,2,,在与智能体已知相矛盾的模型中，KB为假。
chap5_para466,3,,"例如，在所有[1, 2]含有无底洞的模型中，KB都为假，因为[1, 1]中没有微风。"
chap5_para466,4,,实际上，使KB为真的模型只有3个，这些模型在图7-5中用实线包围。
chap5_para466,5,,我们现在考虑两个可能的结论：
chap5_para467,1,,"=“[1, 2]中没有无底洞”　=“[2, 2]中没有无底洞”"
chap5_para468,1,,在图7-5a和图7-5b中分别用虚线包围了和的模型。
chap5_para468,2,,仔细观察后，我们可以得出
chap5_para469,1,,在所有KB为真的模型中，也为真
chap5_para47,1,There are however two reasons why we might prefer a global constraint such as Alldiff rather than a set of binary constraints.,图5-4　三人博弈的博弈树的前三层，3个玩家为A、B、C。
chap5_para47,2,"First, it is easier and less error-prone to write the problem description using Alldiff.",每个节点都标有3个玩家各自的效用值。
chap5_para47,3,"Second, it is possible to design special-purpose inference algorithms for global constraints that are more efficient than operating with primitive constraints.",最佳移动标示在根节点上
chap5_para47,4,We describe these inference algorithms in Section 5.,
chap5_para47,5,2.,
chap5_para47,6,5.,
chap5_para470,1,,"因此，，即[1,2]中没有无底洞。"
chap5_para470,2,,我们还可以得出
chap5_para471,1,,在一些KB为真的模型中，为假
chap5_para472,1,,"因此，KB不蕴含，即智能体无法断定[2,2]中没有无底洞。"
chap5_para472,2,,"（也无法断定[2,2]中有无底洞。"
chap5_para472,3,,）[4]
chap5_para474,1,,"[4]　智能体可以计算[2,2]中有无底洞的概率，第12章将介绍如何计算。"
chap5_para475,1,,前述的例子不仅阐明了什么是蕴含，还展示了如何用蕴含的定义来推导出结论，即进行逻辑推断。
chap5_para475,2,,图7-5所示的推断算法被称为模型检验，因为这个示例枚举了所有可能的模型来检验在所有KB为真的模型中都为真，即。
chap5_para476,1,,将KB的所有推论的集合比作干草堆而将比做一根针或许有助于理解蕴含和推断。
chap5_para476,2,,蕴含正如草堆中的针一样，而推断就像找到这根针的过程。
chap5_para476,3,,一些形式化记法体现了这种区别：如果一个推断算法i可以从KB中推导出，则记为
chap5_para477,1,,读作“是由i从KB中推得的”或“i从KB推得”。
chap5_para478,1,,一个仅推导蕴含语句的推断算法被称为是可靠的或保真的。
chap5_para478,2,,可靠性是极为重要的属性。
chap5_para478,3,,一个不可靠的推断过程在运作时本质上会编造事实——它会声称发现了并不存在的针。
chap5_para478,4,,我们很容易看出，模型检验在适用时[5]是一个可靠的程序。
chap5_para48,1,"The constraints we have described so far have all been absolute constraints, violation of which rules out a potential solution.",在某些情况下，显式联盟只是将无论如何都会发生的事情具体化。
chap5_para48,2,Many real-world CSPs include preference constraints indicating which solutions are preferred.,而在其他情况下，破坏联盟会被记录为社会污点，所以参与者必须权衡破坏联盟所带来的即时优势和失去信任所造成的长期劣势。
chap5_para48,3,"For example, in a university class-scheduling problem there are absolute constraints that no professor can teach two classes at the same time.",有关这些复杂问题的更多讨论，详见18.2节。
chap5_para48,4,But we also may allow preference constraints: Prof.,
chap5_para48,5,"R might prefer teaching in the morning, whereas Prof.",
chap5_para48,6,N prefers teaching in the afternoon.,
chap5_para48,7,A schedule that has Prof.,
chap5_para48,8,R teaching at 2 p.,
chap5_para48,9,m.,
chap5_para48,10,would still be an allowable solution (unless Prof.,
chap5_para48,11,R happens to be the department chair) but would not be an optimal one.,
chap5_para480,1,,[5]　如果模型空间是有限的，则模型检验是有效的，例如，在固定大小的wumpus世界中。
chap5_para480,2,,而对算术来说，模型空间是无限的：即使我们局限于整数范围，语句x+y=4中x和y的值也是有无限多对的。
chap5_para481,1,,完备性也是很重要的属性：如果一个推断算法能够推导出所有蕴含的语句，则它是完备的。
chap5_para481,2,,真正的草堆大小是有限的，对其进行全面仔细的检查就一定能确定针在不在草堆里，这似乎是很显然的道理。
chap5_para481,3,,然而，对许多知识库来说，推论的草堆是无限的，因而完备性就成了一个重大问题。
chap5_para481,4,,[6]幸运的是，逻辑学中有完备的推断过程，其表达能力足以处理许多知识库。
chap5_para483,1,,[6]　比如说，在第3章的无限搜索空间的情形中，深度优先搜索就是不完备的。
chap5_para484,1,,我们已经描述了一个推理过程，在前提为真的任何世界中都保证结论为真。
chap5_para484,2,,具体来说，如果KB在真实世界中为真，则用可靠的推断过程从KB中推出的所有语句在真实世界中也为真。
chap5_para484,3,,因此，当推断过程在“语法”（例如，寄存器中的位或大脑中的电信号模式这样的内部物理结构）上进行操作时，这个过程对应于一个真实世界的关系，即真实世界的某个部分为真是因为真实世界的其他一些部分为真。
chap5_para484,4,,[7]这种世界与表示的对应如图7-6所示。
chap5_para486,1,,"[7]　正如路德维希•维特根斯坦（Ludwig Wittgenstein）在其著名的《逻辑哲学论》（Tractatus）（Wittgenstein, 1922）中所述：“世界就是所有为真的一切。"
chap5_para486,2,,”
chap5_para487,1,,最后要考虑的问题是落地，也就是逻辑推理过程与智能体所存在的真实环境的联系。
chap5_para487,2,,尤其是，我们如何知道KB在真实世界中为真？
chap5_para487,3,,（毕竟KB只是存在于智能体头脑中的“语法”。
chap5_para487,4,,）这是一个哲学问题，众多的书籍都对此进行了讨论（见第27章）。
chap5_para487,5,,一个简单的回答是，智能体的传感器创建了这个联系。
chap5_para487,6,,例如，我们的wumpus世界智能体有嗅觉传感器。
chap5_para487,7,,一旦有气味，智能体程序就会创建一条合适的语句。
chap5_para487,8,,因此，一旦这条语句被包含在知识库中，就意味着它在真实世界中也为真。
chap5_para487,9,,这样，感知语句的含义和真值就是由产生这些语句的感知过程和语句构建过程定义的。
chap5_para487,10,,那么智能体知识的其他部分呢？
chap5_para487,11,,例如，它对于“wumpus相邻的方格有臭味”这件事的信念呢？
chap5_para487,12,,这不是单个感知的直接表示，而是一项一般规则，它可能是从感知的经验推导出的，却与经验陈述并不完全相同。
chap5_para487,13,,这种一般规则是通过被称为学习的语句构建过程产生的，这是第五部分的主题。
chap5_para487,14,,学习是难免会出错的。
chap5_para487,15,,一种可能的情况是，wumpus有臭味但闰年2月29日这一天除外，因为这一天它要洗澡。
chap5_para487,16,,因此，KB在真实世界中可能并不为真，但因为有很好的学习过程，我们对此就有理由乐观。
chap5_para488,1,,图7-6　语句是智能体的物理结构，而推理是从旧结构构建新结构的过程。
chap5_para488,2,,逻辑推理应当确保新结构所表示的部分世界确实能够从旧结构所表示的部分世界推得
chap5_para489,1,,7.4　命题逻辑：一种非常简单的逻辑
chap5_para49,1,"Preference constraints can often be encoded as costs on individual variable assignments—for example, assigning an afternoon slot for Prof. R costs 2 points against the overall objective function, whereas a morning slot costs 1. With this formulation, CSPs with preferences can be solved with optimization search methods, either path-based or local. We call such a problem a constrained optimization problem, or COP. Linear programs are one class of COPs.",如果博弈不是零和博弈，那么在只有两个参与者时，合作也可能发生。
chap5_para49,2,,例如，假设存在一个效用值为的终止状态，并且每个参与者最高的可能效用值也是1000。
chap5_para49,3,,那么最优策略是双方都尽一切可能到达该状态，也就是说，参与者会自动合作以实现共同的期望目标。
chap5_para490,1,,本节讲解命题逻辑（propositional logic）。
chap5_para490,2,,我们将阐述其语法（即语句的结构）和语义（确定语句真值的方法）。
chap5_para490,3,,由此，我们将推导出一个简单的、语法的逻辑推断算法，它能够实现蕴含的语义概念。
chap5_para490,4,,当然，这一切都仍将发生在wumpus世界中。
chap5_para492,1,,命题逻辑的语法定义合法的语句。
chap5_para492,2,,原子语句（atomic sentence）由单个命题符号（proposition symbol）构成。
chap5_para492,3,,每个这样的符号代表一个为真或假的命题。
chap5_para492,4,,"我们使用以大写字母开头的、可能包含其他字母或下标的符号来表示，例如P、Q、R、W1,3以及FacingEast等。"
chap5_para492,5,,"我们可以任意地进行命名，但通常选择一些有助记功能的名字，例如，使用W1,3代表“wumpus位于[1, 3]”。"
chap5_para492,6,,"请记住，像W1,3这样的符号是原子的，也就是说分开的W、1、3并非符号的有意义的部分。"
chap5_para492,7,,）有两个命题符号有固定的含义：True是永真命题，False是永假命题。
chap5_para492,8,,使用括号和被称作逻辑联结词（logical connective）的运算符可以将简单语句构造成复合语句（complex sentence）。
chap5_para492,9,,常用的联结词有5个。
chap5_para493,1,,● （非）。
chap5_para493,2,,"类似这样的语句称为W1,3的否定。"
chap5_para493,3,,一个文字要么是原子语句，即正文字，要么是原子语句的否定，即负文字。
chap5_para494,1,,● ∧（与）。
chap5_para494,2,,主要联结词是∧的语句称为合取式，例如，其各部分称为合取子句。
chap5_para494,3,,（∧看起来像是“And”中的“A”。
chap5_para494,4,,）
chap5_para495,1,,● ∨（或）。
chap5_para495,2,,"主要联结词是∨的语句称为析取式，例如，其各部分为析取子句，本例中分别为和W2,2。"
chap5_para496,1,,● （蕴涵）。
chap5_para496,2,,如这样的语句称为蕴涵式（implication）或条件式，其前提（premise）或前件（antecedent）是，其结论（conclusion）或后件（consequent）是。
chap5_para496,3,,蕴涵式也被称为规则（rule）或if-then声明。
chap5_para496,4,,有时，蕴涵符号在一些书籍中写作或。
chap5_para497,1,,● （当且仅当）。
chap5_para497,2,,语句是双向蕴涵式（biconditional）。
chap5_para498,1,,图7-7给出了命题逻辑的形式文法。
chap5_para498,2,,［附录B将会介绍巴克斯-诺尔范式（Backus-Naur form，BNF）的概念。
chap5_para498,3,,］我们在BNF文法上附加了运算符优先级，以避免在使用多个运算符时出现歧义。
chap5_para498,4,,“非”运算符的优先级最高，这意味着在语句中，的结合力更强，因此它等价于而不是。
chap5_para498,5,,（这与普通算术一样：−2+4等于2而不是−6。
chap5_para498,6,,）我们也会适时地使用圆括号和方括号来明确语句结构，以改善可读性。
chap5_para499,1,,图7-7　命题逻辑中语句的BNF文法以及从高到低排列的运算符优先级
chap5_para5,1,CSP search algorithms take advantage of the structure of states and use general rather than domain-specific heuristics to enable the solution of complex problems.,
chap5_para5,2,The main idea is to eliminate large portions of the search space all at once by identifying variable/value combinations that violate the constraints.,
chap5_para5,3,CSPs have the additional advantage that the actions and transition model can be deduced from the problem description.,
chap5_para50,1,5.,
chap5_para50,2,2Constraint Propagation: Inference in CSPs,
chap5_para501,1,,了解了命题逻辑的语法后，我们来说明其语义。
chap5_para501,2,,语义定义了用于判定特定模型中语句真值的规则。
chap5_para501,3,,命题逻辑中，模型就是对每个命题符号设定真值，即真（true）或假（false）。
chap5_para501,4,,"例如，如果知识库中的语句使用了命题符号P1,2、P2,2和P3,1，则一个可能模型为"
chap5_para502,1,,由于含有3个命题符号，因此有23=8种可能的模型，与图7-5所示的完全相同。
chap5_para502,2,,但要注意，这些模型是纯粹的数学对象，不必与wumpus世界有关。
chap5_para502,3,,"P1,2只是符号，它可能代表“[1, 2]中有无底洞”，也可能代表“我今天和明天都在巴黎”。"
chap5_para503,1,,命题逻辑的语义必须指定在给定模型下如何计算任一语句的真值。
chap5_para503,2,,这是以递归的方式实现的。
chap5_para503,3,,所有语句都是由原子语句和5个联结词构建的。
chap5_para503,4,,因此，我们需要指定如何计算原子语句的真值和用5个联结词构建的语句的真值。
chap5_para503,5,,对原子语句来说这很简单。
chap5_para504,1,,● true在每个模型里都为真，false在每个模型里都为假。
chap5_para505,1,,● 其余命题符号的真值必须在模型中直接指定。
chap5_para505,2,,"例如，在先前给出的模型m1中，P1,2为假。"
chap5_para506,1,,对于复合语句，有5条规则，它们对任一模型m中的任一子句P和Q（原子语句或复合语句）都成立。
chap5_para507,1,,● 为真，当且仅当在m中P为假。
chap5_para508,1,,● 为真，当且仅当在m中P和Q都为真。
chap5_para509,1,,● 为真，当且仅当在m中P或Q中至少一个为真。
chap5_para51,1,An atomic state-space search algorithm makes progress in only one way: by expanding a node to visit the successors.,博弈的状态数关于树的深度是指数量级的。
chap5_para51,2,A CSP algorithm has choices.,没有一种算法可以完全消除指数项，但有时可以将它减半，即通过剪枝（见3.5.3节）消除对结果没有影响的树的大部分，从而不需要检查所有状态就能计算出正确的极小化极大决策。
chap5_para51,3,"It can generate successors by choosing a new variable assignment, or it can do a specific type of inference called constraint propagation: using the constraints to reduce the number of legal values for a variable, which in turn can reduce the legal values for another variable, and so on.",这种技术称为剪枝（alpha-beta pruning）。
chap5_para51,4,The idea is that this will leave fewer choices to consider when we make the next choice of a variable assignment.,
chap5_para51,5,"Constraint propagation may be intertwined with search, or it may be done as a preprocessing step, before search starts.",
chap5_para51,6,"Sometimes this preprocessing can solve the whole problem, so no search is required at all.",
chap5_para510,1,,● 为真，除非在m中P为真而Q为假。
chap5_para511,1,,● 为真，当且仅当在m中P和Q都为真或都为假。
chap5_para512,1,,这些规则也可以用真值表表示。
chap5_para512,2,,真值表指明在对复合语句的组成部分进行每种可能的真值赋值后，该复合语句的真值。
chap5_para512,3,,图7-8给出了5个联结词的真值表。
chap5_para512,4,,任一语句s关于任一模型m的真值都可以用简单的递归求值来计算。
chap5_para512,5,,例如，在模型m1中求语句的值，得到。
chap5_para512,6,,"习题7.TRUV要求写出算法PL-True?(s, m)，用于计算命题逻辑语句s在模型m中的真值。"
chap5_para513,1,,图7-8　5个逻辑联结词的真值表。
chap5_para513,2,,若要使用真值表计算在P为真、Q为假时的值，首先在左边找到P为true而Q为false的行（第3行），然后找到该行位于列处的值，得到结果true
chap5_para514,1,,“与”“或”“非”的真值表与我们对这些词的直观认识非常接近。
chap5_para514,2,,可能会混淆的关键点是当P为真或Q为真，或者二者同时为真时，为真。
chap5_para514,3,,而另一个联结词“排他或”（简称“异或”）则会在两个子句都为真时为假。
chap5_para514,4,,[8]排他或没有公认的符号，有些人选择使用、或者⊕。
chap5_para516,1,,[8]　在拉丁语中，“或”用两个词表示：“vel”是相容或，“aut”是排他或。
chap5_para517,1,,⇒的真值表可能不太符合人们对“P蕴涵Q”或“若P则Q”的直观理解。
chap5_para517,2,,一种解释是，命题逻辑并不要求P和Q之间有任何因果关系或相关性。
chap5_para517,3,,（在一般的理解下）语句“5是奇数蕴涵东京是日本的首都”是命题逻辑中的真语句，尽管这句话相当奇怪。
chap5_para517,4,,另一个容易混淆之处在于前件为假的所有蕴涵式都为真。
chap5_para517,5,,例如，“5是偶数蕴涵Sam很聪明”为真，而不论Sam是否聪明。
chap5_para517,6,,这似乎很怪异，但如果你将“”当作“如果P为真，则我可以断言Q为真，否则我无法断言”的话，就可以理解了。
chap5_para517,7,,这条语句为假的唯一情形是当P为真而Q为假时。
chap5_para518,1,,当与均为真时，双向蕴涵式为真，英语中常写作“P if and only if Q”（P当且仅当Q）。
chap5_para518,2,,wumpus世界的大部分规则都可以用很好地表示。
chap5_para518,3,,例如，当一个方格的相邻方格中有无底洞，该方格有微风，而且，仅当一个方格的某个相邻方格中有无底洞，该方格有微风。
chap5_para518,4,,因此，我们需要使用双向蕴涵式
chap5_para519,1,,"其中B1, 1代表[1, 1]有微风。"
chap5_para52,1,The key idea is local consistency.,再次考虑图5-2中的双层博弈树。
chap5_para52,2,If we treat each variable as a node in a graph (see Figure 5.,让我们再进行一次最优决策的计算，这一次要仔细观察在这个过程中的每个点上都获得了什么信息。
chap5_para52,3,"1(b)) and each binary constraint as an edge, then the process of enforcing local consistency in each part of the graph causes inconsistent values to be eliminated throughout the graph.",步骤如图5-5所示。
chap5_para52,4,"There are different types of local consistency, which we now cover in turn.",结果是，我们可以在无须评估其中两个叶节点的情况下就能确定极小化极大决策。
chap5_para520,1,,7.4.3　一个简单的知识库
chap5_para521,1,,我们已经定义了命题逻辑的语义，现在可以为wumpus世界构建一个知识库了。
chap5_para521,2,,首先关注wumpus世界的不变部分，后面章节再处理其可变部分。
chap5_para521,3,,"对于每个位置[x, y]，需要用到下列符号："
chap5_para522,1,,"当[x, y]有无底洞，Px, y为真。"
chap5_para523,1,,"当wumpus在[x, y]，不论其死活Wx, y都为真。"
chap5_para524,1,,"当[x, y]有微风，Bx, y为真。"
chap5_para525,1,,"当[x, y]处有臭味，Sx, y为真。"
chap5_para526,1,,"当智能体位于位置[x, y]，Lx, y为真。"
chap5_para527,1,,"我们写下的语句将足以推得（[1, 2]中没有无底洞），正如7.3节用非形式化的方法所做的那样。"
chap5_para527,2,,我们用Ri代表每个语句，以便推导。
chap5_para528,1,,"● [1, 1]中没有无底洞："
chap5_para529,1,,● 一个方格有微风，当且仅当其相邻方格中有无底洞。
chap5_para529,2,,必须对每个方格都进行这样的表示，在此我们只写出相关方格的表示：
chap5_para53,1,5.,另一种考虑这一问题的方式是将Minimax公式简化。
chap5_para53,2,2.,假设图5-5中节点C的两个未评估的后继节点的值分别为x和y，则根节点的值为
chap5_para53,3,1Node consistency,
chap5_para530,1,,● 上述语句在所有wumpus世界中都为真。
chap5_para530,2,,我们现在为智能体在这个特定世界中已访问过的前两个方格引入微风感知，以形成图7-3b所示的情形：
chap5_para531,1,,7.4.4　一个简单的推断过程
chap5_para532,1,,我们现在的目标是确定对于一些语句，是否成立。
chap5_para532,2,,例如，我们的KB是否蕴含？
chap5_para532,3,,我们的第一个推理算法是模型检验方法，它直接实现了蕴含的定义：枚举所有模型，检验在KB为真的每个模型中是否为真。
chap5_para532,4,,模型是对每个命题符号进行真或假的赋值。
chap5_para532,5,,"回到例子中的wumpus世界，它涉及的命题符号是B1, 1、B2, 1、P1, 1、P1, 2、P2, 1、P2, 2和P3, 1。"
chap5_para532,6,,在有7个符号的情况下，总共有27=128个可能的模型，KB在其中3个模型中为真（如图7-9所示）。
chap5_para532,7,,"在这3个模型中，为真，因此[1, 2]中没有无底洞。"
chap5_para532,8,,"但是，在3个模型中，P2, 2在其中两个模型中为真，在另一个模型中为假，因此我们还无法确定[2, 2]中是否有无底洞。"
chap5_para533,1,,图7-9以更准确的形式再现了图7-5所示的推理。
chap5_para533,2,,图7-10描述了一个确定命题逻辑中蕴含关系的通用算法。
chap5_para533,3,,与6.3节所示的Backtracking-Search算法类似，TT-Entails?在符号赋值的有限空间中进行递归枚举。
chap5_para533,4,,这个算法是可靠的，因为它直接实现了蕴含的定义；这个算法也是完备的，因为它对所有KB和都适用，并且算法最后都会终止——因为需要检验的模型数量是有限的。
chap5_para534,1,,图7-9　根据文中所述的知识库构建的真值表。
chap5_para534,2,,如果从R1到R5都为true，则KB为true。
chap5_para534,3,,这种情况在全部128行中只出现了3次（在最右侧的列中用下划线标出）。
chap5_para534,4,,"在这3行中，P1, 2均为false，因此[1, 2]中没有无底洞。"
chap5_para534,5,,"但是，[2, 2]中可能有（也可能没有）无底洞"
chap5_para535,1,,图7-10　用于确定命题蕴含的真值表枚举算法（TT代表真值表）。
chap5_para535,2,,当语句在一个模型中成立，PL-True?返回true。
chap5_para535,3,,变量model代表部分模型——对于部分符号的赋值。
chap5_para535,4,,此处的关键字and不是命题逻辑中的运算符，而是伪代码编程语言中的中缀；如果其两个参数中的任意一个为true，则返回true
chap5_para536,1,,当然，“有限数量”并不总是等同于“少量”。
chap5_para536,2,,如果KB和总共含有n个符号，那么就会有2n个模型。
chap5_para536,3,,这样，算法的时间复杂性就会达到O(2n)。
chap5_para536,4,,（空间复杂性仅为O(n)，因为枚举是深度优先的。
chap5_para536,5,,）在本章稍后部分，我们将展示一个在大多数情况下更高效的算法。
chap5_para536,6,,遗憾的是，命题蕴含是余NP完全的（即很可能不比NP完全简单，见附录A），因此命题逻辑所有已知推断算法的最坏情况复杂性都是输入规模的指数量级。
chap5_para537,1,,7.5　命题定理证明
chap5_para538,1,,至此，我们已经展示了如何用模型检验判定蕴含关系：枚举模型，并验证语句在所有模型中必须成立。
chap5_para538,2,,本节将展示如何通过定理证明找出蕴含关系。
chap5_para538,3,,定理证明对知识库中的语句直接应用推断规则，它能够在不检验模型的情况下，构建对所需语句的证明。
chap5_para538,4,,如果模型的数量很多，但其证明很短，则定理证明会比模型检验更为高效。
chap5_para539,1,,在深入定理证明算法的细节之前，我们还需要了解一些与蕴含相关的概念。
chap5_para539,2,,第一个概念是逻辑等价（logical equivalence）：如果两个语句和在相同的模型集合中都为真，则这两个语句逻辑等价，可以写作。
chap5_para539,3,,（注意，用于对语句进行声明，而则用作语句的一部分。
chap5_para539,4,,）例如，我们可以很容易地（用真值表）证明与是逻辑等价的。
chap5_para539,5,,其他逻辑等价见图7-11。
chap5_para539,6,,这些等价关系在逻辑中扮演的角色与算术恒等式在普通数学中的角色非常相似。
chap5_para539,7,,等价的另一种定义为“任意两条语句和是等价的，当且仅当它们互相蕴含”：
chap5_para54,1,"A single variable (corresponding to a node in the CSP graph) is node-consistent if all the values in the variable’s domain satisfy the variable’s unary constraints. For example, in the variant of the Australia map-coloring problem (Figure 5.1) where South Australians dislike green, the variable SA starts with domain {red,green,blue}, and we can make it node consistent by eliminating green, leaving SA with the reduced domain {red, blue}. We say that a graph is node-consistent if every variable in the graph is node-consistent.",也就是说，根节点的值以及极小化极大决策与叶节点x和y的值无关，因此可以将它们剪枝。
chap5_para541,1,,第二个概念是有效性（validity）。
chap5_para541,2,,如果一条语句在所有模型中都为真，则这条语句是有效的。
chap5_para541,3,,例如，语句是有效的。
chap5_para541,4,,有效的语句也被称为重言式（tautology）——它们必然为真。
chap5_para541,5,,由于语句True在所有模型中都为真，所有有效的语句都逻辑等价于True。
chap5_para541,6,,有效语句有什么用？
chap5_para541,7,,从蕴含的定义可以推导出古希腊人早已懂得的演绎定理（deduction theorem）：
chap5_para542,1,,对于任意语句和，当且仅当语句是有效的。
chap5_para543,1,,（习题7.DEDU要求对其进行证明。
chap5_para543,2,,）因此，可以像图7-10所示的推断算法那样，通过检验是否在每个模型中为真来确定是否成立，或者通过证明等价于True来确定是否成立。
chap5_para543,3,,反过来，演绎定理表明每条有效的蕴涵语句都描述一个合法的推断。
chap5_para544,1,,图7-11　标准的逻辑等价。
chap5_para544,2,,符号、、代表任意命题逻辑语句
chap5_para545,1,,最后一个概念是可满足性（satisfiability）。
chap5_para545,2,,如果一条语句在某些模型中为真或能够被满足，则这条语句是可满足的。
chap5_para545,3,,例如，前述的知识库中，是可满足的，因为如图7-9所示，它在3个模型中为真。
chap5_para545,4,,可以通过枚举可能的模型，直到找出满足语句的模型来验证可满足性。
chap5_para545,5,,在命题逻辑中确定语句的可满足性的问题——SAT问题——是第一个被证明为NP完全的问题。
chap5_para545,6,,计算机科学中的许多问题实际上都是可满足性问题。
chap5_para545,7,,例如，第6章的所有约束满足问题询问约束是否可以通过某种赋值来满足。
chap5_para546,1,,有效性和可满足性当然是有联系的：是有效的，当且仅当是不可满足的；换言之，是可满足的，当且仅当不是有效的。
chap5_para546,2,,我们还能得出下述非常有用的结论：
chap5_para547,1,,当且仅当语句是不可满足的
chap5_para548,1,,通过检验的不可满足性，可以从证明，这正是数学证明方法中标准的归谬法（reductio ad absurdum，意为“归结为荒谬之物”）。
chap5_para548,2,,它也被称为反证法或矛盾法。
chap5_para548,3,,假设为假，并证明这会导致与已知公理矛盾，这个矛盾的含义与声明语句是不可满足的完全相同。
chap5_para549,1,,7.5.1　推断与证明
chap5_para55,1,It is easy to eliminate all the unary constraints in a CSP by reducing the domain of variables with unary constraints at the start of the solving process.,剪枝可以应用于任何深度的树，而且通常可以将整个子树而不只是叶节点剪枝。
chap5_para55,2,"As mentioned earlier, it is also possible to transform all n-ary constraints into binary ones.",一般原则是：考虑树中某个位置的节点n（见图5-6），玩家可以选择移动到n。
chap5_para55,3,"Because of this, some CSP solvers work with only binary constraints, expecting the user to eliminate the other constraints ahead of time.",如果玩家在树中同一层（如图5-6中的m'）或更上层的任何位置（如图5-6中的m）有更好的选择，那么玩家永远都不愿移动到n。
chap5_para55,4,"We make that assumption for the rest of this chapter, except where noted.",所以，一旦我们对n有了足够的了解（通过检查它的某些后继）来得出上述结论，就可以将它剪枝。
chap5_para550,1,,本节介绍可以用于推导证明的推断规则。
chap5_para550,2,,证明是一系列可以引向所需目标的结论。
chap5_para550,3,,最著名的规则是肯定前件（Modus Ponens，mode that affirms的拉丁语），写作
chap5_para551,1,,它的意思是，当给出和具有形式的语句时，可以推导出语句。
chap5_para551,2,,例如，如果给出，并且已知，可以推导出Shoot。
chap5_para552,1,,另一个有用的推断规则是合取消去（and-elimination），即可以从一个合取式推导出任一合取子句：
chap5_para553,1,,例如，由，可推导出WumpusAlive。
chap5_para554,1,,通过考虑和的可能真值，可以证明肯定前件和合取消去是可靠的。
chap5_para554,2,,这些规则可用于任意适用的实例，不必枚举所有模型就可以生成可靠的推断。
chap5_para555,1,,图7-11所示的所有逻辑等价都可以用作推断规则。
chap5_para555,2,,例如，等价消去可以产生两条推断规则：
chap5_para556,1,,并非所有推断规则都能像上面这样双向适用。
chap5_para556,2,,例如，不能反向运用肯定前件规则，从得出和。
chap5_para557,1,,让我们来看看这些推断规则和等价关系是如何应用于wumpus世界的。
chap5_para557,2,,"我们从含有R1到R5的知识库开始，演示如何证明，即证明[1, 2]中没有无底洞。"
chap5_para558,1,,（1）对R2使用等价消去，得到
chap5_para559,1,,（2）对R6使用合取消去，得到
chap5_para56,1,5.,图5-5　图5-2中博弈树的最优决策计算过程。
chap5_para56,2,2.,每一步都标有每个节点可能的值的范围。
chap5_para56,3,2Arc consistency,（a）B下面的第一个叶节点值为3。
chap5_para56,4,,因此，作为min节点，B的值最多为3。
chap5_para56,5,,（b）B下面的第二个叶节点值为12，min将避免移动到该节点，所以B的值仍然最多为3。
chap5_para56,6,,（c）B下面的第三个叶节点值为8，此时我们已经检查完了B的所有后继状态，所以B的值就是3。
chap5_para56,7,,现在我们可以推断根节点的值至少是3，因为max在根节点处有值为3的选择。
chap5_para56,8,,（d）C下面的第一个叶节点值为2。
chap5_para56,9,,因此，作为min节点，C的值最多为2。
chap5_para56,10,,但是我们知道B的值为3，所以max永远不会选择C。
chap5_para56,11,,因此，没有必要再去检查C的其他后继状态。
chap5_para56,12,,这是剪枝的一个实例。
chap5_para56,13,,（e）D下面的第一个叶节点值为14，所以D的值最多为14。
chap5_para56,14,,这仍然高于max的最佳选择（即3），所以我们需要继续探索D的后继状态。
chap5_para56,15,,注意，此时根节点的所有后继都有界，所以根节点的值也最多为14。
chap5_para56,16,,（f）D的第二个后继值为5，所以我们又需要继续探索。
chap5_para56,17,,第三个后继值为2，所以D的值就是2。
chap5_para56,18,,最终，max在根节点处的决策是移动到值为3的节点B
chap5_para560,1,,（3）假言易位逻辑等价关系得到
chap5_para561,1,,（4）对R8和感知R4（即）使用肯定前件，得到
chap5_para562,1,,（5）使用德摩根律，得到结论
chap5_para563,1,,"也就是，[1, 2]和[2, 1]都没有无底洞。"
chap5_para564,1,,应用第3章的任意搜索算法都可以找到构成这种证明的一系列步骤。
chap5_para564,2,,只需要定义如下的证明问题。
chap5_para565,1,,● 初始状态（Initial State）：最初的知识库。
chap5_para566,1,,● 动作（Actions）：动作的集合，它包含所有推断规则应用于所有符合上半部分推断规则的语句。
chap5_para567,1,,● 结果（Result）：一个动作的结果是将推断规则下半部分的语句实例加入知识库。
chap5_para568,1,,● 目标（Goal）：目标是含有我们试图证明的语句的状态。
chap5_para569,1,,这样，搜索证明就可以替代枚举模型。
chap5_para569,2,,在许多实际案例中，找出某种证明的效率更高，因为证明可以忽略许多无关的命题，不论这种命题有多少。
chap5_para569,3,,"例如，刚才给出的，得出的证明并没有提及命题B2,1、P1,1、P2,2或P3,1。"
chap5_para569,4,,"由于目标命题P2,1只出现于语句R2，因此可以忽略它们；而R2中的其他命题只出现在R4和R2中，因此R1、R3和R5与证明无关。"
chap5_para569,5,,即使在知识库中再添加一百万条语句，这一结果依然成立。
chap5_para569,6,,而简单的真值表算法将无法承受这种模型的指数级爆炸式增长。
chap5_para57,1,"A variable in a CSP is arc-consistent1 if every value in its domain satisfies the variable’s binary constraints. More formally, Xi is arc-consistent with respect to another variable Xj if for every value in the current domain Di there is some value in the domain Dj that satisfies the binary constraint on the arc (Xi, Xj). A graph is arc-consistent if every variable is arc-consistent with every other variable. For example, consider the constraint Y = X2 where the domain of both X and Y is the set of decimal digits. We can write this constraint explicitly as",图5-6　剪枝的一般情况。
chap5_para57,2,,如果对玩家来说m或m'要好于n，那么我们永远都不会在博弈中到达n
chap5_para570,1,,逻辑系统的最后一个属性是单调性，它表明蕴含的语句集只能随着信息被加入知识库而增长。
chap5_para570,2,,[9]对于任意语句和，
chap5_para572,1,,[9]　违反单调性的非单调逻辑刻画了人类推理的常见性质：改变想法。
chap5_para572,2,,我们将在10.6节对其进行讨论。
chap5_para574,1,,例如，假设知识库含有额外的断言，它表明世界中恰好有8个无底洞。
chap5_para574,2,,"这条知识可能有助于智能体得出额外的结论，但它不能使任何已经得出的结论失效，例如[1,2]中没有无底洞这样的结论。"
chap5_para574,3,,单调性意味着只要在知识库中找到合适的前提，就可以使用推断规则——规则的结论必然是合理的，不论知识库中还有什么东西。
chap5_para575,1,,7.5.2　通过归结证明
chap5_para576,1,,我们已经论证了目前所说的推断规则是可靠的，但还没讨论过使用这些规则的推断算法的完备性问题。
chap5_para576,2,,像迭代加深搜索（3.4.4节）这样的搜索算法能够找到任意的可达目标，从这种意义上说它是完备的；但如果可用的推断规则不充分，则目标是不可达的——仅使用这些推断规则的证明是不存在的。
chap5_para576,3,,例如，如果去掉等价消去规则，7.5.1节所述的证明就行不通了。
chap5_para576,4,,本节我们只介绍一个推断规则——归结（resolution），当它与任意完备的搜索算法结合后，可以产生一个完备的推断算法。
chap5_para577,1,,我们从在wumpus世界使用简单的归结规则入手。
chap5_para577,2,,"考虑导致图7-4a所示状态的步骤开始：智能体从[2, 1]返回到[1, 1]，然后走到[1, 2]，它在此处感知到臭味，但没有微风。"
chap5_para577,3,,我们将如下事实添加到知识库中：
chap5_para578,1,,"用先前推得R10时使用的相同步骤，可以推出[2, 2]和[1, 3]中没有无底洞（别忘了已知[1, 1]中没有无底洞）："
chap5_para579,1,,"还可以对R3使用等价消去，然后对R5使用肯定前件，以得到[1, 1]、[2, 2]或[3, 1]中有无底洞的事实："
chap5_para58,1,"To make X arc-consistent with respect to Y, we reduce X’s domain to {0,1,2,3}. If we also make Y arc-consistent with respect to X, then Y’s domain becomes {0,1,4,9}, and the whole CSP is arc-consistent. On the other hand, arc consistency can do nothing for the Australia map-coloring problem. Consider the following inequality constraint on (SA, WA):",记住，极小化极大搜索是深度优先的，所以在任何时候我们只需考虑树中单个路径上的节点。
chap5_para58,2,,"剪枝得名于Max-Value(state, , )（见图5-7）中的两个额外参数，它们分别是路径上任何位置的倒推值的下界和上界。"
chap5_para580,1,,"现在我们首次运用归结规则：R13中的文字与R15中的文字P2,2归结，得到归结句（resolvent）"
chap5_para581,1,,"用自然语言描述：如果[1, 1]、[2, 2]或[3, 1]中必有无底洞，而[2, 2]中没有无底洞，则无底洞在[1, 1]或[3, 1]中。"
chap5_para581,2,,"类似地，R1中的文字与R16中的文字P1,1归结，得到"
chap5_para582,1,,"用自然语言描述：如果[1, 1]或[3, 1]中有无底洞，无底洞又不在[1, 1]中，则它在[3, 1]中。"
chap5_para582,2,,最后两步推断采用了单元归结（unit resolution）规则
chap5_para583,1,,其中每个都是文字，而和m是互补文字（即各自是对方的否定）。
chap5_para583,2,,这样，单元归结推断规则使用一个子句（文字的析取式）以及一个文字，生成一个新的子句。
chap5_para583,3,,注意，单个文字可看作是一个文字的析取式，也被称为单元子句。
chap5_para584,1,,单元归结规则可以推广为全归结规则
chap5_para585,1,,其中，li和mj是互补文字。
chap5_para585,2,,这表明归结使用两个子句并产生一个新的子句，该新子句包含除一对互补文字以外的原始子句的所有文字，例如，我们有
chap5_para586,1,,可以一次只归结一对互补文字。
chap5_para586,2,,例如，可以归结P和推得
chap5_para587,1,,但不能同时归结P和Q来推得R。
chap5_para587,2,,归结规则还有一个技术细节：结果子句只能含有每个文字的一个副本。
chap5_para587,3,,[10]去除文字的多个副本被称为因子提取。
chap5_para587,4,,例如，如果我们用归结，得到，通过因子提取简化为A。
chap5_para589,1,,[10]　如果一个子句被视作文字的集合，则这条限制自然地适用。
chap5_para589,2,,对子句使用集合的概念可以使归结规则更简洁，但代价是引入了额外的记号。
chap5_para59,1,"No matter what value you choose for SA (or for WA), there is a valid value for the other variable.",= 到目前为止，路径上发现的max的任一选择点中最佳（即最大值）选择的值。
chap5_para59,2,So applying arc consistency has no effect on the domains of either variable.,也就是 说， = “至少”。
chap5_para590,1,,通过对文字和另一个子句中的互补文字mj的讨论，我们可以很容易理解归结规则的可靠性。
chap5_para590,2,,如果为真，则mj为假，因此必然为真，因为已知。
chap5_para590,3,,如果为假，则必为真，因为已知。
chap5_para590,4,,现无论为真还是为假，结论必然成立，这与归结法则所述的完全相同。
chap5_para591,1,,归结法则更为惊人的部分在于，它形成了一类完备推断过程的基础。
chap5_para591,2,,基于归结的定理证明器可以对命题逻辑中的任意语句和确定是否成立。
chap5_para591,3,,接下来的“合取范式”和“归结算法”两小节将解释归结是如何完成这项任务的。
chap5_para593,1,,归结规则仅适用于子句（也就是文字的析取式），因此它似乎只能用于含有子句的知识库和查询。
chap5_para593,2,,那么对于所有命题逻辑，它如何实现完备的推断过程？
chap5_para593,3,,答案是，命题逻辑的所有语句逻辑上都等价于子句合取式。
chap5_para594,1,,形式为子句合取式的语句被称为合取范式（conjunctive normal form）或CNF（见图7-12）。
chap5_para594,2,,下面介绍把语句转换为CNF的过程。
chap5_para594,3,,我们通过将语句 转换为CNF来阐明这一过程。
chap5_para594,4,,转换的步骤如下。
chap5_para595,1,,（1）消去，将替换为：
chap5_para596,1,,（2）消去，将替换为
chap5_para597,1,,（3）CNF要求只能在文字前出现，因此我们反复应用图7-11的如下等价关系“将内移”：
chap5_para6,1,5.,对于多智能体环境，我们至少可以有3种观点。
chap5_para6,2,1Defining Constraint Satisfaction Problems,第一种观点适用于智能体数量非常大的情况，即把它们看作一个经济（economy）整体来考虑，这让我们可以做出例如“需求增长会导致价格上涨”这样的预测，而不需要预测任何个体智能体的动作。
chap5_para60,1,"The most popular algorithm for enforcing arc consistency is called AC-3 (see Figure 5.3). To make every variable arc-consistent, the AC-3 algorithm maintains a queue of arcs to consider. Initially, the queue contains all the arcs in the CSP. (Each binary constraint becomes two arcs, one in each direction.) AC-3 then pops off an arbitrary arc (Xi, Xj) from the queue and makes Xi arc-consistent with respect to Xj. If this leaves Di unchanged, the algorithm just moves on to the next arc. But if this revises Di (makes the domain smaller), then we add to the queue all arcs (Xk, Xi) where Xk is a neighbor of Xi. We need to do that because the change in Di might enable further reductions in Dk, even if we have previously considered Xk. If Di is revised down to nothing, then we know the whole CSP has no consistent solution, and AC-3 can immediately return failure. Otherwise, we keep checking, trying to remove values from the domains of variables until no more arcs are in the queue. At that point, we are left with a CSP that is equivalent to the original CSP—they both have the same solutions—but the arc-consistent CSP will be faster to search because its variables have smaller domains. In some cases, it solves the problem completely (by reducing every domain to size 1) and in others it proves that no solution exists (by reducing some domain to size 0).",= 到目前为止，路径上发现的min的任一选择点中最佳（即最小值）选择的值。
chap5_para60,2,,也就是 说， = “至多”。
chap5_para601,1,,本例中，我们只需运用最后一条规则一次：
chap5_para602,1,,（4）现在我们得到了一个∧和∨嵌套、运算符直接作用于文字的语句。
chap5_para602,2,,运用图7-11的分配律，尽可能地对∧分配∨：
chap5_para603,1,,原始语句现在已经成为CNF，是3个子句的合取式。
chap5_para603,2,,它读起来难了很多，但它可以作为归结过程的输入。
chap5_para604,1,,图7-12　合取范式、霍恩子句、确定子句、目标子句的文法。
chap5_para604,2,,形式如这样的CNF子句可以写成确定子句
chap5_para606,1,,基于归结的推断过程使用7.5.1节介绍的反证法来进行证明。
chap5_para606,2,,也就是说，为了证明，我们要证明是不可满足的。
chap5_para606,3,,我们通过证明矛盾来做到这一点。
chap5_para607,1,,图7-13展示了一个归结算法。
chap5_para607,2,,首先，被转换为CNF。
chap5_para607,3,,然后，归结规则被应用在得到的子句上。
chap5_para607,4,,每一对互补文字都被归结生成新的子句，如果新子句没有出现过，就将其加入子句集合。
chap5_para607,5,,这一过程不断持续，直到发生下述的两件事情之一。
chap5_para608,1,,● 没有可供添加的新子句，此时KB不蕴含；
chap5_para609,1,,● 两个子句归结为空子句，此时KB蕴含。
chap5_para61,1,"Description The game tree is a binary tree. The first level of the game tree is labeled to move ""A"" and the node is labeled (1, 2, 6). The two child nodes of (1, 2, 6) are labeled (1, 2, 6) and (0, 5, 2) and are in the second level. The second level is labeled to move B. An arrow from the node (1, 2, 6) in level “A” points to node (1, 2, 6) in level B. The two child nodes of (1, 2, 6) in level B are labeled (1, 2, 6) with a cross and (6, 1, 2) in the third level. The two child nodes of (0, 5, 2) in level B are labeled (0, 5, 2) and (5, 4, 5) in the third level. The third level is labeled to move C. The two child nodes of (1, 2, 6) with a cross are labeled (1, 2, 6) and (4, 2, 3) in the fourth level. The two child nodes of (6, 1, 2) in the level C are labeled (6, 1, 2) and (4, 7, 1) in the fourth level. The two child nodes of (0, 5, 2) in level C are labeled (0, 5, 2) and (5, 1, 1) in the fourth level. The two child nodes of (5, 4, 5) in level C are labeled (5, 4, 5) and (7, 7, 1) in the fourth level. The fourth level is labeled to move ""A"".",搜索不断更新和的值，并且一旦当前节点的值比此时的（对于max）或（对于min）值更差，就剪掉该节点的剩余分支（即终止递归调用）。
chap5_para61,2,,完整算法如图5-7所示。
chap5_para61,3,,图5-5跟踪了博弈树上的算法进程。
chap5_para610,1,,图7-13　简单的命题逻辑归结算法。
chap5_para610,2,,PL-Resolve返回对其两个输入进行归结得到的所有可能子句集合
chap5_para611,1,,空子句是一个没有析取子句的析取式，它等价于False，因为仅当至少一个析取子句为真时析取式为真。
chap5_para611,2,,另外，空子句仅在归结两个矛盾的单元子句（如P和）时出现。
chap5_para612,1,,我们可以将归结过程用在wumpus世界中一个很简单的推断中。
chap5_para612,2,,"当智能体位于[1,1]时，该处没有微风，因此相邻的方格没有无底洞。"
chap5_para612,3,,相关的知识库是
chap5_para613,1,,我们要证明，即。
chap5_para613,2,,如果将转换为CNF，我们就能得到在图7-14顶部所示的子句。
chap5_para613,3,,该图的第二行列出了归结第一行后的子句。
chap5_para613,4,,"随后，当P1,2与归结后，我们得到了空子句，用小方块表示。"
chap5_para613,5,,观察图7-14，可以发现许多归结是毫无意义的。
chap5_para613,6,,例如，子句等价于，进而等价于True。
chap5_para613,7,,推出True为真并没有什么用处。
chap5_para613,8,,因此，我们可以忽略所有含有两个互补文字的子句。
chap5_para614,1,,图7-14　对wumpus世界的一个简单推断部分运用PL-Resolution来证明查询。
chap5_para614,2,,顶行最左侧的4个子句的每一个与其他3个都互相成对，运用归结规则产生底行的子句。
chap5_para614,3,,"顶行的第3个和第4个子句结合生成，它继而与P1,2归结，生成空子句，表明查询被证明"
chap5_para616,1,,作为对归结的讨论的总结，现在来了解为何PL-Resolution是完备的。
chap5_para616,2,,为此，我们引入子句集合S的归结闭包（resolution closure）RC(S)，即对S中子句及其生成子句反复使用归结规则可推得的所有子句的集合。
chap5_para616,3,,归结闭包就是RL-Resolution计算所得的变量clauses的最终值。
chap5_para616,4,,"易知RC(S)必然是有限的：得益于因子提取，由S中出现的符号P1, …, Pk得出的子句数量是有限的。"
chap5_para616,5,,因此，PL-Resolution总是能够终止。
chap5_para617,1,,命题逻辑中归结的完备性定理被称为基本归结定理（ground resolution theorem）：
chap5_para618,1,,如果一个子句集是不可满足的，则这些子句的归结闭包含有空子句。
chap5_para619,1,,定理的证明是通过其假言易位进行的：如果闭包RC(S)不含有空子句，则S可满足。
chap5_para619,2,,"实际上，可以为S构建一个在P1, …, Pk上有适当真值的模型。"
chap5_para619,3,,构建过程如下：
chap5_para62,1,"Figure 5.3The arc-consistency algorithm AC-3. After applying AC-3, either every arc is arc-consistent, or some variable has an empty domain, indicating that the CSP cannot be solved. The name “AC-3” was used by the algorithm’s inventor (Mackworth, 1977) because it was the third version developed in the paper.",图5-7　搜索算法。
chap5_para62,2,,注意，这些函数与图5-3中的Minimax-Search函数相同，除了需要维护变量和，以及在值超出边界时截断搜索
chap5_para621,1,,"● 如果RC(S)中的子句含有文字且所有其他文字在对P1, …, Pi−1选定的赋值下为假，则对Pi赋值为false；"
chap5_para622,1,,● 否则，对Pi赋值为true。
chap5_para623,1,,"对P1, …, Pk的赋值是S的一个模型。"
chap5_para623,2,,要搞清楚这一点，我们假设其反面——在序列中的某处i，对符号Pi赋值使得某个子句C为假。
chap5_para623,3,,"此时，情况必然是C中所有其他文字都已经被对P1, …, Pi−1的赋值定为假。"
chap5_para623,4,,因此，C的形式必然类似或。
chap5_para623,5,,如果只有其中一个在RC(S)中，则算法将对Pi赋适当的值以使C为真，因此仅在这两个子句都在RC(S)中时，C才会为假。
chap5_para624,1,,"现在，由于RC(S)在归结时是闭的，它会含有这两个子句的归结句，且这个归结句的所有文字已经被对P1, …, Pi−1的赋值定为假。"
chap5_para624,2,,这与我们的假设，即第一个为假的子句出现在i处矛盾。
chap5_para624,3,,因此，我们证明了这种构建永远无法使RC(S)中的子句为假，也就是说它创建了一个RC(S)的模型。
chap5_para624,4,,最后，由于S包含在RC(S)中，因此任意RC(S)的模型也是S本身的模型。
chap5_para625,1,,7.5.3　霍恩子句与确定子句
chap5_para626,1,,归结的完备性使其成为一种非常重要的推断方法。
chap5_para626,2,,而许多实际情形并不需要用到归结的全部能力。
chap5_para626,3,,一些真实世界的知识库中的语句满足某些限制，这使得它们可以使用更为受限而更高效的推断算法。
chap5_para627,1,,其中一种受限形式是确定子句（definite clause），它是文字的析取式，其中只有一个为正文字。
chap5_para627,2,,例如，子句是确定子句而不是，因为它含有两个正文字。
chap5_para628,1,,更一般性的是霍恩子句（Horn clause），它是文字的析取式，其中最多只有一个为正文字。
chap5_para628,2,,因此所有的确定子句都是霍恩子句，没有正文字的子句也是霍恩子句——也被称为目标子句（goal clause）。
chap5_para628,3,,霍恩子句在归结时是闭的：如果归结两个霍恩子句，仍然会得到霍恩子句。
chap5_para628,4,,还有一种类型是k-CNF语句，它是每个子句最多含有k个文字的CNF语句。
chap5_para629,1,,仅含有确定子句的知识库很有意义，原因有3个。
chap5_para63,1,The complexity of AC-3 can be analyzed as follows.,5.2.4　移动顺序
chap5_para63,2,"Assume a CSP with n variables, each with domain size at most d, and with c binary constraints (arcs).",
chap5_para63,3,"Each arc (Xk, Xi) can be inserted in the queue only d times because Xi has at most d values to delete.",
chap5_para63,4,"Checking consistency of an arc can be done in O(d2) time, so we get O(cd3) total worst-case time.",
chap5_para630,1,,（1）每个确定子句都可以写成一个蕴涵式，前提是正文字的合取式，结论是一个正文字。
chap5_para630,2,,（见习题7.DISJ。
chap5_para630,3,,）例如，确定子句可以写成蕴涵式。
chap5_para630,4,,"蕴涵形式的语句更容易理解：它说明如果智能体位于[1, 1]，且感知到微风，则[1, 1]有微风。"
chap5_para630,5,,在霍恩形式中，前提被称为体（body）而结论被称为头（head）。
chap5_para630,6,,"由单个正文字构成的语句，例如L1,1，被称为事实（fact）。"
chap5_para630,7,,"它也可以写成形式的蕴涵式，但只写成L1,1更为简洁。"
chap5_para631,1,,（2）用霍恩子句进行推断可以通过前向链接（forward-chaining）算法和反向链接（backward-chaining）算法完成，我们稍后会介绍。
chap5_para631,2,,这些算法都很自然，因为它们的推断步骤很直观，便于人类理解。
chap5_para631,3,,这类推断是逻辑编程（logic programming）的基础，我们将在第9章进行讨论。
chap5_para632,1,,（3）用霍恩子句确定蕴含关系所需的时间与知识库大小呈线性关系，这格外令人满意。
chap5_para633,1,,7.5.4　前向链接与反向链接
chap5_para634,1,,"前向链接算法PL-FC-Entails?(KB,q)确定单个命题符号q（即查询）是否被确定子句的知识库所蕴含。"
chap5_para634,2,,它从知识库中的已知事实（正文字）开始。
chap5_para634,3,,如果一个蕴涵式的所有前提都已知，则将其结论添加到已知事实的集合中。
chap5_para634,4,,"例如，如果L1,1和Breeze已知，且在知识库中，则在知识库中添加B1,1。"
chap5_para634,5,,这一过程持续进行，直到查询q被添加，或直到无法进一步进行推断。
chap5_para634,6,,这一算法在图7-15中展示，我们要记住的要点是它的运行时间是线性的。
chap5_para635,1,,用图和示例来理解算法是最好的办法。
chap5_para635,2,,图7-16a展示了一个简单的霍恩子句知识库，其中有A和B两个已知事实。
chap5_para635,3,,图7-16b展示了绘制为与或图（见第4章）的同一个知识库。
chap5_para635,4,,在与或图中，用曲线连接的多个边表示一个合取式，每个边都要证明；而没有曲线连接的多个边表示一个析取式，证明任一边即可。
chap5_para635,5,,图上很容易看懂前向链接是如何运作的。
chap5_para635,6,,已知的叶节点（此处为A和B）具有真值之后，推断就会沿着图尽可能远地向上传递。
chap5_para635,7,,当出现合取式时，传递过程开始等待，直到所有合取子句都已知。
chap5_para635,8,,我们鼓励读者细致地研究这个示例。
chap5_para636,1,,图7-15　命题逻辑的前向链接算法。
chap5_para636,2,,queue记录了已知为真但还没“处理过”的符号。
chap5_para636,3,,表count记录每个蕴涵式尚未证明的前提数量。
chap5_para636,4,,一旦queue中的新符号p被处理，count就会为每个前提中出现p的蕴涵式减1（使用合适的索引方法，很容易在常数时间内完成）。
chap5_para636,5,,如果count为0，则蕴涵式的所有前提都已知，因此其结论可以添加到queue。
chap5_para636,6,,最后，我们还需要记录哪个符号已经被处理过，如此在已推断符号集inferred中的符号就无需被再次加入queue。
chap5_para636,7,,这避免了重复的工作，也避免了由类似P⇒Q和Q⇒P这样的蕴涵式引起的循环
chap5_para637,1,,图7-16　（a）一个霍恩子句集。
chap5_para637,2,,（b）相应的与或图
chap5_para638,1,,显然，前向链接是可靠的：每个推断实际上都是对肯定前件的运用。
chap5_para638,2,,前向链接也是完备的：所有蕴含的原子语句都将被推得。
chap5_para638,3,,要理解这一点，最简单的方法是考虑（在算法到达不动点，无法产生新推断的时候）inferred表格的最终状态。
chap5_para638,4,,该表中每个推得的符号都为真，所有其他符号都为假。
chap5_para638,5,,我们可以将这个表看作一个逻辑模型，且原始KB的每条确定子句在这个模型中都为真。
chap5_para639,1,,为理解这一点，可以假设其反面，即存在子句在模型中为假。
chap5_para639,2,,则在模型中必然为真，且b在模型中必然为假。
chap5_para639,3,,这与我们假设的算法已经到达不动点相矛盾，因为我们此时可以将b加入知识库。
chap5_para639,4,,因此我们可以断定，不动点处推得的原子语句集定义了一个原始知识库的模型。
chap5_para639,5,,更进一步地，知识库蕴含的任意原子语句q必然在其所有模型中都为真，在这个特定模型中也一样。
chap5_para639,6,,因此，所有蕴含的原子语句q必然会被算法推得。
chap5_para64,1,5.,剪枝的有效性很大程度上依赖于状态的检查顺序。
chap5_para64,2,2.,例如，在图5-5e和图5-5f中，根本不能剪掉D的任何后继，因为最差的后继（从min的角度来看）是最先生成的。
chap5_para64,3,3Path consistency,如果最先生成D的第三个后继，它的值为2，那么我们就可以剪掉另外两个后继。
chap5_para64,4,,这表明，应该先检查有可能是最佳选择的后继节点。
chap5_para640,1,,前向链接是数据驱动（data-driven）推理这一更广泛概念的例子，也就是其注意力开始集中在已知数据的推理。
chap5_para640,2,,它可以用于智能体，以便从收到的感知推导出结论，且常常是在没有特定查询的情况下。
chap5_para640,3,,例如，wumpus世界的智能体可以用递增前向链接算法（即新的事实可以被加入队列来启动新的推断）将它的感知告知知识库。
chap5_para640,4,,对人类来说，当获取新信息后会出现一定数量的数据驱动推理。
chap5_para640,5,,例如，如果我在屋子里听到外面开始下雨，则我可能会想到取消野餐；但是，我大概不会想到邻居花园里最大的一朵玫瑰的第17片花瓣会淋湿——人类会对前向链接进行精心地控制，以免被无关的结果淹没。
chap5_para641,1,,反向链接算法如其名称所示，从查询开始反向运作。
chap5_para641,2,,如果查询q已知为真，则不需要做任何操作。
chap5_para641,3,,否则，算法将在知识库中找寻结论为q的蕴涵式。
chap5_para641,4,,如果这些蕴涵式的所有前提都可以（用反向链接）证明为真，则q为真。
chap5_para641,5,,将反向链接算法用于图7-16的查询Q时，它反向地向图的下方运行，直到到达构成证明基础的已知事实集，即A和B。
chap5_para641,6,,算法实质上与图4-11的And-Or-Graph-Search算法完全相同。
chap5_para641,7,,与前向链接一样，它的高效实现的时间复杂性是线性的。
chap5_para642,1,,反向链接是一种目标导向推理（goal-directed reasoning）。
chap5_para642,2,,它对于回答类似“我现在该做什么？
chap5_para642,3,,”和“我的钥匙在哪里？
chap5_para642,4,,”这样的特定问题非常有用。
chap5_para642,5,,通常，反向链接的代价远小于知识库规模的线性变化，因为这个过程仅涉及相关的事实。
chap5_para643,1,,7.6　高效命题模型检验
chap5_para644,1,,本节，我们介绍两种高效的、基于模型检验的一般命题推断的算法，其中一种是基于回溯搜索的，另一种则基于局部爬山搜索。
chap5_para644,2,,这些算法是命题逻辑的“技术”部分。
chap5_para644,3,,首次阅读本章时可以略过本节内容。
chap5_para645,1,,我们描述的算法是用于可满足性检验的，即SAT问题。
chap5_para645,2,,（如7.5节所述，可以通过检验的不可满足性来检验蕴含。
chap5_para645,3,,）我们在7.5节中提到过找到满足逻辑语句的模型与找到约束满足问题的解的关系，因此这两种命题可满足性算法与6.3节的回溯算法和6.4节的局部搜索算法非常相似并不令人意外。
chap5_para645,4,,尽管如此，这些算法本身还是极为重要的，因为许多计算机科学中的组合问题都可以被归为检验命题语句的可满足性。
chap5_para645,5,,对可满足性算法的任何改进对于我们处理复杂性的能力都有巨大的作用。
chap5_para646,1,,7.6.1　完备的回溯算法
chap5_para647,1,,"我们要探讨的第一个算法常称为戴维斯-普特南算法（Davis-Putnam algorithm），得名于马丁·戴维斯（Martin Davis）和希拉里·普特南（Hilary Putnam）的重要论文（Davis and Putnam, 1960）。"
chap5_para647,2,,"这个算法实际上采用的是戴维斯、洛吉曼和洛夫兰所描述的版本（Davis, Logemann, and Loveland, 1962），因此我们用所有4位作者姓氏的首字母DPLL命名这个算法。"
chap5_para647,3,,DPLL使用一个合取范式形式（即一个子句集）的语句作为输入。
chap5_para647,4,,类似于Backtracking-Search和TT-Entails?，它本质上是递归地、深度优先地枚举可能的模型。
chap5_para647,5,,它在TT-Entails?的基础上进行了3项改进。
chap5_para648,1,,● 提前终止：算法可以用部分完成的模型来检测语句是否必然为真或为假。
chap5_para648,2,,如果任一文字为真则子句为真，即使其他文字还没有真值；这样，整条语句在模型完成之前就可以断定其真值。
chap5_para648,3,,例如，若A为真则语句为真，无论B和C的值是什么。
chap5_para648,4,,类似地，若任一子句为假，即其所有文字为假，则语句为假。
chap5_para648,5,,同样，这种情形可能会在模型完成前很久就发生。
chap5_para648,6,,提前终止避免了在搜索空间中检查全部子树。
chap5_para649,1,,● 纯符号启发式方法：纯符号是指在所有子句中“符号位”都相同的符号。
chap5_para649,2,,例如，在3个子句、和中，A是纯符号，因为它只以正文字的形式出现；B也是纯符号，因为它总以负文字的形式出现。
chap5_para649,3,,而C是不纯的。
chap5_para649,4,,易知如果一条语句有模型，则存在一个模型对纯符号的赋值使其文字为真，因为这样做不会使子句为假。
chap5_para649,5,,注意，在确定符号是否为纯时，算法可以忽略当前已构建的模型中已知为真的子句。
chap5_para649,6,,例如，如果上述模型含有B=false，则子句已经为真，且在剩余子句中C仅作为正文字出现，因此C变为纯符号。
chap5_para65,1,"Suppose we are to color the map of Australia with just two colors, red and blue.",如果能够完美地实现这一点，搜索算法只需要检查个节点就能选出最佳移动，而极小化极大算法需要O(bm)。
chap5_para65,2,Arc consistency does nothing because every constraint can be satisfied individually with red at one end and blue at the other.,这意味着有效分支因子从b变为了，对国际象棋来说，大约从35变为了6。
chap5_para65,3,"But clearly there is no solution to the problem: because Western Australia, Northern Territory, and South Australia all touch each other, we need at least three colors for them alone.",换句话说，在相同时间内，拥有完美移动顺序的剪枝可以求解的树的深度大约是极小化极大算法的两倍。
chap5_para65,4,,如果移动顺序随机，对于适当大小的b，需要检查的节点总数约为。
chap5_para65,5,,显然我们现在无法实现完美移动顺序，否则，在这种情况下，可以用排序函数玩一个完美的游戏！
chap5_para65,6,,但通常我们可以非常接近完美。
chap5_para65,7,,对国际象棋来说，一个非常简单的排序函数（例如，先尝试吃子，然后是威胁，再后是前进和后退）就能让检查的节点数减少到不超过最好情况的大约2倍。
chap5_para650,1,,● 单元子句启发式方法：之前对单元子句的定义是只有一个文字的子句。
chap5_para650,2,,在DPLL中，它也指那些除了一个文字外，其余文字都被模型赋值为false的子句。
chap5_para650,3,,例如，如果模型含有B = true，则简化为，这是一个单元子句。
chap5_para650,4,,显然，要使这个子句为真，C必须赋值为false。
chap5_para650,5,,单元子句启发式方法在余下的部分出现分支前对所有这样的符号赋值。
chap5_para650,6,,这种启发式的一个重要结果是，所有对知识库中的已有文字进行的证明（通过反证法）将立刻得证（见习题7. KNOW）。
chap5_para650,7,,还要注意的是，对一个单元子句赋值可能会创建另一个单元子句，例如，当C被置为假，也变成了单元子句，使得A被赋值为真。
chap5_para650,8,,这种强制赋值的“级联”被称为单元传播（unit propagation）。
chap5_para650,9,,这类似于确定子句的前向链接。
chap5_para650,10,,实际上，如果CNF表达式仅含有确定子句，则DPLL本质上复制了前向链接。
chap5_para650,11,,（见习题7. DPLL。
chap5_para650,12,,）
chap5_para651,1,,DPLL算法如图7-17所示，它给出了搜索程序的主要结构，但并未实现其细节。
chap5_para652,1,,图7-17　用于检验命题逻辑语句可满足性的DPLL算法。
chap5_para652,2,,Find-Pure-Symbol和Find-Unit-Clause背后的思路在正文中进行了介绍。
chap5_para652,3,,这两个函数都返回一个符号（或返回空）以及要赋给这个符号的真值。
chap5_para652,4,,和TT-Entails?一样，DPLL在部分模型上运行
chap5_para653,1,,图7-17没有展示使SAT求解器能够用于大规模问题的技巧。
chap5_para653,2,,有趣的是，这些技巧实际上都很寻常，我们之前已经见过它们的其他形式。
chap5_para654,1,,（1）分量分析（如CSP中的塔斯马尼亚岛问题所见）：当DPLL为变量赋真值时，子句集可能会被分割成不相交的子集，我们称之为分量，它们没有共同的未赋值变量。
chap5_para654,2,,给定一个高效探测这一状况的方法，求解器就可以通过对每个分量独立求解来加快速度。
chap5_para655,1,,（2）变量排序与值排序（如在6.3.1节的CSP中所见）：我们对DPLL的简单实现使用任意的变量顺序，并在赋值时总是先尝试赋真再尝试赋假。
chap5_para655,2,,度启发式算法（6.3.1节）建议在所有剩余子句中优先选择最常出现的变量。
chap5_para656,1,,（3）智能回溯（如在6.3.3节的CSP中所见）：许多用按时序回溯几小时都求解不了的问题，如果改用智能回溯直接回溯到导致冲突的相关点上，那么问题可以在几秒内求解。
chap5_para656,2,,所有运用智能回溯的SAT求解器都使用冲突子句学习的某种形式来记录冲突，以避免在后续的搜索中重复出现。
chap5_para656,3,,通常只保留有限大小的冲突集，丢弃极少使用的冲突。
chap5_para657,1,,（4）随机重启（在4.1.1节用于爬山法）：有时单次运行似乎无法取得进展。
chap5_para657,2,,此时，我们可以从搜索树的顶端重新开始，而非尝试继续搜索。
chap5_para657,3,,重启后（对变量和值选取）进行不同的随机选择。
chap5_para657,4,,第一次运行中学习到的子句在重启后依然被保留，这有助于对搜索空间进行剪枝。
chap5_para657,5,,重启并不保证能更快地找到解，但它能够减小求解时间的方差。
chap5_para658,1,,（5）聪明索引（在许多算法中可以见到）：DPLL和其他现代求解器用到的加速方法需要快速索引“Xi作为正文字出现的子句集合”。
chap5_para658,2,,这一任务相当复杂，因为算法所感兴趣的只是先前的变量赋值尚未满足的子句，因此索引结构必须在计算过程中动态更新。
chap5_para659,1,,有了这些改进，现代求解器可以处理有数千万个变量的问题。
chap5_para659,2,,它们为诸如硬件验证和安全协议验证这样的领域带来革命性的变化。
chap5_para659,3,,在此之前，这些领域需要十分费力的、手动证明。
chap5_para66,1,Arc consistency tightens down the domains (unary constraints) using the arcs (binary constraints).,增加动态的移动排序方案，例如先尝试之前发现的最佳移动，能让我们非常接近理论极限。
chap5_para66,2,"To make progress on problems like map coloring, we need a stronger notion of consistency.",“之前”可能指上一次移动（通常面临同样的威胁），也可能来自之前通过迭代加深（见3.4.4节）过程对当前移动的探索。
chap5_para66,3,Path consistency tightens the binary constraints by using implicit constraints that are inferred by looking at triples of variables.,首先，搜索一层并根据它们的评估结果记录这些移动的排名。
chap5_para66,4,,然后再深入搜索一层，利用之前的排名指导移动顺序，以此类推。
chap5_para66,5,,由于迭代加深过程而增加的搜索时间可以通过更好的移动顺序来弥补。
chap5_para66,6,,这些最佳移动称为绝招（killer move），首先尝试绝招称为绝招启发式评价函数。
chap5_para660,1,,7.6.2　局部搜索算法
chap5_para661,1,,我们已经在本书中见过了一些局部搜索算法，包括Hill-Climbing（4.1.1节）和Simulated-Annealing（4.1.2节）。
chap5_para661,2,,只要我们选择了正确的评价函数，这些算法可就以被直接用于可满足性问题。
chap5_para661,3,,由于目标是找出满足所有子句的赋值，一个对未满足的子句进行计数的评价函数就可以胜任这项工作。
chap5_para661,4,,实际上，这正是用于CSP的Min-Conflict算法所使用的量度（见6.4节）。
chap5_para661,5,,这些算法都在完全赋值的空间采取动作，每次只翻转一个符号的真值。
chap5_para661,6,,这个空间通常含有许多局部极小值，要跳出这些极小值，需要各种形式的随机方法。
chap5_para661,7,,近年来，人们进行了大量实验，试图在贪婪性与随机性之间找到一个良好的平衡。
chap5_para662,1,,这些算法中最为简单和有效的算法之一是WalkSAT（如图7-18所示）。
chap5_para662,2,,算法每次循环都选择一个未满足的子句，并在该子句中选择一个符号来翻转。
chap5_para662,3,,选择要翻转的符号的方法有两种：（1）最小化新状态中未满足子句的数量的“最小冲突”方法；（2）随机挑选一个符号的“随机游走”方法。
chap5_para662,4,,算法随机选取一种。
chap5_para663,1,,图7-18　通过随机翻转变量的值来检验可满足性的WalkSAT算法。
chap5_para663,2,,这个算法有很多版本
chap5_para664,1,,当WalkSAT返回一个模型时，输入语句就是可满足的。
chap5_para664,2,,但当它返回failure时，则有两种可能的原因：语句不可满足，或我们需要多给算法一些时间。
chap5_para664,3,,如果我们设定且p 0，WalkSAT最终将返回一个模型（如果存在的话），因为随机游走步骤终将遇到一个解。
chap5_para664,4,,如果max_flips为无穷大，而语句不可满足，则算法永远不会终止！
chap5_para665,1,,因此，当我们预计问题有解的时候，WalkSAT最为有用。
chap5_para665,2,,例如，第3章和第6章讨论过的问题通常有解。
chap5_para665,3,,但是，WalkSAT并不总是能检测到不可满足性，而对判定蕴含来说这是必备的。
chap5_para665,4,,例如，wumpus世界中，一个智能体不能使用WalkSAT来可靠地证明一个方格是安全的。
chap5_para665,5,,不过，它可以说：“我思考了一小时，都想不出存在一种这个方格不安全的可能世界。
chap5_para665,6,,”这也许是个不错的经验性指示，表明方格是安全的，但它绝对不是一种证明。
chap5_para666,1,,7.6.3　随机SAT问题概览
chap5_para667,1,,某些SAT问题比其他要难。
chap5_para667,2,,简单的问题可以用任意老算法求解，但由于我们知道SAT是NP完全的，至少有一些问题必须需要指数级的运行时间。
chap5_para667,3,,在第6章中，我们见过一些针对某种问题的惊人发现。
chap5_para667,4,,例如，对于回溯搜索算法，n皇后问题被认为是相当困难的，而对于局部搜索方法，如最小冲突法，求解这一问题却非常容易。
chap5_para667,5,,这是由于在赋值空间中，解的分布非常密集，任意初始赋值都能保证在其附近存在解。
chap5_para667,6,,因此，n皇后问题很简单，因为它是欠约束的（underconstrained）。
chap5_para668,1,,当我们考虑合取范式的可满足性问题时，一个欠约束的问题是约束变量的子句非常少的情形。
chap5_para668,2,,例如，下面是一条随机生成的3-CNF语句，它有5个符号和5个子句：
chap5_para669,1,,在32个可能的赋值中，有16个是这条语句的模型。
chap5_para669,2,,因此，平均而言，只需进行两次随机猜测就可以找到一个模型。
chap5_para669,3,,与大部分这样的欠约束问题一样，这是一个简单的可满足性问题。
chap5_para669,4,,但是，一个过约束的问题很可能没有解，因为相对于其变量数量，其子句数量过多。
chap5_para669,5,,过约束问题通常很容易求解，因为这些约束将很快导致算法找出一个解，或进入无法逃离的死胡同。
chap5_para67,1,"A two-variable set {Xi, Xj} is path-consistent with respect to a third variable Xm if, for every assignment {Xi = a, X j = b} consistent with the constraints (if any) on {Xi, Xj}, there is an assignment to Xm that satisfies the constraints on {Xi, Xm} and {Xm, Xj}.",在3.3.3节中，我们指出通往重复状态的冗余路径会导致搜索代价呈指数级增长，而维护一个先前到达状态的表可以解决这个问题。
chap5_para67,2,The name refers to the overall consistency of the path from Xi to Xj with Xm in the middle.,在博弈树搜索中，重复状态的产生是由于换位（transposition）——移动序列的不同排列最终导致相同的局面，这个问题可以通过换位表（transposition table）解决，它将缓存状态的启发式值。
chap5_para670,1,,要超越这些基本的直观理解，我们必须明确定义如何生成随机语句。
chap5_para670,2,,"记法CNFk(m, n)表示一个有m个子句、n个符号的k-CNF语句，其中子句是均匀地、独立地、无放回地从所有有k个文字的子句中选取的，文字的正负也是随机的。"
chap5_para670,3,,（一个符号在子句中不能多次出现，一个子句也不能在语句中多次出现。
chap5_para670,4,,）
chap5_para671,1,,给定一个随机语句源，我们就可以测量可满足性的概率。
chap5_para671,2,,"图7-19a绘制了CNF3(m, 50)的概率，也就是有50个变量、每条子句有3个文字的语句，这一概率被绘制为子句/符号，即m/n的函数。"
chap5_para671,3,,如我们预期，对于较小的m/n，可满足性的概率接近0，而在较大的m/n处这一概率接近0。
chap5_para671,4,,概率在m/n = 4.3左右急剧下降。
chap5_para671,5,,经验上，我们发现这一“峭壁”出现在大致相同的位置（对于k = 3），并随着n的增长越来越陡峭。
chap5_para672,1,,"理论上，可满足性阈值猜想（satisfiability threshold conjecture）表明对所有，存在一个阈值比rk，使得当n接近无穷时CNFk(rn, n)可满足的概率对于所有低于阈值的r接近于1，对于所有高于阈值的r接近于0。"
chap5_para672,2,,即便对于如k = 3这样的特例，这一猜想仍未被证明。
chap5_para672,3,,不论这是不是一个定理，这样的阈值效应在可满足性问题和其他类型的NP困难问题中都是相当寻常的。
chap5_para673,1,,现在我们对可满足和不可满足问题分别会出现在什么地方有了很好的了解，接下来的问题是，困难的问题会出现在什么地方？
chap5_para673,2,,其实它们也经常位于阈值处。
chap5_para673,3,,图7-19b显示，阈值4.3处的50个符号的问题比阈值3.3处的相同问题大约难20倍。
chap5_para673,4,,欠约束问题很好求解（因为很容易就能猜到一个解），而过约束问题不如欠约束问题简单，却仍然比恰好在阈值处的问题简单得多。
chap5_para674,1,,图7-19　（a）有n个符号的随机3-CNF语句的可满足概率图，概率是子句/符号比m/n的函数。
chap5_para674,2,,（b）DPLL和WalkSAT在随机3-CNF语句上的（多次运行后测量的）运行时间中位数图。
chap5_para674,3,,最为困难的问题的子句/符号比约为4.3
chap5_para675,1,,7.7　基于命题逻辑的智能体
chap5_para676,1,,本节我们将目前所学的内容结合起来构建使用命题逻辑的wumpus世界智能体。
chap5_para676,2,,首先我们要使智能体能够根据其历史感知对世界的状态尽可能地进行推导。
chap5_para676,3,,这需要写出动作效果的完整逻辑模型。
chap5_para676,4,,随后我们介绍智能体在wumpus世界中如何使用逻辑推断。
chap5_para676,5,,我们还会介绍智能体如何在不查看每次推断的历史感知的情况下有效地跟踪世界的变化。
chap5_para676,6,,最后，我们介绍在已知其知识库在实际世界中为真的情况下，智能体如何使用逻辑推断来构建能确保达到目标的规划。
chap5_para677,1,,7.7.1　世界的当前状态
chap5_para678,1,,如本章开头所述，逻辑智能体通过用关于世界的语句知识库推导接下来的动作来运作。
chap5_para678,2,,知识库由公理（也就是关于世界如何运行的一般知识）和从智能体在某个特定世界获得的感知语句构成。
chap5_para678,3,,本节，我们聚焦于推导wumpus世界的当前状态这一问题，如我在哪里、方格是否安全等。
chap5_para679,1,,我们从7.4.3节开始收集公理。
chap5_para679,2,,智能体知道起始方格没有无底洞（）也没有wumpus（）。
chap5_para679,3,,此外，对于每个方格，它知道当且仅当一个方格的相邻方格有无底洞，该方格有微风；当且仅当一个方格的相邻方格有wumpus，该方格有臭味。
chap5_para679,4,,由此，我们引入了具有如下形式的大量语句：
chap5_para68,1,"Let’s see how path consistency fares in coloring the Australia map with two colors. We will make the set {WA, SA} path-consistent with respect to NT. We start by enumerating the consistent assignments to the set. In this case, there are only two: {WA = red, SA = blue} and {WA = blue, SA = red}. We can see that with both of these assignments NT can be neither red nor blue (because it would conflict with either WA or SA). Because there is no valid choice for NT, we eliminate both assignments, and we end up with no valid assignments for {WA, SA}. Therefore, we know that there can be no solution to this problem.","例如，假设白方进行了移动w1，而黑方用b1应对，在棋盘的另一边有一个不相关的移动w2，黑方可以用b2应对，我们搜索移动序列[w1, b1, w2, b2]，将其结果状态记为s。"
chap5_para68,2,,在探索了s下面一棵较大的子树之后，我们找到了它的倒推值，并将其存储在换位表中。
chap5_para68,3,,"当我们之后搜索移动序列[w2, b2, w1, b1]时，我们再次到达s，这时我们可以在表中查找它的值而无须重复搜索。"
chap5_para68,4,,在国际象棋中，换位表非常有效，在相同时间内能到达的搜索深度将扩大一倍。
chap5_para680,1,,智能体还知道恰恰只有一个wumpus。
chap5_para680,2,,我们用两部分表示。
chap5_para680,3,,首先，我们说至少有一个wumpus：
chap5_para681,1,,然后我们必须说最多只有一个wumpus。
chap5_para681,2,,我们对每对方格添加一个语句，来表明其中至少一个方格没有wumpus：
chap5_para682,1,,到目前为止都还不错。
chap5_para682,2,,现在让我们考虑智能体的感知。
chap5_para682,3,,"我们使用了S1,1来表示[1, 1]有臭味，那么我们可以只用一个命题Stench来表示智能体感知到臭味吗？"
chap5_para682,4,,遗憾的是，不行。
chap5_para682,5,,如果在之前的时间步中没有臭味，就已经被断言，那么新的断言将与之矛盾。
chap5_para682,6,,我们发现，如果感知只对当前时间的事情进行断言，这个问题就很容易求解。
chap5_para682,7,,如此，假如时间步（与输入图7-1中Make-Percept-Sentence的一样）是4，则我们在知识库中添加Stench4而非Stench，这样就能轻松地避免与矛盾。
chap5_para682,8,,对微风、碰撞、闪光和惨叫等感知也同样处理。
chap5_para683,1,,这个将命题与时间步相关联的思路可以拓展到这个世界中所有随时间变化的部分。
chap5_para683,2,,"例如，最初知识库中有——智能体在时刻0位于[1, 1]，以及FacingEast 0、HaveArrow 0和WumpusAlive0。"
chap5_para684,1,,我们使用流（fluent，源于拉丁语fluens，意为流动）来表示世界随时间变化的部分。
chap5_para684,2,,“流”与2.4.7节所述的对因子化表示的讨论中的“状态变量”同义。
chap5_para684,3,,与世界的不变部分相关的符号不需要时间上标，它们有时被称为非时序变量（atemporal variable）。
chap5_para685,1,,我们可以将微风和臭味直接与体验到这些感知的方格的属性连接。
chap5_para685,2,,"[11]对任意时间步t和任意方格[x, y]，我们断言"
chap5_para687,1,,[11]　7.4.3节出于简便考虑，隐藏了这项要求。
chap5_para688,1,,当然，现在我们需要能够使智能体跟进像这样的流的公理。
chap5_para688,2,,智能体采取动作会改变这些流，因此，用第3章的术语来说，我们需要将wumpus世界的转移模型写成逻辑语句的集合。
chap5_para689,1,,首先我们需要表示发生动作的命题符号。
chap5_para689,2,,与感知一样，这些符号用时间索引。
chap5_para689,3,,因此Forward 0表示智能体在时刻0执行前进动作。
chap5_para689,4,,习惯上，给定时间步的感知先发生，然后是这个时间步上的动作，然后是到下一个时间步的转移。
chap5_para69,1,5.,即使采用剪枝和精巧的移动顺序，极小化极大算法也不适用于国际象棋和围棋这样的游戏，因为在可用时间内仍然有太多状态需要探索。
chap5_para69,2,2.,"在关于计算机博弈的第一篇论文“Programming a Computer for Playing Chess”（Shannon, 1950）中，克劳德·香农意识到这一问题，并提出了两种策略。"
chap5_para69,3,4K-consistency,A型策略（Type A strategy）考虑搜索树中某一深度的所有可能的移动，然后使用启发式评价函数估计该深度下状态的效用值。
chap5_para69,4,,它探索了树的宽但浅的部分。
chap5_para69,5,,B型策略（Type B strategy）舍弃了那些看起来就很差的移动，“尽可能”走那些更有可能的路线。
chap5_para69,6,,它探索了树的深但窄的部分。
chap5_para690,1,,为描述世界如何变化，我们可以试着写出指明动作在下一个时间步产生的结果的效应公理（effect axiom）。
chap5_para690,2,,"例如，如果智能体位于[1, 1]，在时刻0时面朝东并向前走，结果是智能体位于方格[2, 1]且不再在[1, 1]："
chap5_para692,1,,对每个可能的时间步、16个方格中的每一个方格、4个方向中的每一个方向我们都需要类似这样的语句。
chap5_para692,2,,对于其他动作，即抓取、射击、攀爬、左转、右转我们也需要类似的语句。
chap5_para693,1,,假设智能体在时刻0决定向前移动，并在其知识库对此进行了断言。
chap5_para693,2,,"给定式（7-1）的效应公理，结合时刻0时对状态的初始断言，智能体可以推得它位于[2, 1]。"
chap5_para693,3,,也就是，Ask。
chap5_para693,4,,到目前为止，一切还好。
chap5_para693,5,,"遗憾的是，如果我们Ask(KB, HaveArrow1)，答案会是假，也就是智能体无法证明它仍然有箭，它也无法证明它没有箭！"
chap5_para693,6,,信息丢失了，因为效应公理没有说明动作的结果未改变哪些状态。
chap5_para693,7,,对这项功能的需求引出了框架问题。
chap5_para693,8,,[12]框架问题的一个可能的求解办法是明确地添加断言所有不变命题的框架公理。
chap5_para693,9,,例如，对于每个时刻t，我们有
chap5_para695,1,,[12]　“框架问题”（frame problem）的名字来源于物理学中的参照系（frame of reference），也就是测量运动时假设的静止背景。
chap5_para695,2,,电影的帧（frame）也借用了它的含义，其中前景变化时，大部分背景保持静止。
chap5_para696,1,,其中明确地提到了在采取前进动作时所有从时刻t到时刻t+1维持不变状态的命题。
chap5_para696,2,,尽管智能体现在已经知道它在前进后仍然有箭，且wumpus没有死去或复活，但激增的框架公理似乎相当低效。
chap5_para696,3,,在有m个不同动作和n个流的世界，框架公理集的大小为O(mn)。
chap5_para696,4,,这种框架问题被称作表示框架问题。
chap5_para696,5,,这个问题在人工智能史上扮演过重要的角色，我们在本章最后的参考文献与历史注释中将进行进一步探索。
chap5_para697,1,,表示框架问题很重要，因为即便保守来说，真实世界中的流也很多。
chap5_para697,2,,幸运的是，对我们人类来说，每个动作改变的流通常不多于k个（k是某个较小的值），也就是说世界具有局部性。
chap5_para697,3,,求解表示框架问题需要定义公理集大小为O(mk)而非O(mn)的转移模型。
chap5_para697,4,,还有一个问题是推断框架问题：将t步动作规划的结果在O(kt)时间而非O(nt)时间内前向推进的问题。
chap5_para698,1,,问题的解是关注于写出关于流而非动作的公理。
chap5_para698,2,,这样的话，对于每个流F，以时刻t时的所有流（包括F本身）和时刻t时可能发生的动作来定义Ft+1的真值的公理。
chap5_para698,3,,现在，Ft+1的真值可以用两种方法之一来确定：一种是时刻t的动作导致F在t+1为真，另一种是F在时刻t已经为真而时刻t的动作没有导致它为假。
chap5_para698,4,,这种形式的公理叫作后继状态公理（successor-state axiom），具有如下形式：
chap5_para699,1,,有箭（HaveArrow）的公理是最简单的后继状态公理。
chap5_para699,2,,因为没有重新装填箭支的行动，ActionCausesFt部分可以去掉，所以我们有
chap5_para7,1,"A constraint satisfaction problem consists of three components, X, D, and C:",第二种观点是，我们可以认为对抗智能体只是环境的一部分——这一部分让环境变成非确定性的。
chap5_para7,2,,但如果我们以对雨建模一样的方式（例如，雨有时下，有时不下）对对手进行建模，我们就会忽略对手正在积极地尝试击败我们这一事实，而雨没有这样的意图。
chap5_para70,1,"Stronger forms of propagation can be defined with the notion of k-consistency. A CSP is k-consistent if, for any set of k – 1 variables and for any consistent assignment to those variables, a consistent value can always be assigned to any kth variable. 1-consistency says that, given the empty set, we can make any set of one variable consistent: this is what we called node consistency. 2-consistency is the same as arc consistency. For binary constraint graphs, 3-consistency is the same as path consistency.",历史上，大多数国际象棋程序都是A型策略（我们将在5.3节讨论），而围棋程序通常是B型策略（将在5.4节讨论），因为围棋的分支因子要高得多。
chap5_para70,2,,"最近，B型程序在各种游戏中都达到了世界冠军级水平，包括国际象棋（Silver et al., 2018）。"
chap5_para701,1,,对智能体的位置来说，后继状态公理要更为复杂。
chap5_para701,2,,"例如，如果（a）智能体在面向南方时从[1, 2]，或面向西方时从[2, 1]向前移动，或者（b）已经为真且动作未产生移动（因为动作不是向前或动作导致撞墙），则为真。"
chap5_para701,3,,用命题逻辑写出，就是
chap5_para703,1,,习题7.SSAX要求写出剩余的wumpus世界的流的公理。
chap5_para704,1,,给定完整的后继状态公理和本节开始列出的其他公理，智能体就能够询问和回答世界当前状态的所有可解答问题。
chap5_para704,2,,例如，在7.2节，感知和动作的初始序列是
chap5_para705,1,,此时，有Ask，因此智能体知道它在什么位置。
chap5_para705,2,,而且，Ask和Ask，因此智能体已经找到了wumpus和一个无底洞。
chap5_para705,3,,对于智能体最重要的问题是一个方格是否能够进入，也就是这个方格是否没有无底洞也没有wumpus。
chap5_para705,4,,为此添加公理很容易，形式如下：
chap5_para706,1,,"最后，Ask，因此方格[2, 2]可以安全进入。"
chap5_para706,2,,实际上，给定一个如DPLL的可靠且完备的推断算法，智能体可以回答关于哪个方格安全的任意可解答问题，而且对于小型到中型的wumpus世界可以在几毫秒内完成回答。
chap5_para707,1,,求解表示框架问题和推断框架问题是一步重大的前进，但仍有一个亟待解决的问题：我们需要确认一个动作的所有必要的前提都成立才能保证结果效应。
chap5_para707,2,,我们说过向前动作使智能体向前方移动，除非前方有墙，但也有许多其他意外会导致动作失败：智能体可能会被绊倒，会犯心脏病，会被巨型蝙蝠抓走，诸如此类。
chap5_para707,3,,明确所有这些意外被称为资格问题（qualification problem）。
chap5_para707,4,,它在逻辑学的范畴内没有完备的解，在决定要多么详细地明确模型以及要忽略哪些细节时，系统设计者必须做出很好的判断。
chap5_para707,5,,我们将在第12章中看到，概率论允许以非显式的方式总结所有意外。
chap5_para708,1,,7.7.2　混合智能体
chap5_para709,1,,推导世界状态的多个方面的能力可以直接与条件-动作规则（见2.4.2节）以及第3章和第4章的问题求解算法结合，产生一个wumpus世界的混合智能体。
chap5_para709,2,,图7-20展示了达成这个目标的一种可能方式。
chap5_para709,3,,智能体程序维护并更新一个知识库和一个当前规划。
chap5_para709,4,,初始知识库含有非时变公理——不依赖于时间t的公理，例如将方格的微风与无底洞的存在联系起来的公理。
chap5_para709,5,,在每个时间步，新的感知和所有依赖于t的公理，如后继状态公理，被加入知识库。
chap5_para709,6,,（7.7.3节将解释为何智能体不需要未来时间步的公理。
chap5_para709,7,,）然后，智能体通过向知识库询问来使用逻辑推断，以找出哪些方格是安全的且未被访问过。
chap5_para71,1,"A CSP is strongly k-consistent if it is k-consistent and is also (k – 1)-consistent, (k – 2)-consistent, ... all the way down to 1-consistent. Now suppose we have a CSP with n nodes and make it strongly n-consistent (i.e., strongly k-consistent for k = n). We can then solve the problem as follows: First, we choose a consistent value for X1. We are then guaranteed to be able to choose a value for X2 because the graph is 2-consistent, for X3 because it is 3-consistent, and so on. For each variable Xi, we need only search through the d values in the domain to find a value consistent with X1,...,Xi–1. The total run time is only O(n2d).",5.3　启发式树搜索
chap5_para710,1,,智能体程序的主体根据目标优先级降序创建一个规划。
chap5_para710,2,,首先，如果存在闪光，则程序创建一个抓取金块、原路返回初始位置并爬出洞穴的规划。
chap5_para710,3,,否则，如果没有当前规划，程序会规划一个前往最近的、未被访问过的安全方格的路线，并确保路线仅经过安全方格。
chap5_para711,1,,路径规划使用A*搜索算法完成，而没有用Ask。
chap5_para711,2,,如果没有可探索的安全方格，下一步——如果智能体还有箭的话——就是试图对一个可能有wumpus的位置射击来创造一个安全方格。
chap5_para711,3,,这是通过询问Ask在何处为假完成的，也就是智能体还不知道的没有wumpus的地方。
chap5_para711,4,,函数Plan-Shot（图中未展示）使用Plan-Route规划一系列动作来完成这次射击。
chap5_para711,5,,如果失败，则程序寻找尚未证明是不安全的方格，也就是询问Ask返回假的方格。
chap5_para711,6,,"如果不存在这样的方格，则任务不可能完成，智能体撤退到[1, 1]并爬出洞穴。"
chap5_para712,1,,图7-20　wumpus世界的一个混合智能体。
chap5_para712,2,,它使用命题知识库来推断世界的状态，结合问题求解搜索和论域特定代码来选择动作。
chap5_para712,3,,每次调用Hybrid-Wumpus-Agent，它都会将感知添加到知识库，然后依据先前定义的规划或创建一个新规划，弹出这个规划的第一步作为下一个要采取的动作
chap5_para713,1,,7.7.3　逻辑状态估计
chap5_para714,1,,图7-20所示的智能体工作得不错，但它有一个重大弱点：随着时间流逝，涉及对Ask调用的计算开销不断增大。
chap5_para714,2,,这主要是由于所需的推断不得不回到越来越早的时间点，并涉及越来越多的命题符号。
chap5_para714,3,,显然，这是不可持续的——我们不能让一个智能体处理每次感知的时间随着其寿命的增长成比例地增加！
chap5_para714,4,,我们真正需要的是常数更新时间，也就是，与t无关。
chap5_para714,5,,一个显然的答案是保存或缓存（cache）推断的结果，以便下一个时间步的推断过程构建在先前的结果上，而非必须从零开始。
chap5_para715,1,,如我们在4.4节所见，感知的历史和所有其后果都可以用信念状态代替，即对所有可能的当前世界状态集合的某种表示[13]。
chap5_para715,2,,在新感知到来时更新信念的过程被称为状态估计（见4.4.4节）。
chap5_para715,3,,而在4.4节，信念状态是状态的显式列表，此处我们可以使用含有关于当前时间步的命题符号，以及非时变符号的逻辑语句。
chap5_para715,4,,例如，逻辑语句
chap5_para717,1,,[13]　我们可以认为感知历史本身就是一个信念状态的表示，但它是一个随着历史变长使得推断代价逐渐增加的表示。
chap5_para719,1,,"代表时刻1的所有状态的集合，这时wumpus还活着，智能体位于[2, 1]，方格中有微风，[3, 1]或[2, 2]其中之一有无底洞或两个都有无底洞。"
chap5_para72,1,"Of course, there is no free lunch: constraint satisfaction is NP-complete in general, and any algorithm for establishing n-consistency must take time exponential in n in the worst case.",为了充分利用有限的计算时间，我们可以提前截断搜索，并对状态应用启发式评价函数，从而有效地将非终止节点转变为终止节点。
chap5_para72,2,"Worse, n-consistency also requires space that is exponential in n.",换句话说，我们用Eval函数代替Utility函数，Eval对状态效用值进行估计。
chap5_para72,3,"In practice, determining the appropriate level of consistency checking is mostly an empirical science.",用截断测试（cutoff test）代替终止测试，对于终止状态，截断测试必定返回真，但是它可以根据搜索深度和当前状态的任意属性自由决定何时终止搜索。
chap5_para72,4,"Computing 2-consistency is common, and 3-consistency less common.","这样我们得到了搜索深度d处状态s的启发式极小化极大值的计算公式H-Minimax(s, d)："
chap5_para720,1,,维护一个精确的、逻辑公式形式的信念状态并不简单。
chap5_para720,2,,如果对于时刻t有n个流符号，则会有2n个可能的状态，也就是对这些符号的所有赋值。
chap5_para720,3,,而现在，信念状态的集合是物理状态的超集（所有子集的集合）。
chap5_para720,4,,总共有2n个物理状态，因此有个信念状态。
chap5_para720,5,,即便我们对逻辑公式尽可能地使用紧凑的编码方式，即每个信念状态用一个二进制数表示，我们也需要位来标记当前的信念状态。
chap5_para720,6,,也就是说，精确的状态估计需要的逻辑公式的规模可能是符号数量的指数级别的。
chap5_para721,1,,一个用于近似状态估计的常见且自然的方法是用文字的合取式表示信念状态，即1-CNF公式。
chap5_para721,2,,为此，智能体程序只需要在给定时刻t−1的信念状态的情况下，为每个符号X t证明X t和 （以及真值未知的非时变符号）即可。
chap5_para721,3,,可证明文字的合取式成为了新的信念状态，先前的信念状态被丢弃。
chap5_para722,1,,要了解的是，随着时间流逝，这个方法可能会损失一些信息。
chap5_para722,2,,"例如，如果式（7-4）的语句是真正的信念状态，则P3,1和P2,2都无法被单独证明，也都不会出现在1-CNF信念状态中。"
chap5_para722,3,,（习题7.HYBR探索了这一问题的一个可行的解法。
chap5_para722,4,,）另外，由于1-CNF信念状态中的每一个文字都是由前一信念状态证得的，而且初始信念状态是一个真实的断言，可得出整个1-CNF信念状态必然为真。
chap5_para722,5,,因此，1-CNF信念状态所表示的可能状态的集合包含了给定全部感知历史时的所有确实可能的状态。
chap5_para722,6,,如图7-21所示，1-CNF信念状态就是准确信念状态的一个外包络，即保守近似（conservative approximation）。
chap5_para722,7,,我们可以在人工智能的许多领域反复见到复杂集合的保守近似这一概念。
chap5_para723,1,,图7-21　1-CNF信念状态（粗实线外轮廓）作为对准确信念状态（虚线轮廓的深色区域）的简单的、可表示的保守近似。
chap5_para723,2,,每个可能世界都使用圆圈表示，深色圆圈与所有感知一致
chap5_para724,1,,7.7.4　用命题推断进行规划
chap5_para725,1,,图7-20所示的智能体使用逻辑推断来确定哪个方格是安全的，但使用了A*搜索来进行规划。
chap5_para725,2,,本节展示如何通过逻辑推断来进行规划。
chap5_para725,3,,它的思想非常简单。
chap5_para726,1,,（1）构建一个语句，它含有：
chap5_para727,1,,a. 对于初始状态的断言集Init0；
chap5_para728,1,,b. 到最大为时刻t为止的每一时间步的所有可能动作的后继状态公理 ；
chap5_para729,1,,c. 目标在时刻t达成的断言。
chap5_para73,1,5.,5.3.1　评价函数
chap5_para73,2,2.,
chap5_para73,3,5Global constraints,
chap5_para730,1,,（2）将所有语句提供给SAT求解器。
chap5_para730,2,,如果求解器找到一个可满足的模型，则目标是可达成的；如果语句不可满足，则问题无解。
chap5_para731,1,,（3）假设找到了一个模型，从模型中提取代表动作并被赋值为true的变量。
chap5_para731,2,,它们代表一个达成目标的规划。
chap5_para732,1,,图7-22展示了一个命题规划程序SATPlan。
chap5_para732,2,,它实现了上述的想法，仅做了一点改变。
chap5_para732,3,,由于智能体并不知道它需要多少步才能达成目标，算法会尝试每个可能的t步，直到某个可行的最大规划长度Tmax。
chap5_para732,4,,这样，如果这一规划存在的话，它能够确保找到最短的规划。
chap5_para732,5,,由于SATPlan搜索解的特定方式，它无法在部分可观测的环境中使用；SATPlan只能将不可观测的变量设定为它所需的值来求解。
chap5_para733,1,,图7-22　SATPlan算法。
chap5_para733,2,,规划问题被转换为CNF语句，其中目标被断言在固定的时间步t时成立，到t为止的每个时间步都含有公理。
chap5_para733,3,,如果可满足性算法找到了一个模型，则通过查看指向动作并在模型中被赋值为true的命题符号来提取规划。
chap5_para733,4,,如果模型不存在，则将目标后移一步，重复这一过程
chap5_para734,1,,使用SATPlan的关键步骤是构建知识库。
chap5_para734,2,,大体来看，7.7.1节所述的wumpus世界公理似乎足以构成上述步骤1中的a和b。
chap5_para734,3,,但蕴含（正如用Ask来检验的那些）和可满足性对公理的要求有重要的区别。
chap5_para735,1,,"例如，考虑智能体的位置初始为[1, 1]，假设智能体的目标仅为在时刻1时移动到[2, 1]。"
chap5_para735,2,,初始知识库含有，目标为。
chap5_para735,3,,如果断言Forward0，则我们可以使用Ask证得；如果被断言的是Shoot0，则我们无法证得。
chap5_para735,4,,现在，SATPlan会找到规划[Forward0]，目前看起来没什么问题。
chap5_para736,1,,遗憾的是，SATPlan也会找到规划[Shoot0]。
chap5_para736,2,,为什么会这样呢？
chap5_para736,3,,"要找出其原因，先检查一下SATPlan构建的模型：它包括赋值，也就是智能体可以在时刻0时就位于[2, 1]并进行射击，故而在时刻1时也会在[2, 1]。"
chap5_para736,4,,"有人会问：“我们不是刚说过智能体在时刻0时位于[1, 1]吗？"
chap5_para736,5,,”的确如此，但我们没有告诉智能体它不能同时位于两个位置！
chap5_para736,6,,对蕴含来说，是未知的，因此不能被用于证明；而对于可满足性，是未知的，因此可以被设定为任意有助于达成目标的值。
chap5_para737,1,,对知识库来说，SATPlan是很好的调试工具，因为它能够暴露出知识缺失的地方。
chap5_para737,2,,在这个例子中，我们可以使用类似于用来断言恰恰只存在一个wumpus的语句集，来断言在每个时刻智能体只能位于一个位置，以修复知识库。
chap5_para737,3,,"或者，我们可以对除[1, 1]之外的所有位置断言；关于位置的后继状态公理用于处理之后的时刻。"
chap5_para737,4,,相同的修复方式也可以用于确保智能体在一个时刻有且仅有一个朝向。
chap5_para738,1,,但SATPlan还有更怪异的表现。
chap5_para738,2,,首先是，它会找出含有不可能采取的动作的模型，例如在没有箭支的时候射击。
chap5_para738,3,,要理解其原因，我们需要更为仔细地查看后继状态公理，如式（7-3），对于前提无法满足的动作的描述。
chap5_para738,4,,公理的确正确地预测了执行这种动作不会产生任何结果（见习题7.SATP），但它没有表明这一动作不能被执行！
chap5_para738,5,,要避免生成含有不合规动作的规划，我们必须加入表明动作的出现需要满足其前提的前提公理（precondition axiom）。
chap5_para738,6,,[14]例如，我们需要说，对于每个时刻t，有
chap5_para74,1,Remember that a global constraint is one involving an arbitrary number of variables (but not necessarily all variables).,"就像第3章的启发式函数返回到目标距离的估计值一样，启发式评价函数Eval(s, p)向参与者p返回状态s的期望效用的估计值。"
chap5_para74,2,Global constraints occur frequently in real problems and can be handled by special-purpose algorithms that are more efficient than the general-purpose methods described so far.,"对于终止状态，一定是Eval(s, p) = Utility(s, p)，而对于非终止状态，估计值必须介于输和赢之间：。"
chap5_para74,3,"For example, the Alldiff constraint says that all the variables involved must have distinct values (as in the cryptarithmetic problem above and Sudoku puzzles below).",
chap5_para74,4,"One simple form of inconsistency detection for Alldiff constraints works as follows: if m variables are involved in the constraint, and if they have n possible distinct values altogether, and m > n, then the constraint cannot be satisfied.",
chap5_para740,1,,[14]　注意，加入前提公理意味着我们不再需要在后继状态公理中包含动作的前提条件。
chap5_para741,1,,这就确保了如果规划在某一时刻选择采取动作Shoot，则此时智能体必然有一支箭。
chap5_para742,1,,SATPlan的另一个怪异的行为是它会创建具有多个同时进行的动作的规划。
chap5_para742,2,,例如，它会生成一个Fotward0和Shoot0都为真的模型，而这是不允许的。
chap5_para742,3,,要解决这个问题，我们引入动作排除公理（action exclusion axiom）：对于每对动作和，我们加入公理
chap5_para743,1,,可能有人会提出同时向前走并射击并不是很困难，但如果是同时抓取并射击的话就相当不现实了。
chap5_para743,2,,通过只对相互冲突的每对动作施以动作排除公理，可以使规划同时含有多个动作——而由于SATPlan能找出最短的合规规划，我们就可以确定它能够利用同时动作这个能力。
chap5_para744,1,,总之，SATPlan能对含有初始状态、目标、后继状态公理、前提公理和动作排除公理的语句找出模型。
chap5_para744,2,,由于不再存在任何错误的“解”，我们可以证明这一公理集是充分的。
chap5_para744,3,,所有满足命题语句的模型都将是原始问题的有效解。
chap5_para744,4,,现代SAT求解技术使得这一方法相当实用。
chap5_para744,5,,例如，一个DPLL风格的求解器可以毫不费力地生成图7-2所示的wumpus世界的解。
chap5_para745,1,,本节已经讲过构建智能体的一个陈述性方法：智能体通过结合在知识库中断言语句和执行逻辑推断运行。
chap5_para745,2,,"这种方法有一些弱点，它们就隐含于类似“对于每个时刻t”和“对于每个方格[x, y]”这样的表述中。"
chap5_para745,3,,对于所有实用的智能体，这些表述必须用从一般语句模式中自动生成实例的代码来实现，这些实例被用于插入知识库中。
chap5_para745,4,,对于一个规模适中（相当于小型计算机游戏的大小）的wumpus世界，我们可能需要一个100×100的场地和1000个时间步，这样的话知识库中的语句就会有上亿条之多。
chap5_para746,1,,这种情况不仅相当不现实，也揭露了一个深层次的问题：我们对wumpus世界的理解（即它的“物理学”在所有方格和所有时刻都一样）不能直接用命题逻辑的语言来表示。
chap5_para746,2,,"要解决这个问题，我们需要更有表达能力的语言，也就是那种可以自然地写出像“对于每个时刻t”和“对于每个方格[x, y]”这种表述的语言。"
chap5_para746,3,,第8章所述的一阶逻辑就是一种这样的语言。
chap5_para746,4,,在一阶逻辑中，任意大小、任意时长的wumpus世界都可以用大约10条逻辑语句来描述，而非1000万条乃至1万亿条。
chap5_para748,1,,我们已经介绍了基于知识的智能体，也展示了如何定义一种逻辑，以便使这种智能体能够对世界进行推理。
chap5_para748,2,,本章重点如下。
chap5_para749,1,,● 智能体需要关于世界的知识来获得良好的决策。
chap5_para75,1,"This leads to the following simple algorithm: First, remove any variable in the constraint that has a singleton domain, and delete that variable’s value from the domains of the remaining variables. Repeat as long as there are singleton variables. If at any point an empty domain is produced or there are more variables than domain values left, then an inconsistency has been detected.",除了满足这些需求之外，一个好的评价函数是由什么组成的？
chap5_para75,2,,首先，计算时间不能太长！
chap5_para75,3,,（重点是加快搜索速度。
chap5_para75,4,,）其次，评价函数应与实际的获胜机会密切相关。
chap5_para75,5,,你可能会对“获胜机会”一词感到疑惑。
chap5_para75,6,,毕竟，国际象棋并不是一种碰运气的游戏：我们确定地知道当前的状态，博弈没有任何随机性；如果双方都没有犯错，结果是预先确定的。
chap5_para75,7,,但是，如果搜索必须在非终止状态截断，那么算法对这些状态的最终结果必然是不确定的（即使这种不确定性可以通过提供无限的计算资源来解决）。
chap5_para750,1,,● 知识包含在智能体中，其形式为存储于知识库中的、用知识表示语言表述的语句。
chap5_para751,1,,● 一个基于知识的智能体由一个知识库和一套推断机制组成。
chap5_para751,2,,它的运作方式是在知识库中存储关于世界的语句，使用推断机制推断新语句，并使用这些语句来决定采取何种动作。
chap5_para752,1,,● 一种表示语言是用其语法和语义来定义的，语法规定了语句的结构，语义定义了每个可能世界或模型中每条语句的真值。
chap5_para753,1,,● 语句之间的蕴含关系对于我们对推理的理解非常重要。
chap5_para753,2,,在所有为真的世界中也为真，则语句蕴含语句。
chap5_para753,3,,其等价定义包括语句的有效性和语句的不可满足性。
chap5_para754,1,,● 推断是从旧语句推得新语句的过程。
chap5_para754,2,,可靠的推断算法只推出蕴含的语句，完备的算法则可以推得所有蕴含的语句。
chap5_para755,1,,● 命题逻辑是由命题符号和逻辑联结词构成的简单语言。
chap5_para755,2,,它可以处理已知为真、为假或完全未知的命题。
chap5_para756,1,,● 给出固定命题词汇表的前提下，可能的模型的集合是有限的，因此蕴含可以用枚举模型来检验。
chap5_para756,2,,用于命题逻辑的高效模型检验推断算法包括回溯和局部搜索方法，它们通常能快速求解大规模问题。
chap5_para757,1,,● 推断规则是可靠推断的模式，它可以用于证明。
chap5_para757,2,,归结规则能产生一个用于知识库的完备推断算法，以合取范式的形式表示。
chap5_para757,3,,前向链接和反向链接是霍恩形式知识库的非常自然的推理算法。
chap5_para758,1,,● 如WalkSAT这样的局部搜索方法可以用于问题求解。
chap5_para758,2,,这种算法是可靠的，但不是完备的。
chap5_para759,1,,● 逻辑状态估计需要使描述可能状态集的逻辑语句与历史观测保持一致。
chap5_para759,2,,每一步更新都需要使用环境的转移模型进行推断，转移模型是根据规定流的变化方式的后继状态公理构建的。
chap5_para76,1,"This method can detect the inconsistency in the assignment {WA = red, NSW = red} for Figure 5.",让我们把这一思想进一步具体化。
chap5_para76,2,1.,大多数评价函数需要计算状态的各种特征（feature），例如，在国际象棋中，我们将拥有白兵数目、黑兵数目、白后数目、黑后数目等特征。
chap5_para76,3,"Notice that the variables SA, NT, and Q are effectively connected by an Alldiff constraint because each pair must have two different colors.",这些特征合在一起，定义了状态的各种类别或等价类：同一类别中的状态，对所有特征都具有相同值。
chap5_para76,4,"After applying AC-3 with the partial assignment, the domains of SA, NT, and Q are all reduced to {green, blue}.",例如，某一类别包含所有的“两兵对一兵”残局。
chap5_para76,5,"That is, we have three variables and only two colors, so the Alldiff constraint is violated.",任何给定类别都可能包含一些通往（以完美玩法）胜利的状态，一些通往平局的状态和一些通往失败的状态。
chap5_para76,6,"Thus, a simple consistency procedure for a higher-order constraint is sometimes more effective than applying arc consistency to an equivalent set of binary constraints.",
chap5_para760,1,,● 逻辑智能体内部的决策可以用求解SAT的方式进行：找出描述能达到目标的未来动作序列的可能的模型。
chap5_para760,2,,这个方法仅能用于完全可观测或无传感器环境。
chap5_para761,1,,● 命题逻辑无法扩大到大小无限制的环境中，因为它有限的表达能力不能简洁地处理时间、空间和对象间关系的通用模式。
chap5_para765,1,,在本章中，我们将注意到世界被赋予了许多对象，其中一些对象与另一些对象相关，而我们努力对其进行推理。
chap5_para766,1,,命题逻辑足以展示逻辑、推断和基于知识的智能体的基本概念。
chap5_para766,2,,遗憾的是，命题逻辑的表达能力有限。
chap5_para766,3,,本章我们介绍一阶逻辑，[1]它可以简洁地表达更多东西。
chap5_para766,4,,我们在8.1节中总体上讨论表示语言，在8.2节中介绍一阶逻辑的语法和语义，然后在8.3节和8.4节中展示一阶逻辑在简单表示中的运用。
chap5_para768,1,,[1]　一阶逻辑也称为一阶谓词演算（first-order predicate calculus），可缩写为FOL或FOPC。
chap5_para77,1,"Another important higher-order constraint is the resource constraint, sometimes called the Atmost constraint.",评价函数不知道到底是处于哪种状态，但它可以返回一个值来估计每个结果的状态比例。
chap5_para77,2,"For example, in a scheduling problem, let P1,.",例如，假设我们的经验表明，在“两兵对一兵”类中，82%的状态通向胜利（效用值+1），2%导致失败（效用值0），16%为平局（效用值1/2）。
chap5_para77,3,.,那么，该类别中状态的合理评估为期望值（expected value）：(0.82×+1) + (0.02×0) + (0.16×1/2) = 0.90。
chap5_para77,4,.,原则上，可以为每一个状态类确定一个期望值，这样我们就得到了适用于任何状态的评价函数。
chap5_para77,5,",P4 denote the numbers of personnel assigned to each of four tasks.",
chap5_para77,6,"The constraint that no more than 10 personnel are assigned in total is written as Atmost(10, P1, P2, P3, P4).",
chap5_para77,7,"We can detect an inconsistency simply by checking the sum of the minimum values of the current domains; for example, if each variable has the domain {3,4,5,6}, the Atmost constraint cannot be satisfied.",
chap5_para77,8,We can also enforce consistency by deleting the maximum value of any domain if it is not consistent with the minimum values of the other domains.,
chap5_para77,9,"Thus, if each variable in our example has the domain {2,3,4,5,6}, the values 5 and 6 can be deleted from each domain.",
chap5_para770,1,,本节我们讨论表示语言的特性。
chap5_para770,2,,编程语言（如C++、Java或Python）是常用的最大一类形式化语言。
chap5_para770,3,,程序中的数据结构可以用来表示事实，例如，程序可以使用一个4×4数组表示wumpus世界的内容。
chap5_para770,4,,"这样的话，编程语言中的语句就是断言在方格[2, 2]中有无底洞的一种很自然的方式。"
chap5_para770,5,,将一系列这样的语句合起来，就足以对wumpus世界进行模拟。
chap5_para771,1,,编程语言欠缺的是从其他事实推导事实的通用机制：对数据结构的每次更新都要使用领域特定的过程，而过程中的具体细节是由程序员根据其自身所具有的该领域的知识进行推导的。
chap5_para771,2,,这种过程性的方法可与命题逻辑的陈述性（declarative）特性相对比，在命题逻辑中知识与推断是独立的，而推断完全是领域无关的。
chap5_para771,3,,SQL数据库融合了陈述性与过程性知识。
chap5_para772,1,,"程序（以及数据库）中数据结构的另一个缺点是缺少简便的表示方式来描述像“在方格[2, 2]或[3, 1]中有无底洞”或“如果wumpus在[1, 1]中，则它不在[2, 2]中”这样的概念。"
chap5_para772,2,,程序可以为每个变量存储一个值，一些系统也允许这个值为“未知”，但它们缺乏直接处理部分信息的表达能力。
chap5_para773,1,,命题逻辑是说明性语言，因为它的语义是基于语句与可能世界之间的真值关系的。
chap5_para773,2,,使用析取和否定，命题逻辑有了足够的表达能力来处理部分信息。
chap5_para773,3,,命题逻辑还有一个在表示语言中很有用的特性，即合成性（compositionality）。
chap5_para773,4,,在合成语言中，一条语句的含义是其各个组成部分的含义的一个函数。
chap5_para773,5,,"例如，“S1,4 ∧ S1,2”的含义与“S1,4”和“S1,2”的含义有关。"
chap5_para773,6,,"如果“S1,4”表示方格[1, 4]有臭味，“S1,2”表示方格[1, 2]有臭味，而“S1,4 ∧ S1,2”却表示法国与波兰在上周的冰球资格赛1∶1打平，就显得非常奇怪。"
chap5_para774,1,,然而，命题逻辑作为一种因子化表示，缺乏能够简洁描述具有多个对象的环境的表达能力。
chap5_para774,2,,例如，我们不得不为每个方格分别写出关于微风和无底洞的规则，如：
chap5_para775,1,,而在英语中，我们似乎可以简单地用一句“Squares adjacent to pits are breezy.”（与无底洞相邻的方格有微风）来一举解决问题。
chap5_para775,2,,英语的语法和语义使它能够简洁地描述环境：英语是结构化表示，一阶逻辑也是。
chap5_para776,1,,8.1.1　思想的语言
chap5_para777,1,,自然语言（如英语或西班牙语）确实富有表达能力。
chap5_para777,2,,我们设法用自然语言写作这一整本书的几乎全部内容，只偶尔地转用其他语言（主要是数学和图表）。
chap5_para777,3,,语言学和语言哲学将自然语言视为说明性知识表示语言由来已久。
chap5_para777,4,,如果我们能够揭示自然语言的规则，我们就能将其用于表示和推理系统，并获益于数十亿页已经用自然语言写就的文字。
chap5_para778,1,,自然语言的现代观点是将其视作交流的媒介而非单纯的表示。
chap5_para778,2,,当说者指向一处并说“看！
chap5_para778,3,,”听者就会明白他说的是超人终于出现在房顶了。
chap5_para778,4,,但我们不能说是语句“看！
chap5_para778,5,,”表示了这一事实。
chap5_para778,6,,实际上，语句的含义既取决于语句本身，也取决于说出这一语句时的语境。
chap5_para778,7,,显然，如果不在知识库中存储语句语境的表示而是仅存储像“看！
chap5_para778,8,,”这样的语句，我们就无法搞清其含义——这就引发了语境本身该如何表示的问题。
chap5_para779,1,,自然语言也受制于模糊性，这也是表示语言面临的问题。
chap5_para779,2,,"正如平克（Pinker, 1995）所述：“当人们想到spring时，他们绝对不会困惑于他们到底是想到了一个季节还是想到了那个发出‘啵嘤’声的东西——如果一个词语可以对应于两种思想，那么思想就不能是词语。"
chap5_para779,3,,”[2]
chap5_para78,1,"For large resource-limited problems with integer values—such as logistical problems involving moving thousands of people in hundreds of vehicles—it is usually not possible to represent the domain of each variable as a large set of integers and gradually reduce that set by consistency-checking methods. Instead, domains are represented by upper and lower bounds and are managed by bounds propagation. For example, in an airline-scheduling problem, let’s suppose there are two flights, F1 and F2, for which the planes have capacities 165 and 385, respectively. The initial domains for the numbers of passengers on flights F1 and F2 are then",在实践中，这种方法需要分析太多类别，因此需要非常多的经验去估计所有的可能性。
chap5_para78,2,,与上述方法不同，大多数评价函数会分别计算每个特征的数值贡献，将它们结合起来得到总数值。
chap5_para78,3,,几个世纪以来，国际象棋棋手们已经提出了一些使用这一思想评估局面价值的方法。
chap5_para78,4,,例如，国际象棋入门书籍给出了各个棋子的子力价值（material value）估计：兵值1分，马或象值3分，车值5分，后值9分。
chap5_para78,5,,其他特征，如“好的兵阵”和“王的安全”可能值半个兵。
chap5_para78,6,,这些特征值简单地相加即可得到局面的评估值。
chap5_para781,1,,[2]　表示“春天”和“弹簧”的英语单词都是spring。
chap5_para781,2,,——译者注
chap5_para782,1,,"著名的萨丕尔-沃尔夫假说（Sapir-Whorf hypothesis）（Whorf, 1956）宣称，我们对世界的理解深受我们所说的语言的影响。"
chap5_para782,2,,不同的语言群体以不同的方式划分世界。
chap5_para782,3,,对英语使用者来说，“chair”一词囊括法语中“chaise”和“fauteuil”两个单词的概念，但英语使用者可以轻易地认出fauteuil这个类别，并给它命名——大概是“扶手椅”（open-arm chair）。
chap5_para782,4,,那么语言真的会对理解有影响吗？
chap5_para782,5,,沃尔夫主要依靠直觉和猜测，他的想法也已经基本被摒弃，但多年以来我们其实有来自人类学、心理学和神经科学研究的真实数据。
chap5_para783,1,,例如，你是否还记得下列表述中的哪一个构成了8.1节的开头？
chap5_para784,1,,“本节我们讨论表示语言的特性……”
chap5_para785,1,,“本节讲述表示语言的相关知识……”
chap5_para786,1,,"维纳（Wanner, 1974）进行了类似的实验并发现，实验对象做出正确选择的概率处于随机水平——大概为50%，但对阅读内容记忆的准确率却超过90%。"
chap5_para786,2,,这意味着，人们会解读其阅读过的文字并形成内在的非文字表示，而确切的用词并不重要。
chap5_para787,1,,当某个概念在一种语言里根本不存在时，情况就更加有趣。
chap5_para787,2,,澳大利亚的土著语言Guugu Yimithirr的使用者没有词语来表示如前、后、左、右这样的相对（或自我中心）方向。
chap5_para787,3,,他们只使用绝对方向，例如“我北边的胳膊有点疼”。
chap5_para787,4,,这种语言上的区别就导致了行为的区别：Guugu Yimithirr使用者在开阔地形上的定向能力更好，而英语使用者则更擅长于将叉子放在盘子右侧。
chap5_para788,1,,语言似乎也会通过类似名词的性这种看起来毫无规律的文法特征来影响思维。
chap5_para788,2,,例如，“桥”在西班牙语中是阳性词，而在德语中是阴性词。
chap5_para788,3,,"博罗迪茨基（Boroditsky, 2003）要求实验对象选取英语形容词来描述某座桥的照片。"
chap5_para788,4,,西班牙语使用者选择了大（big）、危险（dangerous）、坚固（strong）、耸立（towering），而德语使用者则选择了优美（beautiful）、优雅（elegant）、脆弱（fragile）、纤细（slender）。
chap5_para789,1,,词语可以充当我们感知世界的锚点。
chap5_para789,2,,洛夫特斯和帕尔默（Loftus and Palmer，1974）向实验对象展示了汽车事故的影片，被问及“车辆接触时的车速是多少？
chap5_para789,3,,”的实验对象报告的平均速度为51.5 km/h，而使用“撞击”替代问题中的“接触”后，对于同一部影片的同一辆车，被提问的实验对象报告的平均速度则为66 km/h。
chap5_para789,4,,总体来看，不同语言的使用者在认知处理上有微小却可测出的区别，但并没有令人信服的证据能够说明这会引起世界观的重大区别。
chap5_para79,1,Now suppose we have the additional constraint that the two flights together must carry 420 people: F1 + F2 = 420.,数学上，这种评价函数称为加权线性函数（weighted linear function），因为它可以表示为如下形式：
chap5_para79,2,"Propagating bounds constraints, we reduce the domains to",
chap5_para790,1,,在使用合取范式（CNF）的逻辑推理系统中，我们知道语言表达式“”和“”是等价的，因为我们可以看到系统的内部，并能够了解到这两条语句是以完全相同的标准CNF形式存储的。
chap5_para790,2,,而对人类的大脑进行类似的操作正在成为可能。
chap5_para790,3,,"米切尔等人（Mitchell et al., 2008）让实验对象进入功能性磁共振成像（fMRI）仪，然后向他们展示如“芹菜”之类的词语，并对他们的大脑进行成像。"
chap5_para790,4,,"使用(词语, fMRI图像)数据对训练而成的机器学习程序能够在二选一任务（例如，是“芹菜”还是“飞机”）中达到77%的准确率。"
chap5_para790,5,,这套系统甚至能够对其先前从未见过fMRI图像的词语（通过考虑相关词语的图像）和从未见过的人（证明fMRI揭示了人脑的表示方式具有某种共性）达到超过随机猜测的准确率。
chap5_para790,6,,"尽管这类研究还相当原始，但fMRI以及其他成像技术，例如颅内电生理学（Sahin et al., 2009），有望将人类的知识表示形式探究得更为详尽。"
chap5_para791,1,,从形式化逻辑的观点来看，用两种不同的方式表示相同的知识一点区别都没有，无论从何种表示出发都能推出相同的事实。
chap5_para791,2,,但在实际中，从其中一种表示推出结论的步骤可能更少，这意味着资源有限的推理机只能从这一种表示得出结论，而非其他表示。
chap5_para791,3,,对于类似从经验中学习这样的非演绎任务，其结果必然地依赖于其所使用的表示。
chap5_para791,4,,我们在第19章阐述了当学习程序考虑两种关于世界的理论时，如果这两种理论与所有数据都是一致的，那么最为常见的破局方式就是选择最简洁的理论，而这取决于用来表示理论的语言。
chap5_para791,5,,那么，对任何进行学习的智能体来说，语言对思想的影响就是不可避免的。
chap5_para792,1,,8.1.2　结合形式语言和自然语言的优点
chap5_para793,1,,我们可以采用形式逻辑的基础——一种上下文无关的、无歧义的说明性、合成式语义——来构建一种更有表达能力的逻辑，同时又从自然语言中借鉴表示方法并避免其缺点。
chap5_para793,2,,当我们考察自然语言时，最为显眼的元素就是指代对象的名词和名词性短语（方格、无底洞、wumpus）和动词与动词性短语以及表示对象关系的形容词和副词（有微风、相邻、射击）。
chap5_para793,3,,这些关系当中有的是函数，即对于一个给定“输入”只有一个“值”的关系。
chap5_para793,4,,很容易就能列出一些对象、关系和函数。
chap5_para794,1,,● 对象：人、房屋、数字、理论、麦当劳叔叔、颜色、棒球游戏、战争、世纪等。
chap5_para795,1,,● 关系：可以是一元关系或属性，如红色的、圆的、伪造的、主要的、多层的等，或更为普适的n元关系，如是……的兄弟、大于、在……里、是……的一部分、有……颜色、发生于……之后、拥有、在……中间等。
chap5_para796,1,,● 函数： ……的父亲、……最好的朋友、……的第三局比赛、比……多一个、……的开始等。
chap5_para797,1,,实际上，几乎所有断言都可以看作对对象和属性的指代或关系。
chap5_para797,2,,下面是一些例子。
chap5_para798,1,,● “1加2等于3”。
chap5_para799,1,,对象：1、2、3、1加2。
chap5_para799,2,,关系：等于。
chap5_para799,3,,函数：加。
chap5_para799,4,,（“1加2”是对对象“1”和“2”应用函数“加”后得到的对象的名称。
chap5_para799,5,,“3”是这个对象的另一个名称。
chap5_para799,6,,）
chap5_para8,1,"X is a set of variables, (X1,.",第三种观点是用对抗博弈树搜索技术显式地对对抗智能体建模。
chap5_para8,2,.,这就是本章所涵盖的内容。
chap5_para8,3,.,我们从一类受限的博弈开始，定义最优移动并寻找最优移动的算法——极小化极大搜索（minimax search），它是与或搜索的一种推广（见图4-11）。
chap5_para8,4,", Xn}.",我们指出，剪枝（pruning）通过忽略搜索树中对最优移动没有影响的部分来提高搜索效率。
chap5_para8,5,,对于非平凡博弈，我们通常没有足够的时间以确保找到最优移动（即使使用剪枝），我们不得不在某个时刻停止搜索。
chap5_para80,1,"We say that a CSP is bounds-consistent if for every variable X, and for both the lower-bound and upper-bound values of X, there exists some value of Y that satisfies the constraint between X and Y for every variable Y.",其中fi是局面的某一特征（例如“白象数目”），wi是其权重（表明该特征的重要性）。
chap5_para80,2,This kind of bounds propagation is widely used in practical constraint problems.,权重需要归一化，使总和始终保持在输（0）到赢（+1）的范围内。
chap5_para80,3,,如图5-8a所示，一个兵的确定优势提供了很大的获胜可能性，而3个兵的确定优势则几乎必胜。
chap5_para80,4,,之前提到，评价函数应与实际的获胜机会密切相关，但并不需要线性相关：如果状态s获胜的可能性是状态s'的两倍，并不意味着Eval(s)必须是Eval(s')的两倍，只需要Eval(s) Eval(s')。
chap5_para800,1,,● “与wumpus相邻的方格有臭味”。
chap5_para801,1,,对象：wumpus、方格。
chap5_para801,2,,属性：有臭味。
chap5_para801,3,,关系：相邻。
chap5_para802,1,,● “邪恶的约翰国王在1200年统治英格兰”。
chap5_para803,1,,对象：约翰、英格兰、1200年。
chap5_para803,2,,关系：统治。
chap5_para803,3,,属性：邪恶的、国王。
chap5_para804,1,,一阶逻辑语言是围绕对象和关系构建的，我们于下一节定义其语法和语义。
chap5_para804,2,,它对于数学、哲学和人工智能乃至人类生活的很多方面都非常重要，因为这些领域要处理的正是对象和对象之间的关系。
chap5_para804,3,,一阶逻辑也可以表示关于全域中的一些和全部对象的事实。
chap5_para804,4,,这就使我们可以表示各种法则和规则，例如陈述“与wumpus相邻的方格很臭”。
chap5_para805,1,,命题逻辑和一阶逻辑的主要区别在于其各自的本体论约定（ontological commitment），即它对真实世界性质的假设。
chap5_para805,2,,数学上来说，这一约定是通过语句真值确定的形式化模型的性质来表示的。
chap5_para805,3,,例如，命题逻辑假设世界中存在要么成立要么不成立的事实。
chap5_para805,4,,每个事实都可以为真或假这两种状态中的一个，而每个模型为每个命题符号进行true或false的赋值（见7.4.2节）。
chap5_para805,5,,一阶逻辑则进行了更多假设，它假设世界是由具有关系的对象组成的，这些关系要么成立要么不成立（见图8-1）。
chap5_para805,6,,因此，一阶逻辑的形式化模型也就比命题逻辑更为复杂。
chap5_para806,1,,图8-1　形式化语言及其本体论约定和认识论约定
chap5_para807,1,,这种本体论约定是逻辑（包括命题逻辑和一阶逻辑）的强项，因为它允许我们从真实的陈述出发来推断其他真实的陈述。
chap5_para807,2,,这对于每条命题都有清晰边界的领域非常有效，例如数学或wumpus世界。
chap5_para807,3,,在wumpus世界中，一个方格要么有无底洞要么没有无底洞，那种有个像无底洞一样的大坑的方格是不存在的。
chap5_para807,4,,但在真实世界中，许多命题的边界是模糊的：维也纳是大城市吗？
chap5_para807,5,,那家餐厅的菜好吃吗？
chap5_para807,6,,这个人高吗？
chap5_para807,7,,这都取决于被你提问的人，而他们的回答可能是“还行吧”。
chap5_para808,1,,对此，一种解决办法是细化表示：如果将城市分为“大”和“不大”的标准太粗略，使我们上述的应用中存在太多疑问，那么我们可以增加分类的个数，或使用Population这样的函数符号。
chap5_para808,2,,另一种解决方案来源于模糊逻辑（fuzzy logic），它使用的本体论约定使得命题具有在0到1之间的真实度（degree of truth）。
chap5_para808,3,,例如，语句“维也纳是大城市”在模糊逻辑中可能真实度是0.8，而“巴黎是一个大城市”则可能真实度是0.9。
chap5_para808,4,,这更符合我们对真实世界的直观理解，但也更难进行推断：不同于确定A∧B真值的唯一规则，模糊逻辑在不同领域需要不同的规则。
chap5_para808,5,,还有一个解决办法（将在24.1节阐述）是在多维空间中为每个概念分配一个点，并测量概念“大城市”与概念“巴黎”或“维也纳”的距离。
chap5_para809,1,,不少特定用途的逻辑还进一步地进行了本体论约定，例如时态逻辑（temporal logic）假设事实在特定的时间成立，而这些时间（可能是时间点或时间区间）是有序的。
chap5_para809,2,,这样，特定用途的逻辑就使某种对象（以及关于它们的公理）在这种逻辑内更“高级”，而非只是在知识库中对其进行定义。
chap5_para809,3,,高阶逻辑（higher-order logic）将一阶逻辑中的关系和函数视作其自身的对象。
chap5_para809,4,,这使我们能对所有关系进行断言，例如，我们可能想定义具有传递性的关系意味着什么。
chap5_para809,5,,不同于大多数特定用途的逻辑，高阶逻辑的表达能力全面高于一阶逻辑，因为高阶逻辑的一些语句无法用有限数量的一阶逻辑语句来表示。
chap5_para81,1,5.,将特征的值相加似乎是合理的，但实际上它涉及一个很强的假设：每个特征的贡献独立于其他特征的值。
chap5_para81,2,2.,因此，目前的国际象棋和其他游戏程序也会使用特征的非线性组合。
chap5_para81,3,6Sudoku,例如，一对象的价值可能比单个象价值的两倍还要大，并且在残局时，象比之前价值更大，即当移动数这一特征很大或剩余棋子数这一特征很小时。
chap5_para810,1,,一种逻辑的特性还包括其认识论约定（epistemological commitment），即这种逻辑允许每个事实所具有的可能知识状态。
chap5_para810,2,,在命题逻辑和一阶逻辑中，一条语句表示一个事实，智能体只能选择相信其为真、相信其为假或没有意见。
chap5_para810,3,,因此，这两种逻辑对于任何语句都具有3种可能的知识状态。
chap5_para811,1,,而使用概率论（probability theory）的系统则可以有信任度或主观可能性，其值可以是从0（完全不信任）到1（完全信任）的任何值。
chap5_para811,2,,千万不要将概率论中的信任度与模糊逻辑中的真实度搞混了。
chap5_para811,3,,实际上，一些模糊系统允许对真实度具有不确定性（信任度）。
chap5_para811,4,,"例如，一个概率的wumpus世界智能体可能相信wumpus在[1, 3]中的概率是0.75，而在[2, 3]中的概率是0.25（尽管wumpus肯定在某一个特定的方格中）。"
chap5_para812,1,,8.2　一阶逻辑的语法和语义
chap5_para813,1,,本节我们先更为确切地阐述一阶逻辑的可能世界是如何反映其关于对象和关系的本体论约定的。
chap5_para813,2,,随后我们介绍这种语言的几个组成部分，并解释其语义。
chap5_para813,3,,本节的主旨是弄清这种语言如何进行简洁的表示，以及其语义如何形成完备的推理过程。
chap5_para814,1,,8.2.1　一阶逻辑模型
chap5_para815,1,,第7章讲过，逻辑语言的模型是组成目前正在考虑的可能世界的形式化结构。
chap5_para815,2,,每个模型都将逻辑语句的词汇表连接到可能世界的元素，使得任意语句的真值可以被确定。
chap5_para815,3,,因此，命题逻辑的模型将命题符号连接到预定义的真值表。
chap5_para816,1,,一阶逻辑模型要有趣得多。
chap5_para816,2,,首先，它们具有对象！
chap5_para816,3,,模型的域（domain）是它包含的对象集或域元素的集合。
chap5_para816,4,,域应当是非空的——每个可能世界至少要含有一个对象。
chap5_para816,5,,（见习题8.EMTP了解关于空世界的讨论。
chap5_para816,6,,）数学上来说，对象是什么无所谓——有意义的只是每个特定模型中有多少对象。
chap5_para816,7,,但出于教学的考虑，我们会使用一个具体的例子。
chap5_para816,8,,图8-2展示了一个具有5个对象的模型，这5个对象分别是英格兰1189年至1199年的国王狮心理查、1199年至1215年统治英格兰的邪恶的约翰国王（理查的弟弟）、理查的左腿、约翰的左腿和王冠。
chap5_para817,1,,图8-2　含有5个对象、2个二元关系（兄弟和在头顶）、3个一元关系（人、国王和王冠）和1个一元函数（左腿）的模型
chap5_para818,1,,这个模型中的对象可能有多方面的关系。
chap5_para818,2,,图中，理查和约翰是兄弟。
chap5_para818,3,,从形式上来看，关系就是相关对象的元组集。
chap5_para818,4,,（一个元组是以固定顺序排列的一系列对象，使用尖括号将对象括起来表示。
chap5_para818,5,,）这样，模型中的兄弟关系就是集合
chap5_para82,1,"The popular Sudoku puzzle has introduced millions of people to constraint satisfaction problems, although they may not realize it. A Sudoku board consists of 81 squares, some of which are initially filled with digits from 1 to 9. The puzzle is to fill in all the remaining squares such that no digit appears twice in any row, column, or 3 × 3 box (see Figure 5.4). A row, column, or box is called a unit.",如何得到特征和权重？
chap5_para82,2,,它们不属于国际象棋规则，而是来自人类下棋的经验。
chap5_para82,3,,在没有这种经验的游戏中，评价函数的权重可以通过第22章的机器学习技术来估计。
chap5_para82,4,,将这些技术应用到国际象棋中，结果表明一个象确实相当于大约3个兵，而且似乎几个世纪的人类经验都可以在短短几小时的机器学习中被复制。
chap5_para820,1,,（此处我们已经命名了对象，但如果你愿意的话，你可以用图片代替对象名称。
chap5_para820,2,,"）王冠在约翰国王的头顶，因此关系“在头顶”仅含有一个元组，〈王冠, 约翰国王〉。"
chap5_para820,3,,“兄弟”关系和“在头顶”关系都是二元关系，也就是说，它们关联了一对对象。
chap5_para820,4,,该模型还含有一元关系，或称为属性：“人”属性对于理查和约翰都为真；“国王”属性仅对于约翰为真（假设此时理查已经去世）；而“王冠”属性则仅对王冠为真。
chap5_para821,1,,最好将某些类型的关系视为函数，因为这样的话给定一个对象，它必然仅关联到一个对象。
chap5_para821,2,,例如，每个人都有一条左腿，因此模型含有一个一元“左腿”函数，即从一个单元素元组到一个对象的映射，它包括如下的映射：
chap5_para823,1,,严格来说，一阶逻辑中的模型需要全函数（total function），也就是对于所有输入的元组都要有值。
chap5_para823,2,,这样，王冠必须要有一条左腿，每条左腿也一样。
chap5_para823,3,,对于这种尴尬的问题有一个技术解决方案，它需要增加一个“不可见”的对象来作为一切没有左腿的东西的左腿，包括它自己。
chap5_para823,4,,幸运的是，只要没人对没有左腿的东西的左腿进行断言，这些技术细节就不重要。
chap5_para824,1,,目前为止，我们已经描述了组成一阶逻辑模型所需的元素。
chap5_para824,2,,模型的另一个重要部分是这些元素与逻辑语句的词汇表的联系，我们接下来进行介绍。
chap5_para825,1,,8.2.2　符号与解释
chap5_para826,1,,我们现在来了解一阶逻辑的语法。
chap5_para826,2,,不耐烦的读者可以通过图8-3获得对形式化文法的完整描述。
chap5_para827,1,,图8-3　包含等价关系的一阶逻辑语法，使用巴克斯-诺尔范式（如果你对此不熟悉，见附录B.1）。
chap5_para827,2,,运算符优先级从高到低定义。
chap5_para827,3,,量词的优先级为一个量词的优先级高于其右边的一切
chap5_para828,1,,一阶逻辑的基本语法元素是代表对象、关系和函数的符号。
chap5_para828,2,,因此，符号分为3种：代表对象的常量符号（constant symbol）、代表关系的谓词符号（predicate symbol）和代表函数的函数符号（function symbol）。
chap5_para828,3,,我们采用的习惯是用大写字母开头来书写这些符号。
chap5_para828,4,,例如，我们可以使用常量符号Richard（理查）和John（约翰），谓词符号Brother（是兄弟）、OnHead（在头顶）、Person（是人）、King（是国王）和Crown（是王冠），函数符号LeftLeg（……的左腿）。
chap5_para828,5,,与命题符号一样，如何命名完全取决于使用者的意愿。
chap5_para828,6,,每个谓词和函数符号都有一个决定参数数量的元数（arity）。
chap5_para829,1,,每个模型必须提供所需的信息来确定任意给定语句为真还是为假。
chap5_para829,2,,因此，除了它的对象、关系和函数，每个模型还要包含一套确切指明常量、谓词和函数符号指代的是哪个对象、关系和函数的解释（interpretation）。
chap5_para829,3,,在我们的例子中，下面是一种可能的解释，也就是逻辑学家所说的预期解释（intended interpretation）。
chap5_para83,1,The Sudoku puzzles that appear in newspapers and puzzle books have the property that there is exactly one solution.,图5-8　两个国际象棋局面，只有右下角车的位置不同。
chap5_para83,2,"Although some can be tricky to solve by hand, taking tens of minutes, a CSP solver can handle thousands of puzzles per second.",在（a）中，黑方有一个马两个兵的优势，这足以取胜。
chap5_para83,3,,在（b）中，白方将吃掉对方的皇后，这几乎是必胜的优势
chap5_para830,1,,● Richard指狮心理查，John指邪恶的约翰国王。
chap5_para831,1,,● Brother指兄弟关系，也就是式（8-1）给出的对象元组集，Onhead是连接王冠和约翰国王的关系，Person、King和Crown是识别人、国王和王冠的一元关系。
chap5_para832,1,,● LeftLeg指式（8-2）定义的“左腿”函数。
chap5_para833,1,,当然，模型还有很多种可能的解释。
chap5_para833,2,,例如，一种解释将Richard映射到王冠而将John映射到约翰国王的左腿。
chap5_para833,3,,模型中有5个对象，因此仅对常量符号Richard和John就有25种可能的解释。
chap5_para833,4,,注意，并非所有对象都有名称。
chap5_para833,5,,例如，预期解释并没有为王冠和腿命名。
chap5_para833,6,,一个对象也可以有多个名称，在一种可能的解释中Richard和John都指代王冠。
chap5_para833,7,,[3]如果你觉得这令人困惑，记住，在命题逻辑中，一个Cloudy（阴天）和Sunny（晴天）都为真的模型是完全可以存在的；排除与我们的知识不符的模型是知识库要做的事情。
chap5_para835,1,,[3]　在随后的8.2.8节，我们会考察一种语义，其中每个对象只能有一个名称。
chap5_para836,1,,总之，一阶逻辑中的模型包含一个对象集和一种解释，这种解释将常量符号映射到对象、将函数符号映射到关于这些对象的函数，将谓词符号映射到关系。
chap5_para836,2,,与命题逻辑一样，蕴含、有效性等都是用所有可能模型来定义的。
chap5_para836,3,,要大致了解可能模型集是什么样子的，见图8-4。
chap5_para836,4,,图中显示，模型的区别在于它们包含的对象数量不同（从一到无穷多个），以及常量符号映射到对象的方式不同。
chap5_para837,1,,图8-4　含有两个常量符号的语言中全部模型的集合的部分成员、R和J以及一个二元关系符号。
chap5_para837,2,,每种常量符号的解释用灰色箭头标明。
chap5_para837,3,,每个模型中，相关的对象用箭头连接
chap5_para838,1,,由于一阶逻辑模型数量没有上限，我们无法通过枚举所有模型的方式（像我们对命题逻辑做的那样）来检验蕴含。
chap5_para838,2,,即便对象的数量是有限的，其组合也会是巨量的。
chap5_para838,3,,（见习题8.MCNT。
chap5_para838,4,,）对图8-4中的例子来说，使用不超过6个对象就会产生137 506 194 466个模型。
chap5_para84,1,"A Sudoku puzzle can be considered a CSP with 81 variables, one for each square.",5.3.2　截断搜索
chap5_para84,2,"We use the variable names A1 through A9 for the top row (left to right), down to 11 through 19 for the bottom row.",
chap5_para84,3,"The empty squares have the domain {1,2,3,4,5,6,7,8,9} and the pre-filled squares have a domain consisting of a single value.",
chap5_para84,4,"In addition, there are 27 different Alldiff constraints, one for each unit (row, column, and box of 9 squares):",
chap5_para840,1,,项（term）是指代对象的逻辑表达式。
chap5_para840,2,,常量符号是项，但对每个对象都使用不同的符号命名往往不太方便。
chap5_para840,3,,在语言中我们使用表达“约翰国王的左腿”而不是给他的腿起个名称来称呼。
chap5_para840,4,,这就是函数符号存在的意义：我们使用LeftLeg(John)，而不是使用常量符号来命名这条腿。
chap5_para840,5,,[4]
chap5_para842,1,,[4]　表达式（-expression，lambda表达式）提供了一种很有用的记法，使得新的函数符号可以“即时”构建。
chap5_para842,2,,例如，对参数进行平方操作的函数可以写作，并可以像其他函数符号那样直接用于参数。
chap5_para842,3,,一个表达式也可以被定义为谓语符号并用作谓词符号。
chap5_para842,4,,这与Lisp和Python中的lambda操作符的作用完全一致。
chap5_para842,5,,注意，像这样使用并不能增加一阶逻辑的形式化表达能力，因为所有含有表达式的语句都能通过“插入”其参数的方式重写，生成一个等价的语句。
chap5_para843,1,,通常情况下，复合项的组成是一个函数符号后跟随一个括号，括号中是一系列项，作为该函数符号的参数。
chap5_para843,2,,需要注意的是，复合项只是复杂一些的名称，而非“返回一个值”的“子程序调用”。
chap5_para843,3,,并不存在以一个人作为输入，返回一条腿的LeftLeg子程序。
chap5_para843,4,,我们甚至可以在不定义LeftLeg的情况下就进行关于左腿的推理（例如，陈述一条一般规则“每个人都有左腿”，并进而推导出约翰必然有左腿）。
chap5_para843,5,,这是无法在编程语言中用子程序实现的。
chap5_para844,1,,项的形式化语义非常直白。
chap5_para844,2,,"考虑项f(t1, …, tn)。"
chap5_para844,3,,"函数符号f指代模型中的某个函数（不妨称为F），参数项指代域中的对象（称为d1, …, dn)），整个项就指代将函数F应用于d1, …, dn产生的对象，即函数的值。"
chap5_para844,4,,例如，假设LeftLeg函数符号代表式（8-2）所示的函数，John代表约翰国王，则LeftLeg(John)代表约翰国王的左腿。
chap5_para844,5,,这样，解释就确定了每个项的被指代物。
chap5_para845,1,,8.2.4　原子语句
chap5_para846,1,,我们现在已经有了指代对象的项以及指代关系的谓词符号，将它们结合起来可以构成陈述事实的原子语句。
chap5_para846,2,,原子语句（或简称原子）是由谓词符号以及其后可能存在的括号中的一系列项组成的，例如：
chap5_para847,1,,在先前给定的预期解释下，这条语句表明狮心理查是约翰国王的兄弟。
chap5_para847,2,,[5]原子语句的参数可以是复合项，如
chap5_para849,1,,"[5]　我们一般遵循P(x, y)读作“x是y的P”这样的参数排序习惯。"
chap5_para85,1,"Let us see how far arc consistency can take us. Assume that the Alldiff constraints have been expanded into binary constraints (such as A1 ≠ A2) so that we can apply the AC-3 algorithm directly. Consider variable E6 from Figure 5.4(a)—the empty square between the 2 and the 8 in the middle box. From the constraints in the box, we can remove 1, 2, 7, and 8 from E6’s domain. From the constraints in its column, we can eliminate 5, 6, 2, 8, 9, and 3 (although 2 and 8 were already removed). That leaves E6 with a domain of {4}; in other words, we know the answer for E6. Now consider variable 16—the square in the bottom middle box surrounded by 1, 3, and 3. Applying arc consistency in its column, we eliminate 5, 6, 2, 4 (since we now know E6 must be 4), 8, 9, and 3. We eliminate 1 by arc consistency with I5, and we are left with only the value 7 in the domain of I6. Now there are 8 known values in column 6, so arc consistency can infer that A6 must be 1. Inference continues along these lines, and eventually, AC-3 can solve the entire puzzle—all the variables have their domains reduced to a single value, as shown in Figure 5.4(b).",下一步是修改Alpha-Beta-Search，让它在合适的时候调用启发式Eval函数截断搜索。
chap5_para85,2,,我们把图5-7中提到Is-Terminal的两行代码替换为下面这行代码：
chap5_para850,1,,表明狮心理查的父亲娶了约翰国王的母亲（再次强调，在合适的解释下）。
chap5_para850,2,,[6]
chap5_para852,1,,[6]　这个本体论认为每个人只有一位父亲和一位母亲。
chap5_para852,2,,更为复杂的本体论可以识别出生物学母亲、生母、养母等。
chap5_para853,1,,如果谓词符号所指代的关系在参数所指代的对象之间成立，则在给定模型中原子句为真。
chap5_para854,1,,8.2.5　复合语句
chap5_para855,1,,我们可以使用逻辑联结词构建更为复杂的语句，这与命题演算的语法和语义一样。
chap5_para855,2,,下面是4条在我们的预期解释下在图8-2的模型中为真的语句：
chap5_para857,1,,当我们有了支持对象的逻辑后，就很自然地想要表达很多对象的整体属性而非根据名称逐个列举对象。
chap5_para857,2,,量词能使我们达到这一目的。
chap5_para857,3,,一阶逻辑含有两个标准量词——全称量词和存在量词。
chap5_para859,1,,回想我们在第7章用命题逻辑表示一般规则时面临的困难。
chap5_para859,2,,像“与wumpus相邻的方格有臭味”和“所有国王都是人”这样的规则对一阶逻辑来说是最基本的。
chap5_para859,3,,我们将在8.3节中解决第一条规则。
chap5_para859,4,,而第二条规则“所有国王都是人”在一阶逻辑中写作
chap5_para86,1,"Description Up and down triangles represent MAX and MIN nodes, respectively.",我们还必须记录一些信息，这样在每一次递归调用时可以逐渐增加当前的depth。
chap5_para86,2,"At the top level, a max node is present and the level is labeled Player.","控制搜索量最直接的方法是设置一个固定的深度限制，这样的话，对所有大于固定深度d的depth（以及所有终止状态），Is-Cutoff(state, depth)都返回true。"
chap5_para86,3,The next level is labeled Opponent and a MIN node is labeled m.,深度d的选择取决于分配时间内所选择的移动。
chap5_para86,4,The nodes in the player and opponent levels are connected.,更稳健的方法是使用迭代加深（见第3章）。
chap5_para86,5,"After many levels, the next level is represented by another level labeled Player and a node present is a MAX node.",当时间耗尽时，程序将返回最深的已完成搜索所选择的移动。
chap5_para86,6,This node is connected to the MAX node of the player level at the top by a dashed line.,如果在每一轮迭代加深中，我们都维护换位表中的条目，那么作为奖励，后续轮次的速度将加快，我们可以使用评估值改进移动顺序。
chap5_para86,7,The last level is labeled Opponent and a MIN node is labeled n.,
chap5_para86,8,The nodes in the last player and opponent levels are connected.,
chap5_para860,1,,全称量词∀通常读作“对所有……”。
chap5_para860,2,,［记住，上下颠倒的A表示“all”（所有）。
chap5_para860,3,,］因此，这条语句表示“对所有x，如果x是国王，则x是人”。
chap5_para860,4,,符号x被称为变量。
chap5_para860,5,,习惯上，变量用小写字母表示。
chap5_para860,6,,一个变量本身就是一个项，因此也可以作为函数的参数，例如LeftLeg(x)。
chap5_para860,7,,一个没有变量的项被称为基本项（ground term）。
chap5_para861,1,,直观上来说，语句∀x P，其中P为任意逻辑语句，表明P对每个对象x都为真。
chap5_para861,2,,更确切地说，如果P在根据一个模型的给定解释构建的所有可能扩展解释（extended interpretation）下为真，则∀x P在该模型中为真，其中每个扩展解释给出了x指代的域元素。
chap5_para862,1,,这听起来很复杂，但它实际上只是陈述全称量词的直观含义的一种严谨的方式。
chap5_para862,2,,考虑图8-2所示的模型及其相应的预期解释。
chap5_para862,3,,我们可以用5种方式扩展这个解释：
chap5_para868,1,,全称量化语句在原模型中为真的前提是语句在这5种扩展解释下都为真。
chap5_para868,2,,也就是说，全称量化语句等价于如下5个断言：
chap5_para869,1,,狮心理查是一位国王⇒ 狮心理查是一个人
chap5_para87,1,Figure 5.,由于评价函数只是一种近似，这些简单方法可能导致误差。
chap5_para87,2,4(a) A Sudoku puzzle and (b) its solution.,重新考虑象棋中基于子力优势的简单评价函数。
chap5_para87,3,,假设程序搜索到达了深度限制，例如到达图5-8b中的局面，即黑方多了一个马、两个兵。
chap5_para87,4,,程序会将其报告为该状态的启发式值，从而认为该状态很可能导致黑方获胜。
chap5_para87,5,,但其实白方下一步就可以不留退路地吃掉黑方的皇后。
chap5_para87,6,,因此，这个局面实际上对白方有利，但这只有通过向前看才能知道。
chap5_para870,1,,约翰国王是一位国王 ⇒ 约翰国王是一个人
chap5_para871,1,,理查的左腿是一位国王 ⇒ 理查的左腿是一个人
chap5_para872,1,,约翰的左腿是一位国王 ⇒ 约翰的左腿是一个人
chap5_para873,1,,王冠是一位国王 ⇒ 王冠是一个人
chap5_para874,1,,让我们仔细研究这些断言。
chap5_para874,2,,在我们的模型中，由于约翰国王是唯一的国王，因而第二条语句断言他是人，正如我们所料。
chap5_para874,3,,那么其他4条语句呢？
chap5_para874,4,,那些声明了腿和王冠的语句呢？
chap5_para874,5,,这也是“所有国王都是人”含义的一部分吗？
chap5_para874,6,,实际上，其他4条断言在模型中都为真，但并未对腿、王冠乃至理查作为人的资格进行任何声明。
chap5_para874,7,,这是因为这些对象都不是国王。
chap5_para874,8,,回顾⇒的真值表（图7-8），我们可以看到当前提为假时蕴涵式为真——无论其结论的真值是什么。
chap5_para874,9,,因此，通过断言全称量化语句——它等价于断言每一条蕴涵式，我们最终仅对前提为真的对象断言规则的结论，而对前提为假的对象什么也不说。
chap5_para874,10,,因此，⇒的真值表定义被证明非常适合用来编写含有全称量词的一般规则。
chap5_para875,1,,即使是勤奋地将本节读了好几遍的读者也可能会犯的常见错误是使用合取式而非蕴涵式与全称量词搭配。
chap5_para875,2,,语句
chap5_para877,1,,狮心理查是国王∧狮心理查是人
chap5_para878,1,,约翰国王是国王∧约翰国王是人
chap5_para879,1,,理查的左腿是国王∧理查的左腿是人
chap5_para88,1,"Of course, Sudoku would soon lose its appeal if every puzzle could be solved by a mechanical application of AC-3, and indeed AC-3 works only for the easiest Sudoku puzzles.",评价函数只能应用于静态（quiescent）局面，也就是说，在这些局面中不存在会使评估值大幅度摇摆变化的待定移动（例如吃掉皇后）。
chap5_para88,2,"Slightly harder ones can be solved by PC-2, but at a greater computational cost: there are 255,960 different path constraints to consider in a Sudoku puzzle.",对于非静态局面，Is-Cutoff将返回false，并继续搜索直到到达静态局面。
chap5_para88,3,"To solve the hardest puzzles and to make efficient progress, we will have to be more clever.",这种额外的静态搜索（quiescence search）有时会被进一步限制为只考虑特定类型的移动（例如吃子），它能快速消除当前局面的不确定性。
chap5_para881,1,,显然，这并不是我们想要表达的。
chap5_para883,1,,全称量词对所有对象进行陈述。
chap5_para883,2,,反之，我们也可以对某些对象进行陈述而不需指明其名称。
chap5_para883,3,,使用存在量词就可以实现这一点。
chap5_para883,4,,例如，要说约翰国王的头顶有王冠，我们写作
chap5_para884,1,,∃x读作“存在x使得……”或“对于一些x……”。
chap5_para885,1,,直观上来说，语句∃x P说的是P至少对于一个对象x为真。
chap5_para885,2,,更准确地说，如果P在至少一个将x分配给域元素的扩展解释下为真，则∃x P在给定模型中为真。
chap5_para885,3,,也就是，下列语句中至少有一个为真：
chap5_para886,1,,狮心理查是王冠 ∧ 狮心理查在约翰的头顶
chap5_para887,1,,约翰国王是王冠 ∧ 约翰国王在约翰的头顶
chap5_para888,1,,理查的左腿是王冠 ∧ 理查的左腿在约翰的头顶
chap5_para889,1,,约翰的左腿是王冠 ∧ 约翰的左腿在约翰的头顶
chap5_para89,1,"Indeed, the appeal of Sudoku puzzles for the human solver is the need to be resourceful in applying more complex inference strategies. Aficionados give them colorful names, such as “naked triples.” That strategy works as follows: in any unit (row, column or box), find three squares that each have a domain that contains the same three numbers or a subset of those numbers. For example, the three domains might be {1,8}, {3,8}, and {1,3,8}. From that we don’t know which square contains 1, 3, or 8, but we do know that the three numbers must be distributed among the three squares. Therefore we can remove 1, 3, and 8 from the domains of every other square in the unit.",视野效应（horizon effect）则更难消除。
chap5_para89,2,,它是指程序面临一个将给我方造成严重损失而且基本无法避免的对方移动，但可以使用拖延战术暂时避开。
chap5_para89,3,,考虑图5-9中的国际象棋局面。
chap5_para89,4,,很明显，黑象已经无路可逃。
chap5_para89,5,,例如，白车可以通过依次移动到h1、a1、a2吃掉黑象，在第6步完成吃子。
chap5_para890,1,,王冠是王冠 ∧ 王冠在约翰的头顶
chap5_para891,1,,第五个断言在模型中为真，因此先前的存在量化语句在模型中为真。
chap5_para891,2,,注意，根据我们的定义，这条语句在约翰国王戴了两顶王冠的模型中也为真。
chap5_para891,3,,这与原始语句“约翰国王的头顶有王冠”完全不矛盾。
chap5_para891,4,,[7]
chap5_para893,1,,[7]　存在量词有一个变种，通常写作∃1或∃!，意思是“恰好存在一个”。
chap5_para893,2,,相同的含义可以用等词陈述表示。
chap5_para894,1,,正如⇒是能自然地与∀合用的联结词一样，∧是与∃自然合用的联结词。
chap5_para894,2,,使用∧作为∀的主要联结词会导致前面示例中的过强陈述，而使用⇒搭配∃则会导致过弱的陈述。
chap5_para894,3,,考虑如下语句：
chap5_para895,1,,表面来看，这似乎是对我们的语句的一种合理的表示。
chap5_para895,2,,使用语义规则，我们发现该语句表达的是如下断言中至少一条为真：
chap5_para896,1,,狮心理查是一顶王冠 ⇒ 狮心理查在约翰的头顶
chap5_para897,1,,约翰国王是一顶王冠 ⇒ 约翰国王在约翰的头顶
chap5_para898,1,,理查的左腿是一顶王冠 ⇒ 理查的左腿在约翰的头顶
chap5_para9,1,"D is a set of domains, {D1,.",对于每一个我们选择在那里停止搜索的状态，我们都需要知道谁是获胜者。
chap5_para9,2,.,要回答这个问题，有一个选择：可以基于状态特征应用启发式评价函数来估计谁是获胜者（5.3节），或者可以从该状态开始快速模拟至博弈结束，再取多次模拟结果的平均值（5.4节）。
chap5_para9,3,.,
chap5_para9,4,", Dn}, one for each variable.",
chap5_para90,1,"It is interesting to note how far we can go without saying much that is specific to Sudoku. We do of course have to say that there are 81 variables, that their domains are the digits 1 to 9, and that there are 27 Alldiff constraints. But beyond that, all the strategies—arc consistency, path consistency, and so on—apply generally to all CSPs, not just to Sudoku problems. Even naked triples is really a strategy for enforcing consistency of Alldiff constraints and is not specific to Sudoku per se. This is the power of the CSP formalism: for each new problem area, we only need to define the problem in terms of constraints; then the general constraintsolving mechanisms can take over.",但黑方确实可以采取一系列移动，将象被吃掉这一结果推向“视野”以外。
chap5_para90,2,,假设黑方搜索深度为8层。
chap5_para90,3,,黑方的大多数出招都会导致象最终被吃掉，因此被标记为“坏招”。
chap5_para90,4,,但黑棋也会考虑这样的移动序列，即先用兵来阻挡王，引诱王去吃兵。
chap5_para90,5,,然后黑方可以同样地处理第二个兵。
chap5_para90,6,,上述过程占用了太多步，在剩余的搜索步数内，象不会被吃掉。
chap5_para90,7,,黑方自认为这一策略用两个兵保住了象，但实际上它所做的只是白白浪费了兵，象被吃掉是不可避免的，只是被推到了黑方能搜索到的视野之外。
chap5_para900,1,,蕴涵式为真的条件是其前提和结论都为真，或其前提为假。
chap5_para900,2,,因此，如果狮心理查不是一顶王冠，则第一条断言为真，存在量化语句被满足。
chap5_para900,3,,因此，只要任一对象不能满足前提，存在量化的蕴涵式语句就为真。
chap5_para900,4,,因而这种语句其实基本上什么都没说。
chap5_para902,1,,我们经常希望用多个量词表示更复杂的语句。
chap5_para902,2,,最简单的情形是量词种类相同的情形。
chap5_para902,3,,例如，“兄弟是同胞”可以写成
chap5_para903,1,,连续的同类量词可以写成有多个变量的单个量词。
chap5_para903,2,,例如，要表示同胞是对称关系，可以写成
chap5_para904,1,,其他情况下，我们得混用量词。
chap5_para904,2,,“每个人都喜爱一些人”意思是，对所有人都存在其喜爱的人：
chap5_para905,1,,相反，要说“有人被所有人喜爱”，就写成
chap5_para906,1,,因此，量词的顺序非常重要。
chap5_para906,2,,添加括号会使语句看起来更清晰。
chap5_para906,3,,表明每个人都有某种属性，也就是他们喜爱一些人的属性。
chap5_para906,4,,反之，则表示世界上的一些人具有某种属性，即每个人都喜爱他们的属性。
chap5_para907,1,,当两个量词与相同的变量名合用时会引起一些混淆。
chap5_para907,2,,考虑语句
chap5_para908,1,,"此处Brother(Richard, x)中的x是被存在量化的。"
chap5_para908,2,,规则是，变量属于提及它的最内层量词，随后便不再受任何其他量词约束。
chap5_para908,3,,"另一种考虑方式是，∃x Brother(Richard, x)是关于理查（有一个兄弟）的语句，不是关于x的语句；因此在外层放一个∀x并无效果。"
chap5_para908,4,,"该语句一个等价的写法是∃z Brother (Richard, z)。"
chap5_para908,5,,因为这可能是导致混淆的源头，所以我们会始终在嵌套量词中使用不同的变量名。
chap5_para91,1,5.,缓解视野效应的一种策略是允许单步延伸（singular extension），该策略是说，即使搜索本应在此状态截断，但是，如果在给定局面中有比其他所有移动都“明显更好”的一种移动，我们就允许算法继续沿着这个移动延伸搜索。
chap5_para91,2,3Backtracking Search for CSPs,在我们的例子中，搜索将发现白车的3次移动——h2到h1，h1到a1，从a1吃掉a2处的象——依次都是明显更好的移动，因此，即使兵的某个移动序列将搜索推到视野之外，这些明显更好的移动将有机会被延伸搜索。
chap5_para91,3,,这会使树变得更深，但由于单步延伸通常很少，这一策略并不会增加很多节点，在实践中，它已被证明是有效的。
chap5_para910,1,,∀与∃两个量词实际上通过否定词紧密相关。
chap5_para910,2,,断言每个人都讨厌欧洲萝卜与断言不存在喜欢欧洲萝卜的人是等价的，反之亦然：
chap5_para912,1,,我们可以更进一步——“每个人都喜欢冰激凌”意思是没有人不喜欢冰激凌：
chap5_para914,1,,由于∀实际上是对全体对象的合取而∃则是析取，因此它们遵循德摩根律就不足为奇了。
chap5_para914,2,,量化语句和非量化语句的德摩根律如下：
chap5_para915,1,,因此，我们实际上并不同时需要∀和∃，正如我们不同时需要∧和∨一样。
chap5_para915,2,,不过，可读性比简洁性更重要，因此我们同时保留这两种量词。
chap5_para917,1,,除了使用前述的谓词和项，一阶逻辑还有一种构成原子语句的方式。
chap5_para917,2,,我们可以使用等词符号（equality symbol）来表示两个项指代相同的对象。
chap5_para917,3,,例如：
chap5_para918,1,,Father(John) = Henry
chap5_para919,1,,表示Father(John)指代的对象与Henry指代的对象是相同的。
chap5_para919,2,,由于解释会固定所有项的被指代物，确定等词语句的真值就只需要观察两项的被指代物是否为相同的对象即可。
chap5_para92,1,Sometimes we can finish the constraint propagation process and still have variables with multiple possible values.,图5-9　视野效应。
chap5_para92,2,In that case we have to search for a solution.,黑方移动后，黑象注定难逃厄运。
chap5_para92,3,In this section we cover backtracking search algorithms that work on partial assignments; in the next section we look at local search algorithms over complete assignments.,但是黑方可以用兵来阻挡白方的王，引诱王去吃掉兵。
chap5_para92,4,,这会将不可避免的象的损失推到视野之外，因此，搜索算法将牺牲兵的这一步看作“好招”
chap5_para920,1,,等词符号可以用于陈述关于给定函数的事实，正如我们对Father符号所做的那样。
chap5_para920,2,,它也可以与否定合用，表示两项不是相同的对象。
chap5_para920,3,,要表示理查至少有两个兄弟，我们可以写成
chap5_para922,1,,就不能表示我们所期望的含义。
chap5_para922,2,,具体来说，这条语句在图8-2的模型中也为真，尽管其中理查只有一个兄弟。
chap5_para922,3,,要弄清楚这一点，考虑x和y都被指定到约翰国王的扩展解释。
chap5_para922,4,,附加的排除了这种模型。
chap5_para922,5,,记法可以用作的简写。
chap5_para923,1,,8.2.8　数据库语义
chap5_para924,1,,继续8.2.7节中的例子，假设我们相信理查有2个兄弟——约翰和杰弗里[8]，我们可以写
chap5_para926,1,,[8]　实际上理查有4个兄弟，另外两个是威廉和亨利。
chap5_para928,1,,但这并不能完全反映我们要表示的状态。
chap5_para928,2,,首先，这条断言在理查只有一个兄弟的模型中也为真——我们需要加上。
chap5_para928,3,,其次，这条语句没有剔除理查除了约翰和杰弗里还有很多其他兄弟的模型。
chap5_para928,4,,因此，对“理查的兄弟是约翰和杰弗里”的正确翻译如下：
chap5_para929,1,,这条逻辑语句似乎比对应的自然语言表述烦琐很多。
chap5_para929,2,,如果不能恰当地翻译自然语言，我们的逻辑推理系统就会犯错。
chap5_para929,3,,我们能否构思一种语义，使逻辑语句更加直白呢？
chap5_para93,1,"Consider how a standard depth-limited search (from Chapter 3) could solve CSPs. A state would be a partial assignment, and an action would extend the assignment, adding, say, NSW = red or SA = blue for the Australia map-coloring problem. For a CSP with n variables of domain size d we would end up with a search tree where all the complete assignments (and thus all the solutions) are leaf nodes at depth n. But notice that the branching factor at the top level would be nd because any of d values can be assigned to any of n variables. At the next level, the branching factor is (n – 1)d, and so on for n levels. So the tree has n! · dn leaves, even though there are only dn possible complete assignments!",5.3.3　前向剪枝
chap5_para930,1,,一种在数据库系统中非常流行的做法的工作方式如下。
chap5_para930,2,,首先，我们确定每个常量符号都指代一个唯一的对象——唯一名称假设（unique-names assumption）。
chap5_para930,3,,然后，我们假设未知其为真的原子语句事实上都为假——封闭世界假设（closed world assumption）。
chap5_para930,4,,最后，我们调用域闭包（domain closure），意味着每个模型中的域元素不多于常量符号指代的那些。
chap5_para931,1,,在由此产生的语义中，式（8-3）的确能表明理查仅有两个兄弟，约翰和杰弗里。
chap5_para931,2,,我们称之为数据库语义（database semantics），以区别于标准的一阶逻辑语义。
chap5_para931,3,,数据库语义也用于逻辑编程系统中，在9.4.4节我们对此进行解释。
chap5_para932,1,,在数据库语义里考虑图8-4所示的情形中的所有可能的模型是很有指导性的。
chap5_para932,2,,图8-5展示了其中一些模型，从没有元组满足关系的模型到所有元组都满足关系的模型。
chap5_para932,3,,在有两个对象的情况下，有4种可能的二元素元组，存在24 = 16种不同的元组子集满足关系。
chap5_para932,4,,因此，总共有16种可能模型——大大少于标准一阶逻辑语法下巨量的模型数量。
chap5_para932,5,,不过，数据库语义需要世界中包含的东西的确定知识。
chap5_para933,1,,图8-5　在数据库语义下，含有两个常量符号R和J以及一个二元关系符号的语言中的全部模型集的一部分成员。
chap5_para933,2,,常量符号的解释是固定的，每个常量符号有唯一的对象
chap5_para934,1,,这个例子引发了一个重要的观点：逻辑中不存在“正确的”语义。
chap5_para934,2,,提出的语义的有用性取决于它对我们想要记录的知识的表示是否简洁和直观，以及相应的推断规则的生成是否容易和自然。
chap5_para934,3,,当我们明确了知识库中描述的所有对象的身份，并且掌握了所有事实的时候，数据库语义最有用，而在其他情况下，数据库语义就很棘手。
chap5_para934,4,,本章剩余部分，我们默认使用标准语义，并会在这种语义使表达变得非常繁琐的实例中另行标注。
chap5_para935,1,,8.3　使用一阶逻辑
chap5_para936,1,,现在我们已经定义了一种很有表达能力的逻辑语言，接下来我们学习如何使用它。
chap5_para936,2,,本节，我们在一些简单的论域（domain）中给出范例语句。
chap5_para936,3,,在知识表示中，论域是指我们要表示其知识的那部分世界。
chap5_para937,1,,我们从简要地解释一阶知识库中的Tell/Ask推断开始。
chap5_para937,2,,随后我们考察家庭关系、数、集合、列表以及wumpus世界论域。
chap5_para937,3,,8.4.2节展示一个更大规模的示例（电子电路），而第10章则涵盖了宇宙万物。
chap5_para938,1,,8.3.1　一阶逻辑的断言与查询
chap5_para939,1,,语句是通过Tell添加到知识库的，与在命题逻辑中完全一样。
chap5_para939,2,,这种语句被称为断言（assertion）。
chap5_para939,3,,例如，我们可以断言约翰是国王、理查是人以及所有的国王都是人：
chap5_para94,1,We can get back that factor of n!,剪枝将剪掉对最终评估没有影响的树的分支，但前向剪枝（forward pruning）将剪掉那些看上去很糟糕但也可能实际很好的移动。
chap5_para94,2,by recognizing a crucial property of CSPs: commutativity.,因此，这一策略以出错风险增大的代价节省了计算时间。
chap5_para94,3,A problem is commutative if the order of application of any given set of actions does not matter.,用香农的话说，这是B型策略。
chap5_para94,4,"In CSPs, it makes no difference if we first assign NSW = red and then SA = blue,or the other way around.",显然，大多数人类棋手都会这么做，仅考虑每个局面的几步移动（至少是潜意识地）。
chap5_para94,5,"Therefore, we need only consider a single variable at each node in the search tree.",
chap5_para94,6,"At the root we might make a choice between SA = red, SA = green, and SA = blue, but we would never choose between NSW = red and SA = blue.",
chap5_para94,7,"With this restriction, the number of leaves is dn, as we would hope.",
chap5_para94,8,"At each level of the tree we do have to choose which variable we will deal with, but we never have to backtrack over that choice.",
chap5_para940,1,,我们可以使用Ask对知识库提问。
chap5_para940,2,,例如：
chap5_para941,1,,返回true。
chap5_para941,2,,使用Ask提出的问题被称为查询或目标。
chap5_para941,3,,一般来说，知识库中逻辑蕴含的所有查询都应该得到肯定的回答。
chap5_para941,4,,例如，给定上述3条断言，查询
chap5_para942,1,,应该也返回true。
chap5_para942,2,,我们可以提出量化的问题，例如：
chap5_para943,1,,答案为true，但它可能并不是我们想要的答案。
chap5_para943,2,,它就像用“可以”回答“你能告我现在几点了吗？
chap5_para943,3,,”一样。
chap5_para943,4,,如果我们想了解使语句为真的x的值，我们就需要另一个函数AskVars：
chap5_para944,1,,将返回一系列答案。
chap5_para944,2,,在这个例子中有两个答案：以及。
chap5_para944,3,,这种回答叫作置换（substitution）或绑定表（binding list）。
chap5_para944,4,,AskVars通常与仅由霍恩子句构成的知识库合用，因为在这种知识库中，每种使查询为真的方式都将变量绑定到特定的值。
chap5_para944,5,,而一阶逻辑中并不存在这种状况：在KB仅被告知King(John)的情况下，不存在使得查询∃x King(x)为真的x的单个绑定，即使这条查询实际上为真。
chap5_para945,1,,8.3.2　亲属关系论域
chap5_para946,1,,我们第一个考虑的范例是家庭关系（或称亲属关系）论域。
chap5_para946,2,,这个论域包括类似“伊丽莎白是查尔斯的母亲”和“查尔斯是威廉的父亲”这样的事实，以及类似“一个人的祖母（外祖母）是他父母的母亲”这样的规则。
chap5_para947,1,,显然，这个论域的对象是人。
chap5_para947,2,,一元谓词包括Male和Female等。
chap5_para947,3,,亲属关系（父母、兄弟、婚姻等）使用二元谓词表示：Parent、Sibling、Brother、Sister、Child、Daughter、Son、Spouse、Wife、Husband、Grandparent、Grandchild、Cousin、Aunt和Uncle。
chap5_para947,4,,我们用函数表示Mother和Father，因为从生物学角度来说，每个人只有一对父母（尽管我们可以引入更多函数来处理养母、代孕妈妈等）。
chap5_para948,1,,我们可以考察每个函数和谓词，并就我们知道的写下它们与其他符号的关系。
chap5_para948,2,,例如， 一个人的母亲就是他父母中的女性成员：
chap5_para949,1,,一个人的丈夫是她的男性配偶：
chap5_para95,1,Figure 5.,前向剪枝的一种方法是束搜索（见4.1.3节）：在每一层，只考虑一“束”n个最佳移动（根据评价函数），而不是所有可能的移动。
chap5_para95,2,5 shows a backtracking search procedure for CSPs.,遗憾的是，这种方法相当危险，因为无法保证最佳移动不被剪枝。
chap5_para95,3,"It repeatedly chooses an unassigned variable, and then tries all values in the domain of that variable in turn, trying to extend each one into a solution via a recursive call.",
chap5_para95,4,"If the call succeeds, the solution is returned, and if it fails, the assignment is restored to the previous state, and we try the next value.",
chap5_para95,5,If no value works then we return failure.,
chap5_para95,6,Part of the search tree for the Australia problem is shown in Figure 5.,
chap5_para95,7,"6, where we have assigned variables in the order WA, NT, Q,.",
chap5_para95,8,.,
chap5_para95,9,.,
chap5_para95,10,.,
chap5_para950,1,,父母与孩子是反关系：
chap5_para951,1,,祖父母（外祖父母）是一个人父母的父母：
chap5_para952,1,,兄弟姐妹是一个人父母的其他孩子：
chap5_para953,1,,我们可以像这样写出很多页，这正是习题8.KINS的题目。
chap5_para954,1,,所有这些语句都可以看作亲属关系论域中的公理，如7.1节所阐述。
chap5_para954,2,,公理通常与纯数学论域相关（我们很快就能看到一些关于数字的公理），但它们在所有论域都有用。
chap5_para954,3,,它们提供了用于推导有用结论的基本因子化信息。
chap5_para954,4,,我们的亲属关系公理同时也是定义，它们具有形式。
chap5_para954,5,,公理用其他谓词定义了Mother函数以及Husband、Male、Parent、Grandparent和Sibling谓词。
chap5_para954,6,,我们的定义从基本的谓词集（Child、Female等）发展而来，并以此最终定义其他谓词。
chap5_para955,1,,这是构建一个论域的表示的自然方式，类似于用基本的库函数定义子程序，再用子程序构建软件包。
chap5_para955,2,,注意，基本谓词集并不一定是唯一的，我们可以使用Parent而非Child来得到同样的结果。
chap5_para955,3,,像我们所展示的一样，在一些论域中并不存在清晰可辨的基本谓词集。
chap5_para956,1,,并非所有关于论域的逻辑语句都是公理，其中一些是定理，也就是说，它们被公理所蕴含。
chap5_para956,2,,例如，考虑如下关于兄弟姐妹关系对称性的断言：
chap5_para957,1,,这条语句是公理还是定理？
chap5_para957,2,,实际上，它是与定义兄弟姐妹的公理逻辑一致的定理。
chap5_para957,3,,如果我们用这条语句Ask知识库，它应当返回true。
chap5_para958,1,,从纯逻辑的观点来看，知识库应当只包含公理并且不含有定理，因为定理并不能增加从知识库导出的结论集。
chap5_para958,2,,从实用的角度来看，定理对于降低推导新语句的计算开销是很有意义的。
chap5_para958,3,,没有定理，推理系统就不得不每次都从基本原则出发，就像物理学家每次求解问题时都要重新推导微积分的法则一样。
chap5_para959,1,,并非所有的公理都是定义。
chap5_para959,2,,一些公理提供了关于某些谓词的更一般的信息，却不构成定义。
chap5_para959,3,,实际上，一些谓词并没有完整的定义，因为我们不具有完全刻画它们的知识。
chap5_para959,4,,例如，没有显而易见的定义方式能够完成语句
chap5_para96,1,"Description Part (“a”): The blacks are in the following positions. King, e 8. Queen, g 2. Rooks, ""a"" 8 and h 8. Bishop, c 8. Knights d 4 and g 8. Pawns, ""a"" 7, b 7, c 7, d 6, e 5, f 7, g 7, and h 7. The whites are in the following positions. King, e 1. Queen, d 1. Rooks, ""a"" 1 and h 1. Bishop, c 4. Knight c3. Pawns, ""a"" 2, b 2, c 2, e 4, f 2, and h 2. Part (b): All the pieces are in the same positions as in part (“a”), except the white rook at h 1 moves to g 1.","ProbCut（概率截断，probabilistic cut）算法（Buro, 1995）是搜索的前向剪枝版本，它使用从先前经验中获得的统计数据来减少最佳移动被剪除的概率。"
chap5_para96,2,,搜索将剪除所有可证明位于当前窗口之外的节点。
chap5_para96,3,,ProbCut算法则剪除有可能位于窗口之外的节点。
chap5_para96,4,,它通过执行浅层搜索计算某个节点的倒推值v，然后利用过去的经验估计树中深度为d的节点的值v位于范围之外的可能性。
chap5_para96,5,,布罗（Buro）将这种技术应用到了他的黑白棋程序Logistello，发现即使常规版本的黑白棋程序拥有两倍的可用时间，ProbCut版本依然以64%的获胜率击败了常规版本。
chap5_para960,1,,幸运的是，一阶逻辑允许我们使用Person谓词而无须对其进行完整定义。
chap5_para960,2,,不过我们可以写出每个人具有的性质和使某物成为人的性质：
chap5_para961,1,,"公理也可以是“直白的事实”，例如Male(Jim)和Spouse(Jim, Laura)。"
chap5_para961,2,,这些来自特定问题实例描述的事实使特定的提问能够得到解答。
chap5_para961,3,,如果一切顺利的话，这些问题的答案会成为与公理逻辑一致的定理。
chap5_para962,1,,"我们常常会发现期望的答案不是现成的，例如，从Spouse(Jim, Laura)出发，我们期望（根据很多国家的法律）能推得，但这并不能由先前给出的公理推导得出，即便在我们像8.2.8节所述的那样添加也不行。"
chap5_para962,2,,这表明缺失了一条公理。
chap5_para962,3,,习题8.HILL要求读者提供这条公理。
chap5_para963,1,,8.3.3　数、集合与列表
chap5_para964,1,,数可能是展示从一小部分核心公理构建庞大理论的最生动的示例。
chap5_para964,2,,我们在此阐述自然数或称非负整数的理论。
chap5_para964,3,,我们需要谓词NatNum对于自然数为真，我们还需要常量符号0，以及一个函数符号S（后继）。
chap5_para964,4,,皮亚诺公理（Peano axioms）定义了自然数和加法。
chap5_para964,5,,[9]自然数是递归定义的：
chap5_para966,1,,[9]　皮亚诺公理还包括归纳法则，但它是二阶逻辑的语句而非一阶逻辑。
chap5_para966,2,,这种区别的重要性将在第9章中进行解释。
chap5_para967,1,,也就是说，0是自然数，对于每一个对象n，如果n是自然数，则S(n)是自然数。
chap5_para967,2,,"因此自然数是0, S(0), S(S(0)), …。"
chap5_para967,3,,我们还需要约束后继函数的公理：
chap5_para968,1,,现在我们就可以用后继函数定义加法：
chap5_para969,1,,这些公理中，第一个公理表示对任何自然数m加0等于m本身。
chap5_para969,2,,"注意，在+(m, 0)项中二元函数符号“+”的使用：在普通数学中，这一项会使用中缀（infix）记法写作m + 0。"
chap5_para969,3,,［我们在一阶逻辑中使用的记法称为前缀（prefix）。
chap5_para969,4,,］为使我们关于数的语句更容易阅读，我们允许使用中缀记法。
chap5_para969,5,,我们可以将S(n)写成n + 1，因此第二个公理变为
chap5_para97,1,Figure 5.,另一种技术，即后期移动缩减（late move reduction）技术，假设移动顺序已经调整好，因此在可能的移动的列表中后期才出现的移动不太可能是好的移动。
chap5_para97,2,5A simple backtracking algorithm for constraint satisfaction problems.,这一技术没有将后期的移动完全删除，只是减少了搜索这些移动的深度，从而节省了时间。
chap5_para97,3,The algorithm is modeled on the recursive depth-first search of Chapter 3.,如果缩减后的搜索返回的值高于当前值，我们可以重新运行全深度搜索。
chap5_para97,4,The functions SELECT-UNASSIGNED-VARIABLE and ORDER-DOMAIN-VALUES implement the generalpurpose heuristics discussed in Section 5.,
chap5_para97,5,3.,
chap5_para97,6,1.,
chap5_para97,7,"The INFERENCE function can optionally impose arc-, path-, or k-consistency, as desired.",
chap5_para97,8,"If a value choice leads to failure (noticed either by INFERENCE or by BACKTRACK), then value assignments (including those made by INFERENCE) are retracted and a new value is tried.",
chap5_para970,1,,这条公理将加法简化为对后继函数的反复应用。
chap5_para971,1,,使用中缀记法是一个语法糖（syntactic sugar）的示例。
chap5_para971,2,,语法糖是一种对标准语法的扩展或缩略，但不改变语义。
chap5_para971,3,,所有使用糖的语句都可以“脱糖”生成普通一阶逻辑中的等价语句。
chap5_para971,4,,还有一个示例是使用方括号而非圆括号来使左右括号的对应关系更易读。
chap5_para971,5,,而另一个示例是量词折叠：用代替。
chap5_para972,1,,我们有了加法以后，将乘法定义为重复的加法、乘方定义为连续的乘法就是顺理成章的事情，同样我们可以定义整数除法和余数、质数等。
chap5_para972,2,,这样，整个数论（包括密码学）就能从一个常量、一个函数、一个谓词和4条公理开始构建起来。
chap5_para973,1,,集合的论域对数学和常识推理也是非常重要的。
chap5_para973,2,,（实际上，可以用集合论来定义数论。
chap5_para973,3,,）我们希望能够表示每个集合，包括空集。
chap5_para973,4,,我们需要一种方法用其他集合的元素或对其他集合的操作构建集合。
chap5_para973,5,,我们想知道一个元素是否是集合的成员，也需要区分一个对象是否是集合。
chap5_para974,1,,我们将使用集合论中的一般词汇作为语法糖。
chap5_para974,2,,空集是一个常量，写作{}。
chap5_para974,3,,一元谓词Set对集合为真。
chap5_para974,4,,二元谓词包括（x是集合s的成员）以及（集合s1是集合s2的子集，两个集合也可以相同）。
chap5_para974,5,,"二元函数是（交集）、（并集）和Add(x, s)（将元素x添加到集合s生成的集合）。"
chap5_para974,6,,下面是一个可能的公理集。
chap5_para975,1,,（1）集合只能是空集和向集合中添加元素产生的集合：
chap5_para976,1,,（2）空集没有被加入的元素。
chap5_para976,2,,换言之，无法将空集分解为更小的集合和元素：
chap5_para977,1,,（3）对集合添加已有元素没有作用：
chap5_para978,1,,（4）集合中的成员只能是被添加到集合中的元素。
chap5_para978,2,,我们用递归的形式表示它：声明x是s中的元素，当且仅当s等于某个将元素y添加到集合s2后的集合，其中y与x相同，或x是s2的成员：
chap5_para979,1,,（5）一个集合是另一个集合的子集当且仅当第一个集合的所有成员都是第二个集合的成员：
chap5_para98,1,Description The blacks are in the following positions.,结合本章介绍的所有技术，可以得到一个国际象棋（或其他游戏）程序。
chap5_para98,2,"King, g 7.",我们假设，已经实现了一个国际象棋评价函数——一个使用静态搜索的合理截断测试。
chap5_para98,3,"Bishop, ""a"" 2.",我们还假设，经过几个月的努力，可以在最新的个人计算机上每秒生成并评估大约100万个节点。
chap5_para98,4,"Pawns, g 6, f 5, e 4, and b 4.",国际象棋的分支因子平均约为35，而355约等于5000万，因此，如果我们使用极小化极大搜索，在大约1分钟的计算时间内只能向前搜索5层。
chap5_para98,5,The whites are in the following positions.,按照比赛规则，我们没有足够的时间去搜索第6层。
chap5_para98,6,"King, d 2.",平均水平的人类棋手就可以击败这样的程序，因为他们偶尔会向前规划6～8步。
chap5_para98,7,"Rook, h 2.",
chap5_para98,8,"Pawns, c 2 and b 3.",
chap5_para980,1,,（6）两个集合相等当且仅当它们互为对方的子集：
chap5_para981,1,,（7）一个对象在两个集合的交集中，当且仅当它同时是这两个集合的成员：
chap5_para982,1,,（8）一个对象在两个集合的并集中，当且仅当它同时是某个集合的成员：
chap5_para983,1,,列表与集合类似。
chap5_para983,2,,它们的区别是，列表是有序的，相同的元素在列表中可以出现多次。
chap5_para983,3,,我们可以用Lisp语言的词汇表示列表：Nil是没有元素的常量列表；Cons、Append、First和Rest是函数；Find在列表中的作用与Member在集合中的作用相同。
chap5_para983,4,,List是仅对列表为真的谓词。
chap5_para983,5,,与集合一样，涉及列表的逻辑语句也常用到语法糖。
chap5_para983,6,,空列表是[]。
chap5_para983,7,,"Cons(x, Nil)项（即仅含有元素x，尾部没有其他元素的列表）写作[x]。"
chap5_para983,8,,"含有若干元素的列表，如[A, B, C]，对应于嵌套项。"
chap5_para983,9,,习题8.LIST要求你写出列表的公理。
chap5_para984,1,,8.3.4　wumpus世界
chap5_para985,1,,第7章给出了wumpus世界的一些命题逻辑公理。
chap5_para985,2,,本节介绍的一阶公理简洁得多，自然、精确地刻画了我们的意图。
chap5_para986,1,,如前所述，wumpus世界智能体接收一个含有5个元素的感知向量。
chap5_para986,2,,知识库中存储的对应一阶语句必须包含感知和感知出现的时间，否则，智能体会搞不清何时接收到什么感知。
chap5_para986,3,,我们使用整数表示时间步。
chap5_para986,4,,一个典型的感知语句是
chap5_para987,1,,此处，Percept是二元谓词，Stench等是列表中的常量。
chap5_para987,2,,wumpus世界中的动作可以用逻辑项表示：
chap5_para988,1,,要确定哪个动作最优，智能体程序执行查询
chap5_para99,1,Figure 5.,通过搜索和大型换位表，我们可以向前搜索大约14层，已经到达了专家级水平。
chap5_para99,2,6Part of the search tree for the map-coloring problem in Figure 5.,我们可以将个人计算机换成一台拥有8个GPU的工作站，每秒可以计算超过10亿个节点，但如果要达到大师级水平，还需要一个经过精心调整的评价函数和一个存储残局招式的大型数据库。
chap5_para99,3,1.,像Stockfish这样的顶级国际象棋程序拥有所有这些功能，它在搜索树中通常能达到超过30的深度，远远超过任何一个人类棋手的能力。
chap5_para990,1,,将返回一个类似的绑定表。
chap5_para990,2,,智能体程序将Grab作为要采取的动作。
chap5_para990,3,,原始感知数据蕴涵了关于当前状态的某些事实。
chap5_para990,4,,例如：
chap5_para991,1,,这些规则展现了一个被称为感知的推理形式的细节，我们将在第25章进行深入研究。
chap5_para991,2,,注意对时间t的量化。
chap5_para991,3,,在命题逻辑中，我们需要每个时间步的每条语句的副本。
chap5_para992,1,,简单的“反射”行为也可以用量化蕴涵式语句来实现。
chap5_para992,2,,例如，我们有
chap5_para993,1,,"给定感知和先前几段给出的规则，就能得出所需的结论BestAction(Grab, 5)，也就是说，Grab是要做的正确的事。"
chap5_para994,1,,我们已经表示了智能体的输入和输出，现在可以表示环境本身了。
chap5_para994,2,,我们从对象开始。
chap5_para994,3,,显然，候选的对象有方格、无底洞和wumpus。
chap5_para994,4,,"我们可以命名方格，如Square1,2等，但接下来Square1,2与Square1,3相邻的事实就必须是“额外”的事实，我们要为每一对方格列出一条这样的事实。"
chap5_para994,5,,"使用行和列为整数的复合项是更好的做法，例如，我们可以简单地使用列表项[1, 2]。"
chap5_para994,6,,任意相邻的方格可以定义为
chap5_para995,1,,我们也可以为每个无底洞命名，但不宜这么做另有原因：没有必要去区分每个无底洞。
chap5_para995,2,,[10]使用一元谓词Pit并使其在含有无底洞的方格中为真是更简单的做法。
chap5_para995,3,,最后，由于只存在一个wumpus，用常量Wumpus与使用一元谓词并没什么区别（从wumpus的视角看，使用常量可能更威严）。
chap5_para997,1,,[10]　同样，大多数人也不会为冬天迁徙到温暖地区的每一只鸟命名。
chap5_para997,2,,但想研究迁徙模式、生存率等的鸟类学家要追踪每一只鸟，因此会为每只鸟命名，方法是为鸟安装腿环。
chap5_para998,1,,"智能体的位置随时间变化，因此我们用At(Agent, s, t)来表示智能体在时间t位于方格s。"
chap5_para998,2,,我们可以用将wumpus永远固定在一个位置。
chap5_para998,3,,然后我们就可以说对象在一个时刻只能在一个位置：
chap5_para999,1,,给定智能体的当前位置，它就可以用当前的感知来推断方格的属性。
chap5_para999,2,,例如，如果智能体在一个方格中并感知到微风，则这个方格是有微风的：
