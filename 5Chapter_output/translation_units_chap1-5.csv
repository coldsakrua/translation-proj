单元ID,章节号,原文,上下文关联,领域,语体要求,关键术语,命名实体,Agent译文,人工修正
chap1_para1,1,"INTRODUCTION In which we try to explain why we consider artificial intelligence to be a subject most worthy of study, and in which we try to decide what exactly it is, this being a good thing to decide before embarking. We call ourselves Homo sapiens—man the wise—because our intelligence is so important to us. For thousands of years, we have tried to understand how we think and act—that is, how our brain, a mere handful of matter, can perceive, understand, predict, and manipulate a world far larger and more complicated than itself. The field of artificial intelligence, or AI, is concerned with not just understanding but also building intelligent entities—machines that can compute how to act effectively and safely in a wide variety of novel situations. Surveys regularly rank AI as one of the most interesting and fastest-growing fields, and it is already generating over a trillion dollars a year in revenue. AI expert Kai-Fu Lee predicts that its impact will be “more than anything in the history of mankind. ” Moreover, the intellectual frontiers of AI are wide open. Whereas a student of an older science such as physics might feel that the best ideas have already been discovered by Galileo, Newton, Curie, Einstein, and the rest, AI still has many openings for full-time masterminds. AI currently encompasses a huge variety of subfields, ranging from the general (learning, reasoning, perception, and so on) to the specific, such as playing chess, proving mathematical theorems, writing poetry, driving a car, or diagnosing diseases. AI is relevant to any intellectual task; it is truly a universal field. 1. 1What Is AI? We have claimed that AI is interesting, but we have not said what it is. Historically, researchers have pursued several different versions of AI. Some have defined intelligence in terms of fidelity to human performance, while others prefer an abstract, formal definition of intelligence called rationality—loosely speaking, doing the “right thing. ” The subject matter itself also varies: some consider intelligence to be a property of internal thought processes and reasoning, while others focus on intelligent behavior, an external characterization. 1 From these two dimensions—human vs. rational2 and thought vs. behavior—there are four possible combinations, and there have been adherents and research programs for all four. The methods used are necessarily different: the pursuit of human-like intelligence must be in part an empirical science related to psychology, involving observations and hypotheses about actual human behavior and thought processes; a rationalist approach, on the other hand, involves a combination of mathematics and engineering, and connects to statistics, control theory, and economics. The various groups have both disparaged and helped each other. Let us look at the four approaches in more detail. 1. 1. 1Acting humanly: The Turing test approach The Turing test, proposed by Alan Turing (1950), was designed as a thought experiment that would sidestep the philosophical vagueness of the question “Can a machine think? ” A computer passes the test if a human interrogator, after posing some written questions, cannot tell whether the written responses come from a person or from a computer. Chapter 28 discusses the details of the test and whether a computer would really be intelligent if it passed. For now, we note that programming a computer to pass a rigorously applied test provides plenty to work on. The computer would need the following capabilities: •natural language processing to communicate successfully in a human language; •knowledge representation to store what it knows or hears; •automated reasoning to answer questions and to draw new conclusions; •machine learning to adapt to new circumstances and to detect and extrapolate patterns. Turing viewed the physical simulation of a person as unnecessary to demonstrate intelligence. However, other researchers have proposed a total Turing test, which requires interaction with objects and people in the real world. To pass the total Turing test, a robot will need •computer vision and speech recognition to perceive the world; •robotics to manipulate objects and move about. These six disciplines compose most of AI. Yet AI researchers have devoted little effort to passing the Turing test, believing that it is more important to study the underlying principles of intelligence. The quest for “artificial flight” succeeded when engineers and inventors stopped imitating birds and started using wind tunnels and learning about aerodynamics. Aeronautical engineering texts do not define the goal of their field as making “machines that fly so exactly like pigeons that they can fool even other pigeons. ” 1. 1. 2Thinking humanly: The cognitive modeling approach To say that a program thinks like a human, we must know how humans think. We can learn about human thought in three ways: •introspection—trying to catch our own thoughts as they go by; •psychological experiments—observing a person in action; •brain imaging—observing the brain in action. Once we have a sufficiently precise theory of the mind, it becomes possible to express the theory as a computer program. If the program’s input–output behavior matches corresponding human behavior, that is evidence that some of the program’s mechanisms could also be operating in humans. For example, Allen Newell and Herbert Simon, who developed GPS, the “General Problem Solver” (Newell and Simon, 1961), were not content merely to have their program solve problems correctly. They were more concerned with comparing the sequence and timing of its reasoning steps to those of human subjects solving the same problems. The interdisciplinary field of cognitive science brings together computer models from AI and experimental techniques from psychology to construct precise and testable theories of the human mind. Cognitive science is a fascinating field in itself, worthy of several textbooks and at least one encyclopedia (Wilson and Keil, 1999). We will occasionally comment on similarities or differences between AI techniques and human cognition. Real cognitive science, however, is necessarily based on experimental investigation of actual humans or animals. We will leave that for other books, as we assume the reader has only a computer for experimentation. In the early days of AI there was often confusion between the approaches. An author would argue that an algorithm performs well on a task and that it is therefore a good model of human performance, or vice versa. Modern authors separate the two kinds of claims; this distinction has allowed both AI and cognitive science to develop more rapidly. The two fields fertilize each other, most notably in computer vision, which incorporates neurophysiological evidence into computational models. Recently, the combination of neuroimaging methods combined with machine learning techniques for analyzing such data has led to the beginnings of a capability to “read minds”—that is, to ascertain the semantic content of a person’s inner thoughts. This capability could, in turn, shed further light on how human cognition works. 1. 1. 3Thinking rationally: The “laws of thought” approach The Greek philosopher Aristotle was one of the first to attempt to codify “right thinking”—that is, irrefutable reasoning processes. His syllogisms provided patterns for argument structures that always yielded correct conclusions when given correct premises. The canonical example starts with Socrates is a man and all men are mortal and concludes that Socrates is mortal. (This example is probably due to Sextus Empiricus rather than Aristotle. ) These laws of thought were supposed to govern the operation of the mind; their study initiated the field called logic. Logicians in the 19th century developed a precise notation for statements about objects in the world and the relations among them. (Contrast this with ordinary arithmetic notation, which provides only for statements about numbers. ) By 1965, programs could, in principle, solve any solvable problem described in logical notation. The so-called logicist tradition within artificial intelligence hopes to build on such programs to create intelligent systems. Logic as conventionally understood requires knowledge of the world that is certain—a condition that, in reality, is seldom achieved. We simply don’t know the rules of, say, politics or warfare in the same way that we know the rules of chess or arithmetic. The theory of probability fills this gap, allowing rigorous reasoning with uncertain information. In principle, it allows the construction of a comprehensive model of rational thought, leading from raw perceptual information to an understanding of how the world works to predictions about the future. What it does not do, is generate intelligent behavior. For that, we need a theory of rational action. Rational thought, by itself, is not enough. 1. 1. 4Acting rationally: The rational agent approach An agent is just something that acts (agent comes from the Latin agere, to do). Of course, all computer programs do something, but computer agents are expected to do more: operate autonomously, perceive their environment, persist over a prolonged time period, adapt to change, and create and pursue goals. A rational agent is one that acts so as to achieve the best outcome or, when there is uncertainty, the best expected outcome. In the “laws of thought” approach to AI, the emphasis was on correct inferences. Making correct inferences is sometimes part of being a rational agent, because one way to act rationally is to deduce that a given action is best and then to act on that conclusion. On the other hand, there are ways of acting rationally that cannot be said to involve inference. For example, recoiling from a hot stove is a reflex action that is usually more successful than a slower action taken after careful deliberation. All the skills needed for the Turing test also allow an agent to act rationally. Knowledge representation and reasoning enable agents to reach good decisions. We need to be able to generate comprehensible sentences in natural language to get by in a complex society. We need learning not only for erudition, but also because it improves our ability to generate effective behavior, especially in circumstances that are new. The rational-agent approach to AI has two advantages over the other approaches. First, it is more general than the “laws of thought” approach because correct inference is just one of several possible mechanisms for achieving rationality. Second, it is more amenable to scientific development. The standard of rationality is mathematically well defined and completely general. We can often work back from this specification to derive agent designs that provably achieve it—something that is largely impossible if the goal is to imitate human behavior or thought processes. For these reasons, the rational-agent approach to AI has prevailed throughout most of the field’s history. In the early decades, rational agents were built on logical foundations and formed definite plans to achieve specific goals. Later, methods based on probability theory and machine learning allowed the creation of agents that could make decisions under uncertainty to attain the best expected outcome. In a nutshell, AI has focused on the study and construction of agents that do the right thing. What counts as the right thing is defined by the objective that we provide to the agent. This general paradigm is so pervasive that we might call it the standard model. It prevails not only in AI, but also in control theory, where a controller minimizes a cost function; in operations research, where a policy maximizes a sum of rewards; in statistics, where a decision rule minimizes a loss function; and in economics, where a decision maker maximizes utility or some measure of social welfare. We need to make one important refinement to the standard model to account for the fact that perfect rationality—always taking the exactly optimal action—is not feasible in complex environments. The computational demands are just too high. Chapters 6 and 16 deal with the issue of limited rationality—acting appropriately when there is not enough time to do all the computations one might like. However, perfect rationality often remains a good starting point for theoretical analysis. 1. 1. 5Beneficial machines The standard model has been a useful guide for AI research since its inception, but it is probably not the right model in the long run. The reason is that the standard model assumes that we will supply a fully specified objective to the machine. For an artificially defined task such as chess or shortest-path computation, the task comes with an objective built in—so the standard model is applicable. As we move into the real world, however, it becomes more and more difficult to specify the objective completely and correctly. For example, in designing a self-driving car, one might think that the objective is to reach the destination safely. But driving along any road incurs a risk of injury due to other errant drivers, equipment failure, and so on; thus, a strict goal of safety requires staying in the garage. There is a tradeoff between making progress towards the destination and incurring a risk of injury. How should this tradeoff be made? Furthermore, to what extent can we allow the car to take actions that would annoy other drivers? How much should the car moderate its acceleration, steering, and braking to avoid shaking up the passenger? These kinds of questions are difficult to answer a priori. They are particularly problematic in the general area of human–robot interaction, of which the self-driving car is one example. The problem of achieving agreement between our true preferences and the objective we put into the machine is called the value alignment problem: the values or objectives put into the machine must be aligned with those of the human. If we are developing an AI system in the lab or in a simulator—as has been the case for most of the field’s history—there is an easy fix for an incorrectly specified objective: reset the system, fix the objective, and try again. As the field progresses towards increasingly capable intelligent systems that are deployed in the real world, this approach is no longer viable. A system deployed with an incorrect objective will have negative consequences. Moreover, the more intelligent the system, the more negative the consequences. Returning to the apparently unproblematic example of chess, consider what happens if the machine is intelligent enough to reason and act beyond the confines of the chessboard. In that case, it might attempt to increase its chances of winning by such ruses as hypnotizing or blackmailing its opponent or bribing the audience to make rustling noises during its opponent’s thinking time. 3 It might also attempt to hijack additional computing power for itself. These behaviors are not “unintelligent” or “insane”; they are a logical consequence of defining winning as the sole objective for the machine. It is impossible to anticipate all the ways in which a machine pursuing a fixed objective might misbehave. There is good reason, then, to think that the standard model is inadequate. We don’t want machines that are intelligent in the sense of pursuing their objectives; we want them to pursue our objectives. If we cannot transfer those objectives perfectly to the machine, then we need a new formulation—one in which the machine is pursuing our objectives, but is necessarily uncertain as to what they are. When a machine knows that it doesn’t know the complete objective, it has an incentive to act cautiously, to ask permission, to learn more about our preferences through observation, and to defer to human control. Ultimately, we want agents that are provably beneficial to humans. We will return to this topic in Section 1. 5. 1. 2The Foundations of Artificial Intelligence In this section, we provide a brief history of the disciplines that contributed ideas, viewpoints, and techniques to AI. Like any history, this one concentrates on a small number of people, events, and ideas and ignores others that also were important. We organize the history around a series of questions. We certainly would not wish to give the impression that these questions are the only ones the disciplines address or that the disciplines have all been working toward AI as their ultimate fruition. 1. 2. 1Philosophy •Can formal rules be used to draw valid conclusions? •How does the mind arise from a physical brain? •Where does knowledge come from? •How does knowledge lead to action? Aristotle (384–322 BCE) was the first to formulate a precise set of laws governing the rational part of the mind. He developed an informal system of syllogisms for proper reasoning, which in principle allowed one to generate conclusions mechanically, given initial premises. Ramon Llull (c. 1232–1315) devised a system of reasoning published as Ars Magna or The Great Art (1305). Llull tried to implement his system using an actual mechanical device: a set of paper wheels that could be rotated into different permutations. Around 1500, Leonardo da Vinci (1452–1519) designed but did not build a mechanical calculator; recent reconstructions have shown the design to be functional. The first known calculating machine was constructed around 1623 by the German scientist Wilhelm Schickard (1592–1635). Blaise Pascal (1623–1662) built the Pascaline in 1642 and wrote that it “produces effects which appear nearer to thought than all the actions of animals. ” Gottfried Wilhelm Leibniz (1646–1716) built a mechanical device intended to carry out operations on concepts rather than numbers, but its scope was rather limited. In his 1651 book Leviathan, Thomas Hobbes (1588–1679) suggested the idea of a thinking machine, an “artificial animal” in his words, arguing “For what is the heart but a spring; and the nerves, but so many strings; and the joints, but so many wheels. ” He also suggested that reasoning was like numerical computation: “For ‘reason’. . . is nothing but ‘reckoning, ’ that is adding and subtracting. ” It’s one thing to say that the mind operates, at least in part, according to logical or numerical rules, and to build physical systems that emulate some of those rules. It’s another to say that the mind itself is such a physical system. René Descartes (1596–1650) gave the first clear discussion of the distinction between mind and matter. He noted that a purely physical conception of the mind seems to leave little room for free will. If the mind is governed entirely by physical laws, then it has no more free will than a rock “deciding” to fall downward. Descartes was a proponent of dualism. He held that there is a part of the human mind (or soul or spirit) that is outside of nature, exempt from physical laws. Animals, on the other hand, did not possess this dual quality; they could be treated as machines. An alternative to dualism is materialism, which holds that the brain’s operation according to the laws of physics constitutes the mind. Free will is simply the way that the perception of available choices appears to the choosing entity. The terms physicalism and naturalism are also used to describe this view that stands in contrast to the supernatural. Given a physical mind that manipulates knowledge, the next problem is to establish the source of knowledge. The empiricism movement, starting with Francis Bacon’s (1561–1626) Novum Organum, 4 is characterized by a dictum of John Locke (1632–1704): “Nothing is in the understanding, which was not first in the senses. ” David Hume’s (1711–1776) A Treatise of Human Nature (Hume, 1739) proposed what is now known as the principle of induction: that general rules are acquired by exposure to repeated associations between their elements. Building on the work of Ludwig Wittgenstein (1889–1951) and Bertrand Russell (1872–1970), the famous Vienna Circle (Sigmund, 2017), a group of philosophers and mathematicians meeting in Vienna in the 1920s and 1930s, developed the doctrine of logical positivism. This doctrine holds that all knowledge can be characterized by logical theories connected, ultimately, to observation sentences that correspond to sensory inputs; thus logical positivism combines rationalism and empiricism. The confirmation theory of Rudolf Carnap (1891–1970) and Carl Hempel (1905–1997) attempted to analyze the acquisition of knowledge from experience by quantifying the degree of belief that should be assigned to logical sentences based on their connection to observations that confirm or disconfirm them. Carnap’s book The Logical Structure of the World (1928) was perhaps the first theory of mind as a computational process. The final element in the philosophical picture of the mind is the connection between knowledge and action. This question is vital to AI because intelligence requires action as well as reasoning. Moreover, only by understanding how actions are justified can we understand how to build an agent whose actions are justifiable (or rational). Aristotle argued (in De Motu Animalium) that actions are justified by a logical connection between goals and knowledge of the action’s outcome: But how does it happen that thinking is sometimes accompanied by action and sometimes not, sometimes by motion, and sometimes not? It looks as if almost the same thing happens as in the case of reasoning and making inferences about unchanging objects. But in that case the end is a speculative proposition. . . whereas here the conclusion which results from the two premises is an action. . . . I need covering; a cloak is a covering. I need a cloak. What I need, I have to make; I need a cloak. I have to make a cloak. And the conclusion, the “I have to make a cloak, ” is an action. In the Nicomachean Ethics (Book III. 3, 1112b), Aristotle further elaborates on this topic, suggesting an algorithm: We deliberate not about ends, but about means. For a doctor does not deliberate whether he shall heal, nor an orator whether he shall persuade, . . . They assume the end and consider how and by what means it is attained, and if it seems easily and best produced thereby; while if it is achieved by one means only they consider how it will be achieved by this and by what means this will be achieved, till they come to the first cause, . . . and what is last in the order of analysis seems to be first in the order of becoming. And if we come on an impossibility, we give up the search, e. g. , if we need money and this cannot be got; but if a thing appears possible we try to do it. Aristotle’s algorithm was implemented 2300 years later by Newell and Simon in their General Problem Solver program. We would now call it a greedy regression planning system (see Chapter 11). Methods based on logical planning to achieve definite goals dominated the first few decades of theoretical research in AI. Thinking purely in terms of actions achieving goals is often useful but sometimes inapplicable. For example, if there are several different ways to achieve a goal, there needs to be some way to choose among them. More importantly, it may not be possible to achieve a goal with certainty, but some action must still be taken. How then should one decide? Antoine Arnauld (1662), analyzing the notion of rational decisions in gambling, proposed a quantitative formula for maximizing the expected monetary value of the outcome. Later, Daniel Bernoulli (1738) introduced the more general notion of utility to capture the internal, subjective value of an outcome. The modern notion of rational decision making under uncertainty involves maximizing expected utility, as explained in Chapter 15. In matters of ethics and public policy, a decision maker must consider the interests of multiple individuals. Jeremy Bentham (1823) and John Stuart Mill (1863) promoted the idea of utilitarianism: that rational decision making based on maximizing utility should apply to all spheres of human activity, including public policy decisions made on behalf of many individuals. Utilitarianism is a specific kind of consequentialism: the idea that what is right and wrong is determined by the expected outcomes of an action. In contrast, Immanuel Kant, in 1785, proposed a theory of rule-based or deontological ethics, in which “doing the right thing” is determined not by outcomes but by universal social laws that govern allowable actions, such as “don’t lie” or “don’t kill. ” Thus, a utilitarian could tell a white lie if the expected good outweighs the bad, but a Kantian would be bound not to, because lying is inherently wrong. Mill acknowledged the value of rules, but understood them as efficient decision procedures compiled from first-principles reasoning about consequences. Many modern AI systems adopt exactly this approach. 1. 2. 2Mathematics •What are the formal rules to draw valid conclusions? •What can be computed? •How do we reason with uncertain information? Philosophers staked out some of the fundamental ideas of AI, but the leap to a formal science required the mathematization of logic and probability and the introduction of a new branch of mathematics: computation. The idea of formal logic can be traced back to the philosophers of ancient Greece, India, and China, but its mathematical development really began with the work of George Boole (1815–1864), who worked out the details of propositional, or Boolean, logic (Boole, 1847). In 1879, Gottlob Frege (1848–1925) extended Boole’s logic to include objects and relations, creating the first-order logic that is used today. 5 In addition to its central role in the early period of AI research, first-order logic motivated the work of Gödel and Turing that underpinned computation itself, as we explain below. The theory of probability can be seen as generalizing logic to situations with uncertain information—a consideration of great importance for AI. Gerolamo Cardano (1501–1576) first framed the idea of probability, describing it in terms of the possible outcomes of gambling events. In 1654, Blaise Pascal (1623–1662), in a letter to Pierre Fermat (1601–1665), showed how to predict the future of an unfinished gambling game and assign average payoffs to the gamblers. Probability quickly became an invaluable part of the quantitative sciences, helping to deal with uncertain measurements and incomplete theories. Jacob Bernoulli (1654–1705, uncle of Daniel), Pierre Laplace (1749–1827), and others advanced the theory and introduced new statistical methods. Thomas Bayes (1702–1761) proposed a rule for updating probabilities in the light of new evidence; Bayes’ rule is a crucial tool for AI systems. The formalization of probability, combined with the availability of data, led to the emergence of statistics as a field. One of the first uses was John Graunt’s analysis of London census data in 1662. Ronald Fisher is considered the first modern statistician (Fisher, 1922). He brought together the ideas of probability, experiment design, analysis of data, and computing—in 1919, he insisted that he couldn’t do his work without a mechanical calculator called the MILLIONAIRE (the first calculator that could do multiplication), even though the cost of the calculator was more than his annual salary (Ross, 2012). The history of computation is as old as the history of numbers, but the first nontrivial algorithm is thought to be Euclid’s algorithm for computing greatest common divisors. The word algorithm comes from Muhammad ibn Musa al-Khwarizmi, a 9th century mathematician, whose writings also introduced Arabic numerals and algebra to Europe. Boole and others discussed algorithms for logical deduction, and, by the late 19th century, efforts were under way to formalize general mathematical reasoning as logical deduction. Kurt Gӧdel (1906–1978) showed that there exists an effective procedure to prove any true statement in the first-order logic of Frege and Russell, but that first-order logic could not capture the principle of mathematical induction needed to characterize the natural numbers. In 1931, Gӧdel showed that limits on deduction do exist. His incompleteness theorem showed that in any formal theory as strong as Peano arithmetic (the elementary theory of natural numbers), there are necessarily true statements that have no proof within the theory. This fundamental result can also be interpreted as showing that some functions on the integers cannot be represented by an algorithm—that is, they cannot be computed. This motivated Alan Turing (1912–1954) to try to characterize exactly which functions are computable—capable of being computed by an effective procedure. The Church–Turing thesis proposes to identify the general notion of computability with functions computed by a Turing machine (Turing, 1936). Turing also showed that there were some functions that no Turing machine can compute. For example, no machine can tell in general whether a given program will return an answer on a given input or run forever. Although computability is important to an understanding of computation, the notion of tractability has had an even greater impact on AI. Roughly speaking, a problem is called intractable if the time required to solve instances of the problem grows exponentially with the size of the instances. The distinction between polynomial and exponential growth in complexity was first emphasized in the mid-1960s (Cobham, 1964; Edmonds, 1965). It is important because exponential growth means that even moderately large instances cannot be solved in any reasonable time. The theory of NP-completeness, pioneered by Cook (1971) and Karp (1972), provides a basis for analyzing the tractability of problems: any problem class to which the class of NP-complete problems can be reduced is likely to be intractable. (Although it has not been proved that NP-complete problems are necessarily intractable, most theoreticians believe it. ) These results contrast with the optimism with which the popular press greeted the first computers—“Electronic Super-Brains” that were “Faster than Einstein! ” Despite the increasing speed of computers, careful use of resources and necessary imperfection will characterize intelligent systems. Put crudely, the world is an extremely large problem instance! 1. 2. 3Economics •How should we make decisions in accordance with our preferences? •How should we do this when others may not go along? •How should we do this when the payoff may be far in the future? The science of economics originated in 1776, when Adam Smith (1723–1790) published An Inquiry into the Nature and Causes of the Wealth of Nations. Smith proposed to analyze economies as consisting of many individual agents attending to their own interests. Smith was not, however, advocating financial greed as a moral position: his earlier (1759) book The Theory of Moral Sentiments begins by pointing out that concern for the well-being of others is an essential component of the interests of every individual. Most people think of economics as being about money, and indeed the first mathematical analysis of decisions under uncertainty, the maximum-expected-value formula of Arnauld (1662), dealt with the monetary value of bets. Daniel Bernoulli (1738) noticed that this formula didn’t seem to work well for larger amounts of money, such as investments in maritime trading expeditions. He proposed instead a principle based on maximization of expected utility, and explained human investment choices by proposing that the marginal utility of an additional quantity of money diminished as one acquired more money. Léon Walras (pronounced “Valrasse”) (1834–1910) gave utility theory a more general foundation in terms of preferences between gambles on any outcomes (not just monetary outcomes). The theory was improved by Ramsey (1931) and later by John von Neumann and Oskar Morgenstern in their book The Theory of Games and Economic Behavior (1944). Economics is no longer the study of money; rather it is the study of desires and preferences. Decision theory, which combines probability theory with utility theory, provides a formal and complete framework for individual decisions (economic or otherwise) made under uncertainty—that is, in cases where probabilistic descriptions appropriately capture the decision maker’s environment. This is suitable for “large” economies where each agent need pay no attention to the actions of other agents as individuals. For “small” economies, the situation is much more like a game: the actions of one player can significantly affect the utility of another (either positively or negatively). Von Neumann and Morgenstern’s development of game theory (see also Luce and Raiffa, 1957) included the surprising result that, for some games, a rational agent should adopt policies that are (or least appear to be) randomized. Unlike decision theory, game theory does not offer an unambiguous prescription for selecting actions. In AI, decisions involving multiple agents are studied under the heading of multiagent systems (Chapter 17). Economists, with some exceptions, did not address the third question listed above: how to make rational decisions when payoffs from actions are not immediate but instead result from several actions taken in sequence. This topic was pursued in the field of operations research, which emerged in World War II from efforts in Britain to optimize radar installations, and later found innumerable civilian applications. The work of Richard Bellman (1957) formalized a class of sequential decision problems called Markov decision processes, which we study in Chapter 16 and, under the heading of reinforcement learning, in Chapter 23. Work in economics and operations research has contributed much to our notion of rational agents, yet for many years AI research developed along entirely separate paths. One reason was the apparent complexity of making rational decisions. The pioneering AI researcher Herbert Simon (1916–2001) won the Nobel Prize in economics in 1978 for his early work showing that models based on satisficing—making decisions that are “good enough, ” rather than laboriously calculating an optimal decision—gave a better description of actual human behavior (Simon, 1947). Since the 1990s, there has been a resurgence of interest in decision-theoretic techniques for AI. 1. 2. 4Neuroscience •How do brains process information? Neuroscience is the study of the nervous system, particularly the brain. Although the exact way in which the brain enables thought is one of the great mysteries of science, the fact that it does enable thought has been appreciated for thousands of years because of the evidence that strong blows to the head can lead to mental incapacitation. It has also long been known that human brains are somehow different; in about 335 BCE Aristotle wrote, “Of all the animals, man has the largest brain in proportion to his size. ”6 Still, it was not until the middle of the 18th century that the brain was widely recognized as the seat of consciousness. Before then, candidate locations included the heart and the spleen. Paul Broca’s (1824–1880) investigation of aphasia (speech deficit) in brain-damaged patients in 1861 initiated the study of the brain’s functional organization by identifying a localized area in the left hemisphere—now called Broca’s area—that is responsible for speech production. 7 By that time, it was known that the brain consisted largely of nerve cells, or neurons, but it was not until 1873 that Camillo Golgi (1843–1926) developed a staining technique allowing the observation of individual neurons (see Figure 1. 1). This technique was used by Santiago Ramon y Cajal (1852–1934) in his pioneering studies of neuronal organization. 8 It is now widely accepted that cognitive functions result from the electrochemical operation of these structures. That is, a collection of simple cells can lead to thought, action, and consciousness. In the pithy words of John Searle (1992), brains cause minds. Description The neuron consists of a cell body, which is also labeled Soma. The nucleus is present at the center of the cell body. Finger-like fibers labeled dendrites extend out from the cell body. A single long fiber extends into a tubular structure labeled axon. The other end of the axon branches further as tree-like projections labeled Axonal arborization. An axon from another neuron cell is shown to be in contact with one of the dendrites of the neuron cell in view. The region or junction of contact between the dendrite and one of the tree-like projections from another axon is labeled the synapse. Two of such synapses are shown at the end of the tree-like projections from the neuron in view. Figure 1. 1The parts of a nerve cell or neuron. Each neuron consists of a cell body, or soma, that contains a cell nucleus. Branching out from the cell body are a number of fibers called dendrites and a single long fiber called the axon. The axon stretches out for a long distance, much longer than the scale in this diagram indicates. Typically, an axon is 1 cm long (100 times the diameter of the cell body), but can reach up to 1 meter. A neuron makes connections with 10 to 100, 000 other neurons at junctions called synapses. Signals are propagated from neuron to neuron by a complicated electrochemical reaction. The signals control brain activity in the short term and also enable long-term changes in the connectivity of neurons. These mechanisms are thought to form the basis for learning in the brain. Most information processing goes on in the cerebral cortex, the outer layer of the brain. The basic organizational unit appears to be a column of tissue about 0. 5 mm in diameter, containing about 20, 000 neurons and extending the full depth of the cortex (about 4 mm in humans). We now have some data on the mapping between areas of the brain and the parts of the body that they control or from which they receive sensory input. Such mappings are able to change radically over the course of a few weeks, and some animals seem to have multiple maps. Moreover, we do not fully understand how other areas can take over functions when one area is damaged. There is almost no theory on how an individual memory is stored or on how higher-level cognitive functions operate. The measurement of intact brain activity began in 1929 with the invention by Hans Berger of the electroencephalograph (EEG). The development of functional magnetic resonance imaging (fMRI) (Ogawa et al. , 1990; Cabeza and Nyberg, 2001) is giving neuroscientists unprecedentedly detailed images of brain activity, enabling measurements that correspond in interesting ways to ongoing cognitive processes. These are augmented by advances in single-cell electrical recording of neuron activity and by the methods of optogenetics (Crick, 1999; Zemelman et al. , 2002; Han and Boyden, 2007), which allow both measurement and control of individual neurons modified to be light-sensitive. The development of brain-machine interfaces (Lebedev and Nicolelis, 2006) for both sensing and motor control not only promises to restore function to disabled individuals, but also sheds light on many aspects of neural systems. A remarkable finding from this work is that the brain is able to adjust itself to interface successfully with an external device, treating it in effect like another sensory organ or limb. Brains and digital computers have somewhat different properties. Figure 1. 2 shows that computers have a cycle time that is a million times faster than a brain. The brain makes up for that with far more storage and interconnection than even a high-end personal computer, although the largest supercomputers match the brain on some metrics. Futurists make much of these numbers, pointing to an approaching singularity at which computers reach a superhuman level of performance (Vinge, 1993; Kurzweil, 2005; Doctorow and Stross, 2012), and then rapidly improve themselves even further. But the comparisons of raw numbers are not especially informative. Even with a computer of virtually unlimited capacity, we still require further conceptual breakthroughs in our understanding of intelligence (see Chapter 29). Crudely put, without the right theory, faster machines just give you the wrong answer faster. Description The blocks are rectangular, pyramidal, and square in shape. A thin-walled transparent box with its top open is shown. The largest rectangular and pyramidal blocks are kept inside the transparent box. A small square block, two blocks of similar sizes, and a rectangular block that is slightly larger than the two square blocks are kept outside the transparent box. A pyramidal block is kept on the small square block and another pyramidal block is kept on one of the two similar-sized blocks. Figure 1. 2A crude comparison of a leading supercomputer, Summit (Feldman, 2017); a typical personal computer of 2019; and the human brain. Human brain power has not changed much in thousands of years, whereas supercomputers have improved from megaFLOPs in the 1960s to gigaFLOPs in the 1980s, teraFLOPs in the 1990s, petaFLOPs in 2008, and exaFLOPs in 2018 (1 exaFLOP = 1018 floating point operations per second). 1. 2. 5Psychology •How do humans and animals think and act? The origins of scientific psychology are usually traced to the work of the German physicist Hermann von Helmholtz (1821–1894) and his student Wilhelm Wundt (1832–1920). Helmholtz applied the scientific method to the study of human vision, and his Handbook of Physiological Optics has been described as “the single most important treatise on the physics and physiology of human vision” (Nalwa, 1993, p. 15). In 1879, Wundt opened the first laboratory of experimental psychology, at the University of Leipzig. Wundt insisted on carefully controlled experiments in which his workers would perform a perceptual or associative task while introspecting on their thought processes. The careful controls went a long way toward making psychology a science, but the subjective nature of the data made it unlikely that experimenters would ever disconfirm their own theories. Biologists studying animal behavior, on the other hand, lacked introspective data and developed an objective methodology, as described by H. S. Jennings (1906) in his influential work Behavior of the Lower Organisms. Applying this viewpoint to humans, the behaviorism movement, led by John Watson (1878–1958), rejected any theory involving mental processes on the grounds that introspection could not provide reliable evidence. Behaviorists insisted on studying only objective measures of the percepts (or stimulus) given to an animal and its resulting actions (or response). Behaviorism discovered a lot about rats and pigeons but had less success at understanding humans. Cognitive psychology, which views the brain as an information-processing device, can be traced back at least to the works of William James (1842–1910). Helmholtz also insisted that perception involved a form of unconscious logical inference. The cognitive viewpoint was largely eclipsed by behaviorism in the United States, but at Cambridge’s Applied Psychology Unit, directed by Frederic Bartlett (1886–1969), cognitive modeling was able to flourish. The Nature of Explanation, by Bartlett’s student and successor Kenneth Craik (1943), forcefully reestablished the legitimacy of such “mental” terms as beliefs and goals, arguing that they are just as scientific as, say, using pressure and temperature to talk about gases, despite gasses being made of molecules that have neither. Craik specified the three key steps of a knowledge-based agent: (1) the stimulus must be translated into an internal representation, (2) the representation is manipulated by cognitive processes to derive new internal representations, and (3) these are in turn retranslated back into action. He clearly explained why this was a good design for an agent: If the organism carries a “small-scale model” of external reality and of its own possible actions within its head, it is able to try out various alternatives, conclude which is the best of them, react to future situations before they arise, utilize the knowledge of past events in dealing with the present and future, and in every way to react in a much fuller, safer, and more competent manner to the emergencies which face it. (Craik, 1943) After Craik’s death in a bicycle accident in 1945, his work was continued by Donald Broadbent, whose book Perception and Communication (1958) was one of the first works to model psychological phenomena as information processing. Meanwhile, in the United States, the development of computer modeling led to the creation of the field of cognitive science. The field can be said to have started at a workshop in September 1956 at MIT—just two months after the conference at which AI itself was “born. ” At the workshop, George Miller presented The Magic Number Seven, Noam Chomsky presented Three Models of Language, and Allen Newell and Herbert Simon presented The Logic Theory Machine. These three influential papers showed how computer models could be used to address the psychology of memory, language, and logical thinking, respectively. It is now a common (although far from universal) view among psychologists that “a cognitive theory should be like a computer program” (Anderson, 1980); that is, it should describe the operation of a cognitive function in terms of the processing of information. For purposes of this review, we will count the field of human–computer interaction (HCI) under psychology. Doug Engelbart, one of the pioneers of HCI, championed the idea of intelligence augmentation—IA rather than AI. He believed that computers should augment human abilities rather than automate away human tasks. In 1968, Engelbart’s “mother of all demos” showed off for the first time the computer mouse, a windowing system, hypertext, and video conferencing—all in an effort to demonstrate what human knowledge workers could collectively accomplish with some intelligence augmentation. Today we are more likely to see IA and AI as two sides of the same coin, with the former emphasizing human control and the latter emphasizing intelligent behavior on the part of the machine. Both are needed for machines to be useful to humans. 1. 2. 6Computer engineering •How can we build an efficient computer? The modern digital electronic computer was invented independently and almost simultaneously by scientists in three countries embattled in World War II. The first operational computer was the electromechanical Heath Robinson, 9 built in 1943 by Alan Turing’s team for a single purpose: deciphering German messages. In 1943, the same group developed the Colossus, a powerful general-purpose machine based on vacuum tubes. 10 The first operational programmable computer was the Z-3, the invention of Konrad Zuse in Germany in 1941. Zuse also invented floating-point numbers and the first high-level programming language, Plankalkül. The first electronic computer, the ABC, was assembled by John Atanasoff and his student Clifford Berry between 1940 and 1942 at Iowa State University. Atanasoff’s research received little support or recognition; it was the ENIAC, developed as part of a secret military project at the University of Pennsylvania by a team including John Mauchly and J. Presper Eckert, that proved to be the most influential forerunner of modern computers. Since that time, each generation of computer hardware has brought an increase in speed and capacity and a decrease in price—a trend captured in Moore’s law. Performance doubled every 18 months or so until around 2005, when power dissipation problems led manufacturers to start multiplying the number of CPU cores rather than the clock speed. Current expectations are that future increases in functionality will come from massive parallelism—a curious convergence with the properties of the brain. We also see new hardware designs based on the idea that in dealing with an uncertain world, we don’t need 64 bits of precision in our numbers; just 16 bits (as in the bfloat16 format) or even 8 bits will be enough, and will enable faster processing. We are just beginning to see hardware tuned for AI applications, such as the graphics processing unit (GPU), tensor processing unit (TPU), and wafer scale engine (WSE). From the 1960s to about 2012, the amount of computing power used to train top machine learning applications followed Moore’s law. Beginning in 2012, things changed: from 2012 to 2018 there was a 300, 000-fold increase, which works out to a doubling every 100 days or so (Amodei and Hernandez, 2018). A machine learning model that took a full day to train in 2014 takes only two minutes in 2018 (Ying et al. , 2018). Although it is not yet practical, quantum computing holds out the promise of far greater accelerations for some important subclasses of AI algorithms. Of course, there were calculating devices before the electronic computer. The earliest automated machines, dating from the 17th century, were discussed on page 24. The first programmable machine was a loom, devised in 1805 by Joseph Marie Jacquard (1752–1834), that used punched cards to store instructions for the pattern to be woven. In the mid-19th century, Charles Babbage (1792–1871) designed two computing machines, neither of which he completed. The Difference Engine was intended to compute mathematical tables for engineering and scientific projects. It was finally built and shown to work in 1991 (Swade, 2000). Babbage’s Analytical Engine was far more ambitious: it included addressable memory, stored programs based on Jacquard’s punched cards, and conditional jumps. It was the first machine capable of universal computation. Babbage’s colleague Ada Lovelace, daughter of the poet Lord Byron, understood its potential, describing it as “a thinking or. . . a reasoning machine, ” one capable of reasoning about “all subjects in the universe” (Lovelace, 1843). She also anticipated AI’s hype cycles, writing, “It is desirable to guard against the possibility of exaggerated ideas that might arise as to the powers of the Analytical Engine. ” Unfortunately, Babbage’s machines and Lovelace’s ideas were largely forgotten. AI also owes a debt to the software side of computer science, which has supplied the operating systems, programming languages, and tools needed to write modern programs (and papers about them). But this is one area where the debt has been repaid: work in AI has pioneered many ideas that have made their way back to mainstream computer science, including time sharing, interactive interpreters, personal computers with windows and mice, rapid development environments, the linked-list data type, automatic storage management, and key concepts of symbolic, functional, declarative, and object-oriented programming. 1. 2. 7Control theory and cybernetics •How can artifacts operate under their own control? Ktesibios of Alexandria (c. 250 BCE) built the first self-controlling machine: a water clock with a regulator that maintained a constant flow rate. This invention changed the definition of what an artifact could do. Previously, only living things could modify their behavior in response to changes in the environment. Other examples of self-regulating feedback control systems include the steam engine governor, created by James Watt (1736–1819), and the thermostat, invented by Cornelis Drebbel (1572–1633), who also invented the submarine. James Clerk Maxwell (1868) initiated the mathematical theory of control systems. A central figure in the post-war development of control theory was Norbert Wiener (1894–1964). Wiener was a brilliant mathematician who worked with Bertrand Russell, among others, before developing an interest in biological and mechanical control systems and their connection to cognition. Like Craik (who also used control systems as psychological models), Wiener and his colleagues Arturo Rosenblueth and Julian Bigelow challenged the behaviorist orthodoxy (Rosenblueth et al. , 1943). They viewed purposive behavior as arising from a regulatory mechanism trying to minimize “error”—the difference between current state and goal state. In the late 1940s, Wiener, along with Warren McCulloch, Walter Pitts, and John von Neumann, organized a series of influential conferences that explored the new mathematical and computational models of cognition. Wiener’s book Cybernetics (1948) became a bestseller and awoke the public to the possibility of artificially intelligent machines. Meanwhile, in Britain, W. Ross Ashby pioneered similar ideas (Ashby, 1940). Ashby, Alan Turing, Grey Walter, and others formed the Ratio Club for “those who had Wiener’s ideas before Wiener’s book appeared. ” Ashby’s Design for a Brain (1948, 1952) elaborated on his idea that intelligence could be created by the use of homeostatic devices containing appropriate feedback loops to achieve stable adaptive behavior. Modern control theory, especially the branch known as stochastic optimal control, has as its goal the design of systems that minimize a cost function over time. This roughly matches the standard model of AI: designing systems that behave optimally. Why, then, are AI and control theory two different fields, despite the close connections among their founders? The answer lies in the close coupling between the mathematical techniques that were familiar to the participants and the corresponding sets of problems that were encompassed in each world view. Calculus and matrix algebra, the tools of control theory, lend themselves to systems that are describable by fixed sets of continuous variables, whereas AI was founded in part as a way to escape from these perceived limitations. The tools of logical inference and computation allowed AI researchers to consider problems such as language, vision, and symbolic planning that fell completely outside the control theorist’s purview. 1. 2. 8Linguistics •How does language relate to thought? In 1957, B. F. Skinner published Verbal Behavior. This was a comprehensive, detailed account of the behaviorist approach to language learning, written by the foremost expert in the field. But curiously, a review of the book became as well known as the book itself, and served to almost kill off interest in behaviorism. The author of the review was the linguist Noam Chomsky, who had just published a book on his own theory, Syntactic Structures. Chomsky pointed out that the behaviorist theory did not address the notion of creativity in language—it did not explain how children could understand and make up sentences that they had never heard before. Chomsky’s theory—based on syntactic models going back to the Indian linguist Panini (c. 350 BCE)—could explain this, and unlike previous theories, it was formal enough that it could in principle be programmed. Modern linguistics and AI, then, were “born” at about the same time, and grew up together, intersecting in a hybrid field called computational linguistics or natural language processing. The problem of understanding language turned out to be considerably more complex than it seemed in 1957. Understanding language requires an understanding of the subject matter and context, not just an understanding of the structure of sentences. This might seem obvious, but it was not widely appreciated until the 1960s. Much of the early work in knowledge representation (the study of how to put knowledge into a form that a computer can reason with) was tied to language and informed by research in linguistics, which was connected in turn to decades of work on the philosophical analysis of language. 1. 3The History of Artificial Intelligence One quick way to summarize the milestones in AI history is to list the Turing Award winners: Marvin Minsky (1969) and John McCarthy (1971) for defining the foundations of the field based on representation and reasoning; Allen Newell and Herbert Simon (1975) for symbolic models of problem solving and human cognition; Ed Feigenbaum and Raj Reddy (1994) for developing expert systems that encode human knowledge to solve real-world problems; Judea Pearl (2011) for developing probabilistic reasoning techniques that deal with uncertainty in a principled manner; and finally Yoshua Bengio, Geoffrey Hinton, and Yann LeCun (2019) for making “deep learning” (multilayer neural networks) a critical part of modern computing. The rest of this section goes into more detail on each phase of AI history. 1. 3. 1The inception of artificial intelligence (1943–1956) The first work that is now generally recognized as AI was done by Warren McCulloch and Walter Pitts (1943). Inspired by the mathematical modeling work of Pitts’s advisor Nicolas Rashevsky (1936, 1938), they drew on three sources: knowledge of the basic physiology and function of neurons in the brain; a formal analysis of propositional logic due to Russell and Whitehead; and Turing’s theory of computation. They proposed a model of artificial neurons in which each neuron is characterized as being “on” or “off, ” with a switch to “on” occurring in response to stimulation by a sufficient number of neighboring neurons. The state of a neuron was conceived of as “factually equivalent to a proposition which proposed its adequate stimulus. ” They showed, for example, that any computable function could be computed by some network of connected neurons, and that all the logical connectives (AND, OR, NOT, etc. ) could be implemented by simple network structures. McCulloch and Pitts also suggested that suitably defined networks could learn. Donald Hebb (1949) demonstrated a simple updating rule for modifying the connection strengths between neurons. His rule, now called Hebbian learning, remains an influential model to this day. Two undergraduate students at Harvard, Marvin Minsky (1927–2016) and Dean Edmonds, built the first neural network computer in 1950. The SNARC, as it was called, used 3000 vacuum tubes and a surplus automatic pilot mechanism from a B-24 bomber to simulate a network of 40 neurons. Later, at Princeton, Minsky studied universal computation in neural networks. His Ph. D. committee was skeptical about whether this kind of work should be considered mathematics, but von Neumann reportedly said, “If it isn’t now, it will be someday. ” There were a number of other examples of early work that can be characterized as AI, including two checkers-playing programs developed independently in 1952 by Christopher Strachey at the University of Manchester and by Arthur Samuel at IBM. However, Alan Turing’s vision was the most influential. He gave lectures on the topic as early as 1947 at the London Mathematical Society and articulated a persuasive agenda in his 1950 article “Computing Machinery and Intelligence. ” Therein, he introduced the Turing test, machine learning, genetic algorithms, and reinforcement learning. He dealt with many of the objections raised to the possibility of AI, as described in Chapter 28. He also suggested that it would be easier to create human-level AI by developing learning algorithms and then teaching the machine rather than by programming its intelligence by hand. In subsequent lectures he warned that achieving this goal might not be the best thing for the human race. In 1955, John McCarthy of Dartmouth College convinced Minsky, Claude Shannon, and Nathaniel Rochester to help him bring together U. S. researchers interested in automata theory, neural nets, and the study of intelligence. They organized a two-month workshop at Dartmouth in the summer of 1956. There were 10 attendees in all, including Allen Newell and Herbert Simon from Carnegie Tech, 11 Trenchard More from Princeton, Arthur Samuel from IBM, and Ray Solomonoff and Oliver Selfridge from MIT. The proposal states: 12 We propose that a 2 month, 10 man study of artificial intelligence be carried out during the summer of 1956 at Dartmouth College in Hanover, New Hampshire. The study is to proceed on the basis of the conjecture that every aspect of learning or any other feature of intelligence can in principle be so precisely described that a machine can be made to simulate it. An attempt will be made to find how to make machines use language, form abstractions and concepts, solve kinds of problems now reserved for humans, and improve themselves. We think that a significant advance can be made in one or more of these problems if a carefully selected group of scientists work on it together for a summer. Despite this optimistic prediction, the Dartmouth workshop did not lead to any breakthroughs. Newell and Simon presented perhaps the most mature work, a mathematical theorem-proving system called the Logic Theorist (LT). Simon claimed, “We have invented a computer program capable of thinking non-numerically, and thereby solved the venerable mind–body problem. ”13 Soon after the workshop, the program was able to prove most of the theorems in Chapter 2 of Russell and Whitehead’s Principia Mathematica. Russell was reportedly delighted when told that LT had come up with a proof for one theorem that was shorter than the one in Principia. The editors of the Journal of Symbolic Logic were less impressed; they rejected a paper coauthored by Newell, Simon, and Logic Theorist. 1. 3. 2Early enthusiasm, great expectations (1952–1969) The intellectual establishment of the 1950s, by and large, preferred to believe that “a machine can never do X. ” (See Chapter 28 for a long list of X’s gathered by Turing. ) AI researchers naturally responded by demonstrating one X after another. They focused in particular on tasks considered indicative of intelligence in humans, including games, puzzles, mathematics, and IQ tests. John McCarthy referred to this period as the “Look, Ma, no hands! ” era. Newell and Simon followed up their success with LT with the General Problem Solver, or GPS. Unlike LT, this program was designed from the start to imitate human problem-solving protocols. Within the limited class of puzzles it could handle, it turned out that the order in which the program considered subgoals and possible actions was similar to that in which humans approached the same problems. Thus, GPS was probably the first program to embody the “thinking humanly” approach. The success of GPS and subsequent programs as models of cognition led Newell and Simon (1976) to formulate the famous physical symbol system hypothesis, which states that “a physical symbol system has the necessary and sufficient means for general intelligent action. ” What they meant is that any system (human or machine) exhibiting intelligence must operate by manipulating data structures composed of symbols. We will see later that this hypothesis has been challenged from many directions. At IBM, Nathaniel Rochester and his colleagues produced some of the first AI programs. Herbert Gelernter (1959) constructed the Geometry Theorem Prover, which was able to prove theorems that many students of mathematics would find quite tricky. This work was a precursor of modern mathematical theorem provers. Of all the exploratory work done during this period, perhaps the most influential in the long run was that of Arthur Samuel on checkers (draughts). Using methods that we now call reinforcement learning (see Chapter 23), Samuel’s programs learned to play at a strong amateur level. He thereby disproved the idea that computers can do only what they are told to: his program quickly learned to play a better game than its creator. The program was demonstrated on television in 1956, creating a strong impression. Like Turing, Samuel had trouble finding computer time. Working at night, he used machines that were still on the testing floor at IBM’s manufacturing plant. Samuel’s program was the precursor of later systems such as TD-GAMMON (Tesauro, 1992), which was among the world’s best backgammon players, and ALPHAGO (Silver et al. , 2016), which shocked the world by defeating the human world champion at Go (see Chapter 6). In 1958, John McCarthy made two important contributions to AI. In MIT AI Lab Memo No. 1, he defined the high-level language Lisp, which was to become the dominant AI programming language for the next 30 years. In a paper entitled Programs with Common Sense, he advanced a conceptual proposal for AI systems based on knowledge and reasoning. The paper describes the Advice Taker, a hypothetical program that would embody general knowledge of the world and could use it to derive plans of action. The concept was illustrated with simple logical axioms that suffice to generate a plan to drive to the airport. The program was also designed to accept new axioms in the normal course of operation, thereby allowing it to achieve competence in new areas without being reprogrammed. The Advice Taker thus embodied the central principles of knowledge representation and reasoning: that it is useful to have a formal, explicit representation of the world and its workings and to be able to manipulate that representation with deductive processes. The paper influenced the course of AI and remains relevant today. 1958 also marked the year that Marvin Minsky moved to MIT. His initial collaboration with McCarthy did not last, however. McCarthy stressed representation and reasoning in formal logic, whereas Minsky was more interested in getting programs to work and eventually developed an anti-logic outlook. In 1963, McCarthy started the AI lab at Stanford. His plan to use logic to build the ultimate Advice Taker was advanced by J. A. Robinson’s discovery in 1965 of the resolution method (a complete theorem-proving algorithm for first-order logic; see Chapter 9). Work at Stanford emphasized general-purpose methods for logical reasoning. Applications of logic included Cordell Green’s question-answering and planning systems (Green, 1969b) and the Shakey robotics project at the Stanford Research Institute (SRI). The latter project, discussed further in Chapter 26, was the first to demonstrate the complete integration of logical reasoning and physical activity. At MIT, Minsky supervised a series of students who chose limited problems that appeared to require intelligence to solve. These limited domains became known as microworlds. James Slagle’s SAINT program (1963) was able to solve closed-form calculus integration problems typical of first-year college courses. Tom Evans’s ANALOGY program (1968) solved geometric analogy problems that appear in IQ tests. Daniel Bobrow’s STUDENT program (1967) solved algebra story problems, such as the following: If the number of customers Tom gets is twice the square of 20 percent of the number of advertisements he runs, and the number of advertisements he runs is 45, what is the number of customers Tom gets? The most famous microworld is the blocks world, which consists of a set of solid blocks placed on a tabletop (or more often, a simulation of a tabletop), as shown in Figure 1. 3. A typical task in this world is to rearrange the blocks in a certain way, using a robot hand that can pick up one block at a time. The blocks world was home to the vision project of David Huffman (1971), the vision and constraint-propagation work of David Waltz (1975), the learning theory of Patrick Winston (1970), the natural-language-understanding program of Terry Winograd (1972), and the planner of Scott Fahlman (1974). Figure 1. 3A scene from the blocks world. SHRDLU (Winograd, 1972) has just completed the command “Find a block which is taller than the one you are holding and put it in the box. ” Early work building on the neural networks of McCulloch and Pitts also flourished. The work of Shmuel Winograd and Jack Cowan (1963) showed how a large number of elements could collectively represent an individual concept, with a corresponding increase in robustness and parallelism. Hebb’s learning methods were enhanced by Bernie Widrow (Widrow and Hoff, 1960; Widrow, 1962), who called his networks adalines, and by Frank Rosenblatt (1962) with his perceptrons. The perceptron convergence theorem (Block et al. , 1962) says that the learning algorithm can adjust the connection strengths of a perceptron to match any input data, provided such a match exists. 1. 3. 3A dose of reality (1966–1973) From the beginning, AI researchers were not shy about making predictions of their coming successes. The following statement by Herbert Simon in 1957 is often quoted: It is not my aim to surprise or shock you—but the simplest way I can summarize is to say that there are now in the world machines that think, that learn and that create. Moreover, their ability to do these things is going to increase rapidly until—in a visible future—the range of problems they can handle will be coextensive with the range to which the human mind has been applied. The term “visible future” is vague, but Simon also made more concrete predictions: that within 10 years a computer would be chess champion and a significant mathematical theorem would be proved by machine. These predictions came true (or approximately true) within 40 years rather than 10. Simon’s overconfidence was due to the promising performance of early AI systems on simple examples. In almost all cases, however, these early systems failed on more difficult problems. There were two main reasons for this failure. The first was that many early AI systems were based primarily on “informed introspection” as to how humans perform a task, rather than on a careful analysis of the task, what it means to be a solution, and what an algorithm would need to do to reliably produce such solutions. The second reason for failure was a lack of appreciation of the intractability of many of the problems that AI was attempting to solve. Most of the early problem-solving systems worked by trying out different combinations of steps until the solution was found. This strategy worked initially because microworlds contained very few objects and hence very few possible actions and very short solution sequences. Before the theory of computational complexity was developed, it was widely thought that “scaling up” to larger problems was simply a matter of faster hardware and larger memories. The optimism that accompanied the development of resolution theorem proving, for example, was soon dampened when researchers failed to prove theorems involving more than a few dozen facts. The fact that a program can find a solution in principle does not mean that the program contains any of the mechanisms needed to find it in practice. The illusion of unlimited computational power was not confined to problem-solving programs. Early experiments in machine evolution (now called genetic programming) (Friedberg, 1958; Friedberg et al. , 1959) were based on the undoubtedly correct belief that by making an appropriate series of small mutations to a machine-code program, one can generate a program with good performance for any particular task. The idea, then, was to try random mutations with a selection process to preserve mutations that seemed useful. Despite thousands of hours of CPU time, almost no progress was demonstrated. Failure to come to grips with the “combinatorial explosion” was one of the main criticisms of AI contained in the Lighthill report (Lighthill, 1973), which formed the basis for the decision by the British government to end support for AI research in all but two universities. (Oral tradition paints a somewhat different and more colorful picture, with political ambitions and personal animosities whose description is beside the point. ) A third difficulty arose because of some fundamental limitations on the basic structures being used to generate intelligent behavior. For example, Minsky and Papert’s book Perceptrons (1969) proved that, although perceptrons (a simple form of neural network) could be shown to learn anything they were capable of representing, they could represent very little. In particular, a two-input perceptron could not be trained to recognize when its two inputs were different. Although their results did not apply to more complex, multilayer networks, research funding for neural-net research soon dwindled to almost nothing. Ironically, the new back-propagation learning algorithms that were to cause an enormous resurgence in neural-net research in the late 1980s and again in the 2010s had already been developed in other contexts in the early 1960s (Kelley, 1960; Bryson, 1962). 1. 3. 4Expert systems (1969–1986) The picture of problem solving that had arisen during the first decade of AI research was of a general-purpose search mechanism trying to string together elementary reasoning steps to find complete solutions. Such approaches have been called weak methods because, although general, they do not scale up to large or difficult problem instances. The alternative to weak methods is to use more powerful, domain-specific knowledge that allows larger reasoning steps and can more easily handle typically occurring cases in narrow areas of expertise. One might say that to solve a hard problem, you have to almost know the answer already. The DENDRAL program (Buchanan et al. , 1969) was an early example of this approach. It was developed at Stanford, where Ed Feigenbaum (a former student of Herbert Simon), Bruce Buchanan (a philosopher turned computer scientist), and Joshua Lederberg (a Nobel laureate geneticist) teamed up to solve the problem of inferring molecular structure from the information provided by a mass spectrometer. The input to the program consists of the elementary formula of the molecule (e. g. , C6H13NO2) and the mass spectrum giving the masses of the various fragments of the molecule generated when it is bombarded by an electron beam. For example, the mass spectrum might contain a peak at m = 15, corresponding to the mass of a methyl (CH3) fragment. The naive version of the program generated all possible structures consistent with the formula, and then predicted what mass spectrum would be observed for each, comparing this with the actual spectrum. As one might expect, this is intractable for even moderate-sized molecules. The DENDRAL researchers consulted analytical chemists and found that they worked by looking for well-known patterns of peaks in the spectrum that suggested common substructures in the molecule. For example, the following rule is used to recognize a ketone (C=O) subgroup (which weighs 28): if M is the mass of the whole molecule and there are two peaks at x1 and x2 such that (a) x1 + x2 = M + 28; (b) x1 – 28 is a high peak; (c) x2 – 28 is a high peak; and (d) At least one of x1 and x2 is high then there is a ketone subgroup. Recognizing that the molecule contains a particular substructure reduces the number of possible candidates enormously. According to its authors, DENDRAL was powerful because it embodied the relevant knowledge of mass spectroscopy not in the form of first principles but in efficient “cookbook recipes” (Feigenbaum et al. , 1971). The significance of DENDRAL was that it was the first successful knowledge-intensive system: its expertise derived from large numbers of special-purpose rules. In 1971, Feigenbaum and others at Stanford began the Heuristic Programming Project (HPP) to investigate the extent to which the new methodology of expert systems could be applied to other areas. The next major effort was the MYCIN system for diagnosing blood infections. With about 450 rules, MYCIN was able to perform as well as some experts, and considerably better than junior doctors. It also contained two major differences from DENDRAL. First, unlike the DENDRAL rules, no general theoretical model existed from which the MYCIN rules could be deduced. They had to be acquired from extensive interviewing of experts. Second, the rules had to reflect the uncertainty associated with medical knowledge. MYCIN incorporated a calculus of uncertainty called certainty factors (see Chapter 13), which seemed (at the time) to fit well with how doctors assessed the impact of evidence on the diagnosis. The first successful commercial expert system, R1, began operation at the Digital Equipment Corporation (McDermott, 1982). The program helped configure orders for new computer systems; by 1986, it was saving the company an estimated $40 million a year. By 1988, DEC’s AI group had 40 expert systems deployed, with more on the way. DuPont had 100 in use and 500 in development. Nearly every major U. S. corporation had its own AI group and was either using or investigating expert systems. The importance of domain knowledge was also apparent in the area of natural language understanding. Despite the success of Winograd’s SHRDLU system, its methods did not extend to more general tasks: for problems such as ambiguity resolution it used simple rules that relied on the tiny scope of the blocks world. Several researchers, including Eugene Charniak at MIT and Roger Schank at Yale, suggested that robust language understanding would require general knowledge about the world and a general method for using that knowledge. (Schank went further, claiming, “There is no such thing as syntax, ” which upset a lot of linguists but did serve to start a useful discussion. ) Schank and his students built a series of programs (Schank and Abelson, 1977; Wilensky, 1978; Schank and Riesbeck, 1981) that all had the task of understanding natural language. The emphasis, however, was less on language per se and more on the problems of representing and reasoning with the knowledge required for language understanding. The widespread growth of applications to real-world problems led to the development of a wide range of representation and reasoning tools. Some were based on logic—for example, the Prolog language became popular in Europe and Japan, and the PLANNER family in the United States. Others, following Minsky’s idea of frames (1975), adopted a more structured approach, assembling facts about particular object and event types and arranging the types into a large taxonomic hierarchy analogous to a biological taxonomy. In 1981, the Japanese government announced the “Fifth Generation” project, a 10-year plan to build massively parallel, intelligent computers running Prolog. The budget was to exceed a $1. 3 billion in today’s money. In response, the United States formed the Microelectronics and Computer Technology Corporation (MCC), a consortium designed to assure national competitiveness. In both cases, AI was part of a broad effort, including chip design and human-interface research. In Britain, the Alvey report reinstated the funding removed by the Lighthill report. However, none of these projects ever met its ambitious goals in terms of new AI capabilities or economic impact. Overall, the AI industry boomed from a few million dollars in 1980 to billions of dollars in 1988, including hundreds of companies building expert systems, vision systems, robots, and software and hardware specialized for these purposes. Soon after that came a period called the “AI winter, ” in which many companies fell by the wayside as they failed to deliver on extravagant promises. It turned out to be difficult to build and maintain expert systems for complex domains, in part because the reasoning methods used by the systems broke down in the face of uncertainty and in part because the systems could not learn from experience. 1. 3. 5The return of neural networks (1986–present) In the mid-1980s at least four different groups reinvented the back-propagation learning algorithm first developed in the early 1960s. The algorithm was applied to many learning problems in computer science and psychology, and the widespread dissemination of the results in the collection Parallel Distributed Processing (Rumelhart and McClelland, 1986) caused great excitement. These so-called connectionist models were seen by some as direct competitors both to the symbolic models promoted by Newell and Simon and to the logicist approach of McCarthy and others. It might seem obvious that at some level humans manipulate symbols—in fact, the anthropologist Terrence Deacon’s book The Symbolic Species (1997) suggests that this is the defining characteristic of humans. Against this, Geoff Hinton, a leading figure in the resurgence of neural networks in the 1980s and 2010s, has described symbols as the “luminiferous aether of AI”—a reference to the non-existent medium through which many 19th-century physicists believed that electromagnetic waves propagated. Certainly, many concepts that we name in language fail, on closer inspection, to have the kind of logically defined necessary and sufficient conditions that early AI researchers hoped to capture in axiomatic form. It may be that connectionist models form internal concepts in a more fluid and imprecise way that is better suited to the messiness of the real world. They also have the capability to learn from examples—they can compare their predicted output value to the true value on a problem and modify their parameters to decrease the difference, making them more likely to perform well on future examples. 1. 3. 6Probabilistic reasoning and machine learning (1987–present) The brittleness of expert systems led to a new, more scientific approach incorporating probability rather than Boolean logic, machine learning rather than hand-coding, and experimental results rather than philosophical claims. 14 It became more common to build on existing theories than to propose brand-new ones, to base claims on rigorous theorems or solid experimental methodology (Cohen, 1995) rather than on intuition, and to show relevance to real-world applications rather than toy examples. Shared benchmark problem sets became the norm for demonstrating progress, including the UC Irvine repository for machine learning data sets, the International Planning Competition for planning algorithms, the LibriSpeech corpus for speech recognition, the MNIST data set for handwritten digit recognition, ImageNet and COCO for image object recognition, SQUAD for natural language question answering, the WMT competition for machine translation, and the International SAT Competitions for Boolean satisfiability solvers. AI was founded in part as a rebellion against the limitations of existing fields like control theory and statistics, but in this period it embraced the positive results of those fields. As David McAllester (1998) put it: In the early period of AI it seemed plausible that new forms of symbolic computation, e. g. , frames and semantic networks, made much of classical theory obsolete. This led to a form of isolationism in which AI became largely separated from the rest of computer science. This isolationism is currently being abandoned. There is a recognition that machine learning should not be isolated from information theory, that uncertain reasoning should not be isolated from stochastic modeling, that search should not be isolated from classical optimization and control, and that automated reasoning should not be isolated from formal methods and static analysis. The field of speech recognition illustrates the pattern. In the 1970s, a wide variety of different architectures and approaches were tried. Many of these were rather ad hoc and fragile, and worked on only a few carefully selected examples. In the 1980s, approaches using hidden Markov models (HMMs) came to dominate the area. Two aspects of HMMs are relevant. First, they are based on a rigorous mathematical theory. This allowed speech researchers to build on several decades of mathematical results developed in other fields. Second, they are generated by a process of training on a large corpus of real speech data. This ensures that the performance is robust, and in rigorous blind tests HMMs improved their scores steadily. As a result, speech technology and the related field of handwritten character recognition made the transition to widespread industrial and consumer applications. Note that there was no scientific claim that humans use HMMs to recognize speech; rather, HMMs provided a mathematical framework for understanding and solving the problem. We will see in Section 1. 3. 8, however, that deep learning has rather upset this comfortable narrative. 1988 was an important year for the connection between AI and other fields, including statistics, operations research, decision theory, and control theory. Judea Pearl’s (1988) Probabilistic Reasoning in Intelligent Systems led to a new acceptance of probability and decision theory in AI. Pearl’s development of Bayesian networks yielded a rigorous and efficient formalism for representing uncertain knowledge as well as practical algorithms for probabilistic reasoning. Chapters 12, 13, 14, 15, and 18 cover this area, in addition to more recent developments that have greatly increased the expressive power of probabilistic formalisms; Chapter 21 describes methods for learning Bayesian networks and related models from data. A second major contribution in 1988 was Rich Sutton’s work connecting reinforcement learning—which had been used in Arthur Samuel’s checker-playing program in the 1950s—to the theory of Markov decision processes (MDPs) developed in the field of operations research. A flood of work followed connecting AI planning research to MDPs, and the field of reinforcement learning found applications in robotics and process control as well as acquiring deep theoretical foundations. One consequence of AI’s newfound appreciation for data, statistical modeling, optimization, and machine learning was the gradual reunification of subfields such as computer vision, robotics, speech recognition, multiagent systems, and natural language processing that had become somewhat separate from core AI. The process of reintegration has yielded significant benefits both in terms of applications—for example, the deployment of practical robots expanded greatly during this period—and in a better theoretical understanding of the core problems of AI. 1. 3. 7Big data (2001–present) Remarkable advances in computing power and the creation of the World Wide Web have facilitated the creation of very large data sets—a phenomenon sometimes known as big data. These data sets include trillions of words of text, billions of images, and billions of hours of speech and video, as well as vast amounts of genomic data, vehicle tracking data, clickstream data, social network data, and so on. This has led to the development of learning algorithms specially designed to take advantage of very large data sets. Often, the vast majority of examples in such data sets are unlabeled; for example, in Yarowsky’s (1995) influential work on word-sense disambiguation, occurrences of a word such as “plant” are not labeled in the data set to indicate whether they refer to flora or factory. With large enough data sets, however, suitable learning algorithms can achieve an accuracy of over 96% on the task of identifying which sense was intended in a sentence. Moreover, Banko and Brill (2001) argued that the improvement in performance obtained from increasing the size of the data set by two or three orders of magnitude outweighs any improvement that can be obtained from tweaking the algorithm. A similar phenomenon seems to occur in computer vision tasks such as filling in holes in photographs—holes caused either by damage or by the removal of ex-friends. Hays and Efros (2007) developed a clever method for doing this by blending in pixels from similar images; they found that the technique worked poorly with a database of only thousands of images but crossed a threshold of quality with millions of images. Soon after, the availability of tens of millions of images in the ImageNet database (Deng et al. , 2009) sparked a revolution in the field of computer vision. The availability of big data and the shift towards machine learning helped AI recover commercial attractiveness (Havenstein, 2005; Halevy et al. , 2009). Big data was a crucial factor in the 2011 victory of IBM’s Watson system over human champions in the Jeopardy! quiz game, an event that had a major impact on the public’s perception of AI. 1. 3. 8Deep learning (2011–present) The term deep learning refers to machine learning using multiple layers of simple, adjustable computing elements. Experiments were carried out with such networks as far back as the 1970s, and in the form of convolutional neural networks they found some success in hand-written digit recognition in the 1990s (LeCun et al. , 1995). It was not until 2011, however, that deep learning methods really took off. This occurred first in speech recognition and then in visual object recognition. In the 2012 ImageNet competition, which required classifying images into one of a thousand categories (armadillo, bookshelf, corkscrew, etc. ), a deep learning system created in Geoffrey Hinton’s group at the University of Toronto (Krizhevsky et al. , 2013) demonstrated a dramatic improvement over previous systems, which were based largely on handcrafted features. Since then, deep learning systems have exceeded human performance on some vision tasks (and lag behind in some other tasks). Similar gains have been reported in speech recognition, machine translation, medical diagnosis, and game playing. The use of a deep network to represent the evaluation function contributed to ALPHAGO’S victories over the leading human Go players (Silver et al. , 2016, 2017, 2018). These remarkable successes have led to a resurgence of interest in AI among students, companies, investors, governments, the media, and the general public. It seems that every week there is news of a new AI application approaching or exceeding human performance, often accompanied by speculation of either accelerated success or a new AI winter. Deep learning relies heavily on powerful hardware. Whereas a standard computer CPU can do 109 or 1010 operations per second. a deep learning algorithm running on specialized hardware (e. g. , GPU, TPU, or FPGA) might consume between 1014 and 1017 operations per second, mostly in the form of highly parallelized matrix and vector operations. Of course, deep learning also depends on the availability of large amounts of training data, and on a few algorithmic tricks (see Chapter 22). 1. 4 The State of the Art Stanford University’s One Hundred Year Study on AI (also known as AI100) convenes panels of experts to provide reports on the state of the art in AI. Their 2016 report (Stone et al. , 2016; Grosz and Stone, 2018) concludes that “Substantial increases in the future uses of AI applications, including more self-driving cars, healthcare diagnostics and targeted treatment, and physical assistance for elder care can be expected” and that “Society is now at a crucial juncture in determining how to deploy AI-based technologies in ways that promote rather than hinder democratic values such as freedom, equality, and transparency. ” AI100 also produces an AI Index at aiindex. org to help track progress. Some highlights from the 2018 and 2019 reports (comparing to a year 2000 baseline unless otherwise stated): •Publications: AI papers increased 20-fold between 2010 and 2019 to about 20, 000 a year. The most popular category was machine learning. (Machine learning papers in arXiv. org doubled every year from 2009 to 2017. ) Computer vision and natural language processing were the next most popular. •Sentiment: About 70% of news articles on AI are neutral, but articles with positive tone increased from 12% in 2016 to 30% in 2018. The most common issues are ethical: data privacy and algorithm bias. •Students: Course enrollment increased 5-fold in the U. S. and 16-fold internationally from a 2010 baseline. AI is the most popular specialization in Computer Science. •Diversity: AI Professors worldwide are about 80% male, 20% female. Similar numbers hold for Ph. D. students and industry hires. •Conferences: Attendance at NeurIPS increased 800% since 2012 to 13, 500 attendees. Other conferences are seeing annual growth of about 30%. •Industry: AI startups in the U. S. increased 20-fold to over 800. •Internationalization: China publishes more papers per year than the U. S. and about as many as all of Europe. However, in citation-weighted impact, U. S. authors are 50% ahead of Chinese authors. Singapore, Brazil, Australia, Canada, and India are the fastest growing countries in terms of the number of AI hires. •Vision: Error rates for object detection (as achieved in LSVRC, the Large-Scale Visual Recognition Challenge) improved from 28% in 2010 to 2% in 2017, exceeding human performance. Accuracy on open-ended visual question answering (VQA) improved from 55% to 68% since 2015, but lags behind human performance at 83%. •Speed: Training time for the image recognition task dropped by a factor of 100 in just the past two years. The amount of computing power used in top AI applications is doubling every 3. 4 months. •Language: Accuracy on question answering, as measured by F1 score on the Stanford Question Answering Dataset (SQUAD), increased from 60 to 95 from 2015 to 2019; on the SQUAD 2 variant, progress was faster, going from 62 to 90 in just one year. Both scores exceed human-level performance. •Human benchmarks: By 2019, AI systems had reportedly met or exceeded human-level performance in chess, Go, poker, Pac-Man, Jeopardy! , ImageNet object detection, speech recognition in a limited domain, Chinese-to-English translation in a restricted domain, Quake III, Dota 2, StarCraft II, various Atari games, skin cancer detection, prostate cancer detection, protein folding, and diabetic retinopathy diagnosis. When (if ever) will AI systems achieve human-level performance across a broad variety of tasks? Ford (2018) interviews AI experts and finds a wide range of target years, from 2029 to 2200, with a mean of 2099. In a similar survey (Grace et al. , 2017) 50% of respondents thought this could happen by 2066, although 10% thought it could happen as early as 2025, and a few said “never. ” The experts were also split on whether we need fundamental new breakthroughs or just refinements on current approaches. But don’t take their predictions too seriously; as Philip Tetlock (2017) demonstrates in the area of predicting world events, experts are no better than amateurs. How will future AI systems operate? We can’t yet say. As detailed in this section, the field has adopted several stories about itself—first the bold idea that intelligence by a machine was even possible, then that it could be achieved by encoding expert knowledge into logic, then that probabilistic models of the world would be the main tool, and most recently that machine learning would induce models that might not be based on any well-understood theory at all. The future will reveal what model comes next. What can AI do today? Perhaps not as much as some of the more optimistic media articles might lead one to believe, but still a great deal. Here are some examples: Robotic vehicles: The history of robotic vehicles stretches back to radio-controlled cars of the 1920s, but the first demonstrations of autonomous road driving without special guides occurred in the 1980s (Kanade et al. , 1986; Dickmanns and Zapp, 1987). After successful demonstrations of driving on dirt roads in the 132-mile DARPA Grand Challenge in 2005 (Thrun, 2006) and on streets with traffic in the 2007 Urban Challenge, the race to develop self-driving cars began in earnest. In 2018, Waymo test vehicles passed the landmark of 10 million miles driven on public roads without a serious accident, with the human driver stepping in to take over control only once every 6, 000 miles. Soon after, the company began offering a commercial robotic taxi service. In the air, autonomous fixed-wing drones have been providing cross-country blood deliveries in Rwanda since 2016. Quadcopters perform remarkable aerobatic maneuvers, explore buildings while constructing 3-D maps, and self-assemble into autonomous formations. Legged locomotion: BigDog, a quadruped robot by Raibert et al. (2008), upended our notions of how robots move—no longer the slow, stiff-legged, side-to-side gait of Hollywood movie robots, but something closely resembling an animal and able to recover when shoved or when slipping on an icy puddle. Atlas, a humanoid robot, not only walks on uneven terrain but jumps onto boxes and does backflips (Ackerman and Guizzo, 2016). Autonomous planning and scheduling: A hundred million miles from Earth, NASA’s Remote Agent program became the first on-board autonomous planning program to control the scheduling of operations for a spacecraft (Jonsson et al. , 2000). Remote Agent generated plans from high-level goals specified from the ground and monitored the execution of those plans—detecting, diagnosing, and recovering from problems as they occurred. Today, the EUROPA planning toolkit (Barreiro et al. , 2012) is used for daily operations of NASA’s Mars rovers and the SEXTANT system (Winternitz, 2017) allows autonomous navigation in deep space, beyond the global GPS system. During the Persian Gulf crisis of 1991, U. S. forces deployed a Dynamic Analysis and Replanning Tool, DART (Cross and Walker, 1994), to do automated logistics planning and scheduling for transportation. This involved up to 50, 000 vehicles, cargo, and people at a time, and had to account for starting points, destinations, routes, transport capacities, port and airfield capacities, and conflict resolution among all parameters. The Defense Advanced Research Project Agency (DARPA) stated that this single application more than paid back DARPA’s 30-year investment in AI. Every day, ride hailing companies such as Uber and mapping services such as Google Maps provide driving directions for hundreds of millions of users, quickly plotting an optimal route taking into account current and predicted future traffic conditions. Machine translation: Online machine translation systems now enable the reading of documents in over 100 languages, including the native languages of over 99% of humans, and render hundreds of billions of words per day for hundreds of millions of users. While not perfect, they are generally adequate for understanding. For closely related languages with a great deal of training data (such as French and English) translations within a narrow domain are close to the level of a human (Wu et al. , 2016b). Speech recognition: In 2017, Microsoft showed that its Conversational Speech Recognition System had reached a word error rate of 5. 1%, matching human performance on the Switchboard task, which involves transcribing telephone conversations (Xiong et al. , 2017). About a third of computer interaction worldwide is now done by voice rather than keyboard; Skype provides real-time speech-to-speech translation in ten languages. Alexa, Siri, Cortana, and Google offer assistants that can answer questions and carry out tasks for the user; for example the Google Duplex service uses speech recognition and speech synthesis to make restaurant reservations for users, carrying out a fluent conversation on their behalf. Recommendations: Companies such as Amazon, Facebook, Netflix, Spotify, YouTube, Walmart, and others use machine learning to recommend what you might like based on your past experiences and those of others like you. The field of recommender systems has a long history (Resnick and Varian, 1997) but is changing rapidly due to new deep learning methods that analyze content (text, music, video) as well as history and metadata (van den Oord et al. , 2014; Zhang et al. , 2017). Spam filtering can also be considered a form of recommendation (or dis-recommendation); current AI techniques filter out over 99. 9% of spam, and email services can also recommend potential recipients, as well as possible response text. Game playing: When Deep Blue defeated world chess champion Garry Kasparov in 1997, defenders of human supremacy placed their hopes on Go. Piet Hut, an astrophysicist and Go enthusiast, predicted that it would take “a hundred years before a computer beats humans at Go—maybe even longer. ” But just 20 years later, ALPHAGO surpassed all human players (Silver et al. , 2017). Ke Jie, the world champion, said, “Last year, it was still quite human-like when it played. But this year, it became like a god of Go. ” ALPHAGO benefited from studying hundreds of thousands of past games by human Go players, and from the distilled knowledge of expert Go players that worked on the team. A followup program, ALPHAZERO, used no input from humans (except for the rules of the game), and was able to learn through self-play alone to defeat all opponents, human and machine, at Go, chess, and shogi (Silver et al. , 2018). Meanwhile, human champions have been beaten by AI systems at games as diverse as Jeopardy! (Ferrucci et al. , 2010), poker (Bowling et al. , 2015; Moravčík et al. , 2017; Brown and Sandholm, 2019), and the video games Dota 2 (Fernandez and Mahlmann, 2018), StarCraft II (Vinyals et al. , 2019), and Quake III (Jaderberg et al. , 2019). Image understanding: Not content with exceeding human accuracy on the challenging ImageNet object recognition task, computer vision researchers have taken on the more difficult problem of image captioning. Some impressive examples include “A person riding a motorcycle on a dirt road, ” “Two pizzas sitting on top of a stove top oven, ” and “A group of young people playing a game of frisbee” (Vinyals et al. , 2017b). Current systems are far from perfect, however: a “refrigerator filled with lots of food and drinks” turns out to be a no-parking sign partially obscured by lots of small stickers. Medicine: AI algorithms now equal or exceed expert doctors at diagnosing many conditions, particularly when the diagnosis is based on images. Examples include Alzheimer’s disease (Ding et al. , 2018), metastatic cancer (Liu et al. , 2017; Esteva et al. , 2017), ophthalmic disease (Gulshan et al. , 2016), and skin diseases (Liu et al. , 2019c). A systematic review and meta-analysis (Liu et al. , 2019a) found that the performance of AI programs, on average, was equivalent to health care professionals. One current emphasis in medical AI is in facilitating human–machine partnerships. For example, the LYNA system achieves 99. 6% overall accuracy in diagnosing metastatic breast cancer—better than an unaided human expert—but the combination does better still (Liu et al. , 2018; Steiner et al. , 2018). The widespread adoption of these techniques is now limited not by diagnostic accuracy but by the need to demonstrate improvement in clinical outcomes and to ensure transparency, lack of bias, and data privacy (Topol, 2019). In 2017, only two medical AI applications were approved by the FDA, but that increased to 12 in 2018, and continues to rise. Climate science: A team of scientists won the 2018 Gordon Bell Prize for a deep learning model that discovers detailed information about extreme weather events that were previously buried in climate data. They used a supercomputer with specialized GPU hardware to exceed the exaop level (1018 operations per second), the first machine learning program to do so (Kurth et al. , 2018). Rolnick et al. (2019) present a 60-page catalog of ways in which machine learning can be used to tackle climate change. These are just a few examples of artificial intelligence systems that exist today. Not magic or science fiction—but rather science, engineering, and mathematics, to which this book provides an introduction. 1. 5 Risks and Benefits of AI Francis Bacon, a philosopher credited with creating the scientific method, noted in The Wisdom of the Ancients (1609) that the “mechanical arts are of ambiguous use, serving as well for hurt as for remedy. ” As AI plays an increasingly important role in the economic, social, scientific, medical, financial, and military spheres, we would do well to consider the hurts and remedies—in modern parlance, the risks and benefits—that it can bring. The topics summarized here are covered in greater depth in Chapters 28 and 29. To begin with the benefits: put simply, our entire civilization is the product of our human intelligence. If we have access to substantially greater machine intelligence, the ceiling on our ambitions is raised substantially. The potential for AI and robotics to free humanity from menial repetitive work and to dramatically increase the production of goods and services could presage an era of peace and plenty. The capacity to accelerate scientific research could result in cures for disease and solutions for climate change and resource shortages. As Demis Hassabis, CEO of Google DeepMind, has suggested: “First solve AI, then use AI to solve everything else. ” Long before we have an opportunity to “solve AI, ” however, we will incur risks from the misuse of AI, inadvertent or otherwise. Some of these are already apparent, while others seem likely based on current trends: •Lethal autonomous weapons: These are defined by the United Nations as weapons that can locate, select, and eliminate human targets without human intervention. A primary concern with such weapons is their scalability: the absence of a requirement for human supervision means that a small group can deploy an arbitrarily large number of weapons against human targets defined by any feasible recognition criterion. The technologies needed for autonomous weapons are similar to those needed for self-driving cars. Informal expert discussions on the potential risks of lethal autonomous weapons began at the UN in 2014, moving to the formal pre-treaty stage of a Group of Governmental Experts in 2017. •Surveillance and persuasion: While it is expensive, tedious, and sometimes legally questionable for security personnel to monitor phone lines, video camera feeds, emails, and other messaging channels, AI (speech recognition, computer vision, and natural language understanding) can be used in a scalable fashion to perform mass surveillance of individuals and detect activities of interest. By tailoring information flows to individuals through social media, based on machine learning techniques, political behavior can be modified and controlled to some extent—a concern that became apparent in elections beginning in 2016. •Biased decision making: Careless or deliberate misuse of machine learning algorithms for tasks such as evaluating parole and loan applications can result in decisions that are biased by race, gender, or other protected categories. Often, the data themselves reflect pervasive bias in society. •Impact on employment: Concerns about machines eliminating jobs are centuries old. The story is never simple: machines do some of the tasks that humans might otherwise do, but they also make humans more productive and therefore more employable, and make companies more profitable and therefore able to pay higher wages. They may render some activities economically viable that would otherwise be impractical. Their use generally results in increasing wealth but tends to have the effect of shifting wealth from labor to capital, further exacerbating increases in inequality. Previous advances in technology—such as the invention of mechanical looms—have resulted in serious disruptions to employment, but eventually people find new kinds of work to do. On the other hand, it is possible that AI will be doing those new kinds of work too. This topic is rapidly becoming a major focus for economists and governments around the world. •Safety-critical applications: As AI techniques advance, they are increasingly used in high-stakes, safety-critical applications such as driving cars and managing the water supplies of cities. Fatal accidents have already occurred and highlight the difficulty of formal verification and statistical risk analysis for systems developed using machine learning techniques. The field of AI will need to develop technical and ethical standards at least comparable to those prevalent in other engineering and healthcare disciplines where people’s lives are at stake. •Cybersecurity: AI techniques are useful in defending against cyberattack, for example by detecting unusual patterns of behavior, but they will also contribute to the potency, survivability, and proliferation capability of malware. For example, reinforcement learning methods have been used to create highly effective tools for automated, personalized blackmail and phishing attacks. We will revisit these topics in more depth in Section 28. 3. As AI systems become more capable, they will take on more of the societal roles previously played by humans. Just as humans have used these roles in the past to perpetrate mischief, we can expect that humans may misuse AI systems in these roles to perpetrate even more mischief. All of the examples given above point to the importance of governance and, eventually, regulation. At present, the research community and the major corporations involved in AI research have developed voluntary self-governance principles for AI-related activities (see Section 28. 3). Governments and international organizations are setting up advisory bodies to devise appropriate regulations for each specific use case, to prepare for the economic and social impacts, and to take advantage of AI capabilities to address major societal problems. What of the longer term? Will we achieve the long-standing goal: the creation of intelligence comparable to or more capable than human intelligence? And, if we do, what then? For much of AI’s history, these questions have been overshadowed by the daily grind of getting AI systems to do anything even remotely intelligent. As with any broad discipline, the great majority of AI researchers have specialized in a specific subfield such as game-playing, knowledge representation, vision, or natural language understanding—often on the assumption that progress in these subfields would contribute to the broader goals of AI. Nils Nilsson (1995), one of the original leaders of the Shakey project at SRI, reminded the field of those broader goals and warned that the subfields were in danger of becoming ends in themselves. Later, some influential founders of AI, including John McCarthy (2007), Marvin Minsky (2007), and Patrick Winston (Beal and Winston, 2009), concurred with Nilsson’s warnings, suggesting that instead of focusing on measurable performance in specific applications, AI should return to its roots of striving for, in Herb Simon’s words, “machines that think, that learn and that create. ” They called the effort human-level AI or HLAI—a machine should be able to learn to do anything a human can do. Their first symposium was in 2004 (Minsky et al. , 2004). Another effort with similar goals, the artificial general intelligence (AGI) movement (Goertzel and Pennachin, 2007), held its first conference and organized the Journal of Artificial General Intelligence in 2008. At around the same time, concerns were raised that creating artificial superintelligence or ASI—intelligence that far surpasses human ability—might be a bad idea (Yudkowsky, 2008; Omohundro, 2008). Turing (1996) himself made the same point in a lecture given in Manchester in 1951, drawing on earlier ideas from Samuel Butler (1863): 15 It seems probable that once the machine thinking method had started, it would not take long to outstrip our feeble powers. . . . At some stage therefore we should have to expect the machines to take control, in the way that is mentioned in Samuel Butler’s Erewhon. These concerns have only become more widespread with recent advances in deep learning, the publication of books such as Superintelligence by Nick Bostrom (2014), and public pronouncements from Stephen Hawking, Bill Gates, Martin Rees, and Elon Musk. Experiencing a general sense of unease with the idea of creating superintelligent machines is only natural. We might call this the gorilla problem: about seven million years ago, a now-extinct primate evolved, with one branch leading to gorillas and one to humans. Today, the gorillas are not too happy about the human branch; they have essentially no control over their future. If this is the result of success in creating superhuman AI—that humans cede control over their future—then perhaps we should stop work on AI, and, as a corollary, give up the benefits it might bring. This is the essence of Turing’s warning: it is not obvious that we can control machines that are more intelligent than us. If superhuman AI were a black box that arrived from outer space, then indeed it would be wise to exercise caution in opening the box. But it is not: we design the AI systems, so if they do end up “taking control, ” as Turing suggests, it would be the result of a design failure. To avoid such an outcome, we need to understand the source of potential failure. Norbert Wiener (1960), who was motivated to consider the long-term future of AI after seeing Arthur Samuel’s checker-playing program learn to beat its creator, had this to say: If we use, to achieve our purposes, a mechanical agency with whose operation we cannot interfere effectively. . . we had better be quite sure that the purpose put into the machine is the purpose which we really desire. Many cultures have myths of humans who ask gods, genies, magicians, or devils for something. Invariably, in these stories, they get what they literally ask for, and then regret it. The third wish, if there is one, is to undo the first two. We will call this the King Midas problem: Midas, a legendary King in Greek mythology, asked that everything he touched should turn to gold, but then regretted it after touching his food, drink, and family members. 16 We touched on this issue in Section 1. 1. 5, where we pointed out the need for a significant modification to the standard model of putting fixed objectives into the machine. The solution to Wiener’s predicament is not to have a definite “purpose put into the machine” at all. Instead, we want machines that strive to achieve human objectives but know that they don’t know for certain exactly what those objectives are. It is perhaps unfortunate that almost all AI research to date has been carried out within the standard model, which means that almost all of the technical material in this edition reflects that intellectual framework. There are, however, some early results within the new framework. In Chapter 15, we show that a machine has a positive incentive to allow itself to be switched off if and only if it is uncertain about the human objective. In Chapter 17, we formulate and study assistance games, which describe mathematically the situation in which a human has an objective and a machine tries to achieve it, but is initially uncertain about what it is. In Chapter 23, we explain the methods of inverse reinforcement learning that allow machines to learn more about human preferences from observations of the choices that humans make. In Chapter 28, we explore two of the principal difficulties: first, that our choices depend on our preferences through a very complex cognitive architecture that is hard to invert; and, second, that we humans may not have consistent preferences in the first place—either individually or as a group—so it may not be clear what AI systems should be doing for us. Summary This chapter defines AI and establishes the cultural background against which it has developed. Some of the important points are as follows: •Different people approach AI with different goals in mind. Two important questions to ask are: Are you concerned with thinking, or behavior? Do you want to model humans, or try to achieve the optimal results? •According to what we have called the standard model, AI is concerned mainly with rational action. An ideal intelligent agent takes the best possible action in a situation. We study the problem of building agents that are intelligent in this sense. •Two refinements to this simple idea are needed: first, the ability of any agent, human or otherwise, to choose rational actions is limited by the computational intractability of doing so; second, the concept of a machine that pursues a definite objective needs to be replaced with that of a machine pursuing objectives to benefit humans, but uncertain as to what those objectives are. •Philosophers (going back to 400 BCE) made AI conceivable by suggesting that the mind is in some ways like a machine, that it operates on knowledge encoded in some internal language, and that thought can be used to choose what actions to take. •Mathematicians provided the tools to manipulate statements of logical certainty as well as uncertain, probabilistic statements. They also set the groundwork for understanding computation and reasoning about algorithms. •Economists formalized the problem of making decisions that maximize the expected utility to the decision maker. •Neuroscientists discovered some facts about how the brain works and the ways in which it is similar to and different from computers. •Psychologists adopted the idea that humans and animals can be considered information-processing machines. Linguists showed that language use fits into this model. •Computer engineers provided the ever-more-powerful machines that make AI applications possible, and software engineers made them more usable. •Control theory deals with designing devices that act optimally on the basis of feedback from the environment. Initially, the mathematical tools of control theory were quite different from those used in AI, but the fields are coming closer together. •The history of AI has had cycles of success, misplaced optimism, and resulting cutbacks in enthusiasm and funding. There have also been cycles of introducing new, creative approaches and systematically refining the best ones. •AI has matured considerably compared to its early decades, both theoretically and methodologically. As the problems that AI deals with became more complex, the field moved from Boolean logic to probabilistic reasoning, and from hand-crafted knowledge to machine learning from data. This has led to improvements in the capabilities of real systems and greater integration with other disciplines. •As AI systems find application in the real world, it has become necessary to consider a wide range of risks and ethical consequences. •In the longer term, we face the difficult problem of controlling superintelligent AI systems that may evolve in unpredictable ways. Solving this problem seems to necessitate a change in our conception of AI. Bibliographical and Historical Notes A comprehensive history of AI is given by Nils Nilsson (2009), one of the early pioneers of the field. Pedro Domingos (2015) and Melanie Mitchell (2019) give overviews of machine learning for a general audience, and Kai-Fu Lee (2018) describes the race for international leadership in AI. Martin Ford (2018) interviews 23 leading AI researchers. The main professional societies for AI are the Association for the Advancement of Artificial Intelligence (AAAI), the ACM Special Interest Group in Artificial Intelligence (SIGAI, formerly SIGART), the European Association for AI, and the Society for Artificial Intelligence and Simulation of Behaviour (AISB). The Partnership on AI brings together many commercial and nonprofit organizations concerned with the ethical and social impacts of AI. AAAI’s AI Magazine contains many topical and tutorial articles, and its Web site, aaai. org, contains news, tutorials, and background information. The most recent work appears in the proceedings of the major AI conferences: the International Joint Conference on AI (IJCAI), the annual European Conference on AI (ECAI), and the AAAI Conference. Machine learning is covered by the International Conference on Machine Learning and the Neural Information Processing Systems (NeurIPS) meeting. The major journals for general AI are Artificial Intelligence, Computational Intelligence, the IEEE Transactions on Pattern Analysis and Machine Intelligence, IEEE Intelligent Systems, and the Journal of Artificial Intelligence Research. There are also many conferences and journals devoted to specific areas, which we cover in the appropriate chapters. 1In the public eye, there is sometimes confusion between the terms “artificial intelligence” and “machine learning. ” Machine learning is a subfield of AI that studies the ability to improve performance based on experience. Some AI systems use machine learning methods to achieve competence, but some do not. 2We are not suggesting that humans are “irrational” in the dictionary sense of “deprived of normal mental clarity. ” We are merely conceding that human decisions are not always mathematically perfect. 3In one of the first books on chess, Ruy Lopez (1561) wrote, “Always place the board so the sun is in your opponent’s eyes. ” 4The Novum Organum is an update of Aristotle’s Organon, or instrument of thought. 5Frege’s proposed notation for first-order logic—an arcane combination of textual and geometric features—never became popular. 6It has since been discovered that the tree shrew and some bird species exceed the human brain/body ratio. 7Many cite Alexander Hood (1824) as a possible prior source. 8Golgi persisted in his belief that the brain’s functions were carried out primarily in a continuous medium in which neurons were embedded, whereas Cajal propounded the “neuronal doctrine. ” The two shared the Nobel Prize in 1906 but gave mutually antagonistic acceptance speeches. 9A complex machine named after a British cartoonist who depicted whimsical and absurdly complicated contraptions for everyday tasks such as buttering toast. 10In the postwar period, Turing wanted to use these computers for AI research—for example, he created an outline of the first chess program (Turing et al. , 1953)—but the British government blocked this research. 11Now Carnegie Mellon University (CMU). 12This was the first official usage of McCarthy’s term artificial intelligence. Perhaps “computational rationality” would have been more precise and less threatening, but “AI” has stuck. At the 50th anniversary of the Dartmouth conference, McCarthy stated that he resisted the terms “computer” or “computational” in deference to Norbert Wiener, who was promoting analog cybernetic devices rather than digital computers. 13Newell and Simon also invented a list-processing language, IPL, to write LT. They had no compiler and translated it into machine code by hand. To avoid errors, they worked in parallel, calling out binary numbers to each other as they wrote each instruction to make sure they agreed. 14Some have characterized this change as a victory of the neats—those who think that AI theories should be grounded in mathematical rigor—over the scruffies—those who would rather try out lots of ideas, write some programs, and then assess what seems to be working. Both approaches are important. A shift toward neatness implies that the held has reached a level of stability and maturity. The present emphasis on deep learning may represent a resurgence of the scruffies. 15Even earlier, in 1847, Richard Thornton, editor of the Primitive Expounder, railed against mechanical calculators: “Mind. . . outruns itself and does away with the necessity of its own existence by inventing machines to do its own thinking. . . . But who knows that such machines when brought to greater perfection, may not think of a plan to remedy all their own defects and then grind out ideas beyond the ken of mortal mind! ” 16Midas would have done better if he had followed basic principles of safety and included an “undo” button and a “pause” button in his wish.",前：None | 后：None,AI_Popular,Formal_Academic,"human,machine,system","AI,AI,Kai-Fu Lee,AI,Galileo,Newton,Curie, Einstein,AI,AI,AI,AI,Turing,Alan Turing,Turing,Turing,AI,Turing,Aeronautical,Allen Newell,Herbert Simon,Newell,Simon,AI,Wilson,Keil,AI,AI,AI,Aristotle,Socrates,Socrates,Sextus Empiricus,Aristotle,AI,Turing,AI,AI,AI,AI,AI,AI,AI,AI,Aristotle,Ramon Llull,Ars Magna,The Great Art,Llull,Leonardo da Vinci,Wilhelm Schickard,Pascaline,Gottfried Wilhelm Leibniz,Leviathan,Thomas Hobbes,Francis Bacon’s,Novum Organum,John Locke,David Hume’s,Ludwig Wittgenstein,Bertrand Russell,Vienna Circle,Vienna,Rudolf Carnap,Carl Hempel,Carnap,The Logical Structure of the World,AI,De Motu Animalium,the Nicomachean Ethics,Aristotle,e. g.,Aristotle,Newell,Simon,Problem Solver,AI,Antoine Arnauld,Daniel Bernoulli,Jeremy Bentham,John Stuart Mill,Immanuel Kant,n’t,Mill,AI,AI,Greece,India,China,George Boole,Boole,Gottlob Frege,Boole,AI,Gödel,AI,Gerolamo Cardano,Pierre Fermat,Jacob Bernoulli,Daniel,Pierre Laplace,Thomas Bayes,Bayes,AI,John Graunt’s,London,Ronald Fisher,Fisher,MILLIONAIRE,Ross,Euclid’s,Muhammad,Kurt Gӧdel,Frege,Russell,Gӧdel,Peano,Alan Turing,Church,Turing,Turing,Turing,AI,Cobham,Edmonds,NP,Cook,Karp,NP,NP,Adam Smith,Smith,Smith,The Theory of Moral Sentiments,Arnauld,Daniel Bernoulli,Léon Walras,Ramsey,John von Neumann,Oskar Morgenstern,The Theory of Games and Economic Behavior,Von Neumann,Morgenstern’s,Luce,Raiffa,AI,World War II,Britain,Richard Bellman,Markov,AI,Herbert Simon,the Nobel Prize,Simon,AI,Neuroscience,BCE Aristotle,Paul Broca’s,aphasia,Broca’s,Camillo Golgi,Santiago Ramon y Cajal,John Searle,Soma,Axonal,neuron,Hans Berger,Ogawa et al.,Cabeza,Nyberg,Crick,Zemelman,Boyden,Lebedev,Nicolelis,Vinge,Kurzweil,Summit,Hermann von Helmholtz,Wilhelm Wundt,Handbook of Physiological Optics,Nalwa,Wundt,the University of Leipzig,H. S. Jennings,Behavior of the Lower Organisms,John Watson,William James,the United States,Cambridge’s Applied Psychology Unit,Frederic Bartlett,The Nature of Explanation,Bartlett,Kenneth Craik,Craik,Craik,Craik,Donald Broadbent,Perception and Communication,the United States,MIT,AI,George Miller,The Magic Number Seven,Noam Chomsky,Allen Newell,Herbert Simon,The Logic Theory Machine,Anderson,Doug Engelbart,HCI,IA,AI,Engelbart,IA,AI,World War II,Heath Robinson,Alan Turing’s,Colossus,Konrad Zuse,Germany,Plankalkül,ABC,John Atanasoff,Clifford Berry,Iowa State University,Atanasoff,ENIAC,the University of Pennsylvania,John Mauchly,J. Presper Eckert,Moore,CPU,GPU,TPU,Moore,Amodei and Hernandez,Ying et al.,AI,Joseph Marie Jacquard,Charles Babbage,Babbage’s Analytical Engine,Jacquard’s,Babbage,Ada Lovelace,Lovelace,AI,the Analytical Engine,Babbage,Lovelace,AI,Ktesibios,Alexandria,James Watt,Cornelis Drebbel,James Clerk Maxwell,Norbert Wiener,Wiener,Bertrand Russell,Craik,Wiener,Arturo Rosenblueth,Julian Bigelow,Rosenblueth et al.,Wiener,Warren McCulloch,Walter Pitts,John von Neumann,Wiener’s book,Cybernetics,Britain,W. Ross Ashby,Ashby,Ashby,Alan Turing,Grey Walter,the Ratio Club,Wiener,Wiener,Ashby’s Design,Brain,AI,AI,AI,AI,B. F. Skinner,Verbal Behavior,Noam Chomsky,Syntactic Structures,Chomsky,AI,AI,Marvin Minsky,John McCarthy,Allen Newell,Herbert Simon,Ed Feigenbaum,Raj Reddy,Judea Pearl,Yoshua Bengio,Geoffrey Hinton,Yann LeCun,multilayer neural networks,AI,AI,Warren McCulloch,Walter Pitts,Pitts’s,Nicolas Rashevsky,Russell,Whitehead,Turing,Pitts,Donald Hebb,Harvard,Marvin Minsky,Dean Edmonds,B-24,Princeton,Minsky,von Neumann,AI,Christopher Strachey,the University of Manchester,Arthur Samuel,IBM,Alan Turing’s,the London Mathematical Society,Computing Machinery and Intelligence,Turing,AI,John McCarthy,Dartmouth College,Claude Shannon,Nathaniel Rochester,U. S.,Dartmouth,Allen Newell,Herbert Simon,Carnegie Tech,Princeton,Arthur Samuel,IBM,Ray Solomonoff,Oliver Selfridge,MIT,Dartmouth College,Hanover,New Hampshire,Dartmouth,Newell,Simon,the Logic Theorist,Simon,Russell,Whitehead,Russell,Principia,the Journal of Symbolic Logic,Newell,Simon,Logic Theorist,X.,Turing,John McCarthy,Look, Ma,Newell,Simon,the General Problem Solver,Newell,Simon,IBM,Nathaniel Rochester,AI,Herbert Gelernter,the Geometry Theorem Prover,Arthur Samuel,Samuel,Samuel,IBM,Samuel,TD-GAMMON,Tesauro,ALPHAGO,John McCarthy,AI,AI,Programs,Common Sense,AI,the Advice Taker,The Advice Taker,AI,Marvin Minsky,MIT,McCarthy,McCarthy,Minsky,McCarthy,AI,Stanford,Advice Taker,J. A. Robinson’s,Stanford,Cordell Green’s,the Stanford Research Institute,MIT,Minsky,James Slagle’s SAINT,Tom Evans’s,Daniel Bobrow’s,Tom,Tom,David Huffman,David Waltz,Patrick Winston,Terry Winograd,Scott Fahlman,SHRDLU,Winograd,McCulloch,Pitts,Shmuel Winograd,Jack Cowan,Bernie Widrow,Widrow,Hoff,Widrow,Frank Rosenblatt,Herbert Simon,Simon,Simon,AI,AI,AI,Friedberg,Friedberg,CPU,AI,Lighthill,AI,Minsky,Papert,Perceptrons,multilayer networks,Kelley,Bryson,AI,DENDRAL,Buchanan,Stanford,Ed Feigenbaum,Herbert Simon,Bruce Buchanan,Joshua Lederberg,Nobel,e. g.,DENDRAL,DENDRAL,Feigenbaum,DENDRAL,Feigenbaum,Stanford,the Heuristic Programming Project,HPP,MYCIN,MYCIN,DENDRAL,DENDRAL,MYCIN,MYCIN,the Digital Equipment Corporation,McDermott,DEC,AI,DuPont,U. S.,AI,Winograd,SHRDLU,Eugene Charniak,MIT,Roger Schank,Yale,Schank,Abelson,Wilensky,Schank,Riesbeck,Japan,the United States,the “Fifth Generation,the United States,the Microelectronics and Computer Technology Corporation,AI,Britain,Alvey,Lighthill,AI,AI,AI,Parallel Distributed Processing (Rumelhart,McClelland,Newell,Simon,McCarthy,Terrence Deacon,The Symbolic Species,Geoff Hinton,AI,Cohen,UC,Irvine,the International Planning Competition,LibriSpeech,ImageNet,SQUAD,WMT,the International SAT Competitions,David McAllester,AI,e. g.,AI,Markov,AI,Judea Pearl’s,AI,Pearl,Rich Sutton’s,Arthur Samuel’s,Markov,AI,AI,AI,AI,the World Wide Web,Yarowsky,Banko,Brill,Efros,ImageNet,Deng et al.,AI,Havenstein,Halevy,al.,IBM,Jeopardy,AI,LeCun et al.,ImageNet,Geoffrey Hinton’s,the University of Toronto,Krizhevsky et al.,ALPHAGO,AI,AI,AI,CPU,GPU,TPU,FPGA,The State of the Art Stanford University’s,AI100,AI,Stone,Grosz and Stone,AI,AI,AI100,AI,AI,the U. S.,AI,Computer Science,AI Professors,Attendance,the U. S.,China,the U. S.,U. S.,Singapore,Brazil,Australia,Canada,India,AI,LSVRC,the Large-Scale Visual Recognition Challenge,VQA,AI,F1,the Stanford Question Answering Dataset,SQUAD,AI,Pac-Man,ImageNet,StarCraft II,Atari,AI,Ford,AI,Grace et al.,Philip Tetlock,AI,Zapp,DARPA Grand Challenge,Thrun,Urban Challenge,Waymo,Rwanda,Raibert,al,Hollywood,Atlas,Ackerman,Guizzo,NASA,Jonsson et al.,NASA,Winternitz,U. S.,DART,Walker,The Defense Advanced Research Project Agency,DARPA,DARPA,AI,Google Maps,Wu,Microsoft,Conversational Speech Recognition System,Switchboard,Xiong,al.,Skype,Alexa,Siri,Cortana,Google,Google Duplex,Amazon,Netflix,Spotify,YouTube,Walmart,Resnick,metadata,van den Oord et al.,Zhang et al.,AI,Deep Blue,Garry Kasparov,Piet Hut,ALPHAGO,Ke Jie,ALPHAGO,ALPHAZERO,AI,Jeopardy,Ferrucci,al.,Bowling et al.,Moravčík,al.,Brown,Sandholm,Dota 2,Fernandez,Mahlmann,StarCraft II,Jaderberg,ImageNet,Ding,Liu et al.,Esteva,Liu et al.,Liu et al.,AI,AI,LYNA,Liu et al.,Steiner et al.,Topol,FDA,Gordon Bell Prize,GPU,Kurth et al.,Rolnick et al.,Francis Bacon,The Wisdom of the Ancients,AI,AI,Demis Hassabis,Google DeepMind,AI,AI,AI,AI,the United Nations,UN,Group of Governmental Experts,AI,AI,AI,AI,AI,AI,AI,AI,AI,AI,AI,AI,Nils Nilsson,Shakey,AI,John McCarthy,Marvin Minsky,Patrick Winston,Winston,Nilsson’s,AI,Herb Simon’s,AI,HLAI,AGI,Goertzel and Pennachin,the Journal of Artificial General Intelligence,ASI,Yudkowsky,Omohundro,Manchester,Samuel Butler,Samuel Butler’s Erewhon,Superintelligence,Nick Bostrom,Stephen Hawking,Bill Gates,Martin Rees,Elon Musk,AI,AI,Turing,AI,AI,Turing,Norbert Wiener,AI,Arthur Samuel’s,King Midas,Midas,King,Wiener,AI,AI,AI,AI,BCE,AI,AI,AI,AI,AI,AI,AI,Nils Nilsson,Pedro Domingos,Melanie Mitchell,Kai-Fu Lee,AI,Martin Ford,AI,AI,the ACM Special Interest Group,Artificial Intelligence,the European Association for AI,the Society for Artificial Intelligence and Simulation of Behaviour,The Partnership on AI,AI,AAAI’s,AI Magazine,AI,the International Joint Conference on AI (IJCAI,European Conference on AI,the AAAI Conference,the International Conference on Machine Learning,the Neural Information Processing Systems,AI,Artificial Intelligence,Pattern Analysis,the Journal of Artificial Intelligence Research,AI,AI,Ruy Lopez,Aristotle’s Organon,6It,Alexander Hood,Cajal,the Nobel Prize,Turing,AI,Turing et al.,Carnegie Mellon University,CMU,McCarthy,Dartmouth,McCarthy,Norbert Wiener,Simon,IPL,AI,Richard Thornton,the Primitive Expounder",,
chap2_para1,2,"INTELLIGENT AGENTS In which we discuss the nature of agents, perfect or otherwise, the diversity of environments, and the resulting menagerie of agent types. Chapter 1 identified the concept of rational agents as central to our approach to artificial intelligence. In this chapter, we make this notion more concrete. We will see that the concept of rationality can be applied to a wide variety of agents operating in any imaginable environment. Our plan in this book is to use this concept to develop a small set of design principles for building successful agents—systems that can reasonably be called intelligent. We begin by examining agents, environments, and the coupling between them. The observation that some agents behave better than others leads naturally to the idea of a rational agent—one that behaves as well as possible. How well an agent can behave depends on the nature of the environment; some environments are more difficult than others. We give a crude categorization of environments and show how properties of an environment influence the design of suitable agents for that environment. We describe a number of basic “skeleton” agent designs, which we flesh out in the rest of the book. 2. 1Agents and Environments An agent is anything that can be viewed as perceiving its environment through sensors and acting upon that environment through actuators. This simple idea is illustrated in Figure 2. 1. A human agent has eyes, ears, and other organs for sensors and hands, legs, vocal tract, and so on for actuators. A robotic agent might have cameras and infrared range finders for sensors and various motors for actuators. A software agent receives file contents, network packets, and human input (keyboard/mouse/touchscreen/voice) as sensory inputs and acts on the environment by writing files, sending network packets, and displaying information or generating sounds. The environment could be everything—the entire universe! In practice it is just that part of the universe whose state we care about when designing this agent—the part that affects what the agent perceives and that is affected by the agent’s actions. Description The block diagram starts with a block labeled Agent. An unknown block marked with a question mark is shown inside the agent block. An arrow from the sensors points to the unknown block. An arrow from the unknown block points to the actuators. An arrow from the actuators points to a block labeled Environment, which is outside the agent block. An arrow from the environment block points back to sensors in the agent block. Figure 2. 1Agents interact with environments through sensors and actuators. We use the term percept to refer to the content an agent’s sensors are perceiving. An agent’s percept sequence is the complete history of everything the agent has ever perceived. In general, an agent’s choice of action at any given instant can depend on its built-in knowledge and on the entire percept sequence observed to date, but not on anything it hasn’t perceived. By specifying the agent’s choice of action for every possible percept sequence, we have said more or less everything there is to say about the agent. Mathematically speaking, we say that an agent’s behavior is described by the agent function that maps any given percept sequence to an action. We can imagine tabulating the agent function that describes any given agent; for most agents, this would be a very large table—infinite, in fact, unless we place a bound on the length of percept sequences we want to consider. Given an agent to experiment with, we can, in principle, construct this table by trying out all possible percept sequences and recording which actions the agent does in response. 1 The table is, of course, an external characterization of the agent. Internally, the agent function for an artificial agent will be implemented by an agent program. It is important to keep these two ideas distinct. The agent function is an abstract mathematical description; the agent program is a concrete implementation, running within some physical system. To illustrate these ideas, we use a simple example—the vacuum-cleaner world, which consists of a robotic vacuum-cleaning agent in a world consisting of squares that can be either dirty or clean. Figure 2. 2 shows a configuration with just two squares, A and B. The vacuum agent perceives which square it is in and whether there is dirt in the square. The agent starts in square A. The available actions are to move to the right, move to the left, suck up the dirt, or do nothing. 2 One very simple agent function is the following: if the current square is dirty, then suck; otherwise, move to the other square. A partial tabulation of this agent function is shown in Figure 2. 3 and an agent program that implements it appears in Figure 2. 8 on page 67. Description A robotic vacuum-cleaning agent and dirt are shown in block ""A"". Dirt is shown in block B. Figure 2. 2A vacuum-cleaner world with just two locations. Each location can be clean or dirty, and the agent can move left or right and can clean the square that it occupies. Different versions of the vacuum world allow for different rules about what the agent can perceive, whether its actions always succeed, and so on. Looking at Figure 2. 3, we see that various vacuum-world agents can be defined simply by filling in the right-hand column in various ways. The obvious question, then, is this: What is the right way to fill out the table? In other words, what makes an agent good or bad, intelligent or stupid? We answer these questions in the next section. Description The block diagram starts with a block labeled Agent. Three blocks are shown inside the Agent block. The first block inside the agent block is labeled, What the world is like now. An arrow from the first block points to the second block labeled, What action I should do now. The third block is labeled Condition action rules and an arrow from the third block points to the second block. An arrow from the second block points to the Actuators. An arrow from the actuators points to a block labeled Environment, which is outside the agent block. An arrow from the environment block points to the sensors in the Agent block. An arrow from the sensors points back to the first block. Figure 2. 3Partial tabulation of a simple agent function for the vacuum-cleaner world shown in Figure 2. 2. The agent cleans the current square if it is dirty, otherwise it moves to the other square. Note that the table is of unbounded size unless there is a restriction on the length of possible percept sequences. Before closing this section, we should emphasize that the notion of an agent is meant to be a tool for analyzing systems, not an absolute characterization that divides the world into agents and non-agents. One could view a hand-held calculator as an agent that chooses the action of displaying “4” when given the percept sequence “2 + 2 =, ” but such an analysis would hardly aid our understanding of the calculator. In a sense, all areas of engineering can be seen as designing artifacts that interact with the world; AI operates at (what the authors consider to be) the most interesting end of the spectrum, where the artifacts have significant computational resources and the task environment requires nontrivial decision making. 2. 2Good Behavior: The Concept of Rationality A rational agent is one that does the right thing. Obviously, doing the right thing is better than doing the wrong thing, but what does it mean to do the right thing? 2. 2. 1Performance measures Moral philosophy has developed several different notions of the “right thing, ” but AI has generally stuck to one notion called consequentialism: we evaluate an agent’s behavior by its consequences. When an agent is plunked down in an environment, it generates a sequence of actions according to the percepts it receives. This sequence of actions causes the environment to go through a sequence of states. If the sequence is desirable, then the agent has performed well. This notion of desirability is captured by a performance measure that evaluates any given sequence of environment states. Humans have desires and preferences of their own, so the notion of rationality as applied to humans has to do with their success in choosing actions that produce sequences of environment states that are desirable from their point of view. Machines, on the other hand, do not have desires and preferences of their own; the performance measure is, initially at least, in the mind of the designer of the machine, or in the mind of the users the machine is designed for. We will see that some agent designs have an explicit representation of (a version of) the performance measure, while in other designs the performance measure is entirely implicit—the agent may do the right thing, but it doesn’t know why. Recalling Norbert Wiener’s warning to ensure that “the purpose put into the machine is the purpose which we really desire” (page 51), notice that it can be quite hard to formulate a performance measure correctly. Consider, for example, the vacuum-cleaner agent from the preceding section. We might propose to measure performance by the amount of dirt cleaned up in a single eight-hour shift. With a rational agent, of course, what you ask for is what you get. A rational agent can maximize this performance measure by cleaning up the dirt, then dumping it all on the floor, then cleaning it up again, and so on. A more suitable performance measure would reward the agent for having a clean floor. For example, one point could be awarded for each clean square at each time step (perhaps with a penalty for electricity consumed and noise generated). As a general rule, it is better to design performance measures according to what one actually wants to be achieved in the environment, rather than according to how one thinks the agent should behave. Even when the obvious pitfalls are avoided, some knotty problems remain. For example, the notion of “clean floor” in the preceding paragraph is based on average cleanliness over time. Yet the same average cleanliness can be achieved by two different agents, one of which does a mediocre job all the time while the other cleans energetically but takes long breaks. Which is preferable might seem to be a fine point of janitorial science, but in fact it is a deep philosophical question with far-reaching implications. Which is better—a reckless life of highs and lows, or a safe but humdrum existence? Which is better—an economy where everyone lives in moderate poverty, or one in which some live in plenty while others are very poor? We leave these questions as an exercise for the diligent reader. For most of the book, we will assume that the performance measure can be specified correctly. For the reasons given above, however, we must accept the possibility that we might put the wrong purpose into the machine—precisely the King Midas problem described on page 51. Moreover, when designing one piece of software, copies of which will belong to different users, we cannot anticipate the exact preferences of each individual user. Thus, we may need to build agents that reflect initial uncertainty about the true performance measure and learn more about it as time goes by; such agents are described in Chapters 15, 17, and 23. 2. 2. 2Rationality What is rational at any given time depends on four things: •The performance measure that defines the criterion of success. •The agent’s prior knowledge of the environment. •The actions that the agent can perform. •The agent’s percept sequence to date. This leads to a definition of a rational agent: For each possible percept sequence, a rational agent should select an action that is expected to maximize its performance measure, given the evidence provided by the percept sequence and whatever built-in knowledge the agent has. Consider the simple vacuum-cleaner agent that cleans a square if it is dirty and moves to the other square if not; this is the agent function tabulated in Figure 2. 3. Is this a rational agent? That depends! First, we need to say what the performance measure is, what is known about the environment, and what sensors and actuators the agent has. Let us assume the following: •The performance measure awards one point for each clean square at each time step, over a “lifetime” of 1000 time steps. •The “geography” of the environment is known a priori (Figure 2. 2) but the dirt distribution and the initial location of the agent are not. Clean squares stay clean and sucking cleans the current square. The Right and Left actions move the agent one square except when this would take the agent outside the environment, in which case the agent remains where it is. •The only available actions are Right, Left, and Suck. •The agent correctly perceives its location and whether that location contains dirt. Under these circumstances the agent is indeed rational; its expected performance is at least as good as any other agent’s. One can see easily that the same agent would be irrational under different circumstances. For example, once all the dirt is cleaned up, the agent will oscillate needlessly back and forth; if the performance measure includes a penalty of one point for each movement, the agent will fare poorly. A better agent for this case would do nothing once it is sure that all the squares are clean. If clean squares can become dirty again, the agent should occasionally check and re-clean them if needed. If the geography of the environment is unknown, the agent will need to explore it. Exercise 2. VACR asks you to design agents for these cases. 2. 2. 3Omniscience, learning, and autonomy We need to be careful to distinguish between rationality and omniscience. An omniscient agent knows the actual outcome of its actions and can act accordingly; but omniscience is impossible in reality. Consider the following example: I am walking along the Champs Elysées one day and I see an old friend across the street. There is no traffic nearby and I’m not otherwise engaged, so, being rational, I start to cross the street. Meanwhile, at 33, 000 feet, a cargo door falls off a passing airliner, 3 and before I make it to the other side of the street I am flattened. Was I irrational to cross the street? It is unlikely that my obituary would read “Idiot attempts to cross street. ” This example shows that rationality is not the same as perfection. Rationality maximizes expected performance, while perfection maximizes actual performance. Retreating from a requirement of perfection is not just a question of being fair to agents. The point is that if we expect an agent to do what turns out after the fact to be the best action, it will be impossible to design an agent to fulfill this specification—unless we improve the performance of crystal balls or time machines. Our definition of rationality does not require omniscience, then, because the rational choice depends only on the percept sequence to date. We must also ensure that we haven’t inadvertently allowed the agent to engage in decidedly underintelligent activities. For example, if an agent does not look both ways before crossing a busy road, then its percept sequence will not tell it that there is a large truck approaching at high speed. Does our definition of rationality say that it’s now OK to cross the road? Far from it! First, it would not be rational to cross the road given this uninformative percept sequence: the risk of accident from crossing without looking is too great. Second, a rational agent should choose the “looking” action before stepping into the street, because looking helps maximize the expected performance. Doing actions in order to modify future percepts—sometimes called information gathering—is an important part of rationality and is covered in depth in Chapter 15. A second example of information gathering is provided by the exploration that must be undertaken by a vacuum-cleaning agent in an initially unknown environment. Our definition requires a rational agent not only to gather information but also to learn as much as possible from what it perceives. The agent’s initial configuration could reflect some prior knowledge of the environment, but as the agent gains experience this may be modified and augmented. There are extreme cases in which the environment is completely known a priori and completely predictable. In such cases, the agent need not perceive or learn; it simply acts correctly. Of course, such agents are fragile. Consider the lowly dung beetle. After digging its nest and laying its eggs, it fetches a ball of dung from a nearby heap to plug the entrance. If the ball of dung is removed from its grasp en route, the beetle continues its task and pantomimes plugging the nest with the nonexistent dung ball, never noticing that it is missing. Evolution has built an assumption into the beetle’s behavior, and when it is violated, unsuccessful behavior results. Slightly more intelligent is the sphex wasp. The female sphex will dig a burrow, go out and sting a caterpillar and drag it to the burrow, enter the burrow again to check all is well, drag the caterpillar inside, and lay its eggs. The caterpillar serves as a food source when the eggs hatch. So far so good, but if an entomologist moves the caterpillar a few inches away while the sphex is doing the check, it will revert to the “drag the caterpillar” step of its plan and will continue the plan without modification, re-checking the burrow, even after dozens of caterpillar-moving interventions. The sphex is unable to learn that its innate plan is failing, and thus will not change it. To the extent that an agent relies on the prior knowledge of its designer rather than on its own percepts and learning processes, we say that the agent lacks autonomy. A rational agent should be autonomous—it should learn what it can to compensate for partial or incorrect prior knowledge. For example, a vacuum-cleaning agent that learns to predict where and when additional dirt will appear will do better than one that does not. As a practical matter, one seldom requires complete autonomy from the start: when the agent has had little or no experience, it would have to act randomly unless the designer gave some assistance. Just as evolution provides animals with enough built-in reflexes to survive long enough to learn for themselves, it would be reasonable to provide an artificial intelligent agent with some initial knowledge as well as an ability to learn. After sufficient experience of its environment, the behavior of a rational agent can become effectively independent of its prior knowledge. Hence, the incorporation of learning allows one to design a single rational agent that will succeed in a vast variety of environments. 2. 3The Nature of Environments Now that we have a definition of rationality, we are almost ready to think about building rational agents. First, however, we must think about task environments, which are essentially the “problems” to which rational agents are the “solutions. ” We begin by showing how to specify a task environment, illustrating the process with a number of examples. We then show that task environments come in a variety of flavors. The nature of the task environment directly affects the appropriate design for the agent program. 2. 3. 1Specifying the task environment In our discussion of the rationality of the simple vacuum-cleaner agent, we had to specify the performance measure, the environment, and the agent’s actuators and sensors. We group all these under the heading of the task environment. For the acronymically minded, we call this the PEAS (Performance, Environment, Actuators, Sensors) description. In designing an agent, the first step must always be to specify the task environment as fully as possible. The vacuum world was a simple example; let us consider a more complex problem: an automated taxi driver. Figure 2. 4 summarizes the PEAS description for the taxi’s task environment. We discuss each element in more detail in the following paragraphs. Description The block diagram starts with a block labeled Agent. There are six blocks inside the Agent block. The first block inside the agent block is labeled, What the world is like now. Arrows from the second, third, and fourth blocks labeled State, How the world evolves, and What my actions do, point to the first block. A dashed arrow from the first block points back to the state block. A solid arrow from the first block points to the fifth block labeled, What action I should do now. An arrow from the sixth block labeled, Condition action rules, points to the fifth block. An arrow from the fifth block points to the Actuators. An arrow from actuators points to the block labeled, Environment, which is outside the agent block. An arrow from the environment block to the sensors in the agent block. An arrow from the sensors points back to the first block. Figure 2. 4PEAS description of the task environment for an automated taxi driver. First, what is the performance measure to which we would like our automated driver to aspire? Desirable qualities include getting to the correct destination; minimizing fuel consumption and wear and tear; minimizing the trip time or cost; minimizing violations of traffic laws and disturbances to other drivers; maximizing safety and passenger comfort; maximizing profits. Obviously, some of these goals conflict, so tradeoffs will be required. Next, what is the driving environment that the taxi will face? Any taxi driver must deal with a variety of roads, ranging from rural lanes and urban alleys to 12-lane freeways. The roads contain other traffic, pedestrians, stray animals, road works, police cars, puddles, and potholes. The taxi must also interact with potential and actual passengers. There are also some optional choices. The taxi might need to operate in Southern California, where snow is seldom a problem, or in Alaska, where it seldom is not. It could always be driving on the right, or we might want it to be flexible enough to drive on the left when in Britain or Japan. Obviously, the more restricted the environment, the easier the design problem. The actuators for an automated taxi include those available to a human driver: control over the engine through the accelerator and control over steering and braking. In addition, it will need output to a display screen or voice synthesizer to talk back to the passengers, and perhaps some way to communicate with other vehicles, politely or otherwise. The basic sensors for the taxi will include one or more video cameras so that it can see, as well as lidar and ultrasound sensors to detect distances to other cars and obstacles. To avoid speeding tickets, the taxi should have a speedometer, and to control the vehicle properly, especially on curves, it should have an accelerometer. To determine the mechanical state of the vehicle, it will need the usual array of engine, fuel, and electrical system sensors. Like many human drivers, it might want to access GPS signals so that it doesn’t get lost. Finally, it will need touchscreen or voice input for the passenger to request a destination. In Figure 2. 5, we have sketched the basic PEAS elements for a number of additional agent types. Further examples appear in Exercise 2. PEAS. The examples include physical as well as virtual environments. Note that virtual task environments can be just as complex as the “real” world: for example, a software agent (or software robot or softbot) that trades on auction and reselling Web sites deals with millions of other users and billions of objects, many with real images. Description The block diagram starts with a block labeled Agent. There are seven blocks inside the Agent block. The first block inside the agent block is labeled, What the word is like now. Arrows from the second, third, and fourth blocks labeled State, How the world evolves, and What my actions do, point to the first block. A dashed arow from the first block points back to the state block. A solid arrow from the first block points to the fifth block labeled, What it will be like if I do action ""A"". Arrows from third and fourth blocks labeled, How the world evolves and What my action do, point to fifth block. An arrow from the fifth block points to the sixth block labeled, What action I should do now. An arrow from the seventh block labeled Goals points to the sixth block. An arrow from the sixth block points to the Actuators. An arrow from the actuators points to the block labeled, Environment, which is outside the agent block. An arrow from the environment block points to the sensors in the agent block. An arrow from the sensors points back to the first block. Figure 2. 5Examples of agent types and their PEAS descriptions. 2. 3. 2Properties of task environments The range of task environments that might arise in AI is obviously vast. We can, however, identify a fairly small number of dimensions along which task environments can be categorized. These dimensions determine, to a large extent, the appropriate agent design and the applicability of each of the principal families of techniques for agent implementation. First we list the dimensions, then we analyze several task environments to illustrate the ideas. The definitions here are informal; later chapters provide more precise statements and examples of each kind of environment. Fully observable vs. partially observable: If an agent’s sensors give it access to the complete state of the environment at each point in time, then we say that the task environment is fully observable. A task environment is effectively fully observable if the sensors detect all aspects that are relevant to the choice of action; relevance, in turn, depends on the performance measure. Fully observable environments are convenient because the agent need not maintain any internal state to keep track of the world. An environment might be partially observable because of noisy and inaccurate sensors or because parts of the state are simply missing from the sensor data—for example, a vacuum agent with only a local dirt sensor cannot tell whether there is dirt in other squares, and an automated taxi cannot see what other drivers are thinking. If the agent has no sensors at all then the environment is unobservable. One might think that in such cases the agent’s plight is hopeless, but, as we discuss in Chapter 4, the agent’s goals may still be achievable, sometimes with certainty. Single-agent vs. multiagent: The distinction between single-agent and multiagent environments may seem simple enough. For example, an agent solving a crossword puzzle by itself is clearly in a single-agent environment, whereas an agent playing chess is in a two-agent environment. However, there are some subtle issues. First, we have described how an entity may be viewed as an agent, but we have not explained which entities must be viewed as agents. Does an agent A (the taxi driver for example) have to treat an object B (another vehicle) as an agent, or can it be treated merely as an object behaving according to the laws of physics, analogous to waves at the beach or leaves blowing in the wind? The key distinction is whether B’s behavior is best described as maximizing a performance measure whose value depends on agent A’s behavior. For example, in chess, the opponent entity B is trying to maximize its performance measure, which, by the rules of chess, minimizes agent A’s performance measure. Thus, chess is a competitive multiagent environment. On the other hand, in the taxi-driving environment, avoiding collisions maximizes the performance measure of all agents, so it is a partially cooperative multiagent environment. It is also partially competitive because, for example, only one car can occupy a parking space. The agent-design problems in multiagent environments are often quite different from those in single-agent environments; for example, communication often emerges as a rational behavior in multiagent environments; in some competitive environments, randomized behavior is rational because it avoids the pitfalls of predictability. Deterministic vs. nondeterministic. If the next state of the environment is completely determined by the current state and the action executed by the agent(s), then we say the environment is deterministic; otherwise, it is nondeterministic. In principle, an agent need not worry about uncertainty in a fully observable, deterministic environment. If the environment is partially observable, however, then it could appear to be nondeterministic. Most real situations are so complex that it is impossible to keep track of all the unobserved aspects; for practical purposes, they must be treated as nondeterministic. Taxi driving is clearly nondeterministic in this sense, because one can never predict the behavior of traffic exactly; moreover, one’s tires may blow out unexpectedly and one’s engine may seize up without warning. The vacuum world as we described it is deterministic, but variations can include nondeterministic elements such as randomly appearing dirt and an unreliable suction mechanism (Exercise 2. VFIN). One final note: the word stochastic is used by some as a synonym for “nondeterministic, ” but we make a distinction between the two terms; we say that a model of the environment is stochastic if it explicitly deals with probabilities (e. g. , “there’s a 25% chance of rain tomorrow”) and “nondeterministic” if the possibilities are listed without being quantified (e. g. , “there’s a chance of rain tomorrow”). Episodic vs. sequential: In an episodic task environment, the agent’s experience is divided into atomic episodes. In each episode the agent receives a percept and then performs a single action. Crucially, the next episode does not depend on the actions taken in previous episodes. Many classification tasks are episodic. For example, an agent that has to spot defective parts on an assembly line bases each decision on the current part, regardless of previous decisions; moreover, the current decision doesn’t affect whether the next part is defective. In sequential environments, on the other hand, the current decision could affect all future decisions. 4 Chess and taxi driving are sequential: in both cases, short-term actions can have long-term consequences. Episodic environments are much simpler than sequential environments because the agent does not need to think ahead. Static vs. dynamic: If the environment can change while an agent is deliberating, then we say the environment is dynamic for that agent; otherwise, it is static. Static environments are easy to deal with because the agent need not keep looking at the world while it is deciding on an action, nor need it worry about the passage of time. Dynamic environments, on the other hand, are continuously asking the agent what it wants to do; if it hasn’t decided yet, that counts as deciding to do nothing. If the environment itself does not change with the passage of time but the agent’s performance score does, then we say the environment is semidynamic. Taxi driving is clearly dynamic: the other cars and the taxi itself keep moving while the driving algorithm dithers about what to do next. Chess, when played with a clock, is semidynamic. Crossword puzzles are static. Discrete vs. continuous: The discrete/continuous distinction applies to the state of the environment, to the way time is handled, and to the percepts and actions of the agent. For example, the chess environment has a finite number of distinct states (excluding the clock). Chess also has a discrete set of percepts and actions. Taxi driving is a continuous-state and continuous-time problem: the speed and location of the taxi and of the other vehicles sweep through a range of continuous values and do so smoothly over time. Taxi-driving actions are also continuous (steering angles, etc. ). Input from digital cameras is discrete, strictly speaking, but is typically treated as representing continuously varying intensities and locations. Known vs. unknown: Strictly speaking, this distinction refers not to the environment itself but to the agent’s (or designer’s) state of knowledge about the “laws of physics” of the environment. In a known environment, the outcomes (or outcome probabilities if the environment is nondeterministic) for all actions are given. Obviously, if the environment is unknown, the agent will have to learn how it works in order to make good decisions. The distinction between known and unknown environments is not the same as the one between fully and partially observable environments. It is quite possible for a known environment to be partially observable—for example, in solitaire card games, I know the rules but am still unable to see the cards that have not yet been turned over. Conversely, an unknown environment can be fully observable—in a new video game, the screen may show the entire game state but I still don’t know what the buttons do until I try them. As noted on page 57, the performance measure itself may be unknown, either because the designer is not sure how to write it down correctly or because the ultimate user—whose preferences matter—is not known. For example, a taxi driver usually won’t know whether a new passenger prefers a leisurely or speedy journey, a cautious or aggressive driving style. A virtual personal assistant starts out knowing nothing about the personal preferences of its new owner. In such cases, the agent may learn more about the performance measure based on further interactions with the designer or user. This, in turn, suggests that the task environment is necessarily viewed as a multiagent environment. The hardest case is partially observable, multiagent, nondeterministic, sequential, dynamic, continuous, and unknown. Taxi driving is hard in all these senses, except that the driver’s environment is mostly known. Driving a rented car in a new country with unfamiliar geography, different traffic laws, and nervous passengers is a lot more exciting. Figure 2. 6 lists the properties of a number of familiar environments. Note that the properties are not always cut and dried. For example, we have listed the medical-diagnosis task as single-agent because the disease process in a patient is not profitably modeled as an agent; but a medical-diagnosis system might also have to deal with recalcitrant patients and skeptical staff, so the environment could have a multiagent aspect. Furthermore, medical diagnosis is episodic if one conceives of the task as selecting a diagnosis given a list of symptoms; the problem is sequential if the task can include proposing a series of tests, evaluating progress over the course of treatment, handling multiple patients, and so on. Description The block diagram starts with a block labeled Agent. There are eight blocks inside the Agent block. The first block inside the agent block is labeled, What the world is like now. Arrows from the second, third, and fourth blocks labeled State, How the world evolves, and What my actions do, point to the first block. A dashed arow from the first block points back to the state block. A solid arrow from the first block points to the fifth block labeled, What it will be like if I do action ""A"". Arrows from third and fourth blocks labeled, How the world evolves and What my action do, point to fifth block. An arrow from the fifth block points to the sixth block labeled, How happy I will be in such a state. An arrow from the seventh block labeled Utility also points to the sixth block. An arrow from the sixth block points to the eighth block labeled, What action I should do now. An arrow from the eighth block points to the Actuators. An arrow from the actuators points to the block labeled, Environment, which is outside the agent block. An arrow from the environment block points to the sensors in the agent block. An arrow from the sensors points back to the first block. Figure 2. 6Examples of task environments and their characteristics. We have not included a “known/unknown” column because, as explained earlier, this is not strictly a property of the environment. For some environments, such as chess and poker, it is quite easy to supply the agent with full knowledge of the rules, but it is nonetheless interesting to consider how an agent might learn to play these games without such knowledge. The code repository associated with this book (aima. cs. berkeley. edu) includes multiple environment implementations, together with a general-purpose environment simulator for evaluating an agent’s performance. Experiments are often carried out not for a single environment but for many environments drawn from an environment class. For example, to evaluate a taxi driver in simulated traffic, we would want to run many simulations with different traffic, lighting, and weather conditions. We are then interested in the agent’s average performance over the environment class. 2. 4The Structure of Agents So far we have talked about agents by describing behavior—the action that is performed after any given sequence of percepts. Now we must bite the bullet and talk about how the insides work. The job of AI is to design an agent program that implements the agent function—the mapping from percepts to actions. We assume this program will run on some sort of computing device with physical sensors and actuators—we call this the agent architecture: agent = architecture + program. Obviously, the program we choose has to be one that is appropriate for the architecture. If the program is going to recommend actions like Walk, the architecture had better have legs. The architecture might be just an ordinary PC, or it might be a robotic car with several onboard computers, cameras, and other sensors. In general, the architecture makes the percepts from the sensors available to the program, runs the program, and feeds the program’s action choices to the actuators as they are generated. Most of this book is about designing agent programs, although Chapters 26 and 27 deal directly with the sensors and actuators. 2. 4. 1Agent programs The agent programs that we design in this book all have the same skeleton: they take the current percept as input from the sensors and return an action to the actuators. 5 Notice the difference between the agent program, which takes the current percept as input, and the agent function, which may depend on the entire percept history. The agent program has no choice but to take just the current percept as input because nothing more is available from the environment; if the agent’s actions need to depend on the entire percept sequence, the agent will have to remember the percepts. We describe the agent programs in the simple pseudocode language that is defined in Appendix B. (The online code repository contains implementations in real programming languages. ) For example, Figure 2. 7 shows a rather trivial agent program that keeps track of the percept sequence and then uses it to index into a table of actions to decide what to do. The table—an example of which is given for the vacuum world in Figure 2. 3—represents explicitly the agent function that the agent program embodies. To build a rational agent in this way, we as designers must construct a table that contains the appropriate action for every possible percept sequence. Description The block diagram starts with a block labeled Agent. There are four blocks inside the Agent block. An arrow labeled, Performance standard, points to a block labeled, Critic. An arrow labeled, feedback, from the Critic block points to a block labeled, Learning element. An arrow labeled, learning goals, from the Learning element block, points to a block labeled, Problem generator. An arrow from the problem generator block points to a block labeled, Performance element. An arrow labeled, changes, from the learning element block points to the performance element block. An arrow labeled, knowledge from the performance element block points back to the Learning element block. Another arrow from the performance element block points to the Actuators. An arrow from the actuators points to the block labeled, Environment, which is outside the agent block. An arrow from the environment block points to the sensors in the agent block. An arrow each from the sensors points to the Performance element and Critic block. Figure 2. 7The TABLE-DRIVEN-AGENT program is invoked for each new percept and returns an action each time. It retains the complete percept sequence in memory. It is instructive to consider why the table-driven approach to agent construction is doomed to failure. Let Ƥ be the set of possible percepts and let T be the lifetime of the agent (the total number of percepts it will receive). The lookup table will contain | Ƥ |t entries. Consider the automated taxi: the visual input from a single camera (eight cameras is typical) comes in at the rate of roughly 70 megabytes per second (30 frames per second, 1080 × 720 pixels with 24 bits of color information). This gives a lookup table with over 10600, 000, 000, 000 entries for an hour’s driving. Even the lookup table for chess—a tiny, well-behaved fragment of the real world—has (it turns out) at least 10150 entries. In comparison, the number of atoms in the observable universe is less than 1080. The daunting size of these tables means that (a) no physical agent in this universe will have the space to store the table; (b) the designer would not have time to create the table; and (c) no agent could ever learn all the right table entries from its experience. Despite all this, TABLE-DRIVEN-AGENT does do what we want, assuming the table is filled in correctly: it implements the desired agent function. The key challenge for AI is to find out how to write programs that, to the extent possible, produce rational behavior from a smallish program rather than from a vast table. We have many examples showing that this can be done successfully in other areas: for example, the huge tables of square roots used by engineers and schoolchildren prior to the 1970s have now been replaced by a five-line program for Newton’s method running on electronic calculators. The question is, can AI do for general intelligent behavior what Newton did for square roots? We believe the answer is yes. In the remainder of this section, we outline four basic kinds of agent programs that embody the principles underlying almost all intelligent systems: •Simple reflex agents; •Model-based reflex agents; •Goal-based agents; and •Utility-based agents. Each kind of agent program combines particular components in particular ways to generate actions. Section 2. 4. 6 explains in general terms how to convert all these agents into learning agents that can improve the performance of their components so as to generate better actions. Finally, Section 2. 4. 7 describes the variety of ways in which the components themselves can be represented within the agent. This variety provides a major organizing principle for the field and for the book itself. 2. 4. 2Simple reflex agents The simplest kind of agent is the simple reflex agent. These agents select actions on the basis of the current percept, ignoring the rest of the percept history. For example, the vacuum agent whose agent function is tabulated in Figure 2. 3 is a simple reflex agent, because its decision is based only on the current location and on whether that location contains dirt. An agent program for this agent is shown in Figure 2. 8. Description Part (“a”), Atomic: An arrow from a block labeled B points to a block labeled C. Part (b), Factored: Two blocks labeled B and C are shown. In both blocks, four circles are shown one below the other and two progress bars are shown below the bottom circle. In block B, the circles have alternating black and blue shades from the top. In the first progress bar, black shade fills about 40 percent of the bar while the blue shade fills the rest. In the second progress bar, the black shade fills about 90 percent of the bar while the blue shade fills the rest. In block C, the first two circles from the top are shaded blue and the other two circles are shaded black. In the first progress bar, black shade fills about 40 percent of the bar while the blue shade fills the rest. In the second progress bar, the black shade fills about 60 percent of the bar while the blue shade fills the rest. Part (c), Structured: The figure shows two blocks connected by an arrow. There are four red blocks, three green blocks, and two white blocks in the first block. These are arranged in three columns and four rows. The following blocks are shown on each row. Row 1: Column 1, red. Column 2, green. Row 2: Column 2, red. Row 3: Column 1, red. Column 2, green. Column 3, white. Row 4: Column 1, white. Column 2, red. Column 3, green. These blocks are connected using arrows in different paths. There are four red blocks, three green blocks, and four white blocks in the second block. These are arranged in three columns and four rows. The following blocks are shown on each row. Row 1: Column 1, white. Column 2, green. Column 3, white. Row 2: Column 2, red. Column 3, red. Row 3: Column 1, red. Column 2, white. Column 3, white. Row 4: Column 1, green. Column 2, red. Column 3, green. These blocks are connected using arrows in different paths. Figure 2. 8The agent program for a simple reflex agent in the two-location vacuum environment. This program implements the agent function tabulated in Figure 2. 3. Notice that the vacuum agent program is very small indeed compared to the corresponding table. The most obvious reduction comes from ignoring the percept history, which cuts down the number of relevant percept sequences from 4T to just 4. A further, small reduction comes from the fact that when the current square is dirty, the action does not depend on the location. Although we have written the agent program using if-then-else statements, it is simple enough that it can also be implemented as a Boolean circuit. Simple reflex behaviors occur even in more complex environments. Imagine yourself as the driver of the automated taxi. If the car in front brakes and its brake lights come on, then you should notice this and initiate braking. In other words, some processing is done on the visual input to establish the condition we call “The car in front is braking. ” Then, this triggers some established connection in the agent program to the action “initiate braking. ” We call such a connection a condition–action rule, 6 written as if car-in-front-is-braking then initiate-braking. Humans also have many such connections, some of which are learned responses (as for driving) and some of which are innate reflexes (such as blinking when something approaches the eye). In the course of the book, we show several different ways in which such connections can be learned and implemented. The program in Figure 2. 8 is specific to one particular vacuum environment. A more general and flexible approach is first to build a general-purpose interpreter for condition–action rules and then to create rule sets for specific task environments. Figure 2. 9 gives the structure of this general program in schematic form, showing how the condition–action rules allow the agent to make the connection from percept to action. Do not worry if this seems trivial; it gets more interesting shortly. Figure 2. 9 Schematic diagram of a simple reflex agent. We use rectangles to denote the current internal state of the agent’s decision process, and ovals to represent the background information used in the process. An agent program for Figure 2. 9 is shown in Figure 2. 10. The INTERPRET-INPUT function generates an abstracted description of the current state from the percept, and the RULE-MATCH function returns the first rule in the set of rules that matches the given state description. Note that the description in terms of “rules” and “matching” is purely conceptual; as noted above, actual implementations can be as simple as a collection of logic gates implementing a Boolean circuit. Alternatively, a “neural” circuit can be used, where the logic gates are replaced by the nonlinear units of artificial neural networks (see Chapter 22). Figure 2. 10A simple reflex agent. It acts according to a rule whose condition matches the current state, as defined by the percept. Simple reflex agents have the admirable property of being simple, but they are of limited intelligence. The agent in Figure 2. 10 will work only if the correct decision can be made on the basis of just the current percept—that is, only if the environment is fully observable. Even a little bit of unobservability can cause serious trouble. For example, the braking rule given earlier assumes that the condition car-in-front-is-braking can be determined from the current percept—a single frame of video. This works if the car in front has a centrally mounted (and hence uniquely identifiable) brake light. Unfortunately, older models have different configurations of taillights, brake lights, and turn-signal lights, and it is not always possible to tell from a single image whether the car is braking or simply has its taillights on. A simple reflex agent driving behind such a car would either brake continuously and unnecessarily, or, worse, never brake at all. We can see a similar problem arising in the vacuum world. Suppose that a simple reflex vacuum agent is deprived of its location sensor and has only a dirt sensor. Such an agent has just two possible percepts: [Dirty] and [Clean]. It can Suck in response to [Dirty]; what should it do in response to [Clean]? Moving Left fails (forever) if it happens to start in square A, and moving Right fails (forever) if it happens to start in square B. Infinite loops are often unavoidable for simple reflex agents operating in partially observable environments. Escape from infinite loops is possible if the agent can randomize its actions. For example, if the vacuum agent perceives [Clean], it might flip a coin to choose between Right and Left. It is easy to show that the agent will reach the other square in an average of two steps. Then, if that square is dirty, the agent will clean it and the task will be complete. Hence, a randomized simple reflex agent might outperform a deterministic simple reflex agent. We mentioned in Section 2. 3 that randomized behavior of the right kind can be rational in some multiagent environments. In single-agent environments, randomization is usually not rational. It is a useful trick that helps a simple reflex agent in some situations, but in most cases we can do much better with more sophisticated deterministic agents. 2. 4. 3Model-based reflex agents The most effective way to handle partial observability is for the agent to keep track of the part of the world it can’t see now. That is, the agent should maintain some sort of internal state that depends on the percept history and thereby reflects at least some of the unobserved aspects of the current state. For the braking problem, the internal state is not too extensive—just the previous frame from the camera, allowing the agent to detect when two red lights at the edge of the vehicle go on or off simultaneously. For other driving tasks such as changing lanes, the agent needs to keep track of where the other cars are if it can’t see them all at once. And for any driving to be possible at all, the agent needs to keep track of where its keys are. Updating this internal state information as time goes by requires two kinds of knowledge to be encoded in the agent program in some form. First, we need some information about how the world changes over time, which can be divided roughly into two parts: the effects of the agent’s actions and how the world evolves independently of the agent. For example, when the agent turns the steering wheel clockwise, the car turns to the right, and when it’s raining the car’s cameras can get wet. This knowledge about “how the world works”—whether implemented in simple Boolean circuits or in complete scientific theories—is called a transition model of the world. Second, we need some information about how the state of the world is reflected in the agent’s percepts. For example, when the car in front initiates braking, one or more illuminated red regions appear in the forward-facing camera image, and, when the camera gets wet, droplet-shaped objects appear in the image partially obscuring the road. This kind of knowledge is called a sensor model. Together, the transition model and sensor model allow an agent to keep track of the state of the world—to the extent possible given the limitations of the agent’s sensors. An agent that uses such models is called a model-based agent. Figure 2. 11 gives the structure of the model-based reflex agent with internal state, showing how the current percept is combined with the old internal state to generate the updated description of the current state, based on the agent’s model of how the world works. The agent program is shown in Figure 2. 12. The interesting part is the function UPDATE-STATE, which is responsible for creating the new internal state description. The details of how models and states are represented vary widely depending on the type of environment and the particular technology used in the agent design. Figure 2. 11A model-based reflex agent. Figure 2. 12A model-based reflex agent. It keeps track of the current state of the world, using an internal model. It then chooses an action in the same way as the reflex agent. Regardless of the kind of representation used, it is seldom possible for the agent to determine the current state of a partially observable environment exactly. Instead, the box labeled “what the world is like now” (Figure 2. 11) represents the agent’s “best guess” (or sometimes best guesses, if the agent entertains multiple possibilities). For example, an automated taxi may not be able to see around the large truck that has stopped in front of it and can only guess about what may be causing the hold-up. Thus, uncertainty about the current state may be unavoidable, but the agent still has to make a decision. 2. 4. 4Goal-based agents Knowing something about the current state of the environment is not always enough to decide what to do. For example, at a road junction, the taxi can turn left, turn right, or go straight on. The correct decision depends on where the taxi is trying to get to. In other words, as well as a current state description, the agent needs some sort of goal information that describes situations that are desirable—for example, being at a particular destination. The agent program can combine this with the model (the same information as was used in the model-based reflex agent) to choose actions that achieve the goal. Figure 2. 13 shows the goal-based agent’s structure. Figure 2. 13A model-based, goal-based agent. It keeps track of the world state as well as a set of goals it is trying to achieve, and chooses an action that will (eventually) lead to the achievement of its goals. Sometimes goal-based action selection is straightforward—for example, when goal satisfaction results immediately from a single action. Sometimes it will be more tricky—for example, when the agent has to consider long sequences of twists and turns in order to find a way to achieve the goal. Search (Chapters 3, 4, and 6) and planning (Chapter 11) are the subfields of AI devoted to finding action sequences that achieve the agent’s goals. Notice that decision making of this kind is fundamentally different from the condition–action rules described earlier, in that it involves consideration of the future—both “What will happen if I do such-and-such? ” and “Will that make me happy? ” In the reflex agent designs, this information is not explicitly represented, because the built-in rules map directly from percepts to actions. The reflex agent brakes when it sees brake lights, period. It has no idea why. A goal-based agent brakes when it sees brake lights because that’s the only action that it predicts will achieve its goal of not hitting other cars. Although the goal-based agent appears less efficient, it is more flexible because the knowledge that supports its decisions is represented explicitly and can be modified. For example, a goal-based agent’s behavior can easily be changed to go to a different destination, simply by specifying that destination as the goal. The reflex agent’s rules for when to turn and when to go straight will work only for a single destination; they must all be replaced to go somewhere new. 2. 4. 5Utility-based agents Goals alone are not enough to generate high-quality behavior in most environments. For example, many action sequences will get the taxi to its destination (thereby achieving the goal), but some are quicker, safer, more reliable, or cheaper than others. Goals just provide a crude binary distinction between “happy” and “unhappy” states. A more general performance measure should allow a comparison of different world states according to exactly how happy they would make the agent. Because “happy” does not sound very scientific, economists and computer scientists use the term utility instead. 7 We have already seen that a performance measure assigns a score to any given sequence of environment states, so it can easily distinguish between more and less desirable ways of getting to the taxi’s destination. An agent’s utility function is essentially an internalization of the performance measure. Provided that the internal utility function and the external performance measure are in agreement, an agent that chooses actions to maximize its utility will be rational according to the external performance measure. Let us emphasize again that this is not the only way to be rational—we have already seen a rational agent program for the vacuum world (Figure 2. 8) that has no idea what its utility function is—but, like goal-based agents, a utility-based agent has many advantages in terms of flexibility and learning. Furthermore, in two kinds of cases, goals are inadequate but a utility-based agent can still make rational decisions. First, when there are conflicting goals, only some of which can be achieved (for example, speed and safety), the utility function specifies the appropriate tradeoff. Second, when there are several goals that the agent can aim for, none of which can be achieved with certainty, utility provides a way in which the likelihood of success can be weighed against the importance of the goals. Partial observability and nondeterminism are ubiquitous in the real world, and so, therefore, is decision making under uncertainty. Technically speaking, a rational utility-based agent chooses the action that maximizes the expected utility of the action outcomes—that is, the utility the agent expects to derive, on average, given the probabilities and utilities of each outcome. (Appendix A defines expectation more precisely. ) In Chapter 15, we show that any rational agent must behave as if it possesses a utility function whose expected value it tries to maximize. An agent that possesses an explicit utility function can make rational decisions with a general-purpose algorithm that does not depend on the specific utility function being maximized. In this way, the “global” definition of rationality—designating as rational those agent functions that have the highest performance—is turned into a “local” constraint on rational-agent designs that can be expressed in a simple program. The utility-based agent structure appears in Figure 2. 14. Utility-based agent programs appear in Chapters 15 and 16, where we design decision-making agents that must handle the uncertainty inherent in nondeterministic or partially observable environments. Decision making in multiagent environments is also studied in the framework of utility theory, as explained in Chapter 17. Figure 2. 14A model-based, utility-based agent. It uses a model of the world, along with a utility function that measures its preferences among states of the world. Then it chooses the action that leads to the best expected utility, where expected utility is computed by averaging over all possible outcome states, weighted by the probability of the outcome. At this point, the reader may be wondering, “Is it that simple? We just build agents that maximize expected utility, and we’re done? ” It’s true that such agents would be intelligent, but it’s not simple. A utility-based agent has to model and keep track of its environment, tasks that have involved a great deal of research on perception, representation, reasoning, and learning. The results of this research fill many of the chapters of this book. Choosing the utility-maximizing course of action is also a difficult task, requiring ingenious algorithms that fill several more chapters. Even with these algorithms, perfect rationality is usually unachievable in practice because of computational complexity, as we noted in Chapter 1. We also note that not all utility-based agents are model-based; we will see in Chapters 23 and 26 that a model-free agent can learn what action is best in a particular situation without ever learning exactly how that action changes the environment. Finally, all of this assumes that the designer can specify the utility function correctly; Chapters 16, 17, and 23 consider the issue of unknown utility functions in more depth. 2. 4. 6Learning agents We have described agent programs with various methods for selecting actions. We have not, so far, explained how the agent programs come into being. In his famous early paper, Turing (1950) considers the idea of actually programming his intelligent machines by hand. He estimates how much work this might take and concludes, “Some more expeditious method seems desirable. ” The method he proposes is to build learning machines and then to teach them. In many areas of AI, this is now the preferred method for creating state-of-the-art systems. Any type of agent (model-based, goal-based, utility-based, etc. ) can be built as a learning agent (or not). Learning has another advantage, as we noted earlier: it allows the agent to operate in initially unknown environments and to become more competent than its initial knowledge alone might allow. In this section, we briefly introduce the main ideas of learning agents. Throughout the book, we comment on opportunities and methods for learning in particular kinds of agents. Chapters 19, 21, 22, and 23 go into much more depth on the learning algorithms themselves. A learning agent can be divided into four conceptual components, as shown in Figure 2. 15. The most important distinction is between the learning element, which is responsible for making improvements, and the performance element, which is responsible for selecting external actions. The performance element is what we have previously considered to be the entire agent: it takes in percepts and decides on actions. The learning element uses feedback from the critic on how the agent is doing and determines how the performance element should be modified to do better in the future. Figure 2. 15A general learning agent. The “performance element” box represents what we have previously considered to be the whole agent program. Now, the “learning element” box gets to modify that program to improve its performance. The design of the learning element depends very much on the design of the performance element. When trying to design an agent that learns a certain capability, the first question is not “How am I going to get it to learn this? ” but “What kind of performance element will my agent use to do this once it has learned how? ” Given a design for the performance element, learning mechanisms can be constructed to improve every part of the agent. The critic tells the learning element how well the agent is doing with respect to a fixed performance standard. The critic is necessary because the percepts themselves provide no indication of the agent’s success. For example, a chess program could receive a percept indicating that it has checkmated its opponent, but it needs a performance standard to know that this is a good thing; the percept itself does not say so. It is important that the performance standard be fixed. Conceptually, one should think of it as being outside the agent altogether because the agent must not modify it to fit its own behavior. The last component of the learning agent is the problem generator. It is responsible for suggesting actions that will lead to new and informative experiences. If the performance element had its way, it would keep doing the actions that are best, given what it knows, but if the agent is willing to explore a little and do some perhaps suboptimal actions in the short run, it might discover much better actions for the long run. The problem generator’s job is to suggest these exploratory actions. This is what scientists do when they carry out experiments. Galileo did not think that dropping rocks from the top of a tower in Pisa was valuable in itself. He was not trying to break the rocks or to modify the brains of unfortunate pedestrians. His aim was to modify his own brain by identifying a better theory of the motion of objects. The learning element can make changes to any of the “knowledge” components shown in the agent diagrams (Figures 2. 9, 2. 11, 2. 13, and 2. 14). The simplest cases involve learning directly from the percept sequence. Observation of pairs of successive states of the environment can allow the agent to learn “What my actions do” and “How the world evolves” in response to its actions. For example, if the automated taxi exerts a certain braking pressure when driving on a wet road, then it will soon find out how much deceleration is actually achieved, and whether it skids off the road. The problem generator might identify certain parts of the model that are in need of improvement and suggest experiments, such as trying out the brakes on different road surfaces under different conditions. Improving the model components of a model-based agent so that they conform better with reality is almost always a good idea, regardless of the external performance standard. (In some cases, it is better from a computational point of view to have a simple but slightly inaccurate model rather than a perfect but fiendishly complex model. ) Information from the external standard is needed when trying to learn a reflex component or a utility function. For example, suppose the taxi-driving agent receives no tips from passengers who have been thoroughly shaken up during the trip. The external performance standard must inform the agent that the loss of tips is a negative contribution to its overall performance; then the agent might be able to learn that violent maneuvers do not contribute to its own utility. In a sense, the performance standard distinguishes part of the incoming percept as a reward (or penalty) that provides direct feedback on the quality of the agent’s behavior. Hard-wired performance standards such as pain and hunger in animals can be understood in this way. More generally, human choices can provide information about human preferences. For example, suppose the taxi does not know that people generally don’t like loud noises, and settles on the idea of blowing its horn continuously as a way of ensuring that pedestrians know it’s coming. The consequent human behavior—covering ears, using bad language, and possibly cutting the wires to the horn—would provide evidence to the agent with which to update its utility function. This issue is discussed further in Chapter 23. In summary, agents have a variety of components, and those components can be represented in many ways within the agent program, so there appears to be great variety among learning methods. There is, however, a single unifying theme. Learning in intelligent agents can be summarized as a process of modification of each component of the agent to bring the components into closer agreement with the available feedback information, thereby improving the overall performance of the agent. 2. 4. 7How the components of agent programs work We have described agent programs (in very high-level terms) as consisting of various components, whose function it is to answer questions such as: “What is the world like now? ” “What action should I do now? ” “What do my actions do? ” The next question for a student of AI is, “How on Earth do these components work? ” It takes about a thousand pages to begin to answer that question properly, but here we want to draw the reader’s attention to some basic distinctions among the various ways that the components can represent the environment that the agent inhabits. Roughly speaking, we can place the representations along an axis of increasing complexity and expressive power—atomic, factored, and structured. To illustrate these ideas, it helps to consider a particular agent component, such as the one that deals with “What my actions do. ” This component describes the changes that might occur in the environment as the result of taking an action, and Figure 2. 16 provides schematic depictions of how those transitions might be represented. Description Part (“a”), Atomic: An arrow from a block labeled B points to a block labeled C. Part (b), Factored: Two blocks labeled B and C are shown. In both blocks, four circles are shown one below the other and two progress bars are shown below the bottom circle. In block B, the circles have alternating black and blue shades from the top. In the first progress bar, black shade fills about 40 percent of the bar while the blue shade fills the rest. In the second progress bar, the black shade fills about 90 percent of the bar while the blue shade fills the rest. In block C, the first two circles from the top are shaded blue and the other two circles are shaded black. In the first progress bar, black shade fills about 40 percent of the bar while the blue shade fills the rest. In the second progress bar, the black shade fills about 60 percent of the bar while the blue shade fills the rest. Part (c), Structured: The figure shows two blocks connected by an arrow. There are four red blocks, three green blocks, and two white blocks in the first block. These are arranged in three columns and four rows. The following blocks are shown on each row. Row 1: Column 1, red. Column 2, green. Row 2: Column 2, red. Row 3: Column 1, red. Column 2, green. Column 3, white. Row 4: Column 1, white. Column 2, red. Column 3, green. These blocks are connected using arrows in different paths. There are four red blocks, three green blocks, and four white blocks in the second block. These are arranged in three columns and four rows. The following blocks are shown on each row. Row 1: Column 1, white. Column 2, green. Column 3, white. Row 2: Column 2, red. Column 3, red. Row 3: Column 1, red. Column 2, white. Column 3, white. Row 4: Column 1, green. Column 2, red. Column 3, green. These blocks are connected using arrows in different paths. Figure 2. 16Three ways to represent states and the transitions between them. (a) Atomic representation: a state (such as B or C) is a black box with no internal structure; (b) Factored representation: a state consists of a vector of attribute values; values can be Boolean, real-valued, or one of a fixed set of symbols. (c) Structured representation: a state includes objects, each of which may have attributes of its own as well as relationships to other objects. In an atomic representation each state of the world is indivisible—it has no internal structure. Consider the task of finding a driving route from one end of a country to the other via some sequence of cities (we address this problem in Figure 3. 1 on page 82). For the purposes of solving this problem, it may suffice to reduce the state of the world to just the name of the city we are in—a single atom of knowledge, a “black box” whose only discernible property is that of being identical to or different from another black box. The standard algorithms underlying search and game-playing (Chapters 3, 4, and 6), hidden Markov models (Chapter 14), and Markov decision processes (Chapter 16) all work with atomic representations. A factored representation splits up each state into a fixed set of variables or attributes, each of which can have a value. Consider a higher-fidelity description for the same driving problem, where we need to be concerned with more than just atomic location in one city or another; we might need to pay attention to how much gas is in the tank, our current GPS coordinates, whether or not the oil warning light is working, how much money we have for tolls, what station is on the radio, and so on. While two different atomic states have nothing in common—they are just different black boxes—two different factored states can share some attributes (such as being at some particular GPS location) and not others (such as having lots of gas or having no gas); this makes it much easier to work out how to turn one state into another. Many important areas of AI are based on factored representations, including constraint satisfaction algorithms (Chapter 5), propositional logic (Chapter 7), planning (Chapter 11), Bayesian networks (Chapters 12, 13, 14, 15, and 18), and various machine learning algorithms. For many purposes, we need to understand the world as having things in it that are related to each other, not just variables with values. For example, we might notice that a large truck ahead of us is reversing into the driveway of a dairy farm, but a loose cow is blocking the truck’s path. A factored representation is unlikely to be pre-equipped with the attribute TruckAheadBackinglntoDairyFarmDrivewayBlockedByLooseCow with value true or false. Instead, we would need a structured representation, in which objects such as cows and trucks and their various and varying relationships can be described explicitly (see Figure 2. 16(c)). Structured representations underlie relational databases and first-order logic (Chapters 8, 9, and 10), first-order probability models (Chapter 18), and much of natural language understanding (Chapters 24 and 25). In fact, much of what humans express in natural language concerns objects and their relationships. As we mentioned earlier, the axis along which atomic, factored, and structured representations lie is the axis of increasing expressiveness. Roughly speaking, a more expressive representation can capture, at least as concisely, everything a less expressive one can capture, plus some more. Often, the more expressive language is much more concise; for example, the rules of chess can be written in a page or two of a structured-representation language such as first-order logic but require thousands of pages when written in a factored-representation language such as propositional logic and around 1038 pages when written in an atomic language such as that of finite-state automata. On the other hand, reasoning and learning become more complex as the expressive power of the representation increases. To gain the benefits of expressive representations while avoiding their drawbacks, intelligent systems for the real world may need to operate at all points along the axis simultaneously. Another axis for representation involves the mapping of concepts to locations in physical memory, whether in a computer or in a brain. If there is a one-to-one mapping between concepts and memory locations, we call that a localist representation. On the other hand, if the representation of a concept is spread over many memory locations, and each memory location is employed as part of the representation of multiple different concepts, we call that a distributed representation. Distributed representations are more robust against noise and information loss. With a localist representation, the mapping from concept to memory location is arbitrary, and if a transmission error garbles a few bits, we might confuse Truck with the unrelated concept Truce. But with a distributed representation, you can think of each concept representing a point in multidimensional space, and if you garble a few bits you move to a nearby point in that space, which will have similar meaning. Summary This chapter has been something of a whirlwind tour of AI, which we have conceived of as the science of agent design. The major points to recall are as follows: •An agent is something that perceives and acts in an environment. The agent function for an agent specifies the action taken by the agent in response to any percept sequence. •The performance measure evaluates the behavior of the agent in an environment. A rational agent acts so as to maximize the expected value of the performance measure, given the percept sequence it has seen so far. •A task environment specification includes the performance measure, the external environment, the actuators, and the sensors. In designing an agent, the first step must always be to specify the task environment as fully as possible. •Task environments vary along several significant dimensions. They can be fully or partially observable, single-agent or multiagent, deterministic or nondeterministic, episodic or sequential, static or dynamic, discrete or continuous, and known or unknown. •In cases where the performance measure is unknown or hard to specify correctly, there is a significant risk of the agent optimizing the wrong objective. In such cases the agent design should reflect uncertainty about the true objective. •The agent program implements the agent function. There exists a variety of basic agent program designs reflecting the kind of information made explicit and used in the decision process. The designs vary in efficiency, compactness, and flexibility. The appropriate design of the agent program depends on the nature of the environment. • Simple reflex agents respond directly to percepts, whereas model-based reflex agents maintain internal state to track aspects of the world that are not evident in the current percept. Goal-based agents act to achieve their goals, and utility-based agents try to maximize their own expected “happiness. ” •All agents can improve their performance through learning. Bibliographical and Historical Notes The central role of action in intelligence—the notion of practical reasoning—goes back at least as far as Aristotle’s Nicomachean Ethics. Practical reasoning was also the subject of McCarthy’s influential paper “Programs with Common Sense” (1958). The fields of robotics and control theory are, by their very nature, concerned principally with physical agents. The concept of a controller in control theory is identical to that of an agent in AI. Perhaps surprisingly, AI has concentrated for most of its history on isolated components of agents—question-answering systems, theorem-provers, vision systems, and so on—rather than on whole agents. The discussion of agents in the text by Genesereth and Nilsson (1987) was an influential exception. The whole-agent view is now widely accepted and is a central theme in recent texts (Padgham and Winikoff, 2004; Jones, 2007; Poole and Mackworth, 2017). Chapter 1 traced the roots of the concept of rationality in philosophy and economics. In AI, the concept was of peripheral interest until the mid-1980s, when it began to suffuse many discussions about the proper technical foundations of the field. A paper by Jon Doyle (1983) predicted that rational agent design would come to be seen as the core mission of AI, while other popular topics would spin off to form new disciplines. Careful attention to the properties of the environment and their consequences for rational agent design is most apparent in the control theory tradition—for example, classical control systems (Dorf and Bishop, 2004; Kirk, 2004) handle fully observable, deterministic environments; stochastic optimal control (Kumar and Varaiya, 1986; Bertsekas and Shreve, 2007) handles partially observable, stochastic environments; and hybrid control (Henzinger and Sastry, 1998; Cassandras and Lygeros, 2006) deals with environments containing both discrete and continuous elements. The distinction between fully and partially observable environments is also central in the dynamic programming literature developed in the field of operations research (Puterman, 1994), which we discuss in Chapter 16. Although simple reflex agents were central to behaviorist psychology (see Chapter 1), most AI researchers view them as too simple to provide much leverage. (Rosenschein (1985) and Brooks (1986) questioned this assumption; see Chapter 26. ) A great deal of work has gone into finding efficient algorithms for keeping track of complex environments (Bar-Shalom et al. , 2001; Choset et al. , 2005; Simon, 2006), most of it in the probabilistic setting. Goal-based agents are presupposed in everything from Aristotle’s view of practical reasoning to McCarthy’s early papers on logical AI. Shakey the Robot (Fikes and Nilsson, 1971; Nilsson, 1984) was the first robotic embodiment of a logical, goal-based agent. A full logical analysis of goal-based agents appeared in Genesereth and Nilsson (1987), and a goal-based programming methodology called agent-oriented programming was developed by Shoham (1993). The agent-based approach is now extremely popular in software engineering (Ciancarini and Wooldridge, 2001). It has also infiltrated the area of operating systems, where autonomic computing refers to computer systems and networks that monitor and control themselves with a perceive–act loop and machine learning methods (Kephart and Chess, 2003). Noting that a collection of agent programs designed to work well together in a true multiagent environment necessarily exhibits modularity—the programs share no internal state and communicate with each other only through the environment—it is common within the field of multiagent systems to design the agent program of a single agent as a collection of autonomous sub-agents. In some cases, one can even prove that the resulting system gives the same optimal solutions as a monolithic design. The goal-based view of agents also dominates the cognitive psychology tradition in the area of problem solving, beginning with the enormously influential Human Problem Solving (Newell and Simon, 1972) and running through all of Newell’s later work (Newell, 1990). Goals, further analyzed as desires (general) and intentions (currently pursued), are central to the influential theory of agents developed by Michael Bratman (1987). As noted in Chapter 1, the development of utility theory as a basis for rational behavior goes back hundreds of years. In AI, early research eschewed utilities in favor of goals, with some exceptions (Feldman and Sproull, 1977). The resurgence of interest in probabilistic methods in the 1980s led to the acceptance of maximization of expected utility as the most general framework for decision making (Horvitz et al. , 1988). The text by Pearl (1988) was the first in AI to cover probability and utility theory in depth; its exposition of practical methods for reasoning and decision making under uncertainty was probably the single biggest factor in the rapid shift towards utility-based agents in the 1990s (see Chapter 15). The formalization of reinforcement learning within a decision-theoretic framework also contributed to this shift (Sutton, 1988). Somewhat remarkably, almost all AI research until very recently has assumed that the performance measure can be exactly and correctly specified in the form of a utility function or reward function (Hadfield-Menell et al. , 2017a; Russell, 2019). The general design for learning agents portrayed in Figure 2. 15 is classic in the machine learning literature (Buchanan et al. , 1978; Mitchell, 1997). Examples of the design, as embodied in programs, go back at least as far as Arthur Samuel’s (1959, 1967) learning program for playing checkers. Learning agents are discussed in depth in Chapters 19, 21, 22, and 23. Some early papers on agent-based approaches are collected by Huhns and Singh (1998) and Wooldridge and Rao (1999). Texts on multiagent systems provide a good introduction to many aspects of agent design (Weiss, 2000a; Wooldridge, 2009). Several conference series devoted to agents began in the 1990s, including the International Workshop on Agent Theories, Architectures, and Languages (ATAL), the International Conference on Autonomous Agents (AGENTS), and the International Conference on Multi-Agent Systems (ICMAS). In 2002, these three merged to form the International Joint Conference on Autonomous Agents and Multi-Agent Systems (AAMAS). From 2000 to 2012 there were annual workshops on Agent-Oriented Software Engineering (AOSE). The journal Autonomous Agents and Multi-Agent Systems was founded in 1998. Finally, Dung Beetle Ecology (Hanski and Cambefort, 1991) provides a wealth of interesting information on the behavior of dung beetles. YouTube has inspiring video recordings of their activities. 1If the agent uses some randomization to choose its actions, then we would have to try each sequence many times to identify the probability of each action. One might imagine that acting randomly is rather silly, but we show later in this chapter that it can be very intelligent. 2In a real robot, it would be unlikely to have an actions like “move right” and “move left. ” Instead the actions would be “spin wheels forward” and “spin wheels backward. ” We have chosen the actions to be easier to follow on the page, not for ease of implementation in an actual robot. 3See N. Henderson, “New door latches urged for Boeing 747 jumbo jets, ” Washington Post, August 24, 1989. 4The word “sequential” is also used in computer science as the antonym of “parallel. ” The two meanings are largely unrelated. 5There are other choices for the agent program skeleton; for example, we could have the agent programs be coroutines that run asynchronously with the environment. Each such coroutine has an input and output port and consists of a loop that reads the input port for percepts and writes actions to the output port. 6Also called situation–action rules, productions, or if–then rules. 7The word “utility” here refers to “the quality of being useful, ” not to the electric company or waterworks.",前：None | 后：None,AI_Popular,Formal_Academic,"agent,environment,block","keyboard/mouse,Dirt,Actuators,AI,AI,Norbert Wiener,King Midas,Suck,Champs Elysées,caterpillar,caterpillar,caterpillar,caterpillar,Nature of Environments,State,Actuators,Alaska,Britain,Japan,State,Actuators,AI,Deterministic,e. g.,e. g.,Chess,Chess,State,Actuators,berkeley,4The Structure of Agents So,AI,Walk,Appendix B.,Critic,Learning,Learning,Learning,Actuators,Performance,TABLE-DRIVEN-AGENT,AI,Newton,AI,Newton,•Goal,Atomic,C. Part,Schematic,The INTERPRET-INPUT,Suck,Knowing,AI,Chapters 16,Turing,AI,Galileo,Pisa,AI,Atomic,C. Part,Markov,Markov,AI,Truck,Truce,AI,Aristotle’s Nicomachean Ethics,McCarthy,Programs with Common Sense,AI,AI,Genesereth,Nilsson,Padgham,Winikoff,Jones,Poole,Mackworth,AI,Jon Doyle,AI,Dorf,Bishop,Kirk,Kumar,Varaiya,Bertsekas,Henzinger and Sastry,Cassandras,Lygeros,AI,Rosenschein,Brooks,Bar-Shalom,Choset,Simon,Aristotle,McCarthy,Nilsson,Nilsson,Genesereth,Nilsson,Shoham,Ciancarini and Wooldridge,Kephart,Chess,Problem Solving,Newell,Simon,Newell,Newell,Michael Bratman,AI,Feldman,Sproull,Horvitz,Pearl,AI,Sutton,AI,Hadfield-Menell,al.,Russell,Buchanan,al.,Mitchell,Arthur Samuel’s,Huhns,Singh,Wooldridge,Rao,Weiss,Wooldridge,the International Workshop on Agent Theories,the International Conference on Autonomous Agents,the International Conference on Multi-Agent Systems,the International Joint Conference on Autonomous Agents,AOSE,Autonomous Agents,Hanski and Cambefort,YouTube,N. Henderson,Boeing,747,Washington Post",,
chap3_para1,3,"SOLVING PROBLEMS BY SEARCHING In which we see how an agent can look ahead to find a sequence of actions that will eventually achieve its goal. When the correct action to take is not immediately obvious, an agent may need to plan ahead: to consider a sequence of actions that form a path to a goal state. Such an agent is called a problem-solving agent, and the computational process it undertakes is called search. Problem-solving agents use atomic representations, as described in Section 2. 4. 7—that is, states of the world are considered as wholes, with no internal structure visible to the problem-solving algorithms. Agents that use factored or structured representations of states are called planning agents and are discussed in Chapters 7 and 11. We will cover several search algorithms. In this chapter, we consider only the simplest environments: episodic, single agent, fully observable, deterministic, static, discrete, and known. We distinguish between informed algorithms, in which the agent can estimate how far it is from the goal, and uninformed algorithms, where no such estimate is available. Chapter 4 relaxes the constraints on environments, and Chapter 6 considers multiple agents. This chapter uses the concepts of asymptotic complexity (that is, O(n) notation). Readers unfamiliar with these concepts should consult Appendix A. 3. 1Problem-Solving Agents Imagine an agent enjoying a touring vacation in Romania. The agent wants to take in the sights, improve its Romanian, enjoy the nightlife, avoid hangovers, and so on. The decision problem is a complex one. Now, suppose the agent is currently in the city of Arad and has a nonrefundable ticket to fly out of Bucharest the following day. The agent observes street signs and sees that there are three roads leading out of Arad: one toward Sibiu, one to Timisoara, and one to Zerind. None of these are the goal, so unless the agent is familiar with the geography of Romania, it will not know which road to follow. 1 If the agent has no additional information—that is, if the environment is unknown—then the agent can do no better than to execute one of the actions at random. This sad situation is discussed in Chapter 4. In this chapter, we will assume our agents always have access to information about the world, such as the map in Figure 3. 1. With that information, the agent can follow this four-phase problem-solving process: Description The road map shows the distance in miles between cities. Neamt to Iasi, 87. Iasi to Valsui, 92. Vaslui to Urziceni, 142. Urziceni to Hirsova, 98. Hirsova to Eforie, 86. Urziceni to Bucharest, 85. Bucharest to Giurgiu, 90. Bucharest to Pitesti, 101. Bucharest to Fagaras, 211. Fagaras to Sibiu, 99. Pitesti to Craiova, 138. Pitesti to Rimnicu Vilcea, 97. Rimnicu Vilcea to Sibiu, 80. Sibiu to Oradea, 151. Sibiu to Arad, 140. Arad to Zerind, 75. Zerind to Oradea, 71. Arad to Timisoara, 118. Timisoara to Lugoj, 111. Lugoj to Mehadia, 70. Mehadia to Drobeta, 75. Drobeta to Craiova, 120. Figure 3. 1A simplified road map of part of Romania, with road distances in miles. •Goal formulation: The agent adopts the goal of reaching Bucharest. Goals organize behavior by limiting the objectives and hence the actions to be considered. •Problem formulation: The agent devises a description of the states and actions necessary to reach the goal—an abstract model of the relevant part of the world. For our agent, one good model is to consider the actions of traveling from one city to an adjacent city, and therefore the only fact about the state of the world that will change due to an action is the current city. •Search: Before taking any action in the real world, the agent simulates sequences of actions in its model, searching until it finds a sequence of actions that reaches the goal. Such a sequence is called a solution. The agent might have to simulate multiple sequences that do not reach the goal, but eventually it will find a solution (such as going from Arad to Sibiu to Fagaras to Bucharest), or it will find that no solution is possible. •Execution: The agent can now execute the actions in the solution, one at a time. It is an important property that in a fully observable, deterministic, known environment, the solution to any problem is a fixed sequence of actions: drive to Sibiu, then Fagaras, then Bucharest. If the model is correct, then once the agent has found a solution, it can ignore its percepts while it is executing the actions—closing its eyes, so to speak—because the solution is guaranteed to lead to the goal. Control theorists call this an open-loop system: ignoring the percepts breaks the loop between agent and environment. If there is a chance that the model is incorrect, or the environment is nondeterministic, then the agent would be safer using a closed-loop approach that monitors the percepts (see Section 4. 4). In partially observable or nondeterministic environments, a solution would be a branching strategy that recommends different future actions depending on what percepts arrive. For example, the agent might plan to drive from Arad to Sibiu but might need a contingency plan in case it arrives in Zerind by accident or finds a sign saying “Drum Închis” (Road Closed). 3. 1. 1Search problems and solutions A search problem can be defined formally as follows: •A set of possible states that the environment can be in. We call this the state space. •The initial state that the agent starts in. For example: Arad. •A set of one or more goal states. Sometimes there is one goal state (e. g. , Bucharest), sometimes there is a small set of alternative goal states, and sometimes the goal is defined by a property that applies to many states (potentially an infinite number). For example, in a vacuum-cleaner world, the goal might be to have no dirt in any location, regardless of any other facts about the state. We can account for all three of these possibilities by specifying an IS-GOAL method for a problem. In this chapter we will sometimes say “the goal” for simplicity, but what we say also applies to “any one of the possible goal states. ” •The actions available to the agent. Given a state s, ACTIONS(s) returns a finite2 set of actions that can be executed in s. We say that each of these actions is applicable in s. An example: •A transition model, which describes what each action does. RESULT(s, a) returns the state that results from doing action a in state s. For example, •An action cost function, denoted by ACTION-COST(S, a, sʹ) when we are programming or c(s, a, sʹ) when we are doing math, that gives the numeric cost of applying action a in state s to reach state sʹ. A problem-solving agent should use a cost function that reflects its own performance measure; for example, for route-finding agents, the cost of an action might be the length in miles (as seen in Figure 3. 1), or it might be the time it takes to complete the action. A sequence of actions forms a path, and a solution is a path from the initial state to a goal state. We assume that action costs are additive; that is, the total cost of a path is the sum of the individual action costs. An optimal solution has the lowest path cost among all solutions. In this chapter, we assume that all action costs will be positive, to avoid certain complications. 3 The state space can be represented as a graph in which the vertices are states and the directed edges between them are actions. The map of Romania shown in Figure 3. 1 is such a graph, where each road indicates two actions, one in each direction. 3. 1. 2Formulating problems Our formulation of the problem of getting to Bucharest is a model—an abstract mathematical description—and not the real thing. Compare the simple atomic state description Arad to an actual cross-country trip, where the state of the world includes so many things: the traveling companions, the current radio program, the scenery out of the window, the proximity of law enforcement officers, the distance to the next rest stop, the condition of the road, the weather, the traffic, and so on. All these considerations are left out of our model because they are irrelevant to the problem of finding a route to Bucharest. The process of removing detail from a representation is called abstraction. A good problem formulation has the right level of detail. If the actions were at the level of “move the right foot forward a centimeter” or “turn the steering wheel one degree left, ” the agent would probably never find its way out of the parking lot, let alone to Bucharest. Can we be more precise about the appropriate level of abstraction? Think of the abstract states and actions we have chosen as corresponding to large sets of detailed world states and detailed action sequences. Now consider a solution to the abstract problem: for example, the path from Arad to Sibiu to Rimnicu Vilcea to Pitesti to Bucharest. This abstract solution corresponds to a large number of more detailed paths. For example, we could drive with the radio on between Sibiu and Rimnicu Vilcea, and then switch it off for the rest of the trip. The abstraction is valid if we can elaborate any abstract solution into a solution in the more detailed world; a sufficient condition is that for every detailed state that is “in Arad, ” there is a detailed path to some state that is “in Sibiu, ” and so on. 4 The abstraction is useful if carrying out each of the actions in the solution is easier than the original problem; in our case, the action “drive from Arad to Sibiu” can be carried out without further search or planning by a driver with average skill. The choice of a good abstraction thus involves removing as much detail as possible while retaining validity and ensuring that the abstract actions are easy to carry out. Were it not for the ability to construct useful abstractions, intelligent agents would be completely swamped by the real world. 3. 2Example Problems The problem-solving approach has been applied to a vast array of task environments. We list some of the best known here, distinguishing between standardized and real-world problems. A standardized problem is intended to illustrate or exercise various problem-solving methods. It can be given a concise, exact description and hence is suitable as a benchmark for researchers to compare the performance of algorithms. A real-world problem, such as robot navigation, is one whose solutions people actually use, and whose formulation is idiosyncratic, not standardized, because, for example, each robot has different sensors that produce different data. 3. 2. 1Standardized problems A grid world problem is a two-dimensional rectangular array of square cells in which agents can move from cell to cell. Typically the agent can move to any obstacle-free adjacent cell—horizontally or vertically and in some problems diagonally. Cells can contain objects, which the agent can pick up, push, or otherwise act upon; a wall or other impassible obstacle in a cell prevents an agent from moving into that cell. The vacuum world from Section 2. 1 can be formulated as a grid world problem as follows: •States: A state of the world says which objects are in which cells. For the vacuum world, the objects are the agent and any dirt. In the simple two-cell version, the agent can be in either of the two cells, and each cell can either contain dirt or not, so there are 2 · 2 · 2 = 8 states (see Figure 3. 2). In general, a vacuum environment with n cells has n · 2n states. •Initial state: Any state can be designated as the initial state. •Actions: In the two-cell world we defined three actions: Suck, move Left, and move Right. In a two-dimensional multi-cell world we need more movement actions. We could add Upward and Downward, giving us four absolute movement actions, or we could switch to egocentric actions, defined relative to the viewpoint of the agent—for example, Forward, Backward, TurnRight, and TurnLeft. •Transition model: Suck removes any dirt from the agent’s cell; Forward moves the agent ahead one cell in the direction it is facing, unless it hits a wall, in which case the action has no effect. Backward moves the agent in the opposite direction, while TurnRight and TurnLeft change the direction it is facing by 90°. •Goal states: The states in which every cell is clean. •Action cost: Each action costs 1. Description A square labeled Start state has three rows and three columns. Row 1: Column 1, 7. Column 2, 2. Column 3, 4. Row 2: Column 1, 5. Column 2, blank. Column 3, 6. Row 3: Column 1, 8. Column 2, 3. Column 3, 1. Another square labeled Goal state has three rows and three columns. Row 1: Column 1, blank. Column 2, 1. Column 3, 2. Row 2: Column 1, 3. Column 2, 4. Column 3, 5. Row 3: Column 1, 6. Column 2, 7. Column 3, 8. Figure 3. 2 The state-space graph for the two-cell vacuum world. There are 8 states and three actions for each state: L = Left, R = Right, S = Suck. Another type of grid world is the sokoban puzzle, in which the agent’s goal is to push a number of boxes, scattered about the grid, to designated storage locations. There can be at most one box per cell. When an agent moves forward into a cell containing a box and there is an empty cell on the other side of the box, then both the box and the agent move forward. The agent can’t push a box into another box or a wall. For a world with n non-obstacle cells and b boxes, there are n × n! /(b! (n – b)! ) states; for example on an 8 × 8 grid with a dozen boxes, there are over 200 trillion states. In a sliding-tile puzzle, a number of tiles (sometimes called blocks or pieces) are arranged in a grid with one or more blank spaces so that some of the tiles can slide into the blank space. One variant is the Rush Hour puzzle, in which cars and trucks slide around a 6 × 6 grid in an attempt to free a car from the traffic jam. Perhaps the best-known variant is the 8-puzzle (see Figure 3. 3), which consists of a 3 × 3 grid with eight numbered tiles and one blank space, and the 15-puzzle on a 4 × 4 grid. The object is to reach a specified goal state, such as the one shown on the right of the figure. The standard formulation of the 8 puzzle is as follows: Description Two squares with a common vertical side represent a state. Each square represents a cell. Eight states are arranged in three rows. Th top row contains two states, the middle row contains four states, and the bottom row contains two states. The first state of the top row has a vacuum cleaner and dirt in the left cell and dirt in the right cell. The second state of the top row has dirt in the left cell and a vacuum cleaner and dirt in the right cell. An arrow labeled L from the left cell of the first state loops back to the same cell. An arrow labeled R from the right cell of the first state points to the left cell of the second state. An arrow labeled L from the left cell of the second state points to the right cell of the first state. An arrow labeled R from the right cell of the second state loops back to the same cell. An arrow labeled S from the first state in the top row points to the first state in the middle row. The first state in the middle row has a vacuum cleaner in the left cell and dirt in the right cell. An arrow labeled L from the left cell of the first state loops back to the same cell. An arrow labeled S from the left cell of the first state points to the right cell of the same state. The second state in the middle row has an empty left cell and a vacuum cleaner and dirt in the right cell. An arrow labeled R from the right cell of the second state loops back to the same cell. An arrow labeled R from the right cell of the first state points to the left cell of the second state. An arrow labeled L from the left cell of the second state points to the right cell of the first state. The third state in the middle row has a vacuum cleaner and dirt in the left cell and an empty right cell. An arrow labeled L from the left cell of the third state loops back to the same cell. The fourth state in the middle row has dirt in the left cell and a vacuum cleaner in the right cell. An arrow labeled R from the right cell of the fourth state loops back to the same cell. An arrow labeled S from the left cell of the fourth state points to the right cell of the same state. An arrow labeled R from the right cell of the third state points to the left cell of the fourth state. An arrow labeled L from the left cell of the fourth state points to the right cell of the third state. An arrow labeled S from the second state in the top row points to the fourth state in the middle row. An arrow from the third state in the middle row points to the first state of the bottom row. The first state on the bottom row has a vacuum cleaner in the left cell and an empty right cell. An arrow labeled L from the left cell of the first state loops back to the same cell. An arrow labeled S from the left cell of the first state points to the right cell of the same state. The second state in the bottom row has an empty left cell and a vacuum cleaner in the right cell. An arrow labeled R from the right cell of the second state loops back to the same cell. An arrow labeled S from the left cell of the second state points to the right cell of the same state. An arrow labeled R from the right cell of the first state points to the left cell of the second state. An arrow labeled L from the left cell of the second state points to the right cell of the first state. An arrow labeled S from the second state in the middle row points to the second state in the third row. Figure 3. 3 A typical instance of the 8-puzzle. •States: A state description specifies the location of each of the tiles. •Initial state: Any state can be designated as the initial state. Note that a parity property partitions the state space—any given goal can be reached from exactly half of the possible initial states (see Exercise 3. PART). •Actions: While in the physical world it is a tile that slides, the simplest way of describing an action is to think of the blank space moving Left, Right, Up, or Down. If the blank is at an edge or corner then not all actions will be applicable. •Transition model: Maps a state and action to a resulting state; for example, if we apply Left to the start state in Figure 3. 3, the resulting state has the 5 and the blank switched. •Goal state: Although any state could be the goal, we typically specify a state with the numbers in order, as in Figure 3. 3. •Action cost: Each action costs 1. Note that every problem formulation involves abstractions. The 8-puzzle actions are abstracted to their beginning and final states, ignoring the intermediate locations where the tile is sliding. We have abstracted away actions such as shaking the board when tiles get stuck and ruled out extracting the tiles with a knife and putting them back again. We are left with a description of the rules, avoiding all the details of physical manipulations. Our final standardized problem was devised by Donald Knuth (1964) and illustrates how infinite state spaces can arise. Knuth conjectured that starting with the number 4, a sequence of square root, floor, and factorial operations can reach any desired positive integer. For example, we can reach 5 from 4 as follows: The problem definition is simple: •States: Positive real numbers. •Initial state: 4. •Actions: Apply square root, floor, or factorial operation (factorial for integers only). •Transition model: As given by the mathematical definitions of the operations. •Goal state: The desired positive integer. •Action cost: Each action costs 1. The state space for this problem is infinite: for any integer greater than 2 the factorial operator will always yield a larger integer. The problem is interesting because it explores very large numbers: the shortest path to 5 goes through (4! )! = 620, 448, 401, 733, 239, 439, 360, 000. Infinite state spaces arise frequently in tasks involving the generation of mathematical expressions, circuits, proofs, programs, and other recursively defined objects. 3. 2. 2Real-world problems We have already seen how the route-finding problem is defined in terms of specified locations and transitions along edges between them. Route-finding algorithms are used in a variety of applications. Some, such as Web sites and in-car systems that provide driving directions, are relatively straightforward extensions of the Romania example. (The main complications are varying costs due to traffic-dependent delays, and rerouting due to road closures. ) Others, such as routing video streams in computer networks, military operations planning, and airline travel-planning systems, involve much more complex specifications. Consider the airline travel problems that must be solved by a travel-planning Web site: •States: Each state obviously includes a location (e. g. , an airport) and the current time. Furthermore, because the cost of an action (a flight segment) may depend on previous segments, their fare bases, and their status as domestic or international, the state must record extra information about these “historical” aspects. •Initial state: The user’s home airport. •Actions: Take any flight from the current location, in any seat class, leaving after the current time, leaving enough time for within-airport transfer if needed. •Transition model: The state resulting from taking a flight will have the flight’s destination as the new location and the flight’s arrival time as the new time. •Goal state: A destination city. Sometimes the goal can be more complex, such as “arrive at the destination on a nonstop flight. ” •Action cost: A combination of monetary cost, waiting time, flight time, customs and immigration procedures, seat quality, time of day, type of airplane, frequent-flyer reward points, and so on. Commercial travel advice systems use a problem formulation of this kind, with many additional complications to handle the airlines’ byzantine fare structures. Any seasoned traveler knows, however, that not all air travel goes according to plan. A really good system should include contingency plans—what happens if this flight is delayed and the connection is missed? Touring problems describe a set of locations that must be visited, rather than a single goal destination. The traveling salesperson problem (TSP) is a touring problem in which every city on a map must be visited. The aim is to find a tour with cost < C (or in the optimization version, to find a tour with the lowest cost possible). An enormous amount of effort has been expended to improve the capabilities of TSP algorithms. The algorithms can also be extended to handle fleets of vehicles. For example, a search and optimization algorithm for routing school buses in Boston saved $5 million, cut traffic and air pollution, and saved time for drivers and students (Bertsimas et al. , 2019). In addition to planning trips, search algorithms have been used for tasks such as planning the movements of automatic circuit-board drills and of stocking machines on shop floors. A VLSI layout problem requires positioning millions of components and connections on a chip to minimize area, minimize circuit delays, minimize stray capacitances, and maximize manufacturing yield. The layout problem comes after the logical design phase and is usually split into two parts: cell layout and channel routing. In cell layout, the primitive components of the circuit are grouped into cells, each of which performs some recognized function. Each cell has a fixed footprint (size and shape) and requires a certain number of connections to each of the other cells. The aim is to place the cells on the chip so that they do not overlap and so that there is room for the connecting wires to be placed between the cells. Channel routing finds a specific route for each wire through the gaps between the cells. These search problems are extremely complex, but definitely worth solving. Robot navigation is a generalization of the route-finding problem described earlier. Rather than following distinct paths (such as the roads in Romania), a robot can roam around, in effect making its own paths. For a circular robot moving on a flat surface, the space is essentially two-dimensional. When the robot has arms and legs that must also be controlled, the search space becomes many-dimensional—one dimension for each joint angle. Advanced techniques are required just to make the essentially continuous search space finite (see Chapter 26). In addition to the complexity of the problem, real robots must also deal with errors in their sensor readings and motor controls, with partial observability, and with other agents that might alter the environment. Automatic assembly sequencing of complex objects (such as electric motors) by a robot has been standard industry practice since the 1970s. Algorithms first find a feasible assembly sequence and then work to optimize the process. Minimizing the amount of manual human labor on the assembly line can produce significant savings in time and cost. In assembly problems, the aim is to find an order in which to assemble the parts of some object. If the wrong order is chosen, there will be no way to add some part later in the sequence without undoing some of the work already done. Checking an action in the sequence for feasibility is a difficult geometrical search problem closely related to robot navigation. Thus, the generation of legal actions is the expensive part of assembly sequencing. Any practical algorithm must avoid exploring all but a tiny fraction of the state space. One important assembly problem is protein design, in which the goal is to find a sequence of amino acids that will fold into a three-dimensional protein with the right properties to cure some disease. 3. 3Search Algorithms A search algorithm takes a search problem as input and returns a solution, or an indication of failure. In this chapter we consider algorithms that superimpose a search tree over the state-space graph, forming various paths from the initial state, trying to find a path that reaches a goal state. Each node in the search tree corresponds to a state in the state space and the edges in the search tree correspond to actions. The root of the tree corresponds to the initial state of the problem. It is important to understand the distinction between the state space and the search tree. The state space describes the (possibly infinite) set of states in the world, and the actions that allow transitions from one state to another. The search tree describes paths between these states, reaching towards the goal. The search tree may have multiple paths to (and thus multiple nodes for) any given state, but each node in the tree has a unique path back to the root (as in all trees). Figure 3. 4 shows the first few steps in finding a path from Arad to Bucharest. The root node of the search tree is at the initial state, Arad. We can expand the node, by considering the available ACTIONS for that state, using the RESULT function to see where those actions lead to, and generating a new node (called a child node or successor node) for each of the resulting states. Each child node has Arad as its parent node. Description Search tree 1: The root node is lavender-colored and all other nodes are in faint dashed lines. Root node Arad has three child nodes: Sibiu, Timisoara, and Zerind. Node Sibiu has four child nodes: Arad, Fagaras, Oradea, and Rimnicu Vilcea. Node Timisoara has two child nodes: Arad and Lugoj. Node Zerind has two child nodes: Arad and Oradea. Search tree 2: The root node is lavender colored. Root node Arad has three green-colored child nodes: Sibiu, Timisoara, and Zerind. Node Sibiu has four child nodes in faint dashed lines: Arad, Fagaras, Oradea, and Rimnicu Vilcea. Node Timisoara has two child nodes in faint dashed lines: Arad and Lugoj. Node Zerind has two child nodes in faint dashed lines: Arad and Oradea. Search tree 3: The root node is lavender colored. Root node Arad has three child nodes: lavender-colored Sibiu, green-colored Timisoara, and green-colored Zerind. Node Sibiu has four green-colored child nodes: Arad, Fagaras, Oradea, and Rimnicu Vilcea. Node Timisoara has two child nodes in faint dashed lines: Arad and Lugoj. Node Zerind has two child nodes in faint dashed lines: Arad and Oradea. Figure 3. 4 Three partial search trees for finding a route from Arad to Bucharest. Nodes that have been expanded are lavender with bold letters; nodes on the frontier that have been generated but not yet expanded are in green; the set of states corresponding to these two types of nodes are said to have been reached. Nodes that could be generated next are shown in faint dashed lines. Notice in the bottom tree there is a cycle from Arad to Sibiu to Arad; that can’t be an optimal path, so search should not continue from there. Now we must choose which of these three child nodes to consider next. This is the essence of search—following up one option now and putting the others aside for later. Suppose we choose to expand Sibiu first. Figure 3. 4 (bottom) shows the result: a set of 6 unexpanded nodes (outlined in bold). We call this the frontier of the search tree. We say that any state that has had a node generated for it has been reached (whether or not that node has been expanded). 5 Figure 3. 5 shows the search tree superimposed on the state-space graph. Description In all three parts, paths to Arad from Zerind, Sibiu, and Timisoara are highlighted and marked in red. Part 1: The highlighted paths are shown. Part 2: Paths in part 1 are shown. Additionally, paths to Sibiu from Fagaras and Rimnicu Vilcea are highlighted and marked in red. Paths to Zerind from Oradea and to Timisoara from Lugoj are highlighted and marked in red. Part 3: All paths in part 2 are shown. Additionally, paths to Lugoj from Mehadia and to Fagaras from Bucharest are highlighted and marked in red. Paths to Rimnicu Vilcea from Craiova and Pitesti are highlighted and marked in red. Figure 3. 5 A sequence of search trees generated by a graph search on the Romania problem of Figure 3. 1. At each stage, we have expanded every node on the frontier, extending every path with all applicable actions that don’t result in a state that has already been reached. Notice that at the third stage, the topmost city (Oradea) has two successors, both of which have already been reached by other paths, so no paths are extended from Oradea. Note that the frontier separates two regions of the state-space graph: an interior region where every state has been expanded, and an exterior region of states that have not yet been reached. This property is illustrated in Figure 3. 6. Description Each rectangular grid has 25 nodes made of five rows and five columns. Each row contains five nodes. The nodes are connected by the paths along the five vertical and five horizontal grid lines. Part (“a”): The node in the third column of the third row is lavender-colored and the nodes that are vertically and horizontally adjacent to it are green-colored. The four paths between the lavender node and green nodes are colored in lavender. All other nodes and paths are in faint dashed lines. Part (b): The two nodes in the third column of the second and third rows are lavender-colored and each of the two has three green-colored adjacent nodes. The paths between the lavender nodes and the green nodes are colored in lavender. All other nodes and paths are in faint dashed lines. Part (c): Five nodes are lavender-colored and are in the following positions: rows 2, 3, and 4 of column 3, and columns 2 and 4 of row 3. The paths from the lavender node at column 3, row 3 to the other four lavender nodes are colored in lavender. The lavender node at row 2 column 3 has three green-colored nodes to the right, left, and top, and the paths from the lavender node to these green nodes are in lavender. The lavender node at row 3, column 4 has two green nodes to the right and below, and the paths from the lavender node to these green nodes are in lavender. The lavender node at row 4, column 3 has two green nodes to the left and below, and the paths from the lavender node to these green nodes are in lavender. The lavender node at row 3, column 2 has one green node to the left, and the path from the lavender node to this green node is in lavender. All other nodes and the paths are in faint dashed lines. Figure 3. 6 The separation property of graph search, illustrated on a rectangular-grid problem. The frontier (green) separates the interior (lavender) from the exterior (faint dashed). The frontier is the set of nodes (and corresponding states) that have been reached but not yet expanded; the interior is the set of nodes (and corresponding states) that have been expanded; and the exterior is the set of states that have not been reached. In (a), just the root has been expanded. In (b), the top frontier node is expanded. In (c), the remaining successors of the root are expanded in clockwise order. 3. 3. 1Best-first search How do we decide which node from the frontier to expand next? A very general approach is called best-first search, in which we choose a node, n, with minimum value of some evaluation function, f(n). Figure 3. 7 shows the algorithm. On each iteration we choose a node on the frontier with minimum f(n) value, return it if its state is a goal state, and otherwise apply EXPAND to generate child nodes. Each child node is added to the frontier if it has not been reached before, or is re-added if it is now being reached with a path that has a lower path cost than any previous path. The algorithm returns either an indication of failure, or a node that represents a path to a goal. By employing different f(n) functions, we get different specific algorithms, which this chapter will cover. Description All the four binary trees have the root node labeled ""A"". Node ""A"" has two child nodes labeled B and C. Node B has two child nodes labeled D and E. Node C has two child nodes labeled F and G. Binary Tree 1: Node ""A"" is green-colored and a right arrowhead points to node ""A"". All other nodes and paths are in faint dashed lines. Binary Tree 2: Node ""A"" is lavender-colored. Nodes B and C are green-colored. The right arrowhead points to node B. The two paths from node ""A"" to B and C are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 3: Nodes ""A"" and B are lavender-colored. Nodes C, D, and E are green-colored. The right arrowhead points to node C. The two paths from node ""A"" to B and C are solid lines. The two paths from node B to D and E are solid lines as well. All other nodes and paths are in faint dashed lines. Binary Tree 4: Nodes ""A"", B, and C are lavender-colored. Other nodes are green-colored. The right arrowhead points to node D. All paths are solid lines. Figure 3. 7The best-first search algorithm, and the function for expanding a node. The data structures used here are described in Section 3. 3. 2. See Appendix B for yield. 3. 3. 2Search data structures Search algorithms require a data structure to keep track of the search tree. A node in the tree is represented by a data structure with four components: •node. STATE: the state to which the node corresponds; •node. PARENT: the node in the tree that generated this node; •node. ACTION: the action that was applied to the parent’s state to generate this node; •node. PATH-COST: the total cost of the path from the initial state to this node. In mathematical formulas, we use g(node) as a synonym for PATH-COST. Following the PARENT pointers back from a node allows us to recover the states and actions along the path to that node. Doing this from a goal node gives us the solution. We need a data structure to store the frontier. The appropriate choice is a queue of some kind, because the operations on a frontier are: •IS-EMPTY(frontier) returns true only if there are no nodes in the frontier. •POP(frontier) removes the top node from the frontier and returns it. •TOP(frontier) returns (but does not remove) the top node of the frontier. •ADD(node, frontier) inserts node into its proper place in the queue. Three kinds of queues are used in search algorithms: •A priority queue first pops the node with the minimum cost according to some evaluation function, f. It is used in best-first search. •A FIFO queue or first-in-first-out queue first pops the node that was added to the queue first; we shall see it is used in breadth-first search. •A LIFO queue or last-in-first-out queue (also known as a stack) pops first the most recently added node; we shall see it is used in depth-first search. The reached states can be stored as a lookup table (e. g. a hash table) where each key is a state and each value is the node for that state. 3. 3. 3Redundant paths The search tree shown in Figure 3. 4 (bottom) includes a path from Arad to Sibiu and back to Arad again. We say that Arad is a repeated state in the search tree, generated in this case by a cycle (also known as a loopy path). So even though the state space has only 20 states, the complete search tree is infinite because there is no limit to how often one can traverse a loop. A cycle is a special case of a redundant path. For example, we can get to Sibiu via the path Arad–Sibiu (140 miles long) or the path Arad–Zerind–Oradea–Sibiu (297 miles long). This second path is redundant—it’s just a worse way to get to the same state—and need not be considered in our quest for optimal paths. Consider an agent in a 10 × 10 grid world, with the ability to move to any of 8 adjacent squares. If there are no obstacles, the agent can reach any of the 100 squares in 9 moves or fewer. But the number of paths of length 9 is almost 89 (a bit less because of the edges of the grid), or more than 100 million. In other words, the average cell can be reached by over a million redundant paths of length 9, and if we eliminate redundant paths, we can complete a search roughly a million times faster. As the saying goes, algorithms that cannot remember the past are doomed to repeat it. There are three approaches to this issue. First, we can remember all previously reached states (as best-first search does), allowing us to detect all redundant paths, and keep only the best path to each state. This is appropriate for state spaces where there are many redundant paths, and is the preferred choice when the table of reached states will fit in memory. Second, we can not worry about repeating the past. There are some problem formulations where it is rare or impossible for two paths to reach the same state. An example would be an assembly problem where each action adds a part to an evolving assemblage, and there is an ordering of parts so that it is possible to add A and then B, but not B and then A. For those problems, we could save memory space if we don’t track reached states and we don’t check for redundant paths. We call a search algorithm a graph search if it checks for redundant paths and a tree-like search6 if it does not check. The BEST-FIRST-SEARCH algorithm in Figure 3. 7 is a graph search algorithm; if we remove all references to reached we get a treelike search that uses less memory but will examine redundant paths to the same state, and thus will run slower. Third, we can compromise and check for cycles, but not for redundant paths in general. Since each node has a chain of parent pointers, we can check for cycles with no need for additional memory by following up the chain of parents to see if the state at the end of the path has appeared earlier in the path. Some implementations follow this chain all the way up, and thus eliminate all cycles; other implementations follow only a few links (e. g. , to the parent, grandparent, and great-grandparent), and thus take only a constant amount of time, while eliminating all short cycles (and relying on other mechanisms to deal with long cycles). 3. 3. 4Measuring problem-solving performance Before we get into the design of various search algorithms, we will consider the criteria used to choose among them. We can evaluate an algorithm’s performance in four ways: •Completeness: Is the algorithm guaranteed to find a solution when there is one, and to correctly report failure when there is not? •Cost optimality: Does it find a solution with the lowest path cost of all solutions? 7 •Time complexity: How long does it take to find a solution? This can be measured in seconds, or more abstractly by the number of states and actions considered. •Space complexity: How much memory is needed to perform the search? To understand completeness, consider a search problem with a single goal. That goal could be anywhere in the state space; therefore a complete algorithm must be capable of systematically exploring every state that is reachable from the initial state. In finite state spaces that is straightforward to achieve: as long as we keep track of paths and cut off ones that are cycles (e. g. Arad to Sibiu to Arad), eventually we will reach every reachable state. In infinite state spaces, more care is necessary. For example, an algorithm that repeatedly applied the “factorial” operator in Knuth’s “4” problem would follow an infinite path from 4 to 4! to (4! )! , and so on. Similarly, on an infinite grid with no obstacles, repeatedly moving forward in a straight line also follows an infinite path of new states. In both cases the algorithm never returns to a state it has reached before, but is incomplete because wide expanses of the state space are never reached. To be complete, a search algorithm must be systematic in the way it explores an infinite state space, making sure it can eventually reach any state that is connected to the initial state. For example, on the infinite grid, one kind of systematic search is a spiral path that covers all the cells that are s steps from the origin before moving out to cells that are s + 1 steps away. Unfortunately, in an infinite state space with no solution, a sound algorithm needs to keep searching forever; it can’t terminate because it can’t know if the next state will be a goal. Time and space complexity are considered with respect to some measure of the problem difficulty. In theoretical computer science, the typical measure is the size of the state-space graph, |V| + |E|, where |V| is the number of vertices (state nodes) of the graph and |E| is the number of edges (distinct state/action pairs). This is appropriate when the graph is an explicit data structure, such as the map of Romania. But in many AI problems, the graph is represented only implicitly by the initial state, actions, and transition model. For an implicit state space, complexity can be measured in terms of d, the depth or number of actions in an optimal solution; m, the maximum number of actions in any path; and b, the branching factor or number of successors of a node that need to be considered. 3. 4Uninformed Search Strategies An uninformed search algorithm is given no clue about how close a state is to the goal(s). For example, consider our agent in Arad with the goal of reaching Bucharest. An uninformed agent with no knowledge of Romanian geography has no clue whether going to Zerind or Sibiu is a better first step. In contrast, an informed agent (Section 3. 5) who knows the location of each city knows that Sibiu is much closer to Bucharest and thus more likely to be on the shortest path. 3. 4. 1Breadth-first search When all actions have the same cost, an appropriate strategy is breadth-first search, in which the root node is expanded first, then all the successors of the root node are expanded next, then their successors, and so on. This is a systematic search strategy that is therefore complete even on infinite state spaces. We could implement breadth-first search as a call to BEST-FIRST-SEARCH where the evaluation function f(n) is the depth of the node—that is, the number of actions it takes to reach the node. However, we can get additional efficiency with a couple of tricks. A first-in-first-out queue will be faster than a priority queue, and will give us the correct order of nodes: new nodes (which are always deeper than their parents) go to the back of the queue, and old nodes, which are shallower than the new nodes, get expanded first. In addition, reached can be a set of states rather than a mapping from states to nodes, because once we’ve reached a state, we can never find a better path to the state. That also means we can do an early goal test, checking whether a node is a solution as soon as it is generated, rather than the late goal test that best-first search uses, waiting until a node is popped off the queue. Figure 3. 8 shows the progress of a breadth-first search on a binary tree, and Figure 3. 9 shows the algorithm with the early-goal efficiency enhancements. Description Sibiu to Fagaras, 99. Fagaras to Bucharest, 211. Sibiu to Rimnicu Vilcea, 80. Rimnicu Vilcea to Pitesti, 97. Pitesti to Bucharest, 101. Figure 3. 8 Breadth-first search on a simple binary tree. At each stage, the node to be expanded next is indicated by the triangular marker. Description The binary trees have the root node labeled “A”. Node “A” has two child nodes labeled B and C. Node B has two child nodes labeled D and E. Node C has two child nodes labeled F and G. Node D has two child nodes labeled H and I. Node E has two child nodes labeled J and K. Node F has two child nodes labeled L and M. Node G has two child nodes labeled N and O. Binary Tree 1: Node “A” is green-colored. An arrowhead points to “A”. All other nodes and paths are in faint dashed lines. Binary Tree 2: Node “A” is lavender-colored. Nodes B and C are green-colored. An arrowhead points to B. The paths from node “A” are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 3: Nodes “A” and B are lavender-colored. Nodes C, D, and E are green-colored. An arrowhead points to D. The paths from nodes “A” and B are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 4: Nodes “A”, B, and D are lavender-colored. Nodes C, E, H, and I are green-colored. An arrowhead points to H. The paths from “A”, B, and D are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 5: Nodes “A”, B, and D are lavender-colored. Nodes C, E, and I are green-colored. An arrowhead points to I. The paths from “A” and B are solid lines. The path between D and I is a solid line. The path from D to H and node H are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 6: Nodes “A” and B are lavender-colored. Nodes E and C are green-colored. An arrowhead points to E. The paths from “A” are solid lines. The path between B and E is a solid line. The path from B to D, node D, and the child nodes of D are all faded out. All other nodes and paths are in faint dashed lines. Binary Tree 7: Nodes “A”, B, and E are lavender-colored. Nodes C, J, and K are green-colored. An arrowhead points to J. The paths from “A” and E are solid lines. The path between B and E is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 8: Nodes “A”, B, and E are lavender-colored. Nodes C and K are green-colored. An arrowhead points to K. The paths from “A” are solid lines. The path between B and E is a solid line. The path between K and E is a solid line. The path from E to J and node J are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 9: Node “A” is lavender-colored and node C is green-colored. An arrowhead points to C. The path between “A” and C is a solid line. The path from “A” to B, node B, and all child nodes of B are faded. All other nodes and paths are in faint dashed lines. Binary Tree 10: Nodes “A” and C are lavender-colored. Nodes F and G are green-colored. An arrowhead points to F. The paths from C are solid lines. The path between “A” and C is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 11: Nodes “A”, C, and F are lavender-colored. Nodes G, L, and M are green-colored. An arrowhead points to L. The paths from C and F are solid lines. The path between “A” and C is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 12: Nodes “A”, C, and F are lavender-colored. Nodes G and M are green-colored. An arrowhead points to M. The paths from C are solid lines. The path between “A” and C is a solid line. The path between F and M is a solid line. The path from F to L and node L are faded out. All other nodes and paths are in faint dashed lines. Figure 3. 9 Breadth-first search and uniform-cost search algorithms. Breadth-first search always finds a solution with a minimal number of actions, because when it is generating nodes at depth d, it has already generated all the nodes at depth d – 1, so if one of them were a solution, it would have been found. That means it is cost-optimal for problems where all actions have the same cost, but not for problems that don’t have that property. It is complete in either case. In terms of time and space, imagine searching a uniform tree where every state has b successors. The root of the search tree generates b nodes, each of which generates b more nodes, for a total of b2 at the second level. Each of these generates b more nodes, yielding b3 nodes at the third level, and so on. Now suppose that the solution is at depth d. Then the total number of nodes generated is All the nodes remain in memory, so both time and space complexity are O(bd). Exponential bounds like that are scary. As a typical real-world example, consider a problem with branching factor b = 10, processing speed 1 million nodes/second, and memory requirements of 1 Kbyte/node. A search to depth d = 10 would take less than 3 hours, but would require 10 terabytes of memory. The memory requirements are a bigger problem for breadth-first search than the execution time. But time is still an important factor. At depth d = 14, even with infinite memory, the search would take 3. 5 years. In general, exponential-complexity search problems cannot be solved by uninformed search for any but the smallest instances. 3. 4. 2Dijkstra’s algorithm or uniform-cost search When actions have different costs, an obvious choice is to use best-first search where the evaluation function is the cost of the path from the root to the current node. This is called Dijkstra’s algorithm by the theoretical computer science community, and uniform-cost search by the AI community. The idea is that while breadth-first search spreads out in waves of uniform depth—first depth 1, then depth 2, and so on—uniform-cost search spreads out in waves of uniform path-cost. The algorithm can be implemented as a call to BEST-FIRST-SEARCH with PATH-COST as the evaluation function, as shown in Figure 3. 9. Consider Figure 3. 10, where the problem is to get from Sibiu to Bucharest. The successors of Sibiu are Rimnicu Vilcea and Fagaras, with costs 80 and 99, respectively. The least-cost node, Rimnicu Vilcea, is expanded next, adding Pitesti with cost 80 + 97 = 177. The least-cost node is now Fagaras, so it is expanded, adding Bucharest with cost 99 + 211 = 310. Bucharest is the goal, but the algorithm tests for goals only when it expands a node, not when it generates a node, so it has not yet detected that this is a path to the goal. Figure 3. 10 Part of the Romania state space, selected to illustrate uniform-cost search. The algorithm continues on, choosing Pitesti for expansion next and adding a second path to Bucharest with cost 80 + 97 + 101 = 278. It has a lower cost, so it replaces the previous path in reached and is added to the frontier. It turns out this node now has the lowest cost, so it is considered next, found to be a goal, and returned. Note that if we had checked for a goal upon generating a node rather than when expanding the lowest-cost node, then we would have returned a higher-cost path (the one through Fagaras). The complexity of uniform-cost search is characterized in terms of C*, the cost of the optimal solution, 8 and ϵ, a lower bound on the cost of each action, with ϵ > 0. Then the algorithm’s worst-case time and space complexity is O(b1+⌊C*/ϵ⌋), which can be much greater than bd. This is because uniform-cost search can explore large trees of actions with low costs before exploring paths involving a high-cost and perhaps useful action. When all action costs are equal, b1+⌊C*/ϵ⌋ is just bd+1, and uniform-cost search is similar to breadth-first search. Uniform-cost search is complete and is cost-optimal, because the first solution it finds will have a cost that is at least as low as the cost of any other node in the frontier. Uniform-cost search considers all paths systematically in order of increasing cost, never getting caught going down a single infinite path (assuming that all action costs are > ϵ > 0). 3. 4. 3Depth-first search and the problem of memory Depth-first search always expands the deepest node in the frontier first. It could be implemented as a call to BEST-FIRST-SEARCH where the evaluation function f is the negative of the depth. However, it is usually implemented not as a graph search but as a tree-like search that does not keep a table of reached states. The progress of the search is illustrated in Figure 3. 11; search proceeds immediately to the deepest level of the search tree, where the nodes have no successors. The search then “backs up” to the next deepest node that still has unexpanded successors. Depth-first search is not cost-optimal; it returns the first solution it finds, even if it is not cheapest. Figure 3. 11 A dozen steps (left to right, top to bottom) in the progress of a depth-first search on a binary tree from start state A to goal M. The frontier is in green, with a triangle marking the node to be expanded next. Previously expanded nodes are lavender, and potential future nodes have faint dashed lines. Expanded nodes with no descendants in the frontier (very faint lines) can be discarded. For finite state spaces that are trees it is efficient and complete; for acyclic state spaces it may end up expanding the same state many times via different paths, but will (eventually) systematically explore the entire space. In cyclic state spaces it can get stuck in an infinite loop; therefore some implementations of depth-first search check each new node for cycles. Finally, in infinite state spaces, depth-first search is not systematic: it can get stuck going down an infinite path, even if there are no cycles. Thus, depth-first search is incomplete. With all this bad news, why would anyone consider using depth-first search rather than breadth-first or best-first? The answer is that for problems where a tree-like search is feasible, depth-first search has much smaller needs for memory. We don’t keep a reached table at all, and the frontier is very small: think of the frontier in breadth-first search as the surface of an ever-expanding sphere, while the frontier in depth-first search is just a radius of the sphere. For a finite tree-shaped state-space like the one in Figure 3. 11, a depth-first tree-like search takes time proportional to the number of states, and has memory complexity of only O(bm), where b is the branching factor and m is the maximum depth of the tree. Some problems that would require exabytes of memory with breadth-first search can be handled with only kilobytes using depth-first search. Because of its parsimonious use of memory, depth-first tree-like search has been adopted as the basic workhorse of many areas of AI, including constraint satisfaction (Chapter 5), propositional satisfiability (Chapter 7), and logic programming (Chapter 9). A variant of depth-first search called backtracking search uses even less memory. (See Chapter 5 for more details. ) In backtracking, only one successor is generated at a time rather than all successors; each partially expanded node remembers which successor to generate next. In addition, successors are generated by modifying the current state description directly rather than allocating memory for a brand-new state. This reduces the memory requirements to just one state description and a path of O(m) actions; a significant savings over O(bm) states for depth-first search. With backtracking we also have the option of maintaining an efficient set data structure for the states on the current path, allowing us to check for a cyclic path in O(1) time rather than O(m). For backtracking to work, we must be able to undo each action when we backtrack. Backtracking is critical to the success of many problems with large state descriptions, such as robotic assembly. 3. 4. 4Depth-limited and iterative deepening search To keep depth-first search from wandering down an infinite path, we can use depth-limited search, a version of depth-first search in which we supply a depth limit, l, and treat all nodes at depth l as if they had no successors (see Figure 3. 12). The time complexity is O(bl) and the space complexity is O(bl). Unfortunately, if we make a poor choice for l the algorithm will fail to reach the solution, making it incomplete again. Since depth-first search is a tree-like search, we can’t keep it from wasting time on redundant paths in general, but we can eliminate cycles at the cost of some computation time. If we look only a few links up in the parent chain we can catch most cycles; longer cycles are handled by the depth limit. Sometimes a good depth limit can be chosen based on knowledge of the problem. For example, on the map of Romania there are 20 cities. Therefore, l = 19 is a valid limit. But if we studied the map carefully, we would discover that any city can be reached from any other city in at most 9 actions. This number, known as the diameter of the state-space graph, gives us a better depth limit, which leads to a more efficient depth-limited search. However, for most problems we will not know a good depth limit until we have solved the problem. Iterative deepening search solves the problem of picking a good value for l by trying all values: first 0, then 1, then 2, and so on—until either a solution is found, or the depth-limited search returns the failure value rather than the cutoff value. The algorithm is shown in Figure 3. 12. Iterative deepening combines many of the benefits of depth-first and breadth-first search. Like depth-first search, its memory requirements are modest: O(bd) when there is a solution, or O(bm) on finite state spaces with no solution. Like breadth-first search, iterative deepening is optimal for problems where all actions have the same cost, and is complete on finite acyclic state spaces, or on any finite state space when we check nodes for cycles all the way up the path. Figure 3. 12 Iterative deepening and depth-limited tree-like search. Iterative deepening repeatedly applies depth-limited search with increasing limits. It returns one of three different types of values: either a solution node; or failure, when it has exhausted all nodes and proved there is no solution at any depth; or cutoff, to mean there might be a solution at a deeper depth than l. This is a tree-like search algorithm that does not keep track of reached states, and thus uses much less memory than best-first search, but runs the risk of visiting the same state multiple times on different paths. Also, if the IS-CYCLE check does not check all cycles, then the algorithm may get caught in a loop. The time complexity is O(bd) when there is a solution, or O(bm) when there is none. Each iteration of iterative deepening search generates a new level, in the same way that breadth-first search does, but breadth-first does this by storing all nodes in memory, while iterative-deepening does it by repeating the previous levels, thereby saving memory at the cost of more time. Figure 3. 13 shows four iterations of iterative-deepening search on a binary search tree, where the solution is found on the fourth iteration. Figure 3. 13 Four iterations of iterative deepening search for goal M on a binary tree, with the depth limit varying from 0 to 3. Note the interior nodes form a single path. The triangle marks the node to expand next; green nodes with dark outlines are on the frontier; the very faint nodes provably can’t be part of a solution with this depth limit. Iterative deepening search may seem wasteful because states near the top of the search tree are re-generated multiple times. But for many state spaces, most of the nodes are in the bottom level, so it does not matter much that the upper levels are repeated. In an iterative deepening search, the nodes on the bottom level (depth d) are generated once, those on the next-to-bottom level are generated twice, and so on, up to the children of the root, which are generated d times. So the total number of nodes generated in the worst case is which gives a time complexity of O(bd)—asymptotically the same as breadth-first search. For example, if b = 10 and d = 5, the numbers are If you are really concerned about the repetition, you can use a hybrid approach that runs breadth-first search until almost all the available memory is consumed, and then runs iterative deepening from all the nodes in the frontier. In general, iterative deepening is the preferred uninformed search method when the search state space is larger than can fit in memory and the depth of the solution is not known. 3. 4. 5Bidirectional search The algorithms we have covered so far start at an initial state and can reach any one of multiple possible goal states. An alternative approach called bidirectional search simultaneously searches forward from the initial state and backwards from the goal state(s), hoping that the two searches will meet. The motivation is that bd/2 + bd/2 is much less than bd (e. g. , 50, 000 times less when b = d = 10). For this to work, we need to keep track of two frontiers and two tables of reached states, and we need to be able to reason backwards: if state sʹ is a successor of s in the forward direction, then we need to know that s is a successor of sʹ in the backward direction. We have a solution when the two frontiers collide. 9 There are many different versions of bidirectional search, just as there are many different unidirectional search algorithms. In this section, we describe bidirectional best-first search. Although there are two separate frontiers, the node to be expanded next is always one with a minimum value of the evaluation function, across either frontier. When the evaluation function is the path cost, we get bidirectional uniform-cost search, and if the cost of the optimal path is C*, then no node with cost will be expanded. This can result in a considerable speedup. The general best-first bidirectional search algorithm is shown in Figure 3. 14. We pass in two versions of the problem and the evaluation function, one in the forward direction (subscript F) and one in the backward direction (subscript B). When the evaluation function is the path cost, we know that the first solution found will be an optimal solution, but with different evaluation functions that is not necessarily true. Therefore, we keep track of the best solution found so far, and might have to update that several times before the TERMINATED test proves that there is no possible better solution remaining. Figure 3. 14 Bidirectional best-first search keeps two frontiers and two tables of reached states. When a path in one frontier reaches a state that was also reached in the other half of the search, the two paths are joined (by the function JOIN-NODES) to form a solution. The first solution we get is not guaranteed to be the best; the function TERMINATED determines when to stop looking for new solutions. 3. 4. 6Comparing uninformed search algorithms Figure 3. 15 compares uninformed search algorithms in terms of the four evaluation criteria set forth in Section 3. 3. 4. This comparison is for tree-like search versions which don’t check for repeated states. For graph searches which do check, the main differences are that depth-first search is complete for finite state spaces, and the space and time complexities are bounded by the size of the state space (the number of vertices and edges, |V | + |E|). Figure 3. 15Evaluation of search algorithms. b is the branching factor; m is the maximum depth of the search tree; d is the depth of the shallowest solution, or is m when there is no solution; l is the depth limit. Superscript caveats are as follows: 1 complete if b is finite, and the state space either has a solution or is finite. 2 complete if all action costs are ≥ ϵ > 0; 3 cost-optimal if action costs are all identical; 4 if both directions are breadth-first or uniform-cost. 3. 5Informed (Heuristic) Search Strategies This section shows how an informed search strategy—one that uses domain-specific hints about the location of goals—can find solutions more efficiently than an uninformed strategy. The hints come in the form of a heuristic function, denoted h(n): 10 h(n) = estimated cost of the cheapest path from the state at node n to a goal state. For example, in route-finding problems, we can estimate the distance from the current state to a goal by computing the straight-line distance on the map between the two points. We study heuristics and where they come from in more detail in Section 3. 6. 3. 5. 1Greedy best-first search Greedy best-first search is a form of best-first search that expands first the node with the lowest h(n) value—the node that appears to be closest to the goal—on the grounds that this is likely to lead to a solution quickly. So the evaluation function f(n)= h(n). Let us see how this works for route-finding problems in Romania; we use the straight-line distance heuristic, which we will call hSLD. If the goal is Bucharest, we need to know the straight-line distances to Bucharest, which are shown in Figure 3. 16. For example, hSLD(Arad) = 366. Notice that the values of hSLD cannot be computed from the problem description itself (that is, the ACTIONS and RESULT functions). Moreover, it takes a certain amount of world knowledge to know that hSLD is correlated with actual road distances and is, therefore, a useful heuristic. Description The binary trees have the root node labeled ""A"". Node ""A"" has two child nodes labeled B and C. Node B has two child nodes labeled D and E. Node C has two child nodes labeled F and G. Node D has two child nodes labeled H and I. Node E has two child nodes labeled J and K. Node F has two child nodes labeled L and M. Node G has two child nodes labeled N and O. Limit: 0. Two binary trees of level 1. Binary Tree 1: An arrowhead points to “A”. Node “A” is green-colored. Binary Tree 2: Node “A” is faded out. Limit: 1. Four binary trees of level 2. Binary Tree 1: Node “A” is lavender-colored. An arrowhead points to “A”. All other nodes and paths are in faint dashed lines. Binary Tree 2: Node “A” is lavender-colored. Nodes B and C are green-colored. An arrowhead points to B. The paths from node “A” are solid lines. Binary Tree 3: Node “A” is lavender-colored. Node C is green-colored. The path between nodes “A” and C is a solid line. The path from “A” to B and node B are faded out. Binary Tree 4: All nodes and paths are faded out. Limit: 2. Eight binary trees of level 2. Binary Tree 1: Node “A” is lavender-colored. An arrowhead points to “A”. All other nodes and paths are in faint dashed lines. Binary Tree 2: Node “A” is lavender-colored. Nodes B and C are green-colored. An arrowhead points to B. The paths from node “A” are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 3: Nodes “A” and B are lavender-colored. Nodes C, D, and E are green-colored. An arrowhead points to D. The paths from “A” and B are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 4: Nodes “A” and B are lavender-colored. Nodes C and E are green-colored. An arrowhead points to E. The paths from “A” are solid lines. The path between B and E is a solid line. The path from B to D and node D are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 5: Node “A” is lavender-colored. Node C is green-colored. An arrowhead points to C. The path between “A” and C is a solid line. The path from “A” to B, node B, and all child nodes of B are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 6: Nodes “A” and C are lavender-colored. Nodes F and G are green-colored. An arrowhead points to F. The path between “A” and C is a solid line. The paths from C are solid lines. Binary Tree 7: Nodes “A” and C are lavender-colored. Node G is green-colored. The path between “A” and C is a solid line. The path between C and G is a solid line. The path from C to E and node E are faded out. Binary Tree 8: All nodes and paths are faded out. Limit: 3. Twelve binary trees of level 3. Binary Tree 1: Node “A” is green-colored. An arrowhead points to “A”. All other nodes and paths are in faint dashed lines. Binary Tree 2: Node “A” is lavender-colored. Nodes B and C are green-colored. An arrowhead points to B. The paths from node “A” are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 3: Nodes “A” and B are lavender-colored. Nodes C, D, and E are green-colored. An arrowhead points to D. The paths from nodes “A” and B are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 4: Nodes “A”, B, and D are lavender-colored. Nodes C, E, H, and I are green-colored. An arrowhead points to H. The paths from “A”, B, and D are solid lines. All other nodes and paths are in faint dashed lines. Binary Tree 5: Nodes “A”, B, and D are lavender-colored. Nodes C, E, and I are green-colored. An arrowhead points to I. The paths from “A” and B are solid lines. The path between D and I is a solid line. The path from D to H and node H are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 6: Nodes “A” and B are lavender-colored. Nodes E and C are green-colored. An arrowhead points to E. The paths from “A” are solid lines. The path between B and E is a solid line. The path from B to D, node D, and the child nodes of D are all faded out. All other nodes and paths are in faint dashed lines. Binary Tree 7: Nodes “A”, B, and E are lavender-colored. Nodes C, J, and K are green-colored. An arrowhead points to J. The paths from “A” and E are solid lines. The path between B and E is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 8: Nodes “A”, B, and E are lavender-colored. Nodes C and K are green-colored. An arrowhead points to K. The paths from “A” are solid lines. The path between B and E is a solid line. The path between K and E is a solid line. The path from E to J and node J are faded out. All other nodes and paths are in faint dashed lines. Binary Tree 9: Node “A” is lavender-colored and node C is green-colored. An arrowhead points to C. The path between “A” and C is a solid line. The path from “A” to B, node B, and all child nodes of B are faded. All other nodes and paths are in faint dashed lines. Binary Tree 10: Nodes “A” and C are lavender-colored. Nodes F and G are green-colored. An arrowhead points to F. The paths from C are solid lines. The path between “A” and C is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 11: Nodes “A”, C, and F are lavender-colored. Nodes G, L, and M are green-colored. An arrowhead points to L. The paths from C and F are solid lines. The path between “A” and C is a solid line. All other nodes and paths are in faint dashed lines. Binary Tree 12: Nodes “A”, C, and F are lavender-colored. Nodes G and M are green-colored. An arrowhead points to M. The paths from C are solid lines. The path between “A” and C is a solid line. The path between F and M is a solid line. The path from F to L and node L are faded out. All other nodes and paths are in faint dashed lines. Figure 3. 16 Values of hSLD—straight-line distances to Bucharest. Figure 3. 17 shows the progress of a greedy best-first search using hSLD to find a path from Arad to Bucharest. The first node to be expanded from Arad will be Sibiu because the heuristic says it is closer to Bucharest than is either Zerind or Timisoara. The next node to be expanded will be Fagaras because it is now closest according to the heuristic. Fagaras in turn generates Bucharest, which is the goal. For this particular problem, greedy best-first search using hSLD finds a solution without ever expanding a node that is not on the solution path. The solution it found does not have optimal cost, however: the path via Sibiu and Fagaras to Bucharest is 32 miles longer than the path through Rimnicu Vilcea and Pitesti. This is why the algorithm is called “greedy”—on each iteration it tries to get as close to a goal as it can, but greediness can lead to worse results than being careful. Description Arad, 366. Bucharest, 0, Craiova, 160. Drobeta, 242. Eforie, 161. Fagaras, 176. Giurgiu, 77. Hirsova, 151. Iasi, 226. Lugoj, 244. Mehadia, 241. Neamt, 234. Oradea, 380. Pitesti, 100. Rimnicu Vilcea, 193. Sibiu, 253. Timisoara, 329. Urziceni, 80. Vaslui, 199. Zerind, 374. Figure 3. 17 Stages in a greedy best-first tree-like search for Bucharest with the straight-line distance heuristic hSLD. Nodes are labeled with their h-values. Greedy best-first graph search is complete in finite state spaces, but not in infinite ones. The worst-case time and space complexity is O(|V|). With a good heuristic function, however, the complexity can be reduced substantially, on certain problems reaching O(bm). 3. 5. 2A* search The most common informed search algorithm is A* search (pronounced “A-star search”), a best-first search that uses the evaluation function where g(n) is the path cost from the initial state to node n, and h(n) is the estimated cost of the shortest path from n to a goal state, so we have In Figure 3. 18, we show the progress of an A* search with the goal of reaching Bucharest. The values of g are computed from the action costs in Figure 3. 1, and the values of hSLD are given in Figure 3. 16. Notice that Bucharest first appears on the frontier at step (e), but it is not selected for expansion (and thus not detected as a solution) because at f = 450 it is not the lowest-cost node on the frontier—that would be Pitesti, at f = 417. Another way to say this is that there might be a solution through Pitesti whose cost is as low as 417, so the algorithm will not settle for a solution that costs 450. At step (f), a different path to Bucharest is now the lowest-cost node, at f =418, so it is selected and detected as the optimal solution. Description In all four parts, a node labeled Arad is shown. Part (“A”): The initial state. The Arad node is green-colored. An arrowhead points to Arad and 366 is marked next to the node. Part (b): After expanding Arad. The Arad node is lavender-colored and is connected to three green-colored nodes labeled Sibiu 253, Timisoara 329, and Zerind 374. An arrowhead points to Sibiu. Part (c): After expanding Sibiu. The Arad node is lavender-colored and is connected to three nodes labeled Sibiu, Timisoara 329, and Zerind 374. Sibiu is lavender-colored while Timisoara and Zerind are green-colored. Sibiu is connected to four green-colored nodes labeled Arad 366, Fagaras 177, Oradea 380, and Rimnicu Vilcea 193. An arrowhead points to Fagaras. Part (d): After expanding Fagaras. The Arad node is lavender-colored and is connected to three nodes labeled Sibiu, Timisoara 329, and Zerind 374. Sibiu is lavender-colored while Timisoara and Zerind are green-colored. Sibiu is connected to four nodes labeled Arad 366, Fagaras, Oradea 380, and Rimnicu Vilcea 193. Of these four, Fagaras is lavender-colored while the other three are green-colored. Fagaras is connected to two green-colored nodes labeled Sibiu 253 and Bucharest 0. An arrowhead points to Bucharest. Figure 3. 18 Stages in an A* search for Bucharest. Nodes are labeled with f = g + h. The h values are the straight-line distances to Bucharest taken from Figure 3. 16. A* search is complete. 11 Whether A* is cost-optimal depends on certain properties of the heuristic. A key property is admissibility: an admissible heuristic is one that never overestimates the cost to reach a goal. (An admissible heuristic is therefore optimistic. ) With an admissible heuristic, A* is cost-optimal, which we can show with a proof by contradiction. Suppose the optimal path has cost C*, but the algorithm returns a path with cost C > C*. Then there must be some node n which is on the optimal path and is unexpanded (because if all the nodes on the optimal path had been expanded, then we would have returned that optimal solution). So then, using the notation g*(n) to mean the cost of the optimal path from the start to n, and h*(n) to mean the cost of the optimal path from n to the nearest goal, we have: The first and last lines form a contradiction, so the supposition that the algorithm could return a suboptimal path must be wrong—it must be that A* returns only cost-optimal paths. A slightly stronger property is called consistency. A heuristic h(n) is consistent if, for every node n and every successor nʹ of n generated by an action a, we have: This is a form of the triangle inequality, which stipulates that a side of a triangle cannot be longer than the sum of the other two sides (see Figure 3. 19). An example of a consistent heuristic is the straight-line distance hSLD that we used in getting to Bucharest. Description Part (“A”): The initial state. A green-colored node is labeled Arad 366 equals 0 plus 366. An arrowhead points to Arad. Part (b): After expanding Arad. The Arad node is now lavender-colored and is connected to three green-colored nodes labeled Sibiu 393 equals 140 plus 253, Timisoara 447 equals 118 plus 329, and Zerind 449 equals 75 plus 374. An arrowhead points to Sibiu. Part (c): After expanding Sibiu. The Sibiu node is now lavender-colored and is connected to four green-colored nodes labeled Arad 646 equals 280 plus 366, Fagaras 415 equals 239 plus 176, Oradea 671 equals 291 plus 380, and Rimnicu Vilcea 413 equals 220 plus 193. An arrowhead points to Rimnicu Vilcea. Part (d): After expanding Rimnicu Vilcea. The Rimnicu Vilcea node is now lavender-colored and is connected to three green-colored nodes labeled Craiova 526 equals 366 plus 160, Pitesti 417 equals 317 plus 100, and Sibiu 553 equals 300 plus 253. An arrowhead points to Fagaras. Part (e): After expanding Fagaras. The Fagaras node under the Sibiu node is now lavender-colored and is connected to two green-colored nodes labeled Sibiu 591 equals 338 plus 253 and Bucharest 450 equals 450 plus 0. An arrowhead points to Pitesti under Rimnicu Vilcea. Part (f): After expanding Pitesti. The node Pitesti is now lavender-colored and is connected to three green-colored nodes labeled Bucharest 418 equals 418 plus 0, Craiova 615 equals 455 plus 160, and Rimnicu Vilcea 607 equals 414 plus 193. An arrowhead points to Bucharest under the Pitesti node. Figure 3. 19 Triangle inequality: If the heuristic h is consistent, then the single number h(n) will be less than the sum of the cost c(n, a, aʹ) of the action from n to nʹ plus the heuristic estimate h(nʹ). Every consistent heuristic is admissible (but not vice versa), so with a consistent heuristic, A* is cost-optimal. In addition, with a consistent heuristic, the first time we reach a state it will be on an optimal path, so we never have to re-add a state to the frontier, and never have to change an entry in reached. But with an inconsistent heuristic, we may end up with multiple paths reaching the same state, and if each new path has a lower path cost than the previous one, then we will end up with multiple nodes for that state in the frontier, costing us both time and space. Because of that, some implementations of A* take care to only enter a state into the frontier once, and if a better path to the state is found, all the successors of the state are updated (which requires that nodes have child pointers as well as parent pointers). These complications have led many implementers to avoid inconsistent heuristics, but Felner et al. (2011) argues that the worst effects rarely happen in practice, and one shouldn’t be afraid of inconsistent heuristics. With an inadmissible heuristic, A* may or may not be cost-optimal. Here are two cases where it is: First, if there is even one cost-optimal path on which h(n) is admissible for all nodes n on the path, then that path will be found, no matter what the heuristic says for states off the path. Second, if the optimal solution has cost C*, and the second-best has cost C2, and if h(n) overestimates some costs, but never by more than C2 – C*, then A* is guaranteed to return cost-optimal solutions. 3. 5. 3Search contours A useful way to visualize a search is to draw contours in the state space, just like the contours in a topographic map. Figure 3. 20 shows an example. Inside the contour labeled 400, all nodes have f(n) = g(n) + h(n) ≤ 400, and so on. Then, because A* expands the frontier node of lowest f-cost, we can see that an A* search fans out from the start node, adding nodes in concentric bands of increasing f-cost. Description Three circles are labeled n, n prime, and G subscript n prime. An arrow from n to G subscript n prime is labeled h (n). An arrow from n prime to G subscript n prime is labeled h (n prime). An arrow from n to n prime is labeled c (n, “A”, n prime). Figure 3. 20 Map of Romania showing contours at f = 380, f = 400, and f = 420, with Arad as the start state. Nodes inside a given contour have f = g + h costs less than or equal to the contour value. With uniform-cost search, we also have contours, but of g-cost, not g + h. The contours with uniform-cost search will be “circular” around the start state, spreading out equally in all directions with no preference towards the goal. With A* search using a good heuristic, the g + h bands will stretch toward a goal state (as in Figure 3. 20) and become more narrowly focused around an optimal path. It should be clear that as you extend a path, the g costs are monotonic: the path cost always increases as you go along a path, because action costs are always positive. 12 Therefore you get concentric contour lines that don’t cross each other, and if you choose to draw the lines fine enough, you can put a line between any two nodes on any path. But it is not obvious whether the f = g + h cost will monotonically increase. As you extend a path from n to nʹ, the cost goes from g(n) + h(n) to g(n) + c(n, a, n') + h(n'). Canceling out the g(n) term, we see that the path’s cost will be monotonically increasing if and only if h(n) ≤ c(n, a, n') + h(n'); in other words if and only if the heuristic is consistent. 13 But note that a path might contribute several nodes in a row with the same g(n) + h(n) score; this will happen whenever the decrease in h is exactly equal to the action cost just taken (for example, in a grid problem, when n is in the same row as the goal and you take a step towards the goal, g is increased by 1 and h is decreased by 1). If C* is the cost of the optimal solution path, then we can say the following: •A* expands all nodes that can be reached from the initial state on a path where every node on the path has f(n) < C*. We say these are surely expanded nodes. •A* might then expand some of the nodes right on the “goal contour” (where f(n) = C*) before selecting a goal node. •A* expands no nodes with f(n) > C*. We say that A* with a consistent heuristic is optimally efficient in the sense that any algorithm that extends search paths from the initial state, and uses the same heuristic information, must expand all nodes that are surely expanded by A* (because any one of them could have been part of an optimal solution). Among the nodes with f(n) = C*, one algorithm could get lucky and choose the optimal one first while another algorithm is unlucky; we don’t consider this difference in defining optimal efficiency. A* is efficient because it prunes away search tree nodes that are not necessary for finding an optimal solution. In Figure 3. 18(b) we see that Timisoara has f = 447 and Zerind has f = 449. Even though they are children of the root and would be among the first nodes expanded by uniform-cost or breadth-first search, they are never expanded by A* search because the solution with f = 418 is found first. The concept of pruning—eliminating possibilities from consideration without having to examine them—is important for many areas of AI. That A* search is complete, cost-optimal, and optimally efficient among all such algorithms is rather satisfying. Unfortunately, it does not mean that A* is the answer to all our searching needs. The catch is that for many problems, the number of nodes expanded can be exponential in the length of the solution. For example, consider a version of the vacuum world with a super-powerful vacuum that can clean up any one square at a cost of 1 unit, without even having to visit the square; in that scenario, squares can be cleaned in any order. With N initially dirty squares, there are 2N states where some subset has been cleaned; all of those states are on an optimal solution path, and hence satisfy f(n) < C*, so all of them would be visited by A*. 3. 5. 4Satisficing search: Inadmissible heuristics and weighted A* A* search has many good qualities, but it expands a lot of nodes. We can explore fewer nodes (taking less time and space) if we are willing to accept solutions that are suboptimal, but are “good enough”—what we call satisficing solutions. If we allow A* search to use an inadmissible heuristic—one that may overestimate—then we risk missing the optimal solution, but the heuristic can potentially be more accurate, thereby reducing the number of nodes expanded. For example, road engineers know the concept of a detour index, which is a multiplier applied to the straight-line distance to account for the typical curvature of roads. A detour index of 1. 3 means that if two cities are 10 miles apart in straight-line distance, a good estimate of the best path between them is 13 miles. For most localities, the detour index ranges between 1. 2 and 1. 6. We can apply this idea to any problem, not just ones involving roads, with an approach called weighted A* search where we weight the heuristic value more heavily, giving us the evaluation function f(n)= g(n) + W × h(n), for some W > 1. Figure 3. 21 shows a search problem on a grid world. In (a), an A* search finds the optimal solution, but has to explore a large portion of the state space to find it. In (b), a weighted A* search finds a solution that is slightly costlier, but the search time is much faster. We see that the weighted search focuses the contour of reached states towards a goal. That means that fewer states are explored, but if the optimal path ever strays outside of the weighted search’s contour (as it does in this case), then the optimal path will not be found. In general, if the optimal solution costs C*, a weighted A* search will find a solution that costs somewhere between C* and W × C*; but in practice we usually get results much closer to C* than W × C*. Description The cities of Romania as shown as nodes and each node is labeled with the respective city’s starting letter. The contour labeled 380 encloses node “A”. The contour labeled 400 encloses “A” and S. The contour labeled 420 encloses “A”, S, R, F, P, and B. The remaining cities are outside all contours shown. Figure 3. 21 Two searches on the same grid: (a) an A* search and (b) a weighted A* search with weight W = 2. The gray bars are obstacles, the purple line is the path from the green start to red goal, and the small dots are states that were reached by each search. On this particular problem, weighted A* explores 7 times fewer states and finds a path that is 5% more costly. We have considered searches that evaluate states by combining g and h in various ways; weighted A* can be seen as a generalization of the others: You could call weighted A* “somewhat-greedy search”: like greedy best-first search, it focuses the search towards a goal; on the other hand, it won’t ignore the path cost completely, and will suspend a path that is making little progress at great cost. There are a variety of suboptimal search algorithms, which can be characterized by the criteria for what counts as “good enough. ” In bounded suboptimal search, we look for a solution that is guaranteed to be within a constant factor W of the optimal cost. Weighted A* provides this guarantee. In bounded-cost search, we look for a solution whose cost is less than some constant C. And in unbounded-cost search, we accept a solution of any cost, as long as we can find it quickly. An example of an unbounded-cost search algorithm is speedy search, which is a version of greedy best-first search that uses as a heuristic the estimated number of actions required to reach a goal, regardless of the cost of those actions. Thus, for problems where all actions have the same cost it is the same as greedy best-first search, but when actions have different costs, it tends to lead the search to find a solution quickly, even if it might have a high cost. 3. 5. 5Memory-bounded search The main issue with A* is its use of memory. In this section we’ll cover some implementation tricks that save space, and then some entirely new algorithms that take better advantage of the available space. Memory is split between the frontier and the reached states. In our implementation of best-first search, a state that is on the frontier is stored in two places: as a node in the frontier (so we can decide what to expand next) and as an entry in the table of reached states (so we know if we have visited the state before). For many problems (such as exploring a grid), this duplication is not a concern, because the size of frontier is much smaller than reached, so duplicating the states in the frontier requires a comparatively trivial amount of memory. But some implementations keep a state in only one of the two places, saving a bit of space at the cost of complicating (and perhaps slowing down) the algorithm. Another possibility is to remove states from reached when we can prove that they are no longer needed. For some problems, we can use the separation property (Figure 3. 6 on page 90), along with the prohibition of U-turn actions, to ensure that all actions either move outwards from the frontier or onto another frontier state. In that case, we need only check the frontier for redundant paths, and we can eliminate the reached table. For other problems, we can keep reference counts of the number of times a state has been reached, and remove it from the reached table when there are no more ways to reach the state. For example, on a grid world where each state can be reached only from its four neighbors, once we have reached a state four times, we can remove it from the table. Now let’s consider new algorithms that are designed to conserve memory usage. Beam search limits the size of the frontier. The easiest approach is to keep only the k nodes with the best f-scores, discarding any other expanded nodes. This of course makes the search incomplete and suboptimal, but we can choose k to make good use of available memory, and the algorithm executes fast because it expands fewer nodes. For many problems it can find good near-optimal solutions. You can think of uniform-cost or A* search as spreading out everywhere in concentric contours, and think of beam search as exploring only a focused portion of those contours, the portion that contains the k best candidates. An alternative version of beam search doesn’t keep a strict limit on the size of the frontier but instead keeps every node whose f-score is within δ of the best f-score. That way, when there are a few strong-scoring nodes only a few will be kept, but if there are no strong nodes then more will be kept until a strong one emerges. Iterative-deepening A* search (IDA*) is to A* what iterative-deepening search is to depth-first: IDA* gives us the benefits of A* without the requirement to keep all reached states in memory, at a cost of visiting some states multiple times. It is a very important and commonly used algorithm for problems that do not fit in memory. In standard iterative deepening the cutoff is the depth, which is increased by one each iteration. In IDA* the cutoff is the f-cost (g + h); at each iteration, the cutoff value is the smallest f-cost of any node that exceeded the cutoff on the previous iteration. In other words, each iteration exhaustively searches an f-contour, finds a node just beyond that contour, and uses that node’s f-cost as the next contour. For problems like the 8-puzzle where each path’s f-cost is an integer, this works very well, resulting in steady progress towards the goal each iteration. If the optimal solution has cost C*, then there can be no more than C* iterations (for example, no more than 31 iterations on the hardest 8-puzzle problems). But for a problem where every node has a different f-cost, each new contour might contain only one new node, and the number of iterations could be equal to the number of states. Recursive best-first search (RBFS) (Figure 3. 22) attempts to mimic the operation of standard best-first search, but using only linear space. RBFS resembles a recursive depth-first search, but rather than continuing indefinitely down the current path, it uses the f-limit variable to keep track of the f-value of the best alternative path available from any ancestor of the current node. If the current node exceeds this limit, the recursion unwinds back to the alternative path. As the recursion unwinds, RBFS replaces the f-value of each node along the path with a backed-up value—the best f-value of its children. In this way, RBFS remembers the f-value of the best leaf in the forgotten subtree and can therefore decide whether it’s worth reexpanding the subtree at some later time. Figure 3. 23 shows how RBFS reaches Bucharest. Description In both parts, equidistant small dots are shown across the entire grid. A maze of multiple gray bars is shown scattered throughout the grid. A green dot is shown toward the left end of the grid and a red dot toward the right end of the grid. A purple line starts from the green, moves through the grid, and ends at the red dot. The purple line doesn’t cross or pass through any gray bars, rather, it moves above, below, or between two gray bars. Part (“A”): The purple line takes a path that almost resembles a curve that opens upward. The purple line stays mostly below the bulk of the gray bars, without navigating much through the maze of the gray bars. Part (b): The purple line moves in an irregular path. The purple line navigates through the maze of the gray bars, through the bulk. Figure 3. 22 The algorithm for recursive best-first search. RBFS is somewhat more efficient than IDA*, but still suffers from excessive node regeneration. In the example in Figure 3. 23, RBFS follows the path via Rimnicu Vilcea, then “changes its mind” and tries Fagaras, and then changes its mind back again. These mind changes occur because every time the current best path is extended, its f-value is likely to increase—h is usually less optimistic for nodes closer to a goal. When this happens, the second-best path might become the best path, so the search has to backtrack to follow it. Each mind change corresponds to an iteration of IDA* and could require many reexpansions of forgotten nodes to recreate the best path and extend it one more node. Description Part (“A”): After expanding Pitesti, Sibiu, and Rimnicu Vilcea. A node labeled Arad 366 is connected to three nodes labeled Sibiu 393, Timisoara 447, and Zerind 449. Timisoara and Zerind are green-colored. A small box above Arad reads infinity. Sibiu is connected to four nodes labeled Arad 646, Fagaras 415, Oradea 671, and Rimnicu Vilcea 413. A small box each above Sibiu and Rimnicu Vilcea read 447 and 415, respectively. Arad, Sibiu, and Rimnicu Vilcea are lavender-colored. The other three nodes under Sibiu are green-colored. Rimnicu Vilcea is connected to three green-colored nodes, Craiova 526, Pitesti 417, and Sibiu 553. Part (b): After unwinding back to Sibiu and expanding Fagaras. Rimnicu Vilcea is now green-colored, the small box above it is removed, and the node’s previous label of 413 is struck off to read the new value of 417. Fagaras is now lavender-colored and has a small box above it that reads 417. Fagaras is connected to two green-colored nodes labeled Sibiu 591 and Bucharest 450. Part (c): After switching back to Rimnicu Vilcea and expanding Pitesti. Fagaras is now back to being green-colored, the small box above it is removed, and the node’s previous label of 415 is struck off to read the new value of 450. Rimnicu Vilcea is back to being lavender-colored and has a small box above it that reads 447. Rimnicu Vilcea is connected to three nodes labeled Craiova 526, Pitesti 417, and Sibiu 553. Pitesti is lavender-colored and has a small box above it that reads 447. The other two nodes under Rimnicu Vilcea are green-colored. Pitesti is connected to three green-colored nodes Bucharest 418, Craiova 615, and Rimnicu Vilcea 607. Figure 3. 23 Stages in an RBFS search for the shortest route to Bucharest. The f-limit value for each recursive call is shown on top of each current node, and every node is labeled with its f-cost. (a) The path via Rimnicu Vilcea is followed until the current best leaf (Pitesti) has a value that is worse than the best alternative path (Fagaras). (b) The recursion unwinds and the best leaf value of the forgotten subtree (417) is backed up to Rimnicu Vilcea; then Fagaras is expanded, revealing a best leaf value of 450. (c) The recursion unwinds and the best leaf value of the forgotten subtree (450) is backed up to Fagaras; then Rimnicu Vilcea is expanded. This time, because the best alternative path (through Timisoara) costs at least 447, the expansion continues to Bucharest. RBFS is optimal if the heuristic function h(n) is admissible. Its space complexity is linear in the depth of the deepest optimal solution, but its time complexity is rather difficult to characterize: it depends both on the accuracy of the heuristic function and on how often the best path changes as nodes are expanded. It expands nodes in order of increasing f-score, even if f is nonmonotonic. IDA* and RBFS suffer from using too little memory. Between iterations, IDA* retains only a single number: the current f-cost limit. RBFS retains more information in memory, but it uses only linear space: even if more memory were available, RBFS has no way to make use of it. Because they forget most of what they have done, both algorithms may end up reexploring the same states many times over. It seems sensible, therefore, to determine how much memory we have available, and allow an algorithm to use all of it. Two algorithms that do this are MA* (memory-bounded A*) and SMA* (simplified MA*). SMA* is—well—simpler, so we will describe it. SMA* proceeds just like A*, expanding the best leaf until memory is full. At this point, it cannot add a new node to the search tree without dropping an old one. SMA* always drops the worst leaf node—the one with the highest f-value. Like RBFS, SMA* then backs up the value of the forgotten node to its parent. In this way, the ancestor of a forgotten subtree knows the quality of the best path in that subtree. With this information, SMA* regenerates the subtree only when all other paths have been shown to look worse than the path it has forgotten. Another way of saying this is that if all the descendants of a node n are forgotten, then we will not know which way to go from n, but we will still have an idea of how worthwhile it is to go anywhere from n. The complete algorithm is described in the online code repository accompanying this book. There is one subtlety worth mentioning. We said that SMA* expands the best leaf and deletes the worst leaf. What if all the leaf nodes have the same f-value? To avoid selecting the same node for deletion and expansion, SMA* expands the newest best leaf and deletes the oldest worst leaf. These coincide when there is only one leaf, but in that case, the current search tree must be a single path from root to leaf that fills all of memory. If the leaf is not a goal node, then even if it is on an optimal solution path, that solution is not reachable with the available memory. Therefore, the node can be discarded exactly as if it had no successors. SMA* is complete if there is any reachable solution—that is, if d, the depth of the shallowest goal node, is less than the memory size (expressed in nodes). It is optimal if any optimal solution is reachable; otherwise, it returns the best reachable solution. In practical terms, SMA* is a fairly robust choice for finding optimal solutions, particularly when the state space is a graph, action costs are not uniform, and node generation is expensive compared to the overhead of maintaining the frontier and the reached set. On very hard problems, however, it will often be the case that SMA* is forced to switch back and forth continually among many candidate solution paths, only a small subset of which can fit in memory. (This resembles the problem of thrashing in disk paging systems. ) Then the extra time required for repeated regeneration of the same nodes means that problems that would be practically solvable by A*, given unlimited memory, become intractable for SMA*. That is to say, memory limitations can make a problem intractable from the point of view of computation time. Although no current theory explains the tradeoff between time and memory, it seems that this is an inescapable problem. The only way out is to drop the optimality requirement. 3. 5. 6Bidirectional heuristic search With unidirectional best-first search, we saw that using f(n) = g(n) + h(n) as the evaluation function gives us an A* search that is guaranteed to find optimal-cost solutions (assuming an admissible h) while being optimally efficient in the number of nodes expanded. With bidirectional best-first search we could also try using f(n) = g(n) + h(n), but unfortunately there is no guarantee that this would lead to an optimal-cost solution, nor that it would be optimally efficient, even with an admissible heuristic. With bidirectional search, it turns out that it is not individual nodes but rather pairs of nodes (one from each frontier) that can be proved to be surely expanded, so any proof of efficiency will have to consider pairs of nodes (Eckerle et al. , 2017). We’ll start with some new notation. We use fF (n) = gF (n)+ hF (n) for nodes going in the forward direction (with the initial state as root) and fB(n) = gB(n) + hB(n) for nodes in the backward direction (with a goal state as root). Although both forward and backward searches are solving the same problem, they have different evaluation functions because, for example, the heuristics are different depending on whether you are striving for the goal or for the initial state. We’ll assume admissible heuristics. Consider a forward path from the initial state to a node m and a backward path from the goal to a node n. We can define a lower bound on the cost of a solution that follows the path from the initial state to m, then somehow gets to n, then follows the path to the goal as In other words, the cost of such a path must be at least as large as the sum of the path costs of the two parts (because the remaining connection between them must have nonnegative cost), and the cost must also be at least as much as the estimated f cost of either part (because the heuristic estimates are optimistic). Given that, the theorem is that for any pair of nodes m, n with lb(m, n) less than the optimal cost C*, we must expand either m or n, because the path that goes through both of them is a potential optimal solution. The difficulty is that we don’t know for sure which node is best to expand, and therefore no bidirectional search algorithm can be guaranteed to be optimally efficient—any algorithm might expand up to twice the minimum number of nodes if it always chooses the wrong member of a pair to expand first. Some bidirectional heuristic search algorithms explicitly manage a queue of (m, n) pairs, but we will stick with bidirectional best-first search (Figure 3. 14), which has two frontier priority queues, and give it an evaluation function that mimics the lb criteria: The node to expand next will be the one that minimizes this f2 value; the node can come from either frontier. This f2 function guarantees that we will never expand a node (from either frontier) with g(n) >. We say the two halves of the search “meet in the middle” in the sense that when the two frontiers touch, no node inside of either frontier has a path cost greater than the bound. Figure 3. 24 works through an example bidirectional search. Description There are four circles in each of the two rows where the circles represent nodes. The four circles in the first row are Start, “A”, F, and Goal. The four circles in the second row are C, B, D, and E. A solid arrow from Start to “A” is labeled 4. For circle “A”, f equals 9 equals 4 plus 5 and f subscript 2 equals 10. Another solid arrow from Start to B is labeled 6. For B, f equals 8 equals 6 plus 2 and f subscript 2 equals 12. A dashed arrow from B to C is labeled 1. For C, f equals 8 equals 7 plus 1 and f subscript 2 equals 14. Another dashed arrow from B to D is labeled 1. For D, f equals 9 equals 7 plus 2 and f subscript 2 equals 14. A dashed arrow from D to E is labeled 1. For E, f equals 9 equals 8 plus 1 and f subscript 2 equals 16. An arrow from Goal to F is labeled 4. For node F, function f equals 10 equals 6 plus 4 and f subscript 2 equals 10. A dashed double-headed arrow from node F to “A” is labeled 2. Figure 3. 24 Bidirectional search maintains two frontiers: on the left, nodes A and B are successors of Start; on the right, node F is an inverse successor of Goal. Each node is labeled with f = g + h values and the f2 = max(2g, g + h) value. (The g values are the sum of the action costs as shown on each arrow; the h values are arbitrary and cannot be derived from anything in the figure. ) The optimal solution, Start-A-F-Goal, has cost C* = 4 + 2 + 4 = 10, so that means that a meet-in-the-middle bidirectional algorithm should not expand any node with g > = 5; and indeed the next node to be expanded would be A or F (each with g=4), leading us to an optimal solution. If we expanded the node with lowest f cost first, then B and C would come next, and D and E would be tied with A, but they all have g > and thus are never expanded when f2 is the evaluation function. We have described an approach where the hF heuristic estimates the distance to the goal (or, when the problem has multiple goal states, the distance to the closest goal) and hB estimates the distance to the start. This is called a front-to-end search. An alternative, called front-to-front search, attempts to estimate the distance to the other frontier. Clearly, if a frontier has millions of nodes, it would be inefficient to apply the heuristic function to every one of them and take the minimum. But it can work to sample a few nodes from the frontier. In certain specific problem domains it is possible to summarize the frontier—for example, in a grid search problem, we can incrementally compute a bounding box of the frontier, and use as a heuristic the distance to the bounding box. Bidirectional search is sometimes more efficient than unidirectional search, sometimes not. In general, if we have a very good heuristic, then A* search produces search contours that are focused on the goal, and adding bidirectional search does not help much. With an average heuristic, bidirectional search that meets in the middle tends to expand fewer nodes and is preferred. In the worst case of a poor heuristic, the search is no longer focused on the goal, and bidirectional search has the same asymptotic complexity as A*. Bidirectional search with the f2 evaluation function and an admissible heuristic h is complete and optimal. 3. 6Heuristic Functions In this section, we look at how the accuracy of a heuristic affects search performance, and also consider how heuristics can be invented. As our main example we’ll return to the 8-puzzle. As mentioned in Section 3. 2, the object of the puzzle is to slide the tiles horizontally or vertically into the empty space until the configuration matches the goal configuration (Figure 3. 25). Description A square labeled Start state has three rows and three columns. Row 1: Column 1, 7. Column 2, 2. Column 3, 4. Row 2: Column 1, 5. Column 2, blank. Column 3, 6. Row 3: Column 1, 8. Column 2, 3. Column 3, 1. Another square labeled Goal state has three rows and three columns. Row 1: Column 1, blank. Column 2, 1. Column 3, 2. Row 2: Column 1, 3. Column 2, 4. Column 3, 5. Row 3: Column 1, 6. Column 2, 7. Column 3, 8. Figure 3. 25 A typical instance of the 8-puzzle. The shortest solution is 26 actions long. There are 9! /2 = 181, 400 reachable states in an 8-puzzle, so a search could easily keep them all in memory. But for the 15-puzzle, there are 16! /2 states—over 10 trillion—so to search that space we will need the help of a good admissible heuristic function. There is a long history of such heuristics for the 15-puzzle; here are two commonly used candidates: •h1 = the number of misplaced tiles (blank not included). For Figure 3. 25, all eight tiles are out of position, so the start state has h1 = 8. h1 is an admissible heuristic because any tile that is out of place will require at least one move to get it to the right place. •h2 = the sum of the distances of the tiles from their goal positions. Because tiles cannot move along diagonals, the distance is the sum of the horizontal and vertical distances—sometimes called the city-block distance or Manhattan distance. h2 is also admissible because all any move can do is move one tile one step closer to the goal. Tiles 1 to 8 in the start state of Figure 3. 25 give a Manhattan distance of As expected, neither of these overestimates the true solution cost, which is 26. 3. 6. 1The effect of heuristic accuracy on performance One way to characterize the quality of a heuristic is the effective branching factor b*. If the total number of nodes generated by A* for a particular problem is N and the solution depth is d, then b* is the branching factor that a uniform tree of depth d would have to have in order to contain N + 1 nodes. Thus, For example, if A* finds a solution at depth 5 using 52 nodes, then the effective branching factor is 1. 92. The effective branching factor can vary across problem instances, but usually for a specific domain (such as 8-puzzles) it is fairly constant across all nontrivial problem instances. Therefore, experimental measurements of b* on a small set of problems can provide a good guide to the heuristic’s overall usefulness. A well-designed heuristic would have a value of b* close to 1, allowing fairly large problems to be solved at reasonable computational cost. Korf and Reid (1998) argue that a better way to characterize the effect of A* pruning with a given heuristic h is that it reduces the effective depth by a constant kh compared to the true depth. This means that the total search cost is O(bd–kh) compared to O(bd) for an uninformed search. Their experiments on Rubik’s Cube and n-puzzle problems show that this formula gives accurate predictions for total search cost for sampled problem instances across a wide range of solution lengths—at least for solution lengths larger than kh. For Figure 3. 26 we generated random 8-puzzle problems and solved them with an uninformed breadth-first search and with A* search using both h1 and h2, reporting the average number of nodes generated and the corresponding effective branching factor for each search strategy and for each solution length. The results suggest that h2 is better than h1, and both are better than no heuristic at all. Description A square labeled Start state has three rows and three columns. Row 1: Column 1, Asterisk. Column 2, 2. Column 3, 4. Row 2: Column 1, Asterisk. Column 2, blank. Column 3, Asterisk. Row 3: Column 1, Asterisk. Column 2, 3. Column 3, 1. Another square labeled Goal state has three rows and three columns. Row 1: Column 1, blank. Column 2, 1. Column 3, 2. Row 2: Column 1, 3. Column 2, 4. Column 3, Asterisk. Row 3: Column 1, Asterisk. Column 2, Asterisk. Column 3, Asterisk. Figure 3. 26 Comparison of the search costs and effective branching factors for 8-puzzle problems using breadth-first search, A* with h1 (misplaced tiles), and A* with h2 (Manhattan distance). Data are averaged over 100 puzzles for each solution length d from 6 to 28. One might ask whether h2 is always better than h1. The answer is “Essentially, yes. ” It is easy to see from the definitions of the two heuristics that for any node n, h2 (n) ≥ h1 (n). We thus say that h2 dominates h1. Domination translates directly into efficiency: A* using h2 will never expand more nodes than A* using h1 (except in the case of breaking ties unluckily). The argument is simple. Recall the observation on page 108 that every node with f(n) < C* will surely be expanded. This is the same as saying that every node with h(n) < C* – g(n) is surely expanded when h is consistent. But because h2 is at least as big as h1 for all nodes, every node that is surely expanded by A* search with h2 is also surely expanded with h1, and h1 might cause other nodes to be expanded as well. Hence, it is generally better to use a heuristic function with higher values, provided it is consistent and that the computation time for the heuristic is not too long. 3. 6. 2Generating heuristics from relaxed problems We have seen that both h1 (misplaced tiles) and h2 (Manhattan distance) are fairly good heuristics for the 8-puzzle and that h2 is better. How might one have come up with h2? Is it possible for a computer to invent such a heuristic mechanically? h1 and h2 are estimates of the remaining path length for the 8-puzzle, but they are also perfectly accurate path lengths for simplified versions of the puzzle. If the rules of the puzzle were changed so that a tile could move anywhere instead of just to the adjacent empty square, then h1 would give the exact length of the shortest solution. Similarly, if a tile could move one square in any direction, even onto an occupied square, then h2 would give the exact length of the shortest solution. A problem with fewer restrictions on the actions is called a relaxed problem. The state-space graph of the relaxed problem is a supergraph of the original state space because the removal of restrictions creates added edges in the graph. Because the relaxed problem adds edges to the state-space graph, any optimal solution in the original problem is, by definition, also a solution in the relaxed problem; but the relaxed problem may have better solutions if the added edges provide shortcuts. Hence, the cost of an optimal solution to a relaxed problem is an admissible heuristic for the original problem. Furthermore, because the derived heuristic is an exact cost for the relaxed problem, it must obey the triangle inequality and is therefore consistent (see page 106). If a problem definition is written down in a formal language, it is possible to construct relaxed problems automatically. 14 For example, if the 8-puzzle actions are described as A tile can move from square X to square Y if X is adjacent to Y and Y is blank, we can generate three relaxed problems by removing one or both of the conditions: (a) A tile can move from square X to square Y if X is adjacent to Y. (b) A tile can move from square X to square Y if Y is blank. (c) A tile can move from square X to square Y. From (a), we can derive h2 (Manhattan distance). The reasoning is that h2 would be the proper score if we moved each tile in turn to its destination. The heuristic derived from (b) is discussed in Exercise 3. GASC. From (c), we can derive h1 (misplaced tiles) because it would be the proper score if tiles could move to their intended destination in one action. Notice that it is crucial that the relaxed problems generated by this technique can be solved essentially without search, because the relaxed rules allow the problem to be decomposed into eight independent subproblems. If the relaxed problem is hard to solve, then the values of the corresponding heuristic will be expensive to obtain. A program called ABSOLVER can generate heuristics automatically from problem definitions, using the “relaxed problem” method and various other techniques (Prieditis, 1993). ABSOLVER generated a new heuristic for the 8-puzzle that was better than any preexisting heuristic and found the first useful heuristic for the famous Rubik’s Cube puzzle. If a collection of admissible heuristics h1. . . hm is available for a problem and none of them is clearly better than the others, which should we choose? As it turns out, we can have the best of all worlds, by defining h(n) = max{h1(n), . . . , hk(n)}. This composite heuristic picks whichever function is most accurate on the node in question. Because the hi components are admissible, h is admissible (and if hi are all consistent, h is consistent). Furthermore, h dominates all of its component heuristics. The only drawback is that h(n) takes longer to compute. If that is an issue, an alternative is to randomly select one of the heuristics at each evaluation, or use a machine learning algorithm to predict which heuristic will be best. Doing this can result in a heuristic that is inconsistent (even if every hi is consistent), but in practice it usually leads to faster problem solving. 3. 6. 3Generating heuristics from subproblems: Pattern databases Admissible heuristics can also be derived from the solution cost of a subproblem of a given problem. For example, Figure 3. 27 shows a subproblem of the 8-puzzle instance in Figure 3. 25. The subproblem involves getting tiles 1, 2, 3, 4, and the blank into their correct positions. Clearly, the cost of the optimal solution of this subproblem is a lower bound on the cost of the complete problem. It turns out to be more accurate than Manhattan distance in some cases. Description The map shows various highways, signs, and city and place names. Two possible routes between Arad and Bucharest are shown. The first route passes through Sibiu, Rimnicu Vilcea, Pitesti, and reaches Bucharest. The distance and estimated time are displayed to be 578 kilometers and 7 hours 17 minutes, respectively. The second route passes through Lugoj, Drobeta, Pitesti, and reaches Bucharest. The estimated time is displayed to be 7 hours and 35 minutes. The first road is highlighted in blue as the selected route. A window pane to the left of the map shows the exact directions to start from Arad and reach Bucharest. Figure 3. 27 A subproblem of the 8-puzzle instance given in Figure 3. 25. The task is to get tiles 1, 2, 3, 4, and the blank into their correct positions, without worrying about what happens to the other tiles. The idea behind pattern databases is to store these exact solution costs for every possible subproblem instance—in our example, every possible configuration of the four tiles and the blank. (There will be 9 × 8 × 7 × 6 × 5 = 15, 120 patterns in the database. The identities of the other four tiles are irrelevant for the purposes of solving the subproblem, but moves of those tiles do count toward the solution cost of the subproblem. ) Then we compute an admissible heuristic hDB for each state encountered during a search simply by looking up the corresponding subproblem configuration in the database. The database itself is constructed by searching back from the goal and recording the cost of each new pattern encountered; 15 the expense of this search is amortized over subsequent problem instances, and so makes sense if we expect to be asked to solve many problems. The choice of tiles 1-2-3-4 to go with the blank is fairly arbitrary; we could also construct databases for 5-6-7-8, for 2-4-6-8, and so on. Each database yields an admissible heuristic, and these heuristics can be combined, as explained earlier, by taking the maximum value. A combined heuristic of this kind is much more accurate than the Manhattan distance; the number of nodes generated when solving random 15-puzzles can be reduced by a factor of 1000. However, with each additional database there are diminishing returns and increased memory and computation costs. One might wonder whether the heuristics obtained from the 1-2-3-4 database and the 5-6-7-8 could be added, since the two subproblems seem not to overlap. Would this still give an admissible heuristic? The answer is no, because the solutions of the 1-2-3-4 subproblem and the 5-6-7-8 subproblem for a given state will almost certainly share some moves—it is unlikely that 1-2-3-4 can be moved into place without touching 5-6-7-8, and vice versa. But what if we don’t count those moves—what if we don’t abstract the other tiles to stars, but rather make them disappear? That is, we record not the total cost of solving the 1-2-3-4 subproblem, but just the number of moves involving 1-2-3-4. Then the sum of the two costs is still a lower bound on the cost of solving the entire problem. This is the idea behind disjoint pattern databases. With such databases, it is possible to solve random 15-puzzles in a few milliseconds—the number of nodes generated is reduced by a factor of 10, 000 compared with the use of Manhattan distance. For 24-puzzles, a speedup of roughly a factor of a million can be obtained. Disjoint pattern databases work for sliding-tile puzzles because the problem can be divided up in such a way that each move affects only one subproblem—because only one tile is moved at a time. 3. 6. 4Generating heuristics with landmarks There are online services that host maps with tens of millions of vertices and find cost-optimal driving directions in milliseconds (Figure 3. 28). How can they do that, when the best search algorithms we have considered so far are about a million times slower? There are many tricks, but the most important one is precomputation of some optimal path costs. Although the precomputation can be time-consuming, it need only be done once, and then can be amortized over billions of user search requests. Description The map shows various highways, signs, and city and place names. Two possible routes between Arad and Bucharest are shown. The first route passes through Sibiu, Rimnicu Vilcea, Pitesti, and reaches Bucharest. The distance and estimated time are displayed to be 578 kilometers and 7 hours 17 minutes, respectively. The second route passes through Lugoj, Drobeta, Pitesti, and reaches Bucharest. The estimated time is displayed to be 7 hours and 35 minutes. The first road is highlighted in blue as the selected route. A window pane to the left of the map shows the exact directions to start from Arad and reach Bucharest. Figure 3. 28 A Web service providing driving directions, computed by a search algorithm. We could generate a perfect heuristic by precomputing and storing the cost of the optimal path between every pair of vertices. That would take O(|V|2) space, and O(|E|3) time—practical for graphs with 10 thousand vertices, but not 10 million. A better approach is to choose a few (perhaps 10 or 20) landmark points16 from the vertices. Then for each landmark L and for each other vertex v in the graph, we compute and store C* (v, L), the exact cost of the optimal path from v to L. (We also need C* (L, v); on an undirected graph this is the same as C* (v, L); on a directed graph—e. g. , with one-way streets—we need to compute this separately. ) Given the stored C* tables, we can easily create an efficient (although inadmissible) heuristic: the minimum, over all landmarks, of the cost of getting from the current node to the landmark, and then to the goal: If the optimal path happens to go through a landmark, this heuristic will be exact; if not it is inadmissible—it overestimates the cost to the goal. In an A* search, if you have exact heuristics, then once you reach a node that is on an optimal path, every node you expand from then on will be on an optimal path. Think of the contour lines as following along this optimal path. The search will trace along the optimal path, on each iteration adding an action with cost c to get to a result state whose h-value will be c less, meaning that the total f = g + h score will remain constant at C* all along the path. Some route-finding algorithms save even more time by adding shortcuts—artificial edges in the graph that define an optimal multi-action path. For example, if there were shortcuts predefined between all the 100 biggest cities in the U. S. , and we were trying to navigate from the Berkeley campus in California to NYU in New York, we could take the shortcut between Sacramento and Manhattan and cover 90% of the path in one action. hL(n) is efficient but not admissible. But with a bit more care, we can come up with a heuristic that is both efficient and admissible: This is called a differential heuristic (because of the subtraction). Think of this with a landmark that is somewhere out beyond the goal. If the goal happens to be on the optimal path from n to the landmark, then this is saying “consider the entire path from n to L, then subtract off the last part of that path, from goal to L, giving us the exact cost of the path from n to goal ” To the extent that the goal is a bit off of the optimal path to the landmark, the heuristic will be inexact, but still admissible. Landmarks that are not out beyond the goal will not be useful; a landmark that is exactly halfway between n and goal will give hDH = 0, which is not helpful. There are several ways to pick landmark points. Selecting points at random is fast, but we get better results if we take care to spread the landmarks out so they are not too close to each other. A greedy approach is to pick a first landmark at random, then find the point that is furthest from that, and add it to the set of landmarks, and continue, at each iteration adding the point that maximizes the distance to the nearest landmark. If you have logs of past search requests by your users, then you can pick landmarks that are frequently requested in searches. For the differential heuristic it is good if the landmarks are spread around the perimeter of the graph. Thus, a good technique is to find the centroid of the graph, arrange k pie-shaped wedges around the centroid, and in each wedge select the vertex that is farthest from the center. Landmarks work especially well in route-finding problems because of the way roads are laid out in the world: a lot of traffic actually wants to travel between landmarks, so civil engineers build the widest and fastest roads along these routes; landmark search makes it easier to recover these routes. 3. 6. 5Learning to search better We have presented several fixed search strategies—breadth-first, A*, and so on—that have been carefully designed and programmed by computer scientists. Could an agent learn how to search better? The answer is yes, and the method rests on an important concept called the metalevel state space. Each state in a metalevel state space captures the internal (computational) state of a program that is searching in an ordinary state space such as the map of Romania. (To keep the two concepts separate, we call the map of Romania an object-level state space. ) For example, the internal state of the A* algorithm consists of the current search tree. Each action in the metalevel state space is a computation step that alters the internal state; for example, each computation step in A* expands a leaf node and adds its successors to the tree. Thus, Figure 3. 18, which shows a sequence of larger and larger search trees, can be seen as depicting a path in the metalevel state space where each state on the path is an object-level search tree. Now, the path in Figure 3. 18 has five steps, including one step, the expansion of Fagaras, that is not especially helpful. For harder problems, there will be many such missteps, and a metalevel learning algorithm can learn from these experiences to avoid exploring unpromising subtrees. The techniques used for this kind of learning are described in Chapter 23. The goal of learning is to minimize the total cost of problem solving, trading off computational expense and path cost. 3. 6. 6Learning heuristics from experience We have seen that one way to invent a heuristic is to devise a relaxed problem for which an optimal solution can be found easily. An alternative is to learn from experience. “Experience” here means solving lots of 8-puzzles, for instance. Each optimal solution to an 8-puzzle problem provides an example (goal, path) pair. From these examples, a learning algorithm can be used to construct a function h that can (with luck) approximate the true path cost for other states that arise during search. Most of these approaches learn an imperfect approximation to the heuristic function, and thus risk inadmissibility. This leads to an inevitable tradeoff between learning time, search run time, and solution cost. Techniques for machine learning are demonstrated in Chapter 19. The reinforcement learning methods described in Chapter 23 are also applicable to search. Some machine learning techniques work better when supplied with features of a state that are relevant to predicting the state’s heuristic value, rather than with just the raw state description. For example, the feature “number of misplaced tiles” might be helpful in predicting the actual distance of an 8-puzzle state from the goal. Let’s call this feature x1(n). We could take 100 randomly generated 8-puzzle configurations and gather statistics on their actual solution costs. We might find that when x1(n) is 5, the average solution cost is around 14, and so on. Of course, we can use multiple features. A second feature x2(n) might be “number of pairs of adjacent tiles that are not adjacent in the goal state. ” How should x1(n) and x2(n) be combined to predict h(n)? A common approach is to use a linear combination: The constants c1 and c2 are adjusted to give the best fit to the actual data across the randomly generated configurations. One expects both c1 and c2 to be positive because misplaced tiles and incorrect adjacent pairs make the problem harder to solve. Notice that this heuristic satisfies the condition h(n) = 0 for goal states, but it is not necessarily admissible or consistent. Summary This chapter has introduced search algorithms that an agent can use to select action sequences in a wide variety of environments—as long as they are episodic, single-agent, fully observable, deterministic, static, discrete, and completely known. There are tradeoffs to be made between the amount of time the search takes, the amount of memory available, and the quality of the solution. We can be more efficient if we have domain-dependent knowledge in the form of a heuristic function that estimates how far a given state is from the goal, or if we precompute partial solutions involving patterns or landmarks. •Before an agent can start searching, a well-defined problem must be formulated. •A problem consists of five parts: the initial state, a set of actions, a transition model describing the results of those actions, a set of goal states, and an action cost function. •The environment of the problem is represented by a state space graph. A path through the state space (a sequence of actions) from the initial state to a goal state is a solution. •Search algorithms generally treat states and actions as atomic, without any internal structure (although we introduced features of states when it came time to do learning). •Search algorithms are judged on the basis of completeness, cost optimality, time complexity, and space complexity. •Uninformed search methods have access only to the problem definition. Algorithms build a search tree in an attempt to find a solution. Algorithms differ based on which node they expand first: –Best-first search selects nodes for expansion using an evaluation function. –Breadth-first search expands the shallowest nodes first; it is complete, optimal for unit action costs, but has exponential space complexity. –Uniform-cost search expands the node with lowest path cost, g(n), and is optimal for general action costs. –Depth-first search expands the deepest unexpanded node first. It is neither complete nor optimal, but has linear space complexity. Depth-limited search adds a depth bound. –Iterative deepening search calls depth-first search with increasing depth limits until a goal is found. It is complete when full cycle checking is done, optimal for unit action costs, has time complexity comparable to breadth-first search, and has linear space complexity. –Bidirectional search expands two frontiers, one around the initial state and one around the goal, stopping when the two frontiers meet. •Informed search methods have access to a heuristic function h(n) that estimates the cost of a solution from n. They may have access to additional information such as pattern databases with solution costs. –Greedy best-first search expands nodes with minimal h(n). It is not optimal but is often efficient. –A* search expands nodes with minimal f(n) = g(n) + h(n). A* is complete and optimal, provided that h(n) is admissible. The space complexity of A* is still an issue for many problems. –Bidirectional A* search is sometimes more efficient than A* itself. –IDA* (iterative deepening A* search) is an iterative deepening version of A*, and thus adresses the space complexity issue. –RBFS (recursive best-first search) and SMA* (simplified memory-bounded A*) are robust, optimal search algorithms that use limited amounts of memory; given enough time, they can solve problems for which A* runs out of memory. –Beam search puts a limit on the size of the frontier; that makes it incomplete and suboptimal, but it often finds reasonably good solutions and runs faster than complete searches. –Weighted A* search focuses the search towards a goal, expanding fewer nodes, but sacrificing optimality. •The performance of heuristic search algorithms depends on the quality of the heuristic function. One can sometimes construct good heuristics by relaxing the problem definition, by storing precomputed solution costs for subproblems in a pattern database, by defining landmarks, or by learning from experience with the problem class. Bibliographical and Historical Notes The topic of state-space search originated in the early years of AI. Newell and Simon’s work on the Logic Theorist (1957) and GPS (1961) led to the establishment of search algorithms as the primary tool for 1960s AI researchers and to the establishment of problem solving as the canonical AI task. Work in operations research by Richard Bellman (1957) showed the importance of additive path costs in simplifying optimization algorithms. The text by Nils Nilsson (1971) established the area on a solid theoretical footing. The 8-puzzle is a smaller cousin of the 15-puzzle, whose history is recounted at length by Slocum and Sonneveld (2006). In 1880, the 15-puzzle attracted broad attention from the public and mathematicians (Johnson and Story, 1879; Tait, 1880). The editors of the American Journal of Mathematics stated, “The ‘15’ puzzle for the last few weeks has been prominently before the American public, and may safely be said to have engaged the attention of nine out of ten persons of both sexes and all ages and conditions of the community, ” while the Weekly News-Democrat of Emporia, Kansas wrote on March 12, 1880 that “It has become literally an epidemic all over the country. ” The famous American game designer Sam Loyd falsely claimed to have invented the 15 puzzle (Loyd, 1959); actually it was invented by Noyes Chapman, a postmaster in Canastota, New York, in the mid-1870s (although a generic patent covering sliding blocks was granted to Ernest Kinsey in 1878). Ratner and Warmuth (1986) showed that the general n × n version of the 15-puzzle belongs to the class of NP-complete problems. Rubik’s Cube was of course invented in 1974 by Ernő Rubik, who also discovered an algorithm for finding good, but not optimal solutions. Korf (1997) found optimal solutions for some random problem instances using pattern databases and IDA* search. Rokicki et al. (2014) proved that any instance can be solved in 26 moves (if you consider a 180° twist to be two moves; 20 if it counts as one). The proof consumed 35 CPU years of computation; it does not lead immediately to an efficient algorithm. Agostinelli et al. (2019) used reinforcement learning, deep learning networks, and Monte Carlo tree search to learn a much more efficient solver for Rubik’s cube. It is not guaranteed to find a cost-optimal solution, but does so about 60% of the time, and typical solutions times are less than a second. Each of the real-world search problems listed in the chapter has been the subject of a good deal of research effort. Methods for selecting optimal airline flights remain proprietary for the most part, but Carl de Marcken has shown by a reduction to Diophantine decision problems that airline ticket pricing and restrictions have become so convoluted that the problem of selecting an optimal flight is formally undecidable (Robinson, 2002). The traveling salesperson problem (TSP) is a standard combinatorial problem in theoretical computer science (Lawler et al. , 1992). Karp (1972) proved the TSP decision problem to be NP-hard, but effective heuristic approximation methods were developed (Lin and Kernighan, 1973). Arora (1998) devised a fully polynomial approximation scheme for Euclidean TSPs. VLSI layout methods are surveyed by LaPaugh (2010), and many layout optimization papers appear in VLSI journals. Robotic navigation is discussed in Chapter 26. Automatic assembly sequencing was first demonstrated by FREDDY (Michie, 1972); a comprehensive review is given by (Bahubalendruni and Biswal, 2016). Uninformed search algorithms are a central topic of computer science (Cormen et al. , 2009) and operations research (Dreyfus, 1969). Breadth-first search was formulated for solving mazes by Moore (1959). The method of dynamic programming (Bellman, 1957; Bellman and Dreyfus, 1962), which systematically records solutions for all subproblems of increasing lengths, can be seen as a form of breadth-first search. Dijkstra’s algorithm in the form it is usually presented in (Dijkstra, 1959) is applicable to explicit finite graphs. Nilsson (1971) introduced a version of Dijkstra’s algorithm that he called uniform-cost search (because the algorithm “spreads out along contours of equal path cost”) that allows for implicitly defined, infinite graphs. Nilsson’s work also introduced the idea of closed and open lists, and the term “graph search. ” The name BEST-FIRST-SEARCH was introduced in the Handbook of AI (Barr and Feigenbaum, 1981). The Floyd–Warshall (Floyd, 1962) and Bellman-Ford (Bellman, 1958; Ford, 1956) algorithms allow negative step costs (as long as there are no negative cycles). A version of iterative deepening designed to make efficient use of the chess clock was first used by Slate and Atkin (1977) in the CHESS 4. 5 game-playing program. Martelli’s algorithm B (1977) also includes an iterative deepening aspect. The iterative deepening technique was introduced by Bertram Raphael (1976) and came to the fore in work by Korf (1985a). The use of heuristic information in problem solving appears in an early paper by Simon and Newell (1958), but the phrase “heuristic search” and the use of heuristic functions that estimate the distance to the goal came somewhat later (Newell and Ernst, 1965; Lin, 1965). Doran and Michie (1966) conducted extensive experimental studies of heuristic search. Although they analyzed path length and “penetrance” (the ratio of path length to the total number of nodes examined so far), they appear to have ignored the information provided by the path cost g(n). The A* algorithm, incorporating the current path cost into heuristic search, was developed by Hart, Nilsson, and Raphael (1968). Dechter and Pearl (1985) studied the conditions under which A* is optimally efficient (in number of nodes expanded). The original A* paper (Hart et al. , 1968) introduced the consistency condition on heuristic functions. The monotone condition was introduced by Pohl (1977) as a simpler replacement, but Pearl (1984) showed that the two were equivalent. Pohl (1977) pioneered the study of the relationship between the error in heuristic functions and the time complexity of A*. Basic results were obtained for tree-like search with unit action costs and a single goal state (Pohl, 1977; Gaschnig, 1979; Huyn et al. , 1980; Pearl, 1984) and with multiple goal states (Dinh et al. , 2007). Korf and Reid (1998) showed how to predict the exact number of nodes expanded (not just an asymptotic approximation) on a variety of actual problem domains. The “effective branching factor” was proposed by Nilsson (1971) as an empirical measure of efficiency. For graph search, Helmert and Röger (2008) noted that several well-known problems contained exponentially many nodes on optimal-cost solution paths, implying exponential time complexity for A*. There are many variations on the A* algorithm. Pohl (1970) introduced weighted A* search, and later a dynamic version (1973), where the weight changes over the depth of the tree. Ebendt and Drechsler (2009) synthesize the results and examine some applications. Hatem and Ruml (2014) show a simplified and improved version of weighted A* that is easier to implement. Wilt and Ruml (2014) introduce speedy search as an alternative to greedy search that focuses on minimizing search time, and Wilt and Ruml (2016) show that the best heuristics for satisficing search are different from the ones for optimal search. Burns et al. (2012) give some implementation tricks for writing fast search code, and Felner (2018) considers how the implementation changes when using an early goal test. Pohl (1971) introduced bidirectional search. Holte et al. (2016) describe the version of bidirectional search that is guaranteed to meet in the middle, making it more widely applicable. Eckerle et al. (2017) describe the set of surely expanded pairs of nodes, and show that no bidirectional search can be optimally efficient. The NBS algorithm (Chen et al. , 2017) makes explicit use of a queue of pairs of nodes. A combination of bidirectional A* and known landmarks was used to efficiently find driving routes for Microsoft’s online map service (Goldberg et al. , 2006). After caching a set of paths between landmarks, the algorithm can find an optimal-cost path between any pair of points in a 24-million-point graph of the United States, searching less than 0. 1% of the graph. Korf (1987) shows how to use subgoals, macro-operators, and abstraction to achieve remarkable speedups over previous techniques. Delling et al. (2009) describe how to use bidirectional search, landmarks, hierarchical structure, and other tricks to find driving routes. Anderson et al. (2008) describe a related technique, called coarse-to-fine search, which can be thought of as defining landmarks at various hierarchical levels of abstraction. Korf (1987) describes conditions under which coarse-to-fine search provides an exponential speedup. Knoblock (1991) provides experimental results and analysis to quantify the advantages of hierarchical search. A* and other state-space search algorithms are closely related to the branch-and-bound techniques that are widely used in operations research (Lawler and Wood, 1966; Rayward-Smith et al. , 1996). Kumar and Kanal (1988) attempt a “grand unification” of heuristic search, dynamic programming, and branch-and-bound techniques under the name of CDP—the “composite decision process. ” Because most computers in the 1960s had only a few thousand words of main memory, memory-bounded heuristic search was an early research topic. The Graph Traverser (Doran and Michie, 1966), one of the earliest search programs, commits to an action after searching best-first up to the memory limit. IDA* (Korf, 1985b) was the first widely used length- optimal, memory-bounded heuristic search algorithm, and a large number of variants have been developed. An analysis of the efficiency of IDA* and of its difficulties with real-valued heuristics appears in Patrick et al. (1992). The original version of RBFS (Korf, 1993) is actually somewhat more complicated than the algorithm shown in Figure 3. 22, which is actually closer to an independently developed algorithm called iterative expansion or IE (Russell, 1992). RBFS uses a lower bound as well as the upper bound; the two algorithms behave identically with admissible heuristics, but RBFS expands nodes in best-first order even with an inadmissible heuristic. The idea of keeping track of the best alternative path appeared earlier in Bratko’s (2009) elegant Prolog implementation of A* and in the DTA* algorithm (Russell and Wefald, 1991). The latter work also discusses metalevel state spaces and metalevel learning. The MA* algorithm appeared in Chakrabarti et al. (1989). SMA*, or Simplified MA*, emerged from an attempt to implement MA* (Russell, 1992). Kaindl and Khorsand (1994) applied SMA* to produce a bidirectional search algorithm that was substantially faster than previous algorithms. Korf and Zhang (2000) describe a divide-and-conquer approach, and Zhou and Hansen (2002) introduce memory-bounded A* graph search and a strategy for switching to breadth-first search to increase memory-efficiency (Zhou and Hansen, 2006). The idea that admissible heuristics can be derived by problem relaxation appears in the seminal paper by Held and Karp (1970), who used the minimum-spanning-tree heuristic to solve the TSP. (See Exercise 3. MSTR. ) The automation of the relaxation process was implemented successfully by Prieditis (1993). There is a growing literature on the application of machine learning to discover heuristic functions (Samadi et al. , 2008; Arfaee et al. , 2010; Thayer et al. , 2011; Lelis et al. , 2012). The use of pattern databases to derive admissible heuristics is due to Gasser (1995) and Culberson and Schaeffer (1996, 1998); disjoint pattern databases are described by Korf and Felner (2002); a similar method using symbolic patterns is due to Edelkamp (2009). Felner et al. (2007) show how to compress pattern databases to save space. The probabilistic interpretation of heuristics was investigated by Pearl (1984) and Hansson and Mayer (1989). Pearl’s (1984) Heuristics and Edelkamp and Schrödl’s (2012) Heuristic Search are influential textbooks on search. Papers about new search algorithms appear at the International Symposium on Combinatorial Search (SoCS) and the International Conference on Automated Planning and Scheduling (ICAPS), as well as in general AI conferences such as AAAI and IJCAI, and journals such as Artificial Intelligence and Journal of the ACM. 1We are assuming that most readers are in the same position and can easily imagine themselves to be as clueless as our agent. We apologize to Romanian readers who are unable to take advantage of this pedagogical device. 2For problems with an infinite number of actions we would need techniques that go beyond this chapter. 3In any problem with a cycle of net negative cost, the cost-optimal solution is to go around that cycle an infinite number of times. The Bellman–Ford and Floyd–Warshall algorithms (not covered here) handle negative-cost actions, as long as there are no negative cycles. It is easy to accommodate zero-cost actions, as long as the number of consecutive zero-cost actions is bounded. For example, we might have a robot where there is a cost to move, but zero cost to rotate 90o; the algorithms in this chapter can handle this as long as no more than three consecutive 90o turns are allowed. There is also a complication with problems that have an infinite number of arbitrarily small action costs. Consider a version of Zeno’s paradox where there is an action to move half way to the goal, at a cost of half of the previous move. This problem has no solution with a finite number of actions, but to prevent a search from taking an unbounded number of actions without quite reaching the goal, we can require that all action costs be at least ϵ, for some small positive value ϵ. 4See Section 11. 4. 5Some authors call the frontier the open list, which is both geographically less evocative and computationally less appropriate, because a queue is more efficient than a list here. Those authors use the term closed list to refer to the set of previously expanded nodes, which in our terminology would be the reached nodes minus the frontier. 6We say “tree-like search” because the state space is still the same graph no matter how we search it; we are just choosing to treat it as if it were a tree, with only one path from each node back to the root. 7Some authors use the term “admissibility” for the property of finding the lowest-cost solution, and some use just “optimality, ” but that can be confused with other types of optimality. 8Here, and throughout the book, the “star” in C* means an optimal value for C. 9In our implementation, the reached data structure supports a query asking whether a given state is a member, and the frontier data structure (a priority queue) does not, so we check for a collision using reached; but conceptually we are asking if the two frontiers have met up. The implementation can be extended to handle multiple goal states by loading the node for each goal state into the backwards frontier and backwards reached table. 10It may seem odd that the heuristic function operates on a node, when all it really needs is the node’s state. It is traditional to use h(n) rather than h(s) to be consistent with the evaluation function f(n) and the path cost g(n). 11Again, assuming all action costs are > ϵ > 0, and the state space either has a solution or is finite. 12Technically, we say “strictly monotonic” for costs that always increase, and “monotonic” for costs that never decrease, but might remain the same. 13In fact, the term “monotonic heuristic” is a synonym for “consistent heuristic. ” The two ideas were developed independently, and then it was proved that they are equivalent (Pearl, 1984). 14In Chapters 8 and 11, we describe formal languages suitable for this task; with formal descriptions that can be manipulated, the construction of relaxed problems can be automated. For now, we use English. 15By working backward from the goal, the exact solution cost of every instance encountered is immediately available. This is an example of dynamic programming, which we discuss further in Chapter 16. 16Landmark points are sometimes called “pivots” or “anchors. ”",前：None | 后：None,AI_Popular,Formal_Academic,"node,search,state","Chapters 7,Appendix A. 3,Romania,Arad,Arad,Sibiu,Timisoara,Zerind,Romania,Iasi,Iasi,Valsui,Vaslui,Hirsova,Hirsova,Eforie,Bucharest,Bucharest,Giurgiu,Fagaras,Sibiu,Craiova,Sibiu,Oradea,Arad,Arad,Zerind,Zerind,Oradea,Arad,Timisoara,Timisoara,Lugoj,Lugoj,Mehadia,Mehadia,Drobeta,Drobeta,Craiova,Romania,•Goal,Arad,Sibiu,Sibiu,Arad,Sibiu,Zerind,Road Closed,Arad,e. g.,ACTION-COST(S,Romania,Bucharest,Arad,Arad,Sibiu,Sibiu,Arad,Sibiu,Arad,Suck,Left,Backward,TurnRight,TurnRight,•Goal,Start,Left, Right,Down,•Goal,Donald Knuth,Knuth,•Goal,Romania,e. g.,•Goal,Boston,Bertsimas,al.,VLSI,Romania,Automatic,Algorithms A,Arad,Arad,node,Arad,Description Search,Root node Arad,Sibiu,Timisoara,Zerind,Node Sibiu,Arad,Oradea,Node Timisoara,Arad,Lugoj,Node Zerind,Arad,Oradea,Root node Arad,Sibiu,Timisoara,Zerind,Node Sibiu,Arad,Oradea,Node Timisoara,Arad,Lugoj,Node Zerind,Arad,Oradea,Root node Arad,Sibiu,Timisoara,Zerind,Node Sibiu,Arad,Oradea,Node Timisoara,Arad,Lugoj,Node Zerind,Arad,Oradea,Arad,Arad,Sibiu,Arad,Sibiu,node,Arad,Zerind,Sibiu,Timisoara,Sibiu,Fagaras,Zerind,Oradea,Timisoara,Lugoj,Lugoj,Mehadia,Craiova,Romania,Oradea,Oradea,node,node,node,node,f(n,f(n,f(n,Node,C. Node,E. Node C,F and G. Binary Tree 1,Binary Tree 2,Binary Tree,Binary Tree 4: Nodes,node,Search,PATH-COST,PARENT,node,node,node,Arad,Sibiu,Arad,Arad,Sibiu,Arad–Sibiu,Arad,e. g.,e. g. Arad,Sibiu,Arad,Knuth,|V| + |E|,|V|,Romania,AI,Arad,Zerind,Sibiu,Sibiu,node,f(n,node,node,Description Sibiu,Fagaras,Bucharest,Node,C. Node,E. Node C,F,G. Node,H,I. Node,L,M. Node G,N,Binary Tree 2,Node,Binary Tree,Binary Tree 4: Nodes,Binary Tree 5: Nodes,I.,Binary Tree,Binary Tree 7: Nodes,J. The,Binary Tree,Binary Tree 9,Node,Binary Tree,Nodes F and G,Binary Tree 11,F,F,Binary Tree 12,F,F and M,F,Dijkstra,AI,Sibiu,Sibiu,node,node,Bucharest,Romania,node,AI,node,O(bl,O(bl,Romania,F,TERMINATED,Bidirectional,|V,≥,h(n,node n,h(n,node,Romania,Bucharest,Bucharest,ACTIONS,Node,C. Node,E. Node C,F,G. Node,H,I. Node,L,M. Node G,N,Binary Tree 1,Node,Binary Tree 2,Node,Binary Tree 2,Node,Binary Tree,Node,Node C,Binary Tree 4,Binary Tree 2,Node,Binary Tree,Binary Tree 4: Nodes,Binary Tree 5,Node,Node C,Binary Tree,Nodes F and G,Binary Tree 7: Nodes,Node G,Binary Tree 8,Binary Tree 2,Node,Binary Tree,Binary Tree 4: Nodes,Binary Tree 5: Nodes,I.,Binary Tree,Binary Tree 7: Nodes,J. The,Binary Tree,Binary Tree 9,Node,Binary Tree,Nodes F and G,Binary Tree 11,F,F,Binary Tree 12,F,F and M,F,Arad,Arad,Sibiu,Zerind,Timisoara,Bucharest,node,Sibiu,Bucharest,Description Arad,Bucharest,Craiova,Drobeta,Hirsova,Lugoj,Mehadia,Oradea,Sibiu,Timisoara,Urziceni,Vaslui,Zerind,O(|V|,g(n,node n,h(n,Pitesti,node,node,Arad,Arad,Arad,Arad,Arad,Sibiu,Timisoara 329,Zerind 374,Sibiu,Sibiu,Arad,Sibiu,Timisoara 329,Zerind 374,Sibiu,Timisoara,Zerind,Sibiu,Arad 366,Oradea 380,Arad,Sibiu,Timisoara 329,Zerind 374,Sibiu,Timisoara,Zerind,Sibiu,Arad 366,Sibiu,Bucharest,h(n,node,Arad 366,Arad,Arad,Arad,Sibiu,Timisoara,Zerind,Sibiu,Sibiu,Sibiu,node,Oradea 671,Craiova 526,Sibiu,Sibiu,node,Sibiu 591,Bucharest 450,Pitesti under Rimnicu Vilcea,Pitesti,Craiova 615,Bucharest,Pitesti,Triangle,Felner et al,h(n,h(n,f(n,g(n,≤,node,Romania,Arad,g(n,g(n,g(n,h(n,≤ c(n,g(n,f(n,f(n,f(n,f(n,Timisoara,Zerind,AI,f(n,g(n,Romania,F,IDA,IDA,node,node,RBFS,RBFS,RBFS,Description Part,Pitesti,Sibiu,node,Arad 366,Sibiu,Timisoara 447,Zerind,Timisoara,Zerind,Arad,Sibiu,Oradea 671,Sibiu,Arad,Sibiu,Sibiu,Craiova 526,Sibiu 553,Sibiu,Sibiu,Pitesti,Sibiu 553,RBFS,node,Timisoara,h(n,RBFS,IDA,RBFS,SMA,MA*,SMA,RBFS,SMA,SMA,SMA,SMA,node,SMA,node,SMA,SMA,f(n,g(n,f(n,g(n,Eckerle et al.,node,node,node,node,g(n,Start,F,Goal,Start,Start,Goal,F,F,node F,Bidirectional,Start,node F,Goal,Start-A-F-Goal,F,f2,Start,•h2,Manhattan,Manhattan,N,N + 1 nodes,Korf,Reid,Rubik’s Cube,Start,Asterisk,Asterisk,Asterisk,Asterisk,Asterisk,Asterisk,Asterisk,Asterisk,Manhattan,≥,f(n,h(n,Manhattan,Y.,Y.,Manhattan,ABSOLVER,Prieditis,ABSOLVER,Rubik’s Cube,h(n,max{h1(n,h(n,Manhattan,Arad,Sibiu,Lugoj,Drobeta,Arad,Manhattan,Manhattan,Arad,Sibiu,Lugoj,Drobeta,Arad,L.,e. g.,node,the U. S.,Berkeley,California,NYU,New York,Sacramento,Manhattan,L,Romania,Romania,x1(n,x1(n,x1(n,h(n,g(n,h(n,f(n,g(n,h(n,SMA,AI,Newell,Simon,the Logic Theorist,Richard Bellman,Nils Nilsson,Slocum,Johnson,Story,Tait,the American Journal of Mathematics,The ‘15,Weekly News-Democrat,Emporia,Kansas,Sam Loyd,Loyd,Noyes Chapman,Canastota,New York,Ernest Kinsey,Ratner,Warmuth,NP,Rubik’s Cube,Ernő Rubik,Korf,IDA,Rokicki et al,Agostinelli,al,Monte Carlo,Rubik,Carl de Marcken,Robinson,Lawler,Karp,TSP,NP,Lin,Kernighan,Arora,LaPaugh,VLSI,Automatic,FREDDY,Michie,Bahubalendruni,Biswal,Dreyfus,Moore,Bellman and Dreyfus,Dijkstra’s,Dijkstra,Nilsson,Dijkstra,Nilsson,Barr,Feigenbaum,The Floyd–Warshall,Bellman-Ford,Ford,Slate,Atkin,Martelli’s,Bertram Raphael,Korf,Simon,Newell,Newell and Ernst,Lin,Doran,Michie,g(n,Hart,Nilsson,Raphael,Pearl,Pohl,Pearl,Gaschnig,Pearl,Korf,Reid,Nilsson,Helmert,Röger,Ebendt,Drechsler,Ruml,Ruml,Ruml,al,Felner,al,Eckerle et al,NBS,Chen et al.,Microsoft,Goldberg et al.,the United States,Korf,al,Anderson et al.,Korf,Knoblock,Lawler and Wood,Rayward-Smith,Kumar,Kanal,CDP,The Graph Traverser,Doran,Michie,Korf,RBFS,Bratko’s,Russell and Wefald,Chakrabarti,Simplified MA*,MA*,Khorsand,SMA,Korf,Zhang,Zhou,Hansen,Zhou,Hansen,Karp,TSP,MSTR,Prieditis,Samadi,Arfaee,Thayer et al.,Lelis,al.,Gasser,Culberson,Schaeffer,Korf and Felner (2002,Pearl,Hansson,Mayer,Pearl,Heuristics and Edelkamp and Schrödl’s,Heuristic Search,the International Conference on Automated Planning and Scheduling,ICAPS,AAAI,IJCAI,Artificial Intelligence and Journal,ACM,Ford,Floyd–Warshall,Zeno’s,node,node,node,h(n,f(n,g(n,Pearl,Chapters 8 and 11",,
chap4_para1,4,"SEARCH IN COMPLEX ENVIRONMENTS In which we relax the simplifying assumptions of the previous chapter, to get closer to the real world. Chapter 3 addressed problems in fully observable, deterministic, static, known environments where the solution is a sequence of actions. In this chapter, we relax those constraints. We begin with the problem of finding a good state without worrying about the path to get there, covering both discrete (Section 4. 1) and continuous (Section 4. 2) states. Then we relax the assumptions of determinism (Section 4. 3) and observability (Section 4. 4). In a nondeterministic world, the agent will need a conditional plan and carry out different actions depending on what it observes—for example, stopping if the light is red and going if it is green. With partial observability, the agent will also need to keep track of the possible states it might be in. Finally, Section 4. 5 guides the agent through an unknown space that it must learn as it goes, using online search. 4. 1Local Search and Optimization Problems In the search problems of Chapter 3 we wanted to find paths through the search space, such as a path from Arad to Bucharest. But sometimes we care only about the final state, not the path to get there. For example, in the 8-queens problem (Figure 4. 3), we care only about finding a valid final configuration of 8 queens (because if you know the configuration, it is trivial to reconstruct the steps that created it). This is also true for many important applications such as integrated-circuit design, factory floor layout, job shop scheduling, automatic programming, telecommunications network optimization, crop planning, and portfolio management. Local search algorithms operate by searching from a start state to neighboring states, without keeping track of the paths, nor the set of states that have been reached. That means they are not systematic—they might never explore a portion of the search space where a solution actually resides. However, they have two key advantages: (1) they use very little memory; and (2) they can often find reasonable solutions in large or infinite state spaces for which systematic algorithms are unsuitable. Local search algorithms can also solve optimization problems, in which the aim is to find the best state according to an objective function. To understand local search, consider the states of a problem laid out in a state-space landscape, as shown in Figure 4. 1. Each point (state) in the landscape has an “elevation, ” defined by the value of the objective function. If elevation corresponds to an objective function, then the aim is to find the highest peak—a global maximum—and we call the process hill climbing. If elevation corresponds to cost, then the aim is to find the lowest valley—a global minimum—and we call it gradient descent. Description The curve starts from the right of the origin and rises toward the upper right until a mid-left point, and remains horizontally constant for a small distance. The constant area is labeled shoulder. The curve further rises and forms a peak labeled global maximum. The curve further drops to its minimum, rises toward the upper right, and forms a small peak labeled local maximum. A point is marked on the rising path toward this peak and is labeled current state. The curve further drops and forms a trough, then again rises, and forms a flat peak, labeled ""flat"" local maximum. The curve then further drops toward the lower right and ends at the lower right of the graph. The heights of the peak decrease from global maximum to flat local maximum. Figure 4. 1A one-dimensional state-space landscape in which elevation corresponds to the objective function. The aim is to find the global maximum. 4. 1. 1Hill-climbing search The hill-climbing search algorithm is shown in Figure 4. 2. It keeps track of one current state and on each iteration moves to the neighboring state with highest value—that is, it heads in the direction that provides the steepest ascent. It terminates when it reaches a “peak” where no neighbor has a higher value. Hill climbing does not look ahead beyond the immediate neighbors of the current state. This resembles trying to find the top of Mount Everest in a thick fog while suffering from amnesia. Note that one way to use hill-climbing search is to use the negative of a heuristic cost function as the objective function; that will climb locally to the state with smallest heuristic distance to the goal. Description The chessboard positions are usually named in such a way that the columns are named from “a” to h, and the rows are named from 1 to 8. The queens are placed at the following positions. “a” 1, b 6, c 2, d 5, e 7, f 4, g 8, and h 3. Figure 4. 2The hill-climbing search algorithm, which is the most basic local search technique. At each step the current node is replaced by the best neighbor. To illustrate hill climbing, we will use the 8-queens problem (Figure 4. 3). We will use a complete-state formulation, which means that every state has all the components of a solution, but they might not all be in the right place. In this case every state has 8 queens on the board, one per column. The initial state is chosen at random, and the successors of a state are all possible states generated by moving a single queen to another square in the same column (so each state has 8 × 7 = 56 successors). The heuristic cost function h is the number of pairs of queens that are attacking each other; this will be zero only for solutions. (It counts as an attack if two pieces are in the same line, even if there is an intervening piece between them. ) Figure 4. 3(b) shows a state that has h = 17. The figure also shows the h values of all its successors. Description The board shows the value of h for each possible successor obtained by moving a queen within its column. The values on each row are as follows. Row 1: 14, 14, 13, 17, 12, 14, 12, 18. Row 2: 18, 14, queen, 15, 15, 14, queen, 16. Row 3: 17, queen, 16, 18, 15, queen, 15, queen. Row 4: queen, 14, 17, 15, queen, 14, 16, 16. Row 5: 15, 14, 14, queen, 13, 16, 13 16. Row 6: 14, 12, 18, 13, 15, 12, 14, 14. Row 7: 14, 16, 13, 15, 12, 14, 12, 16. Row 8: 18, 12, 14, 13, 13, 12, 14, 14. Figure 4. 3(a) The 8-queens problem: place 8 queens on a chess board so that no queen attacks another. (A queen attacks any piece in the same row, column, or diagonal. ) This position is almost a solution, except for the two queens in the fourth and seventh columns that attack each other along the diagonal. (b) An 8-queens state with heuristic cost estimate h = 17. The board shows the value of h for each possible successor obtained by moving a queen within its column. There are 8 moves that are tied for best, with h = 12. The hill-climbing algorithm will pick one of these. Hill climbing is sometimes called greedy local search because it grabs a good neighbor state without thinking ahead about where to go next. Although greed is considered one of the seven deadly sins, it turns out that greedy algorithms often perform quite well. Hill climbing can make rapid progress toward a solution because it is usually quite easy to improve a bad state. For example, from the state in Figure 4. 3(b), it takes just five steps to reach the state in Figure 4. 3(a), which has h = 1 and is very nearly a solution. Unfortunately, hill climbing can get stuck for any of the following reasons: •Local maxima: A local maximum is a peak that is higher than each of its neighboring states but lower than the global maximum. Hill-climbing algorithms that reach the vicinity of a local maximum will be drawn upward toward the peak but will then be stuck with nowhere else to go. Figure 4. 1 illustrates the problem schematically. More concretely, the state in Figure 4. 3(a) is a local maximum (i. e. , a local minimum for the cost h); every move of a single queen makes the situation worse. •Ridges: A ridge is shown in Figure 4. 4. Ridges result in a sequence of local maxima that is very difficult for greedy algorithms to navigate. •Plateaus: A plateau is a flat area of the state-space landscape. It can be a flat local maximum, from which no uphill exit exists, or a shoulder, from which progress is possible. (See Figure 4. 1. ) A hill-climbing search can get lost wandering on the plateau. Description From each of the local maxima, arrows point downward in either direction. The intersecting points are depicted by dark circles. Figure 4. 4Illustration of why ridges cause difficulties for hill climbing. The grid of states (dark circles) is superimposed on a ridge rising from left to right, creating a sequence of local maxima that are not directly connected to each other. From each local maximum, all the available actions point downhill. Topologies like this are common in low-dimensional state spaces, such as points in a two-dimensional plane. But in state spaces with hundreds or thousands of dimensions, this intuitive picture does not hold, and there are usually at least a few dimensions that make it possible to escape from ridges and plateaus. In each case, the algorithm reaches a point at which no progress is being made. Starting from a randomly generated 8-queens state, steepest-ascent hill climbing gets stuck 86% of the time, solving only 14% of problem instances. On the other hand, it works quickly, taking just 4 steps on average when it succeeds and 3 when it gets stuck—not bad for a state space with 88 ≈ 17 million states. How could we solve more problems? One answer is to keep going when we reach a plateau—to allow a sideways move in the hope that the plateau is really a shoulder, as shown in Figure 4. 1. But if we are actually on a flat local maximum, then this approach will wander on the plateau forever. Therefore, we can limit the number of consecutive sideways moves, stopping after, say, 100 consecutive sideways moves. This raises the percentage of problem instances solved by hill climbing from 14% to 94%. Success comes at a cost: the algorithm averages roughly 21 steps for each successful instance and 64 for each failure. Many variants of hill climbing have been invented. Stochastic hill climbing chooses at random from among the uphill moves; the probability of selection can vary with the steepness of the uphill move. This usually converges more slowly than steepest ascent, but in some state landscapes, it finds better solutions. First-choice hill climbing implements stochastic hill climbing by generating successors randomly until one is generated that is better than the current state. This is a good strategy when a state has many (e. g. , thousands) of successors. Another variant is random-restart hill climbing, which adopts the adage, “If at first you don’t succeed, try, try again. ” It conducts a series of hill-climbing searches from randomly generated initial states, until a goal is found. It is complete with probability 1, because it will eventually generate a goal state as the initial state. If each hill-climbing search has a probability p of success, then the expected number of restarts required is 1/p. For 8-queens instances with no sideways moves allowed, p ≈ 0. 14, so we need roughly 7 iterations to find a goal (6 failures and 1 success). The expected number of steps is the cost of one successful iteration plus (1 – p)/p times the cost of failure, or roughly 22 steps in all. When we allow sideways moves, 1/0. 94 ≈ 1. 06 iterations are needed on average and (1 × 21) + (0. 06/0. 94) × 64 ≈ 25 steps. For 8-queens, then, random-restart hill climbing is very effective indeed. Even for three million queens, the approach can find solutions in seconds. 1 The success of hill climbing depends very much on the shape of the state-space landscape: if there are few local maxima and plateaus, random-restart hill climbing will find a good solution very quickly. On the other hand, many real problems have a landscape that looks more like a widely scattered family of balding porcupines on a flat floor, with miniature porcupines living on the tip of each porcupine needle. NP-hard problems (see Appendix A) typically have an exponential number of local maxima to get stuck on. Despite this, a reasonably good local maximum can often be found after a small number of restarts. 4. 1. 2Simulated annealing A hill-climbing algorithm that never makes “downhill” moves toward states with lower value (or higher cost) is always vulnerable to getting stuck in a local maximum. In contrast, a purely random walk that moves to a successor state without concern for the value will eventually stumble upon the global maximum, but will be extremely inefficient. Therefore, it seems reasonable to try to combine hill climbing with a random walk in a way that yields both efficiency and completeness. Simulated annealing is such an algorithm. In metallurgy, annealing is the process used to temper or harden metals and glass by heating them to a high temperature and then gradually cooling them, thus allowing the material to reach a low-energy crystalline state. To explain simulated annealing, we switch our point of view from hill climbing to gradient descent (i. e. , minimizing cost) and imagine the task of getting a ping-pong ball into the deepest crevice in a very bumpy surface. If we just let the ball roll, it will come to rest at a local minimum. If we shake the surface, we can bounce the ball out of the local minimum—perhaps into a deeper local minimum, where it will spend more time. The trick is to shake just hard enough to bounce the ball out of local minima but not hard enough to dislodge it from the global minimum. The simulated-annealing solution is to start by shaking hard (i. e. , at a high temperature) and then gradually reduce the intensity of the shaking (i. e. , lower the temperature). The overall structure of the simulated-annealing algorithm (Figure 4. 5) is similar to hill climbing. Instead of picking the best move, however, it picks a random move. If the move improves the situation, it is always accepted. Otherwise, the algorithm accepts the move with some probability less than 1. The probability decreases exponentially with the “badness” of the move—the amount ∆E by which the evaluation is worsened. The probability also decreases as the “temperature” T goes down: “bad” moves are more likely to be allowed at the start when T is high, and they become more unlikely as T decreases. If the schedule lowers T to 0 slowly enough, then a property of the Boltzmann distribution, e∆E/T, is that all the probability is concentrated on the global maxima, which the algorithm will find with probability approaching 1. Description The genetic algorithm is represented by four sets of blocks, each having four rows of blocks. Each block consists of a real number. Part (“a”) to Part (d) is labeled Initial population, Fitness function, Selection, Cross over, and Mutation. The four 8-digit strings on the initial population blocks are as follows. 24748552, 32752411, 24415124, and 32543213. Selection. The numbers labeled on the selection blocks are as follows, 32752411, 24748552, 32752411, and 24415124. blocks 32752411 and 32752411 are shaded in brown, and the others in blue. Each block is divided into two pairs as follows. First block: 327 and 52411. Second block: 247 and 48552. Third block: 32752 and 411. Fourth block: 24415 and 124. Arrows labeled with a real number and the corresponding percentage depict the ranking by a fitness function. An arrow labeled 24, 31 percent from 24748552 in the initial population set points to a block labeled 24748552 in the selection set. An arrow labeled 23, 29 percent from 32752411 in the initial population set points to 32752411 in the selection set. An arrow labeled 20, 26 percent from 32752411 in the initial population set points to 32752411 in the selection set. An arrow labeled 11, 14 percent from 24415124 in the initial population set points to 24415124 in the selection set. The next section is labeled crossover. The numbers labeled on the cross over section blocks are as follows. 32748552, 24752411, 32752124, and 24415411. Arrows from blocks 32752411 and 24748552 in the selection set point to blocks 32748552, and 24752411 in the crossover set. Arrows from blocks 32752411 and 24415124 in the selection set point to blocks 32752124, and 24415411 in the crossover set. Each block is divided into two pairs as follows. First block: 327 and 48552. Second block: 247 and 52411. Third block: 32752 and 124. Fourth block: 24415 and 411. The numbers labeled on the mutation set blocks are as follows. 32748152 (1 highlighted), 24752411, 32752124 (2 highlighted), and 24415417 (7 highlighted). An arrow from block 32748552 in the crossover set points to the block labeled 32748152 in the mutation set. An arrow from block 24752411 in the crossover set points to the block labeled 24752411 in the mutation set. An arrow from block 32752124 in the crossover set points to the block labeled 32252124 in the mutation set. An arrow from block 24415411 in the crossover set points to the block labeled 24415417 in the mutation set. Figure 4. 5The simulated annealing algorithm, a version of stochastic hill climbing where some downhill moves are allowed. The schedule input determines the value of the “temperature” T as a function of time. Simulated annealing was used to solve VLSI layout problems beginning in the 1980s. It has been applied widely to factory scheduling and other large-scale optimization tasks. 4. 1. 3Local beam search Keeping just one node in memory might seem to be an extreme reaction to the problem of memory limitations. The local beam search algorithm keeps track of k states rather than just one. It begins with k randomly generated states. At each step, all the successors of all k states are generated. If any one is a goal, the algorithm halts. Otherwise, it selects the k best successors from the complete list and repeats. At first sight, a local beam search with k states might seem to be nothing more than running k random restarts in parallel instead of in sequence. In fact, the two algorithms are quite different. In a random-restart search, each search process runs independently of the others. In a local beam search, useful information is passed among the parallel search threads. In effect, the states that generate the best successors say to the others, “Come over here, the grass is greener! ” The algorithm quickly abandons unfruitful searches and moves its resources to where the most progress is being made. Local beam search can suffer from a lack of diversity among the k states—they can become clustered in a small region of the state space, making the search little more than a k-times-slower version of hill climbing. A variant called stochastic beam search, analogous to stochastic hill climbing, helps alleviate this problem. Instead of choosing the top k successors, stochastic beam search chooses successors with probability proportional to the successor’s value, thus increasing diversity. 4. 1. 4Evolutionary algorithms Evolutionary algorithms can be seen as variants of stochastic beam search that are explicitly motivated by the metaphor of natural selection in biology: there is a population of individuals (states), in which the fittest (highest value) individuals produce offspring (successor states) that populate the next generation, a process called recombination. There are endless forms of evolutionary algorithms, varying in the following ways: •The size of the population. •The representation of each individual. In genetic algorithms, each individual is a string over a finite alphabet (often a Boolean string), just as DNA is a string over the alphabet ACGT. In evolution strategies, an individual is a sequence of real numbers, and in genetic programming an individual is a computer program. •The mixing number, ρ, which is the number of parents that come together to form offspring. The most common case is ρ = 2: two parents combine their “genes” (parts of their representation) to form offspring. When ρ = 1 we have stochastic beam search (which can be seen as asexual reproduction). It is possible to have ρ > 2, which occurs only rarely in nature but is easy enough to simulate on computers. •The selection process for selecting the individuals who will become the parents of the next generation: one possibility is to select from all individuals with probability proportional to their fitness score. Another possibility is to randomly select n individuals (n > ρ), and then select the ρ most fit ones as parents. •The recombination procedure. One common approach (assuming ρ = 2), is to randomly select a crossover point to split each of the parent strings, and recombine the parts to form two children, one with the first part of parent 1 and the second part of parent 2; the other with the second part of parent 1 and the first part of parent 2. •The mutation rate, which determines how often offspring have random mutations to their representation. Once an offspring has been generated, every bit in its composition is flipped with probability equal to the mutation rate. •The makeup of the next generation. This can be just the newly formed offspring, or it can include a few top-scoring parents from the previous generation (a practice called elitism, which guarantees that overall fitness will never decrease over time). The practice of culling, in which all individuals below a given threshold are discarded, can lead to a speedup (Baum et al. , 1995). Figure 4. 6(a) shows a population of four 8-digit strings, each representing a state of the 8-queens puzzle: the c-th digit represents the row number of the queen in column c. In (b), each state is rated by the fitness function. Higher fitness values are better, so for the 8-queens problem we use the number of nonattacking pairs of queens, which has a value of 8 × 7/2 = 28 for a solution. The values of the four states in (b) are 24, 23, 20, and 11. The fitness scores are then normalized to probabilities, and the resulting values are shown next to the fitness values in (b). Description The first two chessboard arrangements are added up to form the third, which depicts the three steps of recombination. In the first step, the queens are positioned at G 1, H 1, B 2, E 2, “a” 3, F 4, D 5, and C 7. The first three columns are shaded in red, which are retained in the cross over step, and the next five columns are shaded in green which are lost. In the second step, the queens are positioned at “a” 2, H 2, B 4, D 4, F 5, G 5, C 7, and E 8. The first three columns are shaded in green, that are lost in the cross over step, and the next five columns are shaded in red and retained. In the last step, the queens are arranged at B 2, H 2, “a” 3, D 4, F 5, G 5, C 7, and E 8. All the columns are retained after the crossover step. Figure 4. 6A genetic algorithm, illustrated for digit strings representing 8-queens states. The initial population in (a) is ranked by a fitness function in (b) resulting in pairs for mating in (c). They produce offspring in (d), which are subject to mutation in (e). In (c), two pairs of parents are selected, in accordance with the probabilities in (b). Notice that one individual is selected twice and one not at all. For each selected pair, a crossover point (dotted line) is chosen randomly. In (d), we cross over the parent strings at the crossover points, yielding new offspring. For example, the first child of the first pair gets the first three digits (327) from the first parent and the remaining digits (48552) from the second parent. The 8-queens states involved in this recombination step are shown in Figure 4. 7. Description Two squares are marked at each stage depicting the left and right sides. State 1: Dirts are at the left and right squares. The vacuum cleaner is cleaning the dirt on the left square. State 2: Dirts are at the left and right squares. The vacuum cleaner is cleaning the dirt on the right square. State 3: Dirt is on the left square. The vacuum cleaner is cleaning the dirt on the left square. The right square is clean. State 4: Dirt is on the left square. The vacuum cleaner is on the right square with no dirt. State 5: Dirt is on the right square. The vacuum cleaner is in the clean left square. State 6: Dirt is on the right square. The vacuum cleaner is on the right square. The left square is clean. State 7: Both the squares are clean. The vacuum cleaner is on the left square. State 8: Both the squares are clean. The vacuum cleaner is on the right square. Figure 4. 7The 8-queens states corresponding to the first two parents in Figure 4. 6(c) and the first offspring in Figure 4. 6(d). The green columns are lost in the crossover step and the red columns are retained. (To interpret the numbers in Figure 4. 6: row 1 is the bottom row, and 8 is the top row. ) Finally, in (e), each location in each string is subject to random mutation with a small independent probability. One digit was mutated in the first, third, and fourth offspring. In the 8-queens problem, this corresponds to choosing a queen at random and moving it to a random square in its column. It is often the case that the population is diverse early on in the process, so crossover frequently takes large steps in the state space early in the search process (as in simulated annealing). After many generations of selection towards higher fitness, the population becomes less diverse, and smaller steps are typical. Figure 4. 8 describes an algorithm that implements all these steps. Description A bold arrow labeled suck and an arrow labeled Right from the first state of the vacuum world point to the first two circular nodes. Two bold arrows from the first circular node with an arc point to states 7 and 5 of the vacuum world. State 7 is labeled Goal. An arrow from the second circular node on the right points to state 2 of the vacuum world. A bold arrow labeled Right, and a light arrow labeled suck points to the third and the fourth circular nodes. Arrows labeled left and suck from state 2 points to the fifth and the sixth nodes. Arrows from the third node with an arc point to states 5 and 1 labeled Loop. A bold arrow from the fourth node points to state 6 of the vacuum world. An arrow from the fifth node points to state 1 of vacuum world labeled Loop. Two arrows from the sixth node with an arc point to states 8 and 4 of the vacuum world. State 8 is labeled Goal. Two bold arrows from state 4 points outward. A bold arrow labeled Suck, and a light arrow labeled Left from state 6 points to the seventh and eighth nodes. A bold arrow from the seventh node points to state 8 labeled goal state. A light arrow from the eighth node points to state 5 labeled Loop. Figure 4. 8A genetic algorithm. Within the function, population is an ordered list of individuals, weights is a list of corresponding fitness values for each individual, and fitness is a function to compute these values. Genetic algorithms are similar to stochastic beam search, but with the addition of the crossover operation. This is advantageous if there are blocks that perform useful functions. For example, it could be that putting the first three queens in positions 2, 4, and 6 (where they do not attack each other) constitutes a useful block that can be combined with other useful blocks that appear in other individuals to construct a solution. It can be shown mathematically that, if the blocks do not serve a purpose—for example if the positions of the genetic code are randomly permuted—then crossover conveys no advantage. The theory of genetic algorithms explains how this works using the idea of a schema, which is a substring in which some of the positions can be left unspecified. For example, the schema 246***** describes all 8-queens states in which the first three queens are in positions 2, 4, and 6, respectively. Strings that match the schema (such as 24613578) are called instances of the schema. It can be shown that if the average fitness of the instances of a schema is above the mean, then the number of instances of the schema will grow over time. Evolution and Search The theory of evolution was developed by Charles Darwin in On the Origin of Species by Means of Natural Selection (1859) and independently by Alfred Russel Wallace (1858). The central idea is simple: variations occur in reproduction and will be preserved in successive generations approximately in proportion to their effect on reproductive fitness. Darwin’s theory was developed with no knowledge of how the traits of organisms can be inherited and modified. The probabilistic laws governing these processes were first identified by Gregor Mendel (1866), a monk who experimented with sweet peas. Much later, Watson and Crick (1953) identified the structure of the DNA molecule and its alphabet, AGTC (adenine, guanine, thymine, cytosine). In the standard model, variation occurs both by point mutations in the letter sequence and by “crossover” (in which the DNA of an offspring is generated by combining long sections of DNA from each parent). The analogy to local search algorithms has already been described; the principal difference between stochastic beam search and evolution is the use of sexual reproduction, wherein successors are generated from multiple individuals rather than just one. The actual mechanisms of evolution are, however, far richer than most genetic algorithms allow. For example, mutations can involve reversals, duplications, and movement of large chunks of DNA; some viruses borrow DNA from one organism and insert it into another; and there are transposable genes that do nothing but copy themselves many thousands of times within the genome. There are even genes that poison cells from potential mates that do not carry the gene, thereby increasing their own chances of replication. Most important is the fact that the genes themselves encode the mechanisms whereby the genome is reproduced and translated into an organism. In genetic algorithms, those mechanisms are a separate program that is not represented within the strings being manipulated. Darwinian evolution may appear inefficient, having generated blindly some 1043 or so organisms without improving its search heuristics one iota. But learning does play a role in evolution. Although the otherwise great French naturalist Jean Lamarck (1809) was wrong to propose that traits acquired by adaptation during an organism’s lifetime would be passed on to its offspring, James Baldwin’s (1896) superficially similar theory is correct: learning can effectively relax the fitness landscape, leading to an acceleration in the rate of evolution. An organism that has a trait that is not quite adaptive for its environment will pass on the trait if it also has enough plasticity to learn to adapt to the environment in a way that is beneficial. Computer simulations (Hinton and Nowlan, 1987) confirm that this Baldwin effect is real, and that a consequence is that things that are hard to learn end up in the genome, but things that are easy to learn need not reside there (Morgan and Griffiths, 2015). Clearly, this effect is unlikely to be significant if adjacent bits are totally unrelated to each other, because then there will be few contiguous blocks that provide a consistent benefit. Genetic algorithms work best when schemas correspond to meaningful components of a solution. For example, if the string is a representation of an antenna, then the schemas may represent components of the antenna, such as reflectors and deflectors. A good component is likely to be good in a variety of different designs. This suggests that successful use of genetic algorithms requires careful engineering of the representation. In practice, genetic algorithms have their place within the broad landscape of optimization methods (Marler and Arora, 2004), particularly for complex structured problems such as circuit layout or job-shop scheduling, and more recently for evolving the architecture of deep neural networks (Miikkulainen et al. , 2019). It is not clear how much of the appeal of genetic algorithms arises from their superiority on specific tasks, and how much from the appealing metaphor of evolution. 4. 2Local Search in Continuous Spaces In Chapter 2, we explained the distinction between discrete and continuous environments, pointing out that most real-world environments are continuous. A continuous action space has an infinite branching factor, and thus can’t be handled by most of the algorithms we have covered so far (with the exception of first-choice hill climbing and simulated annealing). This section provides a very brief introduction to some local search techniques for continuous spaces. The literature on this topic is vast; many of the basic techniques originated in the 17th century, after the development of calculus by Newton and Leibniz. 2 We find uses for these techniques in several places in this book, including the chapters on learning, vision, and robotics. We begin with an example. Suppose we want to place three new airports anywhere in Romania, such that the sum of squared straight-line distances from each city on the map to its nearest airport is minimized. (See Figure 3. 1 for the map of Romania. ) The state space is then defined by the coordinates of the three airports: (x1, y1), (x2, y2), and (x3, y3). This is a six-dimensional space; we also say that states are defined by six variables. In general, states are defined by an n-dimensional vector of variables, x. Moving around in this space corresponds to moving one or more of the airports on the map. The objective function f(x) = f(x1, y1, x2, y2, x3, y3) is relatively easy to compute for any particular state once we compute the closest cities. Let Ci be the set of cities whose closest airport (in the state x) is airport i. Then, we have This equation is correct not only for the state x but also for states in the local neighborhood of x. However, it is not correct globally; if we stray too far from x (by altering the location of one or more of the airports by a large amount) then the set of closest cities for that airport changes, and we need to recompute Ci. One way to deal with a continuous state space is to discretize it. For example, instead of allowing the (xi, yi) locations to be any point in continuous two-dimensional space, we could limit them to fixed points on a rectangular grid with spacing of size δ (delta). Then instead of having an infinite number of successors, each state in the space would have only 12 successors, corresponding to incrementing one of the 6 variables by ±δ. We can then apply any of our local search algorithms to this discrete space. Alternatively, we could make the branching factor finite by sampling successor states randomly, moving in a random direction by a small amount, δ. Methods that measure progress by the change in the value of the objective function between two nearby points are called empirical gradient methods. Empirical gradient search is the same as steepest-ascent hill climbing in a discretized version of the state space. Reducing the value of δ over time can give a more accurate solution, but does not necessarily converge to a global optimum in the limit. Often we have an objective function expressed in a mathematical form such that we can use calculus to solve the problem analytically rather than empirically. Many methods attempt to use the gradient of the landscape to find a maximum. The gradient of the objective function is a vector ∇f that gives the magnitude and direction of the steepest slope. For our problem, we have In some cases, we can find a maximum by solving the equation ∇f = 0. (This could be done, for example, if we were placing just one airport; the solution is the arithmetic mean of all the cities’ coordinates. ) In many cases, however, this equation cannot be solved in closed form. For example, with three airports, the expression for the gradient depends on what cities are closest to each airport in the current state. This means we can compute the gradient locally (but not globally); for example, Given a locally correct expression for the gradient, we can perform steepest-ascent hill climbing by updating the current state according to the formula where α (alpha) is a small constant often called the step size. There exist a huge variety of methods for adjusting α. The basic problem is that if α is too small, too many steps are needed; if α is too large, the search could overshoot the maximum. The technique of line search tries to overcome this dilemma by extending the current gradient direction—usually by repeatedly doubling α—until f starts to decrease again. The point at which this occurs becomes the new current state. There are several schools of thought about how the new direction should be chosen at this point. For many problems, the most effective algorithm is the venerable Newton–Raphson method. This is a general technique for finding roots of functions—that is, solving equations of the form g(x) = 0. It works by computing a new estimate for the root x according to Newton’s formula To find a maximum or minimum of f, we need to find x such that the gradient is a zero vector (i. e. , ∇f(x) = 0). Thus, g(x) in Newton’s formula becomes ∇f(x), and the update equation can be written in matrix–vector form as where Hf (x) is the Hessian matrix of second derivatives, whose elements Hij are given by ∂2f/∂xi∂xj. For our airport example, we can see from Equation (4. 2) that Hf (x) is particularly simple: the off-diagonal elements are zero and the diagonal elements for airport i are just twice the number of cities in Ci. A moment’s calculation shows that one step of the update moves airport i directly to the centroid of Ci, which is the minimum of the local expression for f from Equation (4. 1). 3 For high-dimensional problems, however, computing the n2 entries of the Hessian and inverting it may be expensive, so many approximate versions of the Newton–Raphson method have been developed. Local search methods suffer from local maxima, ridges, and plateaus in continuous state spaces just as much as in discrete spaces. Random restarts and simulated annealing are often helpful. High-dimensional continuous spaces are, however, big places in which it is very easy to get lost. A final topic is constrained optimization. An optimization problem is constrained if solutions must satisfy some hard constraints on the values of the variables. For example, in our airport-siting problem, we might constrain sites to be inside Romania and on dry land (rather than in the middle of lakes). The difficulty of constrained optimization problems depends on the nature of the constraints and the objective function. The best-known category is that of linear programming problems, in which constraints must be linear inequalities forming a convex set4 and the objective function is also linear. The time complexity of linear programming is polynomial in the number of variables. Linear programming is probably the most widely studied and broadly useful method for optimization. It is a special case of the more general problem of convex optimization, which allows the constraint region to be any convex region and the objective to be any function that is convex within the constraint region. Under certain conditions, convex optimization problems are also polynomially solvable and may be feasible in practice with thousands of variables. Several important problems in machine learning and control theory can be formulated as convex optimization problems (see Chapter 21). 4. 3Search with Nondeterministic Actions In Chapter 3, we assumed a fully observable, deterministic, known environment. Therefore, an agent can observe the initial state, calculate a sequence of actions that reach the goal, and execute the actions with its “eyes closed, ” never having to use its percepts. When the environment is partially observable, however, the agent doesn’t know for sure what state it is in; and when the environment is nondeterministic, the agent doesn’t know what state it transitions to after taking an action. That means that rather than thinking “I’m in state s1 and if I do action a I’ll end up in state s2, ” an agent will now be thinking “I’m either in state s1 or s3, and if I do action a I’ll end up in state s2, s4 or s5. ” We call a set of physical states that the agent believes are possible a belief state. In partially observable and nondeterministic environments, the solution to a problem is no longer a sequence, but rather a conditional plan (sometimes called a contingency plan or a strategy) that specifies what to do depending on what percepts agent receives while executing the plan. We examine nondeterminism in this section and partial observability in the next. 4. 3. 1The erratic vacuum world The vacuum world from Chapter 2 has eight states, as shown in Figure 4. 9. There are three actions—Right, Left, and Suck—and the goal is to clean up all the dirt (states 7 and 8). If the environment is fully observable, deterministic, and completely known, then the problem is easy to solve with any of the algorithms in Chapter 3, and the solution is an action sequence. For example, if the initial state is 1, then the action sequence [Suck, Right, Suck] will reach a goal state, 8. Description A bold arrow labeled suck and another arrow labeled Right from the first state of the vacuum world point to the first two circular nodes. An arrow from the second node on the right with an arc points back to state 1 and another arrow points to state 2 of the vacuum world. Two bold arrows from state 2 points outward. A bold arrow from the first node points to state 5 of the vacuum world. A bold arrow labeled Right, from state 5, points to the third node with an arc. A bold arrow from the third node points back to state 5. Another bold arrow from the third node points to state 6 of the vacuum world. Two arrows from state 6 points outward. Figure 4. 9The eight possible states of the vacuum world; states 7 and 8 are goal states. Now suppose that we introduce nondeterminism in the form of a powerful but erratic vacuum cleaner. In the erratic vacuum world, the Suck action works as follows: •When applied to a dirty square the action cleans the square and sometimes cleans up dirt in an adjacent square, too. •When applied to a clean square the action sometimes deposits dirt on the carpet. 5 To provide a precise formulation of this problem, we need to generalize the notion of a transition model from Chapter 3. Instead of defining the transition model by a RESULT function that returns a single outcome state, we use a RESULTS function that returns a set of possible outcome states. For example, in the erratic vacuum world, the Suck action in state 1 cleans up either just the current location, or both locations: If we start in state 1, no single sequence of actions solves the problem, but the following conditional plan does: Here we see that a conditional plan can contain if–then–else steps; this means that solutions are trees rather than sequences. Here the conditional in the if statement tests to see what the current state is; this is something the agent will be able to observe at runtime, but doesn’t know at planning time. Alternatively, we could have had a formulation that tests the percept rather than the state. Many problems in the real, physical world are contingency problems, because exact prediction of the future is impossible. For this reason, many people keep their eyes open while walking around. 4. 3. 2AND–OR search trees How do we find these contingent solutions to nondeterministic problems? As in Chapter 3, we begin by constructing search trees, but here the trees have a different character. In a deterministic environment, the only branching is introduced by the agent’s own choices in each state: I can do this action or that action. We call these nodes OR nodes. In the vacuum world, for example, at an OR node the agent chooses Left or Right or Suck. In a nondeterministic environment, branching is also introduced by the environment’s choice of outcome for each action. We call these nodes AND nodes. For example, the Suck action in state 1 results in the belief state {5, 7}, so the agent would need to find a plan for state 5 and for state 7. These two kinds of nodes alternate, leading to an AND-OR tree as illustrated in Figure 4. 10. Description The belief states are depicted by circular sections enclosing the vacuum world states. Part (“a”): State 1 and 3 of the vacuum world are enclosed in a single section and states 2 and 4 of the vacuum world are enclosed in another section. An arrow from state 1 points to state 2 and an arrow from state 3 points to state 4 of the vacuum world. Part (b): State 1 and state 3 of the vacuum world are enclosed in a single section. State 1, 2, 3, and 4 of the vacuum world are enclosed in another section. Two arrows from state 1 in the first section point to states 1 and 2 in the second section. Two arrows from state 3 of the first section point to states 3 and 4 of the second section. Figure 4. 10The first two levels of the search tree for the erratic vacuum world. State nodes are OR nodes where some action must be chosen. At the AND nodes, shown as circles, every outcome must be handled, as indicated by the arc linking the outgoing branches. The solution found is shown in bold lines. A solution for an AND–OR search problem is a subtree of the complete search tree that (1) has a goal node at every leaf, (2) specifies one action at each of its OR nodes, and (3) includes every outcome branch at each of its AND nodes. The solution is shown in bold lines in the figure; it corresponds to the plan given in Equation (4. 3). Figure 4. 11 gives a recursive, depth-first algorithm for AND–OR graph search. One key aspect of the algorithm is the way in which it deals with cycles, which often arise in nondeterministic problems (e. g. , if an action sometimes has no effect or if an unintended effect can be corrected). If the current state is identical to a state on the path from the root, then it returns with failure. This doesn’t mean that there is no solution from the current state; it simply means that if there is a noncyclic solution, it must be reachable from the earlier incarnation of the current state, so the new incarnation can be discarded. With this check, we ensure that the algorithm terminates in every finite state space, because every path must reach a goal, a dead end, or a repeated state. Notice that the algorithm does not check whether the current state is a repetition of a state on some other path from the root, which is important for efficiency. Description Each of the belief state spaces is depicted by rectangular boxes with states of vacuum world inscribed within the box. The initial belief state is at the top center with states 1 to 8 of the vacuum world states. An arrow labeled L from the initial belief state points to a belief state on the left which has states 1, 3, 5, and 7. An arrow labeled R from the initial belief state points to a third belief state on the right which has states 2, 4, 6, and 8. An arrow labeled R from the second belief state points to the third and an arrow labeled L from the third belief state points to the second belief state. An arrow labeled S from the initial belief state points to a fourth belief state below, which has states 4, 5, 7, and 8. Arrows labeled L and R from the fourth belief state point to the fifth and sixth belief states that have 5, 3, 7, and 6, 4, 8 vacuum world states, respectively. An arrow labeled L from the sixth belief state points to the fifth, and an arrow labeled R from the fifth belief state points to the sixth. Arrows labeled S from the fifth and the second belief states point to the seventh belief state, which has the states 5 and 7. Arrows labeled S from the sixth and the third belief states point to the eighth belief state, which has 4 and 8 vacuum world states in it. An arrow labeled L from the eighth belief state points to the ninth belief state which has 3 and 7 vacuum world states in it. An arrow labeled R from the ninth belief state points to the eighth belief state. An arrow labeled S from the ninth belief state points to the tenth which has state 7. An arrow labeled R from the tenth belief state points to the eleventh, which has state 8 in it. An arrow labeled L from the eleventh belief state points back to the tenth. An arrow labeled S from the twelfth belief state points to the eleventh, and an arrow labeled L from the twelfth belief state points to the seventh belief state. An arrow labeled R from the seventh belief state points to the twelfth belief state. The twelfth belief state has the vacuum world states 6 and 8 in it. Figure 4. 11An algorithm for searching AND-OR graphs generated by nondeterministic environments. A solution is a conditional plan that considers every nondeterministic outcome and makes a plan for each one. AND-OR graphs can be explored either breadth-first or best-first. The concept of a heuristic function must be modified to estimate the cost of a contingent solution rather than a sequence, but the notion of admissibility carries over and there is an analog of the A* algorithm for finding optimal solutions. (See the bibliographical notes at the end of the chapter. ) 4. 3. 3Try, try again Consider a slippery vacuum world, which is identical to the ordinary (non-erratic) vacuum world except that movement actions sometimes fail, leaving the agent in the same location. For example, moving Right in state 1 leads to the belief state {1, 2}. Figure 4. 12 shows part of the search graph; clearly, there are no longer any acyclic solutions from state 1, and AND-OR-SEARCH would return with failure. There is, however, a cyclic solution, which is to keep trying Right until it works. We can express this with a new while construct: Description The belief states are depicted by circular shapes, and the vacuum world states are depicted by square blocks with the corresponding state labeled on them. Example “a”, Deterministic world: Vacuum world states 1 and 3 are included in the first belief state. An arrow labeled R from state 1 of the first belief state points to state 2 of the second belief state. An arrow from state 3 of the first belief state points to the vacuum world state 4 of the second belief state. An arrow labeled open square bracket B, Dirty close square bracket, points to the vacuum world state 2 of the third belief state. An arrow labeled open square bracket B, Clean close square bracket, from the vacuum world state 4 of the second belief state points to the vacuum world state 4 of the fourth belief state. Example b, Slippery world: An arrow from the vacuum world state 1 of the first belief state points to the vacuum world state 2 and 1 of the second belief state. An arrow from the vacuum world state 3 of the first belief state points to the vacuum world state 3 and 4 of the second belief state. An arrow labeled open square bracket B, Dirty close square bracket, from the vacuum world state 2 of the second belief state points to the vacuum world state 2 of the third belief state. An arrow from the vacuum world state 1 and 3 of the second belief state points to the vacuum world state 1 and 3 of the fourth belief state. An arrow from the vacuum world state 4 of the second belief state points to the vacuum world state 4 of the fifth belief state. Figure 4. 12Part of the search graph for a slippery vacuum world, where we have shown (some) cycles explicitly. All solutions for this problem are cyclic plans because there is no way to move reliably. or by adding a label to denote some portion of the plan and referring to that label later: When is a cyclic plan a solution? A minimum condition is that every leaf is a goal state and that a leaf is reachable from every point in the plan. In addition to that, we need to consider the cause of the nondeterminism. If it is really the case that the vacuum robot’s drive mechanism works some of the time, but randomly and independently slips on other occasions, then the agent can be confident that if the action is repeated enough times, eventually it will work and the plan will succeed. But if the nondeterminism is due to some unobserved fact about the robot or environment—perhaps a drive belt has snapped and the robot will never move—then repeating the action will not help. One way to understand this decision is to say that the initial problem formulation (fully observable, nondeterministic) is abandoned in favor of a different formulation (partially observable, deterministic) where the failure of the cyclic plan is attributed to an unobserved property of the drive belt. In Chapter 12 we discuss how to decide which of several uncertain possibilities is more likely. 4. 4Search in Partially Observable Environments We now turn to the problem of partial observability, where the agent’s percepts are not enough to pin down the exact state. That means that some of the agent’s actions will be aimed at reducing uncertainty about the current state. 4. 4. 1Searching with no observation When the agent’s percepts provide no information at all, we have what is called a sensorless problem (or a conformant problem). At first, you might think the sensorless agent has no hope of solving a problem if it has no idea what state it starts in, but sensorless solutions are surprisingly common and useful, primarily because they don’t rely on sensors working properly. In manufacturing systems, for example, many ingenious methods have been developed for orienting parts correctly from an unknown initial position by using a sequence of actions with no sensing at all. Sometimes a sensorless plan is better even when a conditional plan with sensing is available. For example, doctors often prescribe a broad-spectrum antibiotic rather than using the conditional plan of doing a blood test, then waiting for the results to come back, and then prescribing a more specific antibiotic. The sensorless plan saves time and money, and avoids the risk of the infection worsening before the test results are available. Consider a sensorless version of the (deterministic) vacuum world. Assume that the agent knows the geography of its world, but not its own location or the distribution of dirt. In that case, its initial belief state is {1, 2, 3, 4, 5, 6, 7, 8} (see Figure 4. 9). Now, if the agent moves Right it will be in one of the states {2, 4, 6, 8}—the agent has gained information without perceiving anything! After [Right, Suck] the agent will always end up in one of the states {4, 8}. Finally, after [Right, Suck, Left, Suck] the agent is guaranteed to reach the goal state 7, no matter what the start state. We say that the agent can coerce the world into state 7. The solution to a sensorless problem is a sequence of actions, not a conditional plan (because there is no perceiving). But we search in the space of belief states rather than physical states. 6 In belief-state space, the problem is fully observable because the agent always knows its own belief state. Furthermore, the solution (if any) for a sensorless problem is always a sequence of actions. This is because, as in the ordinary problems of Chapter 3, the percepts received after each action are completely predictable—they’re always empty! So there are no contingencies to plan for. This is true even if the environment is nondeterministic. We could introduce new algorithms for sensorless search problems. But instead, we can use the existing algorithms from Chapter 3 if we transform the underlying physical problem into a belief-state problem, in which we search over belief states rather than physical states. The original problem, P, has components ActionsP, ResultP etc. , and the belief-state problem has the following components: •States: The belief-state space contains every possible subset of the physical states. If P has N states, then the belief-state problem has 2N belief states, although many of those may be unreachable from the initial state. •Initial state: Typically the belief state consisting of all states in P, although in some cases the agent will have more knowledge than this. •Actions: This is slightly tricky. Suppose the agent is in belief state b = {s1, s2}, but ACTIONSP(s1) ≠ ACTIONSP(s2); then the agent is unsure of which actions are legal. If we assume that illegal actions have no effect on the environment, then it is safe to take the union of all the actions in any of the physical states in the current belief state b: On the other hand, if an illegal action might lead to catastrophe, it is safer to allow only the intersection, that is, the set of actions legal in all the states. For the vacuum world, every state has the same legal actions, so both methods give the same result. •Transition model: For deterministic actions, the new belief state has one result state for each of the current possible states (although some result states may be the same): With nondeterminism, the new belief state consists of all the possible results of applying the action to any of the states in the current belief state: The size of bʹ will be the same or smaller than b for deterministic actions, but may be larger than b with nondeterministic actions (see Figure 4. 13). Description The belief states are depicted by circular sections enclosing the vacuum world states that are depicted by square blocks with corresponding states labeled on them. A bold arrow labeled suck from the first belief state, which includes vacuum world states 1 and 3, points to the first node. A bold arrow labeled open square bracket ""A"", clean close square bracket points to the second belief state, which has 5 and 7 vacuum world states. An arrow labeled right from the first belief state points to a second node with an arc. An arrow labeled open square bracket B, Dirty close square bracket, from the second node points to a third belief state which has singleton vacuum world state 2. An arrow labeled open square bracket B, clean close square bracket, from the second node points to a third belief state which has singleton vacuum world state 4. Figure 4. 13(a) Predicting the next belief state for the sensorless vacuum world with the deterministic action, Right. (b) Prediction for the same belief state and action in the slippery version of the sensorless vacuum world. •Goal test: The agent possibly achieves the goal if any state s in the belief state satisfies the goal test of the underlying problem, IS-GOALP(s). The agent necessarily achieves the goal if every state satisfies IS-GOALP(s). We aim to necessarily achieve the goal. •Action cost: This is also tricky. If the same action can have different costs in different states, then the cost of taking an action in a given belief state could be one of several values. (This gives rise to a new class of problems, which we explore in Exercise 4. MVAL. ) For now we assume that the cost of an action is the same in all states and so can be transferred directly from the underlying physical problem. Figure 4. 14 shows the reachable belief-state space for the deterministic, sensorless vacuum world. There are only 12 reachable belief states out of 28 = 256 possible belief states. Description The belief states are depicted by circular sections, and the vacuum world states are depicted by square blocks with corresponding states labeled in them. Five belief states are shown. The transmission from one belief state to the next is labeled in the order Suck, Open square bracket ""A"", clean close square bracket, Right, and Open square bracket B, Dirty close square bracket. An arrow from the vacuum world state 1 of the first belief state points to the vacuum world state 5 of the second belief state. Two arrows from the vacuum world state 3 of the first belief state point to the vacuum world states 5 and 7 of the second belief state. Arrows from the vacuum world states 5 and 7 of the second belief state point to the vacuum world state 5 and 7 of the third belief state. Two arrows from the vacuum world state 5 of the third belief state point to the vacuum world state 2 and 6 of the fourth belief state. Four arrows from the vacuum world state 7 of the third belief state point to the vacuum world states 2, 6, 4, and 8 of the fourth belief state. Arrows from the vacuum world state 2 and 6 of the fourth belief state together point to the vacuum world state 2 of the fifth belief state. Figure 4. 14The reachable portion of the belief-state space for the deterministic, sensorless vacuum world. Each rectangular box corresponds to a single belief state. At any given point, the agent has a belief state but does not know which physical state it is in. The initial belief state (complete ignorance) is the top center box. The preceding definitions enable the automatic construction of the belief-state problem formulation from the definition of the underlying physical problem. Once this is done, we can solve sensorless problems with any of the ordinary search algorithms of Chapter 3. In ordinary graph search, newly reached states are tested to see if they were previously reached. This works for belief states, too; for example, in Figure 4. 14, the action sequence [Suck, Left, Suck] starting at the initial state reaches the same belief state as [Right, Left, Suck], namely, {5, 7}. Now, consider the belief state reached by [Left], namely, {1, 3, 5, 7}. Obviously, this is not identical to {5, 7}, but it is a superset. We can discard (prune) any such superset belief state. Why? Because a solution from {1, 3, 5, 7} must be a solution for each of the individual states 1, 3, 5, and 7, and thus it is a solution for any combination of these individual states, such as {5, 7}; therefore we don’t need to try to solve {1, 3, 5, 7}, we can concentrate on trying to solve the strictly easier belief state {5, 7}. Conversely, if {1, 3, 5, 7} has already been generated and found to be solvable, then any subset, such as {5, 7}, is guaranteed to be solvable. (If I have a solution that works when I’m very confused about what state I’m in, it will still work when I’m less confused. ) This extra level of pruning may dramatically improve the efficiency of sensorless problem solving. Even with this improvement, however, sensorless problem-solving as we have described it is seldom feasible in practice. One issue is the vastness of the belief-state space—we saw in the previous chapter that often a search space of size N is too large, and now we have search spaces of size 2N. Furthermore, each element of the search space is a set of up to N elements. For large N, we won’t be able to represent even a single belief state without running out of memory space. One solution is to represent the belief state by some more compact description. In English, we could say the agent knows “Nothing” in the initial state; after moving Left, we could say, “Not in the rightmost column, ” and so on. Chapter 7 explains how to do this in a formal representation scheme. Another approach is to avoid the standard search algorithms, which treat belief states as black boxes just like any other problem state. Instead, we can look inside the belief states and develop incremental belief-state search algorithms that build up the solution one physical state at a time. For example, in the sensorless vacuum world, the initial belief state is {1, 2, 3, 4, 5, 6, 7, 8}, and we have to find an action sequence that works in all 8 states. We can do this by first finding a solution that works for state 1; then we check if it works for state 2; if not, go back and find a different solution for state 1, and so on. Just as an AND–OR search has to find a solution for every branch at an AND node, this algorithm has to find a solution for every state in the belief state; the difference is that AND–OR search can find a different solution for each branch, whereas an incremental belief-state search has to find one solution that works for all the states. The main advantage of the incremental approach is that it is typically able to detect failure quickly—when a belief state is unsolvable, it is usually the case that a small subset of the belief state, consisting of the first few states examined, is also unsolvable. In some cases, this leads to a speedup proportional to the size of the belief states, which may themselves be as large as the physical state space itself. 4. 4. 2Searching in partially observable environments Many problems cannot be solved without sensing. For example, the sensorless 8-puzzle is impossible. On the other hand, a little bit of sensing can go a long way: we can solve 8- puzzles if we can see just the upper-left corner square. The solution involves moving each tile in turn into the observable square and keeping track of its location from then on. For a partially observable problem, the problem specification will specify a PERCEPT(s) function that returns the percept received by the agent in a given state. If sensing is nondeterministic, then we can use a PERCEPTS function that returns a set of possible percepts. For fully observable problems, PERCEPT(s) = s for every state s, and for sensorless problems PERCEPT(s) = null. Consider a local-sensing vacuum world, in which the agent has a position sensor that yields the percept L in the left square, and R in the right square, and a dirt sensor that yields Dirty when the current square is dirty and Clean when it is clean. Thus, the PERCEPT in state 1 is [L, Dirty]. With partial observability, it will usually be the case that several states produce the same percept; state 3 will also produce [L, Dirty]. Hence, given this initial percept, the initial belief state will be {1, 3}. We can think of the transition model between belief states for partially observable problems as occurring in three stages, as shown in Figure 4. 15: Description The robot is placed in a maze-like environment with dark shaded and white blocks. The path formed by the white block is where the robot has to move. The dark shaded blocks depict an obstacle. In the percept bit value, the 1s indicate the obstacles and 0s indicate the open path. The four bits depict the north, east, west, and south directions. The robot is depicted by two concentric bold circles. Part (“a”): Possible locations of the robot after E subscript 1 BaseLine equals 1011. The possible positions of the robot are shown at four blocks. Part (b): Possible locations of the robot after E subscript 1 BaseLine equals 1011, E subscript 2 BaseLine equals 1010. One possible position of the robot is depicted on the board. Figure 4. 15Two examples of transitions in local-sensing vacuum worlds. (a) In the deterministic world, Right is applied in the initial belief state, resulting in a new predicted belief state with two possible physical states; for those states, the possible percepts are [R, Dirty] and [R, Clean], leading to two belief states, each of which is a singleton. (b) In the slippery world, Right is applied in the initial belief state, giving a new belief state with four physical states; for those states, the possible percepts are [L, Dirty], [R, Dirty], and [R, Clean], leading to three belief states as shown. •The prediction stage computes the belief state resulting from the action, RESULT(b, a), exactly as we did with sensorless problems. To emphasize that this is a prediction, we use the notation = RESULT(b, a), where the “hat” over the b means “estimated, ” and we also use PREDlCT(b, a) as a synonym for RESULT(b, a). •The possible percepts stage computes the set of percepts that could be observed in the predicted belief state (using the letter o for observation): •The update stage computes, for each possible percept, the belief state that would result from the percept. The updated belief state bo is the set of states in that could have produced the percept: The agent needs to deal with possible percepts at planning time, because it won’t know the actual percepts until it executes the plan. Notice that nondeterminism in the physical environment can enlarge the belief state in the prediction stage, but each updated belief state bo can be no larger than the predicted belief state; observations can only help reduce uncertainty. Moreover, for deterministic sensing, the belief states for the different possible percepts will be disjoint, forming a partition of the original predicted belief state. Putting these three stages together, we obtain the possible belief states resulting from a given action and the subsequent possible percepts: 4. 4. 3Solving partially observable problems The preceding section showed how to derive the RESULTS function for a nondeterministic belief-state problem from an underlying physical problem, given the PERCEPT function. With this formulation, the AND–OR search algorithm of Figure 4. 11 can be applied directly to derive a solution. Figure 4. 16 shows part of the search tree for the local-sensing vacuum world, assuming an initial percept [L, Dirty]. The solution is the conditional plan Description A square block with three rows and three columns depicts the maze. The rows are labeled 3, 2, and 1 from top to bottom. The columns are labeled 1, 2, and 3 from left to right. S is positioned at Row 1 Column 1. G is positioned at Row 3 Column 3. Red bold lines are marked at the border lines of column 1 of rows 2 and 3, row 2 of columns 1 and 2, and columns 2 and 3 of rows 2 and 3. Figure 4. 16The first level of the AND–OR search tree for a problem in the local-sensing vacuum world; Suck is the first action in the solution. Notice that, because we supplied a belief-state problem to the AND–OR search algorithm, it returned a conditional plan that tests the belief state rather than the actual state. This is as it should be: in a partially observable environment the agent won’t know the actual state. As in the case of standard search algorithms applied to sensorless problems, the AND–OR search algorithm treats belief states as black boxes, just like any other states. One can improve on this by checking for previously generated belief states that are subsets or supersets of the current state, just as for sensorless problems. One can also derive incremental search algorithms, analogous to those described for sensorless problems, that provide substantial speedups over the black-box approach. 4. 4. 4An agent for partially observable environments An agent for partially observable environments formulates a problem, calls a search algorithm (such as AND-OR-SEARCH) to solve it, and executes the solution. There are two main differences between this agent and the one for fully observable deterministic environments. First, the solution will be a conditional plan rather than a sequence; to execute an if–then–else expression, the agent will need to test the condition and execute the appropriate branch of the conditional. Second, the agent will need to maintain its belief state as it performs actions and receives percepts. This process resembles the prediction–observation–update process in Equation (4. 5) but is actually simpler because the percept is given by the environment rather than calculated by the agent. Given an initial belief state b, an action a, and a percept o, the new belief state is: Consider a kindergarten vacuum world wherein agents sense only the state of their current square, and any square may become dirty at any time unless the agent is actively cleaning it at that moment. 7 Figure 4. 17 shows the belief state being maintained in this environment. Description State space 1: An arrow from a node labeled S points to a node labeled “a”. Two arrows from the node labeled “a” point to two unlabeled nodes. An arrow from the first unlabeled node points to a node labeled G. An arrow from the second unlabeled node points to a third unlabeled node which has a self-loop. State space 2: An arrow from a node labeled S points to a node labeled “a”. Two arrows from the node labeled “a” point to two unlabeled nodes. An arrow from the first unlabeled node points to a third unlabeled node which has a self-loop. An arrow from the second unlabeled node points to a node labeled G. Figure 4. 17Two prediction–update cycles of belief-state maintenance in the kindergarten vacuum world with local sensing. In partially observable environments—which include the vast majority of real-world environments—maintaining one’s belief state is a core function of any intelligent system. This function goes under various names, including monitoring, filtering, and state estimation. Equation (4. 6) is called a recursive state estimator because it computes the new belief state from the previous one rather than by examining the entire percept sequence. If the agent is not to “fall behind, ” the computation has to happen as fast as percepts are coming in. As the environment becomes more complex, the agent will only have time to compute an approximate belief state, perhaps focusing on the implications of the percept for the aspects of the environment that are of current interest. Most work on this problem has been done for stochastic, continuous-state environments with the tools of probability theory, as explained in Chapter 14. In this section we will show an example in a discrete environment with deterministic sensors and nondeterministic actions. The example concerns a robot with a particular state estimation task called localization: working out where it is, given a map of the world and a sequence of percepts and actions. Our robot is placed in the maze-like environment of Figure 4. 18. The robot is equipped with four sonar sensors that tell whether there is an obstacle—the outer wall or a dark shaded square in the figure—in each of the four compass directions. The percept is in the form of a bit vector, one bit for each of the directions north, east, south, and west in that order, so 1011 means there are obstacles to the north, south, and west, but not east. Description Seven long thin blocks are arranged at different levels, and the count of the block extends to n numbers. A path is traced with alternate upper and lower parts of the blocks. The path starts at S and ends at G. Figure 4. 18Possible positions of the robot, ʘ, (a) after one observation, E1= 1011, and (b) after moving one square and making a second observation, E2 = 1010. When sensors are noiseless and the transition model is accurate, there is only one possible location for the robot consistent with this sequence of two observations. We assume that the sensors give perfectly correct data, and that the robot has a correct map of the environment. But unfortunately, the robot’s navigational system is broken, so when it executes a Right action, it moves randomly to one of the adjacent squares. The robot’s task is to determine its current location. Suppose the robot has just been switched on, and it does not know where it is—its initial belief state b consists of the set of all locations. The robot then receives the percept 1011 and does an update using the equation bo = UPDATE(1011), yielding the 4 locations shown in Figure 4. 18(a). You can inspect the maze to see that those are the only four locations that yield the percept 1011. Next the robot executes a Right action, but the result is nondeterministic. The new belief state, ba = PREDICT(bo, Right), contains all the locations that are one step away from the locations in bo. When the second percept, 1010, arrives, the robot does UPDATE(ba, 1010) and finds that the belief state has collapsed down to the single location shown in Figure 4. 18(b). That’s the only location that could be the result of With nondeterministic actions the PREDICT step grows the belief state, but the UPDATE step shrinks it back down—as long as the percepts provide some useful identifying information. Sometimes the percepts don’t help much for localization: If there were one or more long east-west corridors, then a robot could receive a long sequence of 1010 percepts, but never know where in the corridor(s) it was. But for environments with reasonable variation in geography, localization often converges quickly to a single point, even when actions are nondeterministic. What happens if the sensors are faulty? If we can reason only with Boolean logic, then we have to treat every sensor bit as being either correct or incorrect, which is the same as having no perceptual information at all. But we will see that probabilistic reasoning (Chapter 12), allows us to extract useful information from a faulty sensor as long as it is wrong less than half the time. 4. 5Online Search Agents and Unknown Environments So far we have concentrated on agents that use offline search algorithms. They compute a complete solution before taking their first action. In contrast, an online search8 agent interleaves computation and action: first it takes an action, then it observes the environment and computes the next action. Online search is a good idea in dynamic or semi-dynamic environments, where there is a penalty for sitting around and computing too long. Online search is also helpful in nondeterministic domains because it allows the agent to focus its computational efforts on the contingencies that actually arise rather than those that might happen but probably won’t. Of course, there is a tradeoff: the more an agent plans ahead, the less often it will find itself up the creek without a paddle. In unknown environments, where the agent does not know what states exist or what its actions do, the agent must use its actions as experiments in order to learn about the environment. A canonical example of online search is the mapping problem: a robot is placed in an unknown building and must explore to build a map that can later be used for getting from A to B. Methods for escaping from labyrinths—required knowledge for aspiring heroes of antiquity—are also examples of online search algorithms. Spatial exploration is not the only form of online exploration, however. Consider a newborn baby: it has many possible actions but knows the outcomes of none of them, and it has experienced only a few of the possible states that it can reach. 4. 5. 1Online search problems An online search problem is solved by interleaving computation, sensing, and acting. We’ll start by assuming a deterministic and fully observable environment (Chapter 16 relaxes these assumptions) and stipulate that the agent knows only the following: •ACTIONS(s), the legal actions in state s; •c(s, a, s'), the cost of applying action a in state s to arrive at state s'. Note that this cannot be used until the agent knows that s' is the outcome. •IS-GOAL(s), the goal test. Note in particular that the agent cannot determine RESULT(s, a) except by actually being in s and doing a. For example, in the maze problem shown in Figure 4. 19, the agent does not know that going Up from (1, 1) leads to (1, 2); nor, having done that, does it know that going Down will take it back to (1, 1). This degree of ignorance can be reduced in some applications—for example, a robot explorer might know how its movement actions work and be ignorant only of the locations of obstacles. Description The first and the last nodes are labeled S and G, respectively. All the other nodes are unlabeled. For every two adjacent nodes, a third node is aligned below the mid of the two. To and from arrows connect the adjacent nodes. An arrow from node G points to the last node on the bottom row. An arrow from this node points to the node just above this, and then the flow progresses until the first node. Figure 4. 19A simple maze problem. The agent starts at S and must reach G but knows nothing of the environment. Finally, the agent might have access to an admissible heuristic function h(s) that estimates the distance from the current state to a goal state. For example, in Figure 4. 19, the agent might know the location of the goal and be able to use the Manhattan-distance heuristic (page 116). Typically, the agent’s objective is to reach a goal state while minimizing cost. (Another possible objective is simply to explore the entire environment. ) The cost is the total path cost that the agent incurs as it travels. It is common to compare this cost with the path cost the agent would incur if it knew the search space in advance—that is, the optimal path in the known environment. In the language of online algorithms, this comparison is called the competitive ratio; we would like it to be as small as possible. Online explorers are vulnerable to dead ends: states from which no goal state is reachable. If the agent doesn’t know what each action does, it might execute the “jump into bottomless pit” action, and thus never reach the goal. In general, no algorithm can avoid dead ends in all state spaces. Consider the two dead-end state spaces in Figure 4. 20(a). An online search algorithm that has visited states S and A cannot tell if it is in the top state space or the bottom one; the two look identical based on what the agent has seen. Therefore, there is no way it could know how to choose the correct action in both state spaces. This is an example of an adversary argument—we can imagine an adversary constructing the state space while the agent explores it and putting the goals and dead ends wherever it chooses, as in Figure 4. 20(b). Description Part (“a”): Six nodes labeled 8, 9, 2, 2, 4, and 3 are connected using double-headed arrows labeled 1. Node 2 is shaded in red. Part (b): Six nodes labeled 8, 9, 3, 2, 4, and 3 are connected using double-headed arrows labeled 1. Note: Digit 3 in the third node is encircled. Node 2 is shaded in red. Part (c): Six nodes labeled 8, 9, 3, 4, 4, and 3 are connected using double-headed arrows labeled 1. Note: The digit 4 in the fourth node is encircled. Node 3 is shaded in red. Part (d): Six nodes labeled 8, 9, 5, 4, 4, and 3 are connected using double-headed arrows labeled 1. Note: The digit 5 in the third node is encircled. Node 4 is shaded in red. Part (e): Six nodes labeled 8, 9, 5, 5, 4, and 3 are connected using double-headed arrows labeled 1. Note: The digit 5 in the fourth node is encircled. Node 4 is shaded in red. Figure 4. 20(a) Two state spaces that might lead an online search agent into a dead end. Any given agent will fail in at least one of these spaces. (b) A two-dimensional environment that can cause an online search agent to follow an arbitrarily inefficient route to the goal. Whichever choice the agent makes, the adversary blocks that route with another long, thin wall, so that the path followed is much longer than the best possible path. Dead ends are a real difficulty for robot exploration—staircases, ramps, cliffs, one-way streets, and even natural terrain all present states from which some actions are irreversible—there is no way to return to the previous state. The exploration algorithm we will present is only guaranteed to work in state spaces that are safely explorable—that is, some goal state is reachable from every reachable state. State spaces with only reversible actions, such as mazes and 8-puzzles, are clearly safely explorable (if they have any solution at all). We will cover the subject of safe exploration in more depth in Section 23. 3. 2. Even in safely explorable environments, no bounded competitive ratio can be guaranteed if there are paths of unbounded cost. This is easy to show in environments with irreversible actions, but in fact it remains true for the reversible case as well, as Figure 4. 20(b) shows. For this reason, it is common to characterize the performance of online search algorithms in terms of the size of the entire state space rather than just the depth of the shallowest goal. 4. 5. 2Online search agents After each action, an online agent in an observable environment receives a percept telling it what state it has reached; from this information, it can augment its map of the environment. The updated map is then used to plan where to go next. This interleaving of planning and action means that online search algorithms are quite different from the offline search algorithms we have seen previously: offline algorithms explore their model of the state space, while online algorithms explore the real world. For example, A* can expand a node in one part of the space and then immediately expand a node in a distant part of the space, because node expansion involves simulated rather than real actions. An online algorithm, on the other hand, can discover successors only for a state that it physically occupies. To avoid traveling all the way to a distant state to expand the next node, it seems better to expand nodes in a local order. Depth-first search has exactly this property because (except when the algorithm is backtracking) the next node expanded is a child of the previous node expanded. An online depth-first exploration agent (for deterministic but unknown actions) is shown in Figure 4. 21. This agent stores its map in a table, result[s, a], that records the state resulting from executing action a in state s. (For nondeterministic actions, the agent could record a set of states under results[s, a]. ) Whenever the current state has unexplored actions, the agent tries one of those actions. The difficulty comes when the agent has tried all the actions in a state. In offline depth-first search, the state is simply dropped from the queue; in an online search, the agent has to backtrack in the physical world. In depth-first search, this means going back to the state from which the agent most recently entered the current state. To achieve that, the algorithm keeps another table that lists, for each state, the predecessor states to which the agent has not yet backtracked. If the agent has run out of states to which it can backtrack, then its search is complete. Figure 4. 21An online search agent that uses depth-first exploration. The agent can safely explore only in state spaces in which every action can be “undone” by some other action. We recommend that the reader trace through the progress of ONLINE-DFS-AGENT when applied to the maze given in Figure 4. 19. It is fairly easy to see that the agent will, in the worst case, end up traversing every link in the state space exactly twice. For exploration, this is optimal; for finding a goal, on the other hand, the agent’s competitive ratio could be arbitrarily bad if it goes off on a long excursion when there is a goal right next to the initial state. An online variant of iterative deepening solves this problem; for an environment that is a uniform tree, the competitive ratio of such an agent is a small constant. Because of its method of backtracking, ONLINE-DFS-AGENT works only in state spaces where the actions are reversible. There are slightly more complex algorithms that work in general state spaces, but no such algorithm has a bounded competitive ratio. 4. 5. 3Online local search Like depth-first search, hill-climbing search has the property of locality in its node expansions. In fact, because it keeps just one current state in memory, hill-climbing search is already an online search algorithm! Unfortunately, the basic algorithm is not very good for exploration because it leaves the agent sitting at local maxima with nowhere to go. Moreover, random restarts cannot be used, because the agent cannot teleport itself to a new start state. Instead of random restarts, one might consider using a random walk to explore the environment. A random walk simply selects at random one of the available actions from the current state; preference can be given to actions that have not yet been tried. It is easy to prove that a random walk will eventually find a goal or complete its exploration, provided that the space is finite and safely explorable. 9 On the other hand, the process can be very slow. Figure 4. 22 shows an environment in which a random walk will take exponentially many steps to find the goal, because, for each state in the top row except S, backward progress is twice as likely as forward progress. The example is contrived, of course, but there are many real-world state spaces whose topology causes these kinds of “traps” for random walks. Figure 4. 22An environment in which a random walk will take exponentially many steps to find the goal. Augmenting hill climbing with memory rather than randomness turns out to be a more effective approach. The basic idea is to store a “current best estimate” H(s) of the cost to reach the goal from each state that has been visited. H(s) starts out being just the heuristic estimate h(s) and is updated as the agent gains experience in the state space. Figure 4. 23 shows a simple example in a one-dimensional state space. In (a), the agent seems to be stuck in a flat local minimum at the red state. Rather than staying where it is, the agent should follow what seems to be the best path to the goal given the current cost estimates for its neighbors. The estimated cost to reach the goal through a neighbor s' is the cost to get to s' plus the estimated cost to get to a goal from there—that is, c(s, a, s') + H(s'). In the example, there are two actions, with estimated costs 1 + 9 to the left and 1 + 2 to the right, so it seems best to move right. Figure 4. 23Five iterations of LRTA* on a one-dimensional state space. Each state is labeled with H(s), the current cost estimate to reach a goal, and every link has an action cost of 1. The red state marks the location of the agent, and the updated cost estimates at each iteration have a double circle. In (b) it is clear that the cost estimate of 2 for the red state in (a) was overly optimistic. Since the best move cost 1 and led to a state that is at least 2 steps from a goal, the red state must be at least 3 steps from a goal, so its H should be updated accordingly, as shown in Figure 4. 23(b). Continuing this process, the agent will move back and forth twice more, updating H each time and “flattening out” the local minimum until it escapes to the right. An agent implementing this scheme, which is called learning real-time A* (LRTA*), is shown in Figure 4. 24. Like ONLINE-DFS-AGENT, it builds a map of the environment in the result table. It updates the cost estimate for the state it has just left and then chooses the “apparently best” move according to its current cost estimates. One important detail is that actions that have not yet been tried in a state s are always assumed to lead immediately to the goal with the least possible cost, namely h(s). This optimism under uncertainty encourages the agent to explore new, possibly promising paths. Figure 4. 24LRTA*-AGENT selects an action according to the values of neighboring states, which are updated as the agent moves about the state space. An LRTA* agent is guaranteed to find a goal in any finite, safely explorable environment. Unlike A*, however, it is not complete for infinite state spaces—there are cases where it can be led infinitely astray. It can explore an environment of n states in O(n2) steps in the worst case, but often does much better. The LRTA* agent is just one of a large family of online agents that one can define by specifying the action selection rule and the update rule in different ways. We discuss this family, developed originally for stochastic environments, in Chapter 23. 4. 5. 4Learning in online search The initial ignorance of online search agents provides several opportunities for learning. First, the agents learn a “map” of the environment—more precisely, the outcome of each action in each state—simply by recording each of their experiences. Second, the local search agents acquire more accurate estimates of the cost of each state by using local updating rules, as in LRTA*. In Chapter 23, we show that these updates eventually converge to exact values for every state, provided that the agent explores the state space in the right way. Once exact values are known, optimal decisions can be taken simply by moving to the lowest-cost successor—that is, pure hill climbing is then an optimal strategy. If you followed our suggestion to trace the behavior of ONLINE-DFS-AGENT in the environment of Figure 4. 19, you will have noticed that the agent is not very bright. For example, after it has seen that the Up action goes from (1, 1) to (1, 2), the agent still has no idea that the Down action goes back to (1, 1) or that the Up action also goes from (2, 1) to (2, 2), from (2, 2) to (2, 3), and so on. In general, we would like the agent to learn that Up increases the y-coordinate unless there is a wall in the way, that Down reduces it, and so on. For this to happen, we need two things. First, we need a formal and explicitly manipulable representation for these kinds of general rules; so far, we have hidden the information inside the black box called the RESULT function. Chapters 8 to 11 are devoted to this issue. Second, we need algorithms that can construct suitable general rules from the specific observations made by the agent. These are covered in Chapter 19. If we anticipate that we will be called upon to solve multiple similar problems in the future then it makes sense to invest time (and memory) to make those future searches easier. There are several ways to do this, all falling under the heading of incremental search. We could keep the search tree in memory and reuse the parts of it that are unchanged in the new problem. We could keep the heuristic h values and update them as we gain new information—either because the world has changed or because we have computed a better estimate. Or we could keep the best-path g values, using them to piece together a new solution, and updating them when the world changes. Summary This chapter has examined search algorithms for problems in partially observable, nondeterministic, unknown, and continuous environments. •Local search methods such as hill climbing keep only a small number of states in memory. They have been applied to optimization problems, where the idea is to find a high-scoring state, without worrying about the path to the state. Several stochastic local search algorithms have been developed, including simulated annealing, which returns optimal solutions when given an appropriate cooling schedule. •Many local search methods apply also to problems in continuous spaces. Linear programming and convex optimization problems obey certain restrictions on the shape of the state space and the nature of the objective function, and admit polynomial-time algorithms that are often extremely efficient in practice. For some mathematically well-formed problems, we can find the maximum using calculus to find where the gradient is zero; for other problems we have to make do with the empirical gradient, which measures the difference in fitness between two nearby points. •An evolutionary algorithm is a stochastic hill-climbing search in which a population of states is maintained. New states are generated by mutation and by crossover, which combines pairs of states. •In nondeterministic environments, agents can apply AND–OR search to generate contingent plans that reach the goal regardless of which outcomes occur during execution. •When the environment is partially observable, the belief state represents the set of possible states that the agent might be in. •Standard search algorithms can be applied directly to belief-state space to solve sensorless problems, and belief-state AND–OR search can solve general partially observable problems. Incremental algorithms that construct solutions state by state within a belief state are often more efficient. • Exploration problems arise when the agent has no idea about the states and actions of its environment. For safely explorable environments, online search agents can build a map and find a goal if one exists. Updating heuristic estimates from experience provides an effective method to escape from local minima. Bibliographical and Historical Notes Local search techniques have a long history in mathematics and computer science. Indeed, the Newton–Raphson method (Newton, 1671; Raphson, 1690) can be seen as a very efficient local search method for continuous spaces in which gradient information is available. Brent (1973) is a classic reference for optimization algorithms that do not require such information. Beam search, which we have presented as a local search algorithm, originated as a bounded-width variant of dynamic programming for speech recognition in the HARPY system (Lowerre, 1976). A related algorithm is analyzed in depth by Pearl (1984, Ch. 5). The topic of local search was reinvigorated in the early 1990s by surprisingly good results for large constraint-satisfaction problems such as n-queens (Minton et al. , 1992) and Boolean satisfiability (Selman et al. , 1992) and by the incorporation of randomness, multiple simultaneous searches, and other improvements. This renaissance of what Christos Papadimitriou has called “New Age” algorithms also sparked increased interest among theoretical computer scientists (Koutsoupias and Papadimitriou, 1992; Aldous and Vazirani, 1994). In the field of operations research, a variant of hill climbing called tabu search has gained popularity (Glover and Laguna, 1997). This algorithm maintains a tabu list of k previously visited states that cannot be revisited; as well as improving efficiency when searching graphs, this list can allow the algorithm to escape from some local minima. Another useful improvement on hill climbing is the STAGE algorithm (Boyan and Moore, 1998). The idea is to use the local maxima found by random-restart hill climbing to get an idea of the overall shape of the landscape. The algorithm fits a smooth quadratic surface to the set of local maxima and then calculates the global maximum of that surface analytically. This becomes the new restart point. Gomes et al. (1998) showed that the run times of systematic backtracking algorithms often have a heavy-tailed distribution, which means that the probability of a very long run time is more than would be predicted if the run times were exponentially distributed. When the run time distribution is heavy-tailed, random restarts find a solution faster, on average, than a single run to completion. Hoos and Stützle (2004) provide a book-length coverage of the topic. Simulated annealing was first described by Kirkpatrick et al. (1983), who borrowed directly from the Metropolis algorithm (which is used to simulate complex systems in physics (Metropolis et al. , 1953) and was supposedly invented at a Los Alamos dinner party). Simulated annealing is now a field in itself, with hundreds of papers published every year. Finding optimal solutions in continuous spaces is the subject matter of several fields, including optimization theory, optimal control theory, and the calculus of variations. The basic techniques are explained well by Bishop (1995); Press et al. (2007) cover a wide range of algorithms and provide working software. Researchers have taken inspiration for search and optimization algorithms from a wide variety of fields of study: metallurgy (simulated annealing); biology (genetic algorithms); neuroscience (neural networks); mountaineering (hill climbing); economics (market-based algorithms (Dias et al. , 2006)); physics (particle swarms (Li and Yao, 2012) and spin glasses (Mézard et al. , 1987)); animal behavior (reinforcement learning, grey wolf optimizers (Mirjalili and Lewis, 2014)); ornithology (Cuckoo search (Yang and Deb, 2014)); entomology (ant colony (Dorigo et al. , 2008), bee colony (Karaboga and Basturk, 2007), firefly (Yang, 2009) and glowworm (Krishnanand and Ghose, 2009) optimization); and others. Linear programming (LP) was first studied systematically by the mathematician Leonid Kantorovich (1939). It was one of the first applications of computers; the simplex algorithm (Dantzig, 1949) is still used despite worst-case exponential complexity. Karmarkar (1984) developed the far more efficient family of interior-point methods, which was shown to have polynomial complexity for the more general class of convex optimization problems by Nesterov and Nemirovski (1994). Excellent introductions to convex optimization are provided by Ben-Tal and Nemirovski (2001) and Boyd and Vandenberghe (2004). Work by Sewall Wright (1931) on the concept of a fitness landscape was an important precursor to the development of genetic algorithms. In the 1950s, several statisticians, including Box (1957) and Friedman (1959), used evolutionary techniques for optimization problems, but it wasn’t until Rechenberg (1965) introduced evolution strategies to solve optimization problems for airfoils that the approach gained popularity. In the 1960s and 1970s, John Holland (1975) championed genetic algorithms, both as a useful optimization tool and as a method to expand our understanding of adaptation (Holland, 1995). The artificial life movement (Langton, 1995) took this idea one step further, viewing the products of genetic algorithms as organisms rather than solutions to problems. The Baldwin effect discussed in the chapter was proposed roughly simultaneously by Conwy Lloyd Morgan (1896) and James (Baldwin, 1896). Computer simulations have helped to clarify its implications (Hinton and Nowlan, 1987; Ackley and Littman, 1991; Morgan and Griffiths, 2015). Smith and Szathmáry (1999), Ridley (2004), and Carroll (2007) provide general background on evolution. Most comparisons of genetic algorithms to other approaches (especially stochastic hill climbing) have found that the genetic algorithms are slower to converge (O’Reilly and Oppacher, 1994; Mitchell et al. , 1996; Juels and Wattenberg, 1996; Baluja, 1997). Such findings are not universally popular within the GA community, but recent attempts within that community to understand population-based search as an approximate form of Bayesian learning (see Chapter 21) might help close the gap between the field and its critics (Pelikan et al. , 1999). The theory of quadratic dynamical systems may also explain the performance of GAs (Rabani et al. , 1998). There are some impressive practical applications of GAs, in areas as diverse as antenna design (Lohn et al. , 2001), computer-aided design (Renner and Ekart, 2003), climate models (Stanislawska et al. , 2015), medicine (Ghaheri et al. , 2015), and designing deep neural networks (Miikkulainen et al. , 2019). The field of genetic programming is a subfield of genetic algorithms in which the representations are programs rather than bit strings. The programs are represented in the form of syntax trees, either in a standard programming language or in specially designed formats to represent electronic circuits, robot controllers, and so on. Crossover involves splicing together subtrees in such a way that the offspring are guaranteed to be well-formed expressions. Interest in genetic programming was spurred by the work of John Koza (1992, 1994), but it goes back at least to early experiments with machine code by Friedberg (1958) and with finite-state automata by Fogel et al. (1966). As with genetic algorithms, there is debate about the effectiveness of the technique. Koza et al. (1999) describe experiments in the use of genetic programming to design circuit devices. The journals Evolutionary Computation and IEEE Transactions on Evolutionary Computation cover evolutionary algorithms; articles are also found in Complex Systems, Adaptive Behavior, and Artificial Life. The main conference is the Genetic and Evolutionary Computation Conference (GECCO). Good overview texts on genetic algorithms include those by Mitchell (1996), Fogel (2000), Langdon and Poli (2002), and Poli et al. (2008). The unpredictability and partial observability of real environments were recognized early on in robotics projects that used planning techniques, including Shakey (Fikes et al. , 1972) and FREDDY (Michie, 1972). The problems received more attention after the publication of McDermott’s (1978a) influential article Planning and Acting. The first work to make explicit use of AND–OR trees seems to have been Slagle’s SAINT program for symbolic integration, mentioned in Chapter 1. Amarel (1967) applied the idea to propositional theorem proving, a topic discussed in Chapter 7, and introduced a search algorithm similar to AND-OR-GRAPH-SEARCH. The algorithm was further developed by Nilsson (1971), who also described AO*—which, as its name suggests, finds optimal solutions. AO* was further improved by Martelli and Montanari (1973). AO* is a top-down algorithm; a bottom-up generalization of A* is A*LD, for A* Lightest Derivation (Felzenszwalb and McAllester, 2007). Interest in AND–OR search underwent a revival in the early 2000s, with new algorithms for finding cyclic solutions (Jimenez and Torras, 2000; Hansen and Zilberstein, 2001) and new techniques inspired by dynamic programming (Bonet and Geffner, 2005). The idea of transforming partially observable problems into belief-state problems originated with Astrom (1965) for the much more complex case of probabilistic uncertainty (see Chapter 16). Erdmann and Mason (1988) studied the problem of robotic manipulation without sensors, using a continuous form of belief-state search. They showed that it was possible to orient a part on a table from an arbitrary initial position by a well-designed sequence of tilting actions. More practical methods, based on a series of precisely oriented diagonal barriers across a conveyor belt, use the same algorithmic insights (Wiegley et al. , 1996). The belief-state approach was reinvented in the context of sensorless and partially observable search problems by Genesereth and Nourbakhsh (1993). Additional work was done on sensorless problems in the logic-based planning community (Goldman and Boddy, 1996; Smith and Weld, 1998). This work has emphasized concise representations for belief states, as explained in Chapter 11. Bonet and Geffner (2000) introduced the first effective heuristics for belief-state search; these were refined by Bryce et al. (2006). The incremental approach to belief-state search, in which solutions are constructed incrementally for subsets of states within each belief state, was studied in the planning literature by Kurien et al. (2002); several new incremental algorithms were introduced for nondeterministic, partially observable problems by Russell and Wolfe (2005). Additional references for planning in stochastic, partially observable environments appear in Chapter 16. Algorithms for exploring unknown state spaces have been of interest for many centuries. Depth-first search in a reversible maze can be implemented by keeping one’s left hand on the wall; loops can be avoided by marking each junction. The more general problem of exploring Eulerian graphs (i. e. , graphs in which each node has equal numbers of incoming and outgoing edges) was solved by an algorithm due to Hierholzer (1873). The first thorough algorithmic study of the exploration problem for arbitrary graphs was carried out by Deng and Papadimitriou (1990), who developed a completely general algorithm but showed that no bounded competitive ratio is possible for exploring a general graph. Papadimitriou and Yannakakis (1991) examined the question of finding paths to a goal in geometric path-planning environments (where all actions are reversible). They showed that a small competitive ratio is achievable with square obstacles, but with general rectangular obstacles no bounded ratio can be achieved. (See Figure 4. 20. ) In a dynamic environment, the state of the world can spontaneously change without any action by the agent. For example, the agent can plan an optimal driving route from A to B, but an accident or unusually bad rush hour traffic can spoil the plan. Incremental search algorithms such as Lifelong Planning A* (Koenig et al. , 2004) and D* Lite (Koenig and Likhachev, 2002) deal with this situation. The LRTA* algorithm was developed by Korf (1990) as part of an investigation into realtime search for environments in which the agent must act after searching for only a fixed amount of time (a common situation in two-player games). LRTA* is in fact a special case of reinforcement learning algorithms for stochastic environments (Barto et al. , 1995). Its policy of optimism under uncertainty—always head for the closest unvisited state—can result in an exploration pattern that is less efficient in the uninformed case than simple depth-first search (Koenig, 2000). Dasgupta et al. (1994) show that online iterative deepening search is optimally efficient for finding a goal in a uniform tree with no heuristic information. Several informed variants on the LRTA* theme have been developed with different methods for searching and updating within the known portion of the graph (Pemberton and Korf, 1992). As yet, there is no good theoretical understanding of how to find goals with optimal efficiency when using heuristic information. Sturtevant and Bulitko (2016) provide an analysis of some pitfalls that occur in practice. 1Luby et al. (1993) suggest restarting after a fixed number of steps and show that this can be much more efficient than letting each search continue indefinitely. 2Knowledge of vectors, matrices, and derivatives is useful for this section (see Appendix A). 3In general, the Newton–Raphson update can be seen as fitting a quadratic surface to f at x and then moving directly to the minimum of that surface—which is also the minimum of f if f is quadratic. 4A set of points S is convex if the line joining any two points in S is also contained in S. A convex function is one for which the space “above” it forms a convex set; by definition, convex functions have no local (as opposed to global) minima. 5We assume that most readers face similar problems and can sympathize with our agent. We apologize to owners of modern, efficient cleaning appliances who cannot take advantage of this pedagogical device. 6In a fully observable environment, each belief state contains one physical state. Thus, we can view the algorithms in Chapter 3 as searching in a belief-state space of singleton belief states. 7The usual apologies to those who are unfamiliar with the effect of small children on the environment. 8The term “online” here refers to algorithms that must process input as it is received rather than waiting for the entire input data set to become available. This usage of “online” is unrelated to the concept of “having an Internet connection. ” 9Random walks are complete on infinite one-dimensional and two-dimensional grids. On a three-dimensional grid, the probability that the walk ever returns to the starting point is only about 0. 3405 (Hughes, 1995).",前：None | 后：None,AI_Popular,Formal_Academic,"state,belief,search","Search and Optimization Problems,Arad,Hill,node,Hill,Hill,Hill,Success,maxima,NP,Appendix A,harden,i. e.,minima,Boltzmann,Selection,VLSI,ACGT,Baum et al.,Dirt,Dirt,Dirt,Dirt,Goal,Loop,Loop,Goal,Suck,Left,node,Loop,Charles Darwin,the Origin of Species,Alfred Russel Wallace,Darwin,Gregor Mendel,Watson,Crick,AGTC,Jean Lamarck,James Baldwin’s,Hinton and,Nowlan,Baldwin,Morgan,schemas correspond,Marler,Arora,Miikkulainen et al.,Continuous Spaces,Newton,Leibniz,Romania,Romania,x3,x3,airport i.,x. However,Ci,Newton,Newton,i. e.,Newton,Hij,∂2f/∂xi∂xj,Equation,Ci,Ci,Equation,Newton,maxima,Romania,Linear,Nondeterministic Actions,I’m,Suck,node,node,Suck,•When,•When,Suck,Left,Suck,Suck,Equation,e. g.,Vacuum,Dirty,Dirty,Partially Observable Environments,≠ ACTIONSP(s2,Dirty,•Goal,Suck,Open,Dirty,Suck,N,Dirty,RESULTS,Suck,Equation,Description State,node,node,node,G. An,node,node,node,node,node,node,node,UPDATE(ba,UPDATE,Search Agents and Unknown,n’t,labyrinths,state s',Down,node,node,node,Manhattan,S and A,Description Part,Node 2,Node 2,Node 4,Node 4,node,node,S,H,Down,Down,Linear,algorithm,Newton,Newton,Raphson,HARPY,Lowerre,Pearl,Ch,Minton et al.,Selman,Christos Papadimitriou,New Age,Koutsoupias,Papadimitriou,Vazirani,Glover,Laguna,STAGE,maxima,Stützle,Kirkpatrick,Metropolis,Metropolis et al.,Los Alamos,Bishop,Press et al.,Dias,Li,Yao,grey wolf,Mirjalili and Lewis,Cuckoo,Yang,Dorigo,bee colony,Karaboga,Basturk,Yang,Linear,Leonid Kantorovich,the simplex algorithm,Dantzig,Karmarkar,Nesterov,Nemirovski,Ben-Tal,Nemirovski,Boyd,Vandenberghe,Sewall Wright,Box,Friedman,Rechenberg,John Holland,Holland,Langton,Baldwin,Conwy Lloyd Morgan,James,Baldwin,Hinton and,Nowlan,Ackley,Littman,Morgan,Smith,Szathmáry,Ridley,Carroll,Oppacher,Mitchell,al.,Juels,Wattenberg,Baluja,GA,Pelikan,al.,Rabani,Lohn et al.,Renner,Ekart,Stanislawska,al.,Ghaheri,Miikkulainen et al.,John Koza,Friedberg,Fogel et al,Koza et al,Complex Systems,Adaptive Behavior,Artificial Life,the Genetic and Evolutionary Computation Conference,Mitchell,Fogel,Langdon,Poli,Poli,Shakey (Fikes et al.,FREDDY,Michie,McDermott,Planning and Acting,Slagle’s SAINT,Nilsson,Martelli,Montanari,McAllester,Torras,Hansen,Zilberstein,Erdmann,Mason,Wiegley et al.,Genesereth,Nourbakhsh,Goldman,Boddy,Smith,Weld,Geffner,Bryce et al.,Kurien et al,Russell,i. e.,Hierholzer,Deng,Papadimitriou,Yannakakis,Lifelong Planning A*,Likhachev,Korf,Barto et al.,Koenig,Pemberton,Korf,Bulitko,al,Appendix A,Newton,S,S.,singleton,Hughes",,
chap5_para1,5,"CONSTRAINT SATISFACTION PROBLEMS In which we see how treating states as more than just little black boxes leads to new search methods and a deeper understanding of problem structure. Chapters 3 and 4 explored the idea that problems can be solved by searching the state space: a graph where the nodes are states and the edges between them are actions. We saw that domain-specific heuristics could estimate the cost of reaching the goal from a given state, but that from the point of view of the search algorithm, each state is atomic, or indivisible—a black box with no internal structure. For each problem we need domain-specific code to describe the transitions between states. In this chapter we break open the black box by using a factored representation for each state: a set of variables, each of which has a value. A problem is solved when each variable has a value that satisfies all the constraints on the variable. A problem described this way is called a constraint satisfaction problem, or CSP. CSP search algorithms take advantage of the structure of states and use general rather than domain-specific heuristics to enable the solution of complex problems. The main idea is to eliminate large portions of the search space all at once by identifying variable/value combinations that violate the constraints. CSPs have the additional advantage that the actions and transition model can be deduced from the problem description. 5. 1Defining Constraint Satisfaction Problems A constraint satisfaction problem consists of three components, X, D, and C: X is a set of variables, (X1, . . . , Xn}. D is a set of domains, {D1, . . . , Dn}, one for each variable. C is a set of constraints that specify allowable combinations of values. A domain, Di, consists of a set of allowable values, {v1, . . . , vk}, for variable Xi. For example, a Boolean variable would have the domain {true, false}. Different variables can have different domains of different sizes. Each constraint Cj consists of a pair 〈scope, rel〉, where scope is a tuple of variables that participate in the constraint and rel is a relation that defines the values that those variables can take on. A relation can be represented as an explicit set of all tuples of values that satisfy the constraint, or as a function that can compute whether a tuple is a member of the relation. For example, if X1 and X2 both have the domain {1, 2, 3}, then the constraint saying that X1 must be greater than X2 can be written as 〈(X1, X2), {(3, 1), (3, 2), (2, 1)}〉 or as 〈(X1, X2), X1 > X2〉. CSPs deal with assignments of values to variables, {Xi = vi, Xj = vj, . . . }. An assignment that does not violate any constraints is called a consistent or legal assignment. A complete assignment is one in which every variable is assigned a value, and a solution to a CSP is a consistent, complete assignment. A partial assignment is one that leaves some variables unassigned, and a partial solution is a partial assignment that is consistent. Solving a CSP is an NP-complete problem in general, although there are important subclasses of CSPs that can be solved very efficiently. 5. 1. 1Example problem: Map coloring Suppose that, having tired of Romania, we are looking at a map of Australia showing each of its states and territories (Figure 5. 1(a)). We are given the task of coloring each region either red, green, or blue in such a way that no two neighboring regions have the same color. To formulate this as a CSP, we define the variables to be the regions: Description The game tree has five rows of boxes. Each box has nine squares arranged in three rows and three columns. The first row is labeled MAX (x) and has one square box with nine empty squares. The second row is labeled MIN (o) and has nine boxes. The boxes in the second row show the nine possible squares the x can be placed. The third row is labeled MAX (x) and shows the possibilities of placing an o after placing the x in the top left square of the first box in the second row. The first box in the third row has the x in the first column of the first row and an o in the second column. The other boxes in the third row show the other possible squares the o can be placed, given that an x is already placed in the top left square in each box. The fourth row is labeled MIN (o) and shows the possibilities of placing an x after placing an x and o in the top left and top mid squares. The first box in the fourth row has an x and an o in the first and second columns of the first row. The other boxes in the fourth row show the other possible squares the x can be placed, given that an x and an o are already placed in the top left and top mid squares in each box. The rows continue this way and the last row is labeled TERMINAL. The last row shows three boxes representing three possible ends. The first box has a utility value of negative 1. The first box is filled column-wise as follows. Column 1: x, blank, blank. Column 2: o, o, o. Column 3: x, x, blank. The second box has a utility value of 0. The second box is filled row-wise as follows. Row 1: x, o, x. Row 2: o, o, x. Row 3: x, x, o. The third box has a utility value of positive 1. The third box is filled row-wise as follows. Row 1: x, o, x. Row 2: blank, x, blank. Row 3: x, o, o. Figure 5. 1(a) The principal states and territories of Australia. Coloring this map can be viewed as a constraint satisfaction problem (CSP). The goal is to assign colors to each region so that no neighboring regions have the same color. (b) The map-coloring problem represented as a constraint graph. The domain of every variable is the set Di = {red, green, blue}. The constraints require neighboring regions to have distinct colors. Since there are nine places where regions border, there are nine constraints: Here we are using abbreviations; SA ≠ WA is a shortcut for 〈(SA, WA), SA ≠ WA〉, where SA ≠ WA can be fully enumerated in turn as There are many possible solutions to this problem, such as It can be helpful to visualize a CSP as a constraint graph, as shown in Figure 5. 1(b). The nodes of the graph correspond to variables of the problem, and an edge connects any two variables that participate in a constraint. Why formulate a problem as a CSP? One reason is that the CSPs yield a natural representation for a wide variety of problems; it is often easy to formulate a problem as a CSP. Another is that years of development work have gone into making CSP solvers fast and efficient. A third is that a CSP solver can quickly prune large swathes of the search space that an atomic state-space searcher cannot. For example, once we have chosen {SA = blue} in the Australia problem, we can conclude that none of the five neighboring variables can take on the value blue. A search procedure that does not use constraints would have to consider 35 = 243 assignments for the five neighboring variables; with constraints we have only 25 = 32 assignments to consider, a reduction of 87%. In atomic state-space search we can only ask: is this specific state a goal? No? What about this one? With CSPs, once we find out that a partial assignment violates a constraint, we can immediately discard further refinements of the partial assignment. Furthermore, we can see why the assignment is not a solution—we see which variables violate a constraint—so we can focus attention on the variables that matter. As a result, many problems that are intractable for atomic state-space search can be solved quickly when formulated as a CSP. 5. 1. 2Example problem: Job-shop scheduling Factories have the problem of scheduling a day’s worth of jobs, subject to various constraints. In practice, many of these problems are solved with CSP techniques. Consider the problem of scheduling the assembly of a car. The whole job is composed of tasks, and we can model each task as a variable, where the value of each variable is the time that the task starts, expressed as an integer number of minutes. Constraints can assert that one task must occur before another—for example, a wheel must be installed before the hubcap is put on—and that only so many tasks can go on at once. Constraints can also specify that a task takes a certain amount of time to complete. We consider a small part of the car assembly, consisting of 15 tasks: install axles (front and back), affix all four wheels (right and left, front and back), tighten nuts for each wheel, affix hubcaps, and inspect the final assembly. We can represent the tasks with 15 variables: Next, we represent precedence constraints between individual tasks. Whenever a task T1 must occur before task T2, and task T1 takes duration d1 to complete, we add an arithmetic constraint of the form In our example, the axles have to be in place before the wheels are put on, and it takes 10 minutes to install an axle, so we write Next we say that for each wheel, we must affix the wheel (which takes 1 minute), then tighten the nuts (2 minutes), and finally attach the hubcap (1 minute, but not represented yet): Suppose we have four workers to install wheels, but they have to share one tool that helps put the axle in place. We need a disjunctive constraint to say that AxleF and AxleB must not overlap in time; either one comes first or the other does: This looks like a more complicated constraint, combining arithmetic and logic. But it still reduces to a set of pairs of values that AxleF and AxleB can take on. We also need to assert that the inspection comes last and takes 3 minutes. For every variable except Inspect we add a constraint of the form X + dX ≤ Inspect. Finally, suppose there is a requirement to get the whole assembly done in 30 minutes. We can achieve that by limiting the domain of all variables: This particular problem is trivial to solve, but CSPs have been successfully applied to jobshop scheduling problems like this with thousands of variables. 5. 1. 3Variations on the CSP formalism The simplest kind of CSP involves variables that have discrete, finite domains. Map-coloring problems and scheduling with time limits are both of this kind. The 8-queens problem (Figure 4. 3) can also be viewed as a finite-domain CSP, where the variables Q1, . . . , Q8 correspond to the queens in columns 1 to 8, and the domain of each variable specifies the possible row numbers for the queen in that column, Di = {1, 2, 3, 4, 5, 6, 7, 8}. The constraints say that no two queens can be in the same row or diagonal. A discrete domain can be infinite, such as the set of integers or strings. (If we didn’t put a deadline on the job-scheduling problem, there would be an infinite number of start times for each variable. ) With infinite domains, we must use implicit constraints like T1 + d1 ≤ T2 rather than explicit tuples of values. Special solution algorithms (which we do not discuss here) exist for linear constraints on integer variables—that is, constraints, such as the one just given, in which each variable appears only in linear form. It can be shown that no algorithm exists for solving general nonlinear constraints on integer variables—the problem is undecidable. Constraint satisfaction problems with continuous domains are common in the real world and are widely studied in the field of operations research. For example, the scheduling of experiments on the Hubble Space Telescope requires very precise timing of observations; the start and finish of each observation and maneuver are continuous-valued variables that must obey a variety of astronomical, precedence, and power constraints. The best-known category of continuous-domain CSPs is that of linear programming problems, where constraints must be linear equalities or inequalities. Linear programming problems can be solved in time polynomial in the number of variables. Problems with different types of constraints and objective functions have also been studied—quadratic programming, second-order conic programming, and so on. These problems constitute an important area of applied mathematics. In addition to examining the types of variables that can appear in CSPs, it is useful to look at the types of constraints. The simplest type is the unary constraint, which restricts the value of a single variable. For example, in the map-coloring problem it could be the case that South Australians won’t tolerate the color green; we can express that with the unary constraint 〈(SA), SA ≠ green〉. (The initial specification of the domain of a variable can also be seen as a unary constraint. ) A binary constraint relates two variables. For example, SA ≠ NSW is a binary constraint. A binary CSP is one with only unary and binary constraints; it can be represented as a constraint graph, as in Figure 5. 1(b). We can also define higher-order constraints. The ternary constraint Between(X, Y, Z), for example, can be defined as 〈(X, Y, Z), X < Y < Z or X > Y > Z〉. A constraint involving an arbitrary number of variables is called a global constraint. (The name is traditional but confusing because a global constraint need not involve all the variables in a problem). One of the most common global constraints is Alldiff, which says that all of the variables involved in the constraint must have different values. In Sudoku problems (see Section 5. 2. 6), all variables in a row, column, or 3 × 3 box must satisfy an Alldiff constraint. Another example is provided by cryptarithmetic puzzles (Figure 5. 2(a)). Each letter in a cryptarithmetic puzzle represents a different digit. For the case in Figure 5. 2(a), this would be represented as the global constraint Alldiff (F, T, U, W, R, O). The addition constraints on the four columns of the puzzle can be written as the following n-ary constraints: Description Up and down triangles represent MAX and MIN nodes, respectively. The first level of the game tree is labeled MAX and the MAX node is labeled ""A"". Node ""A"" is marked 3 and has three child nodes. The second level is labeled MIN and the three child nodes are MIN nodes that are labeled B, C, and D. An arrow labeled “a” subscript 1 from node “a” points to node B. Paths labeled “a” subscript 2 and “a” subscript 3 from node “a” connect to nodes C and D, respectively. The three nodes each have three child nodes that are MAX nodes. Node B is marked 3, C is marked 2, and D is marked 2. The three child nodes of B are marked 3, 12, and 8. Paths labeled b subscript 1, b subscript 2, and b subscript 3 connect node B to nodes 3, 12, and 8, respectively. The three child nodes of C are marked 2, 4, and 6. Paths labeled c subscript 1, c subscript 2, and c subscript 3 connect node C to nodes 2, 4, and 6, respectively. The three child nodes of D are marked 14, 5, and 2. Paths labeled d subscript 1, d subscript 2, and d subscript 3 connect node D to nodes 14, 5, and 2, respectively. Figure 5. 2 (a) A cryptarithmetic problem. Each letter stands for a distinct digit; the aim is to find a substitution of digits for letters such that the resulting sum is arithmetically correct, with the added restriction that no leading zeroes are allowed. (b) The constraint hypergraph for the cryptarithmetic problem, showing the Alldiff constraint (square box at the top) as well as the column addition constraints (four square boxes in the middle). The variables C1, C2, and C3 represent the carry digits for the three columns from right to left. where C1, C2, and C3 are auxiliary variables representing the digit carried over into the tens, hundreds, or thousands column. These constraints can be represented in a constraint hypergraph, such as the one shown in Figure 5. 2(b). A hypergraph consists of ordinary nodes (the circles in the figure) and hypernodes (the squares), which represent n-ary constraints—constraints involving n variables. Alternatively, as Exercise 5. NARY asks you to prove, every finite-domain constraint can be reduced to a set of binary constraints if enough auxiliary variables are introduced. This means that we could transform any CSP into one with only binary constraints—which certainly makes the life of the algorithm designer simpler. Another way to convert an n-ary CSP to a binary one is the dual graph transformation: create a new graph in which there will be one variable for each constraint in the original graph, and one binary constraint for each pair of constraints in the original graph that share variables. For example, consider a CSP with the variables χ = {X, Y, Z}, each with the domain {1, 2, 3, 4, 5}, and with the two constraints C1: 〈(X, Y, Z), X + Y = Z〉 and C2: 〈(X, Y), X +1 = Y〉. Then the dual graph would have the variables χ = {C1, C2}, where the domain of the C1 variable in the dual graph is the set of {(xi, yj, zk)} tuples from the C1 constraint in the original problem, and similarly the domain of C2 is the set of {(xi, yj)} tuples. The dual graph has the binary constraint 〈(C1, C2), R1〉, where R1 is a new relation that defines the constraint between C1 and C2; in this case it would be R1 = {((1, 2, 3), (1, 2)), ((2, 3, 5), (2, 3))}. There are however two reasons why we might prefer a global constraint such as Alldiff rather than a set of binary constraints. First, it is easier and less error-prone to write the problem description using Alldiff. Second, it is possible to design special-purpose inference algorithms for global constraints that are more efficient than operating with primitive constraints. We describe these inference algorithms in Section 5. 2. 5. The constraints we have described so far have all been absolute constraints, violation of which rules out a potential solution. Many real-world CSPs include preference constraints indicating which solutions are preferred. For example, in a university class-scheduling problem there are absolute constraints that no professor can teach two classes at the same time. But we also may allow preference constraints: Prof. R might prefer teaching in the morning, whereas Prof. N prefers teaching in the afternoon. A schedule that has Prof. R teaching at 2 p. m. would still be an allowable solution (unless Prof. R happens to be the department chair) but would not be an optimal one. Preference constraints can often be encoded as costs on individual variable assignments—for example, assigning an afternoon slot for Prof. R costs 2 points against the overall objective function, whereas a morning slot costs 1. With this formulation, CSPs with preferences can be solved with optimization search methods, either path-based or local. We call such a problem a constrained optimization problem, or COP. Linear programs are one class of COPs. 5. 2Constraint Propagation: Inference in CSPs An atomic state-space search algorithm makes progress in only one way: by expanding a node to visit the successors. A CSP algorithm has choices. It can generate successors by choosing a new variable assignment, or it can do a specific type of inference called constraint propagation: using the constraints to reduce the number of legal values for a variable, which in turn can reduce the legal values for another variable, and so on. The idea is that this will leave fewer choices to consider when we make the next choice of a variable assignment. Constraint propagation may be intertwined with search, or it may be done as a preprocessing step, before search starts. Sometimes this preprocessing can solve the whole problem, so no search is required at all. The key idea is local consistency. If we treat each variable as a node in a graph (see Figure 5. 1(b)) and each binary constraint as an edge, then the process of enforcing local consistency in each part of the graph causes inconsistent values to be eliminated throughout the graph. There are different types of local consistency, which we now cover in turn. 5. 2. 1Node consistency A single variable (corresponding to a node in the CSP graph) is node-consistent if all the values in the variable’s domain satisfy the variable’s unary constraints. For example, in the variant of the Australia map-coloring problem (Figure 5. 1) where South Australians dislike green, the variable SA starts with domain {red, green, blue}, and we can make it node consistent by eliminating green, leaving SA with the reduced domain {red, blue}. We say that a graph is node-consistent if every variable in the graph is node-consistent. It is easy to eliminate all the unary constraints in a CSP by reducing the domain of variables with unary constraints at the start of the solving process. As mentioned earlier, it is also possible to transform all n-ary constraints into binary ones. Because of this, some CSP solvers work with only binary constraints, expecting the user to eliminate the other constraints ahead of time. We make that assumption for the rest of this chapter, except where noted. 5. 2. 2Arc consistency A variable in a CSP is arc-consistent1 if every value in its domain satisfies the variable’s binary constraints. More formally, Xi is arc-consistent with respect to another variable Xj if for every value in the current domain Di there is some value in the domain Dj that satisfies the binary constraint on the arc (Xi, Xj). A graph is arc-consistent if every variable is arc-consistent with every other variable. For example, consider the constraint Y = X2 where the domain of both X and Y is the set of decimal digits. We can write this constraint explicitly as To make X arc-consistent with respect to Y, we reduce X’s domain to {0, 1, 2, 3}. If we also make Y arc-consistent with respect to X, then Y’s domain becomes {0, 1, 4, 9}, and the whole CSP is arc-consistent. On the other hand, arc consistency can do nothing for the Australia map-coloring problem. Consider the following inequality constraint on (SA, WA): No matter what value you choose for SA (or for WA), there is a valid value for the other variable. So applying arc consistency has no effect on the domains of either variable. The most popular algorithm for enforcing arc consistency is called AC-3 (see Figure 5. 3). To make every variable arc-consistent, the AC-3 algorithm maintains a queue of arcs to consider. Initially, the queue contains all the arcs in the CSP. (Each binary constraint becomes two arcs, one in each direction. ) AC-3 then pops off an arbitrary arc (Xi, Xj) from the queue and makes Xi arc-consistent with respect to Xj. If this leaves Di unchanged, the algorithm just moves on to the next arc. But if this revises Di (makes the domain smaller), then we add to the queue all arcs (Xk, Xi) where Xk is a neighbor of Xi. We need to do that because the change in Di might enable further reductions in Dk, even if we have previously considered Xk. If Di is revised down to nothing, then we know the whole CSP has no consistent solution, and AC-3 can immediately return failure. Otherwise, we keep checking, trying to remove values from the domains of variables until no more arcs are in the queue. At that point, we are left with a CSP that is equivalent to the original CSP—they both have the same solutions—but the arc-consistent CSP will be faster to search because its variables have smaller domains. In some cases, it solves the problem completely (by reducing every domain to size 1) and in others it proves that no solution exists (by reducing some domain to size 0). Description The game tree is a binary tree. The first level of the game tree is labeled to move ""A"" and the node is labeled (1, 2, 6). The two child nodes of (1, 2, 6) are labeled (1, 2, 6) and (0, 5, 2) and are in the second level. The second level is labeled to move B. An arrow from the node (1, 2, 6) in level “A” points to node (1, 2, 6) in level B. The two child nodes of (1, 2, 6) in level B are labeled (1, 2, 6) with a cross and (6, 1, 2) in the third level. The two child nodes of (0, 5, 2) in level B are labeled (0, 5, 2) and (5, 4, 5) in the third level. The third level is labeled to move C. The two child nodes of (1, 2, 6) with a cross are labeled (1, 2, 6) and (4, 2, 3) in the fourth level. The two child nodes of (6, 1, 2) in the level C are labeled (6, 1, 2) and (4, 7, 1) in the fourth level. The two child nodes of (0, 5, 2) in level C are labeled (0, 5, 2) and (5, 1, 1) in the fourth level. The two child nodes of (5, 4, 5) in level C are labeled (5, 4, 5) and (7, 7, 1) in the fourth level. The fourth level is labeled to move ""A"". Figure 5. 3The arc-consistency algorithm AC-3. After applying AC-3, either every arc is arc-consistent, or some variable has an empty domain, indicating that the CSP cannot be solved. The name “AC-3” was used by the algorithm’s inventor (Mackworth, 1977) because it was the third version developed in the paper. The complexity of AC-3 can be analyzed as follows. Assume a CSP with n variables, each with domain size at most d, and with c binary constraints (arcs). Each arc (Xk, Xi) can be inserted in the queue only d times because Xi has at most d values to delete. Checking consistency of an arc can be done in O(d2) time, so we get O(cd3) total worst-case time. 5. 2. 3Path consistency Suppose we are to color the map of Australia with just two colors, red and blue. Arc consistency does nothing because every constraint can be satisfied individually with red at one end and blue at the other. But clearly there is no solution to the problem: because Western Australia, Northern Territory, and South Australia all touch each other, we need at least three colors for them alone. Arc consistency tightens down the domains (unary constraints) using the arcs (binary constraints). To make progress on problems like map coloring, we need a stronger notion of consistency. Path consistency tightens the binary constraints by using implicit constraints that are inferred by looking at triples of variables. A two-variable set {Xi, Xj} is path-consistent with respect to a third variable Xm if, for every assignment {Xi = a, X j = b} consistent with the constraints (if any) on {Xi, Xj}, there is an assignment to Xm that satisfies the constraints on {Xi, Xm} and {Xm, Xj}. The name refers to the overall consistency of the path from Xi to Xj with Xm in the middle. Let’s see how path consistency fares in coloring the Australia map with two colors. We will make the set {WA, SA} path-consistent with respect to NT. We start by enumerating the consistent assignments to the set. In this case, there are only two: {WA = red, SA = blue} and {WA = blue, SA = red}. We can see that with both of these assignments NT can be neither red nor blue (because it would conflict with either WA or SA). Because there is no valid choice for NT, we eliminate both assignments, and we end up with no valid assignments for {WA, SA}. Therefore, we know that there can be no solution to this problem. 5. 2. 4K-consistency Stronger forms of propagation can be defined with the notion of k-consistency. A CSP is k-consistent if, for any set of k – 1 variables and for any consistent assignment to those variables, a consistent value can always be assigned to any kth variable. 1-consistency says that, given the empty set, we can make any set of one variable consistent: this is what we called node consistency. 2-consistency is the same as arc consistency. For binary constraint graphs, 3-consistency is the same as path consistency. A CSP is strongly k-consistent if it is k-consistent and is also (k – 1)-consistent, (k – 2)-consistent, . . . all the way down to 1-consistent. Now suppose we have a CSP with n nodes and make it strongly n-consistent (i. e. , strongly k-consistent for k = n). We can then solve the problem as follows: First, we choose a consistent value for X1. We are then guaranteed to be able to choose a value for X2 because the graph is 2-consistent, for X3 because it is 3-consistent, and so on. For each variable Xi, we need only search through the d values in the domain to find a value consistent with X1, . . . , Xi–1. The total run time is only O(n2d). Of course, there is no free lunch: constraint satisfaction is NP-complete in general, and any algorithm for establishing n-consistency must take time exponential in n in the worst case. Worse, n-consistency also requires space that is exponential in n. In practice, determining the appropriate level of consistency checking is mostly an empirical science. Computing 2-consistency is common, and 3-consistency less common. 5. 2. 5Global constraints Remember that a global constraint is one involving an arbitrary number of variables (but not necessarily all variables). Global constraints occur frequently in real problems and can be handled by special-purpose algorithms that are more efficient than the general-purpose methods described so far. For example, the Alldiff constraint says that all the variables involved must have distinct values (as in the cryptarithmetic problem above and Sudoku puzzles below). One simple form of inconsistency detection for Alldiff constraints works as follows: if m variables are involved in the constraint, and if they have n possible distinct values altogether, and m > n, then the constraint cannot be satisfied. This leads to the following simple algorithm: First, remove any variable in the constraint that has a singleton domain, and delete that variable’s value from the domains of the remaining variables. Repeat as long as there are singleton variables. If at any point an empty domain is produced or there are more variables than domain values left, then an inconsistency has been detected. This method can detect the inconsistency in the assignment {WA = red, NSW = red} for Figure 5. 1. Notice that the variables SA, NT, and Q are effectively connected by an Alldiff constraint because each pair must have two different colors. After applying AC-3 with the partial assignment, the domains of SA, NT, and Q are all reduced to {green, blue}. That is, we have three variables and only two colors, so the Alldiff constraint is violated. Thus, a simple consistency procedure for a higher-order constraint is sometimes more effective than applying arc consistency to an equivalent set of binary constraints. Another important higher-order constraint is the resource constraint, sometimes called the Atmost constraint. For example, in a scheduling problem, let P1, . . . , P4 denote the numbers of personnel assigned to each of four tasks. The constraint that no more than 10 personnel are assigned in total is written as Atmost(10, P1, P2, P3, P4). We can detect an inconsistency simply by checking the sum of the minimum values of the current domains; for example, if each variable has the domain {3, 4, 5, 6}, the Atmost constraint cannot be satisfied. We can also enforce consistency by deleting the maximum value of any domain if it is not consistent with the minimum values of the other domains. Thus, if each variable in our example has the domain {2, 3, 4, 5, 6}, the values 5 and 6 can be deleted from each domain. For large resource-limited problems with integer values—such as logistical problems involving moving thousands of people in hundreds of vehicles—it is usually not possible to represent the domain of each variable as a large set of integers and gradually reduce that set by consistency-checking methods. Instead, domains are represented by upper and lower bounds and are managed by bounds propagation. For example, in an airline-scheduling problem, let’s suppose there are two flights, F1 and F2, for which the planes have capacities 165 and 385, respectively. The initial domains for the numbers of passengers on flights F1 and F2 are then Now suppose we have the additional constraint that the two flights together must carry 420 people: F1 + F2 = 420. Propagating bounds constraints, we reduce the domains to We say that a CSP is bounds-consistent if for every variable X, and for both the lower-bound and upper-bound values of X, there exists some value of Y that satisfies the constraint between X and Y for every variable Y. This kind of bounds propagation is widely used in practical constraint problems. 5. 2. 6Sudoku The popular Sudoku puzzle has introduced millions of people to constraint satisfaction problems, although they may not realize it. A Sudoku board consists of 81 squares, some of which are initially filled with digits from 1 to 9. The puzzle is to fill in all the remaining squares such that no digit appears twice in any row, column, or 3 × 3 box (see Figure 5. 4). A row, column, or box is called a unit. The Sudoku puzzles that appear in newspapers and puzzle books have the property that there is exactly one solution. Although some can be tricky to solve by hand, taking tens of minutes, a CSP solver can handle thousands of puzzles per second. A Sudoku puzzle can be considered a CSP with 81 variables, one for each square. We use the variable names A1 through A9 for the top row (left to right), down to 11 through 19 for the bottom row. The empty squares have the domain {1, 2, 3, 4, 5, 6, 7, 8, 9} and the pre-filled squares have a domain consisting of a single value. In addition, there are 27 different Alldiff constraints, one for each unit (row, column, and box of 9 squares): Let us see how far arc consistency can take us. Assume that the Alldiff constraints have been expanded into binary constraints (such as A1 ≠ A2) so that we can apply the AC-3 algorithm directly. Consider variable E6 from Figure 5. 4(a)—the empty square between the 2 and the 8 in the middle box. From the constraints in the box, we can remove 1, 2, 7, and 8 from E6’s domain. From the constraints in its column, we can eliminate 5, 6, 2, 8, 9, and 3 (although 2 and 8 were already removed). That leaves E6 with a domain of {4}; in other words, we know the answer for E6. Now consider variable 16—the square in the bottom middle box surrounded by 1, 3, and 3. Applying arc consistency in its column, we eliminate 5, 6, 2, 4 (since we now know E6 must be 4), 8, 9, and 3. We eliminate 1 by arc consistency with I5, and we are left with only the value 7 in the domain of I6. Now there are 8 known values in column 6, so arc consistency can infer that A6 must be 1. Inference continues along these lines, and eventually, AC-3 can solve the entire puzzle—all the variables have their domains reduced to a single value, as shown in Figure 5. 4(b). Description Up and down triangles represent MAX and MIN nodes, respectively. At the top level, a max node is present and the level is labeled Player. The next level is labeled Opponent and a MIN node is labeled m. The nodes in the player and opponent levels are connected. After many levels, the next level is represented by another level labeled Player and a node present is a MAX node. This node is connected to the MAX node of the player level at the top by a dashed line. The last level is labeled Opponent and a MIN node is labeled n. The nodes in the last player and opponent levels are connected. Figure 5. 4(a) A Sudoku puzzle and (b) its solution. Of course, Sudoku would soon lose its appeal if every puzzle could be solved by a mechanical application of AC-3, and indeed AC-3 works only for the easiest Sudoku puzzles. Slightly harder ones can be solved by PC-2, but at a greater computational cost: there are 255, 960 different path constraints to consider in a Sudoku puzzle. To solve the hardest puzzles and to make efficient progress, we will have to be more clever. Indeed, the appeal of Sudoku puzzles for the human solver is the need to be resourceful in applying more complex inference strategies. Aficionados give them colorful names, such as “naked triples. ” That strategy works as follows: in any unit (row, column or box), find three squares that each have a domain that contains the same three numbers or a subset of those numbers. For example, the three domains might be {1, 8}, {3, 8}, and {1, 3, 8}. From that we don’t know which square contains 1, 3, or 8, but we do know that the three numbers must be distributed among the three squares. Therefore we can remove 1, 3, and 8 from the domains of every other square in the unit. It is interesting to note how far we can go without saying much that is specific to Sudoku. We do of course have to say that there are 81 variables, that their domains are the digits 1 to 9, and that there are 27 Alldiff constraints. But beyond that, all the strategies—arc consistency, path consistency, and so on—apply generally to all CSPs, not just to Sudoku problems. Even naked triples is really a strategy for enforcing consistency of Alldiff constraints and is not specific to Sudoku per se. This is the power of the CSP formalism: for each new problem area, we only need to define the problem in terms of constraints; then the general constraintsolving mechanisms can take over. 5. 3Backtracking Search for CSPs Sometimes we can finish the constraint propagation process and still have variables with multiple possible values. In that case we have to search for a solution. In this section we cover backtracking search algorithms that work on partial assignments; in the next section we look at local search algorithms over complete assignments. Consider how a standard depth-limited search (from Chapter 3) could solve CSPs. A state would be a partial assignment, and an action would extend the assignment, adding, say, NSW = red or SA = blue for the Australia map-coloring problem. For a CSP with n variables of domain size d we would end up with a search tree where all the complete assignments (and thus all the solutions) are leaf nodes at depth n. But notice that the branching factor at the top level would be nd because any of d values can be assigned to any of n variables. At the next level, the branching factor is (n – 1)d, and so on for n levels. So the tree has n! · dn leaves, even though there are only dn possible complete assignments! We can get back that factor of n! by recognizing a crucial property of CSPs: commutativity. A problem is commutative if the order of application of any given set of actions does not matter. In CSPs, it makes no difference if we first assign NSW = red and then SA = blue, or the other way around. Therefore, we need only consider a single variable at each node in the search tree. At the root we might make a choice between SA = red, SA = green, and SA = blue, but we would never choose between NSW = red and SA = blue. With this restriction, the number of leaves is dn, as we would hope. At each level of the tree we do have to choose which variable we will deal with, but we never have to backtrack over that choice. Figure 5. 5 shows a backtracking search procedure for CSPs. It repeatedly chooses an unassigned variable, and then tries all values in the domain of that variable in turn, trying to extend each one into a solution via a recursive call. If the call succeeds, the solution is returned, and if it fails, the assignment is restored to the previous state, and we try the next value. If no value works then we return failure. Part of the search tree for the Australia problem is shown in Figure 5. 6, where we have assigned variables in the order WA, NT, Q, . . . . Description Part (“a”): The blacks are in the following positions. King, e 8. Queen, g 2. Rooks, ""a"" 8 and h 8. Bishop, c 8. Knights d 4 and g 8. Pawns, ""a"" 7, b 7, c 7, d 6, e 5, f 7, g 7, and h 7. The whites are in the following positions. King, e 1. Queen, d 1. Rooks, ""a"" 1 and h 1. Bishop, c 4. Knight c3. Pawns, ""a"" 2, b 2, c 2, e 4, f 2, and h 2. Part (b): All the pieces are in the same positions as in part (“a”), except the white rook at h 1 moves to g 1. Figure 5. 5A simple backtracking algorithm for constraint satisfaction problems. The algorithm is modeled on the recursive depth-first search of Chapter 3. The functions SELECT-UNASSIGNED-VARIABLE and ORDER-DOMAIN-VALUES implement the generalpurpose heuristics discussed in Section 5. 3. 1. The INFERENCE function can optionally impose arc-, path-, or k-consistency, as desired. If a value choice leads to failure (noticed either by INFERENCE or by BACKTRACK), then value assignments (including those made by INFERENCE) are retracted and a new value is tried. Description The blacks are in the following positions. King, g 7. Bishop, ""a"" 2. Pawns, g 6, f 5, e 4, and b 4. The whites are in the following positions. King, d 2. Rook, h 2. Pawns, c 2 and b 3. Figure 5. 6Part of the search tree for the map-coloring problem in Figure 5. 1. Notice that BACKTRACKING-SEARCH keeps only a single representation of a state (assignment) and alters that representation rather than creating new ones (see page 98). Whereas the uninformed search algorithms of Chapter 3 could be improved only by supplying them with domain-specific heuristics, it turns out that backtracking search can be improved using domain-independent heuristics that take advantage of the factored representation of CSPs. In the following four sections we show how this is done: •(5. 3. 1) Which variable should be assigned next (SELECT-UNASSIGNED-VARIABLE), and in what order should its values be tried (ORDER-DOMAIN-VALUES)? •(5. 3. 2) What inferences should be performed at each step in the search (INFERENCE)? •(5. 3. 3) Can we BACKTRACK more than one step when appropriate? •(5. 3. 4) Can we save and reuse partial results from the search? 5. 3. 1Variable and value ordering The backtracking algorithm contains the line The simplest strategy for SELECT-UNASSIGNED-VARIABLE is static ordering: choose the variables in order, {X1, X2, . . . }. The next simplest is to choose randomly. Neither strategy is optimal. For example, after the assignments for WA = red and NT = green in Figure 5. 6, there is only one possible value for SA, so it makes sense to assign SA = blue next rather than assigning Q. in fact, after SA is assigned, the choices for Q, NSW, and V are all forced. This intuitive idea—choosing the variable with the fewest “legal” values—is called the minimum-remaining-values (MRV) heuristic. It also has been called the “most constrained variable” or “fail-first” heuristic, the latter because it picks a variable that is most likely to cause a failure soon, thereby pruning the search tree. If some variable X has no legal values left, the MRV heuristic will select X and failure will be detected immediately—avoiding pointless searches through other variables. The MRV heuristic usually performs better than a random or static ordering, sometimes by orders of magnitude, although the results vary depending on the problem. The MRV heuristic doesn’t help at all in choosing the first region to color in Australia, because initially every region has three legal colors. In this case, the degree heuristic comes in handy. It attempts to reduce the branching factor on future choices by selecting the variable that is involved in the largest number of constraints on other unassigned variables. In Figure 5. 1, SA is the variable with highest degree, 5; the other variables have degree 2 or 3, except for T, which has degree 0. If we assign the SA first, we can then go around the five mainland regions in clockwise or counterclockwise order and assign each one a color that is different than SA and different than the previous region. The minimum-remaining-values heuristic is usually a more powerful guide, but the degree heuristic can be useful as a tie-breaker. Once a variable has been selected, the algorithm must decide on the order in which to examine its values. The least-constraining-value heuristic is effective for this. It prefers the value that rules out the fewest choices for the neighboring variables in the constraint graph. For example, suppose that in Figure 5. 1 we have generated the partial assignment with WA = red and NT = green and that our next choice is for Q. Blue would be a bad choice because it eliminates the last legal value left for Q’s neighbor, SA. The least-constraining-value heuristic therefore prefers red to blue. In general, the heuristic is trying to leave the maximum flexibility for subsequent variable assignments. Why should variable selection be fail-first, but value selection be fail-last? Every variable has to be assigned eventually, so by choosing the ones that are likely to fail first, we will on average have fewer successful assignments to backtrack over. For value ordering, the trick is that we only need one solution; therefore it makes sense to look for the most likely values first. If we wanted to enumerate all solutions rather than just find one, then value ordering would be irrelevant. 5. 3. 2Interleaving search and inference We saw how AC-3 can reduce the domains of variables before we begin the search. But inference can be even more powerful during the course of a search: every time we make a choice of a value for a variable, we have a brand-new opportunity to infer new domain reductions on the neighboring variables. One of the simplest forms of inference is called forward checking. Whenever a variable X is assigned, the forward-checking process establishes arc consistency for it: for each unassigned variable Y that is connected to X by a constraint, delete from Y 's domain any value that is inconsistent with the value chosen for X. Figure 5. 7 shows the progress of backtracking search on the Australia CSP with forward checking. There are two important points to notice about this example. First, notice that after WA = red and Q = green are assigned, the domains of NT and SA are reduced to a single value; we have eliminated branching on these variables altogether by propagating information from WA and Q. A second point to notice is that after V = blue, the domain of SA is empty. Hence, forward checking has detected that the partial assignment {WA = red, Q = green, V = blue} is inconsistent with the constraints of the problem, and the algorithm backtracks immediately. Description Part (“a”): Selection. The node at the top is labeled 37 by 100. The three child nodes of the node are labeled 60 by 79, 1 by 10, and 2 by 11. The two child nodes of 60 by 79 are labeled 3 by 26 and 16 by 53. The two child nodes of 1 by 10 are labeled 6 by 6 and 3 by 4. The two child nodes of 16 by 53 are labeled 27 by 35 and 10 by 18. The two child nodes of 6 by 6 are labeled 0 by 3 and 0 by 3. Normal arrows are shown from parent nodes to child nodes. Bold arrows are shown for the following. From 37 by 100 to 60 by 79. From 60 by 79 to 16 by 53. From 16 by 53 to 27 by 35. Part (b): Expansion and simulation. The node at the top is labeled 37 by 100. The three child nodes of the node are labeled 60 by 79, 1 by 10, and 2 by 11. The two child nodes of 60 by 79 are labeled 3 by 26 and 16 by 53. The two child nodes of 1 by 10 are labeled 6 by 6 and 3 by 4. The two child nodes of 16 by 53 are labeled 27 by 35 and 10 by 18. The two child nodes of 6 by 6 are labeled 0 by 3 and 0 by 3. The child node of 27 by 35 is labeled 0 by 0. Normal arrows are shown from parent nodes to child nodes. A bold arrow is shown from 27 by 35 to 0 by 0. A curved arrow from 0 by 0 is labeled black wins. Part (c): Backpropagation. The node at the top is labeled 37 by 101. The three child nodes of the node are labeled 61 by 80, 1 by 10, and 2 by 11. The two child nodes of 61 by 80 are labeled 3 by 26 and 16 by 54. The two child nodes of 1 by 10 are labeled 6 by 6 and 3 by 4. The two child nodes of 16 by 54 are labeled 28 by 36 and 10 by 18. The two child nodes of 6 by 6 are labeled 0 by 3 and 0 by 3. The child node of 28 by 36 is labeled 0 by 1. Normal arrows are shown from parent nodes to child nodes. Bold arrows are shown from child nodes to parent nodes for the following. From 0 by 1 to 28 by 36. From 28 by 36 to 16 by 54. From 16 by 54 to 61 by 80. From 61 by 80 to 37 by 101. Figure 5. 7The progress of a map-coloring search with forward checking. WA = red is assigned first; then forward checking deletes red from the domains of the neighboring variables NT and SA. After Q = green is assigned, green is deleted from the domains of NT, SA, and NSW. After V = blue is assigned, blue is deleted from the domains of NSW and SA, leaving SA with no legal values. For many problems the search will be more effective if we combine the MRV heuristic with forward checking. Consider Figure 5. 7 after assigning {WA = red}. Intuitively, it seems that that assignment constrains its neighbors, NT and SA, so we should handle those variables next, and then all the other variables will fall into place. That’s exactly what happens with MRV: NT and SA each have two values, so one of them is chosen first, then the other, then Q, NSW, and V in order. Finally T still has three values, and any one of them works. We can view forward checking as an efficient way to incrementally compute the information that the MRV heuristic needs to do its job. Although forward checking detects many inconsistencies, it does not detect all of them. The problem is that it doesn't look ahead far enough. For example, consider the Q = green row of Figure 5. 7. We’ve made WA and Q arc-consistent, but we’ve left both NT and SA with blue as their only possible value, which is an inconsistency, since they are neighbors. The algorithm called MAC (for Maintaining Arc Consistency) detects inconsistencies like this. After a variable Xi is assigned a value, the INFERENCE procedure calls AC-3, but instead of a queue of all arcs in the CSP, we start with only the arcs (Xj, Xi) for all Xj that are unassigned variables that are neighbors of Xi. From there, AC-3 does constraint propagation in the usual way, and if any variable has its domain reduced to the empty set, the call to AC-3 fails and we know to backtrack immediately. We can see that MAC is strictly more powerful than forward checking because forward checking does the same thing as MAC on the initial arcs in MAC’s queue; but unlike MAC, forward checking does not recursively propagate constraints when changes are made to the domains of variables. 5. 3. 3Intelligent backtracking: Looking backward The BACKTRACKING-SEARCH algorithm in Figure 5. 5 has a very simple policy for what to do when a branch of the search fails: back up to the preceding variable and try a different value for it. This is called chronological backtracking because the most recent decision point is revisited. in this subsection, we consider better possibilities. Consider what happens when we apply simple backtracking in Figure 5. 1 with a fixed variable ordering Q, NSW, V, T, SA, WA, NT. Suppose we have generated the partial assignment {Q = red, NSW = green, V = blue, T = red}. When we try the next variable, SA, we see that every value violates a constraint. We back up to T and try a new color for Tasmania! Obviously this is silly—recoloring Tasmania cannot possibly help in resolving the problem with South Australia. A more intelligent approach is to backtrack to a variable that might fix the problem—a variable that was responsible for making one of the possible values of SA impossible. To do this, we will keep track of a set of assignments that are in conflict with some value for SA. The set (in this case {Q = red, NSW = green, V = blue}), is called the conflict set for SA. The backjumping method backtracks to the most recent assignment in the conflict set; in this case, backjumping would jump over Tasmania and try a new value for V. This method is easily implemented by a modification to BACKTRACK such that it accumulates the conflict set while checking for a legal value to assign. If no legal value is found, the algorithm should return the most recent element of the conflict set along with the failure indicator. The sharp-eyed reader may have noticed that forward checking can supply the conflict set with no extra work: whenever forward checking based on an assignment X = x deletes a value from Y’s domain, it should add X = x to Y’s conflict set. If the last value is deleted from Y’s domain, then the assignments in the conflict set of Y are added to the conflict set of X. That is, we now know that X = x leads to a contradiction (in Y), and thus a different assignment should be tried for X. The eagle-eyed reader may have noticed something odd: backjumping occurs when every value in a domain is in conflict with the current assignment; but forward checking detects this event and prevents the search from ever reaching such a node! In fact, it can be shown that every branch pruned by backjumping is also pruned by forward checking. Hence, simple backjumping is redundant in a forward-checking search or, indeed, in a search that uses stronger consistency checking, such as MAC—you need only do one or the other. Despite the observations of the preceding paragraph, the idea behind backjumping remains a good one: to backtrack based on the reasons for failure. Backjumping notices failure when a variable’s domain becomes empty, but in many cases a branch is doomed long before this occurs. Consider again the partial assignment {WA = red, NSW = red} (which, from our earlier discussion, is inconsistent). Suppose we try T = red next and then assign NT, Q, V, SA. We know that no assignment can work for these last four variables, so eventually we run out of values to try at NT. Now, the question is, where to backtrack? Backjumping cannot work, because NT does have values consistent with the preceding assigned variables—NT doesn’t have a complete conflict set of preceding variables that caused it to fail. We know, however, that the four variables NT, Q, V, and SA, taken together, failed because of a set of preceding variables, which must be those variables that directly conflict with the four. This leads to a different–and deeper–notion of the conflict set for a variable such as NT: it is that set of preceding variables that caused NT, together with any subsequent variables, to have no consistent solution. In this case, the set is WA and NSW, so the algorithm should backtrack to NSW and skip over Tasmania. A backjumping algorithm that uses conflict sets defined in this way is called conflict-directed backjumping. We must now explain how these new conflict sets are computed. The method is in fact quite simple. The “terminal” failure of a branch of the search always occurs because a variable’s domain becomes empty; that variable has a standard conflict set. In our example, SA fails, and its conflict set is (say) {WA, NT, Q}. We backjump to Q, and Q absorbs the conflict set from SA (minus Q itself, of course) into its own direct conflict set, which is {NT, NSW}; the new conflict set is {WA, NT, NSW}. That is, there is no solution from Q onward, given the preceding assignment to {WA, NT, NSW}. Therefore, we backtrack to NT, the most recent of these. NT absorbs {WA, NT, NSW} – {NT} into its own direct conflict set {WA}, giving {WA, NSW} (as stated in the previous paragraph). Now the algorithm backjumps to NSW, as we would hope. To summarize: let Xj be the current variable, and let conf (Xj) be its conflict set. If every possible value for Xj fails, backjump to the most recent variable Xi in conf (Xj) and recompute the conflict set for Xi as follows: 5. 3. 4Constraint learning When we reach a contradiction, backjumping can tell us how far to back up, so we don’t waste time changing variables that won’t fix the problem. But we would also like to avoid running into the same problem again. When the search arrives at a contradiction, we know that some subset of the conflict set is responsible for the problem. Constraint learning is the idea of finding a minimum set of variables from the conflict set that causes the problem. This set of variables, along with their corresponding values, is called a no-good. We then record the no-good, either by adding a new constraint to the CSP to forbid this combination of assignments or by keeping a separate cache of no-goods. For example, consider the state {WA = red, NT = green, Q = blue} in the bottom row of Figure 5. 6. Forward checking can tell us this state is a no-good because there is no valid assignment to SA. In this particular case, recording the no-good would not help, because once we prune this branch from the search tree, we will never encounter this combination again. But suppose that the search tree in Figure 5. 6 were actually part of a larger search tree that started by first assigning values for V and T. Then it would be worthwhile to record {WA = red, NT = green, Q = blue} as a no-good because we are going to run into the same problem again for each possible set of assignments to V and T. No-goods can be effectively used by forward checking or by backjumping. Constraint learning is one of the most important techniques used by modern CSP solvers to achieve efficiency on complex problems. 5. 4Local Search for CSPs Local search algorithms (see Section 4. 1) turn out to be very effective in solving many CSPs. They use a complete-state formulation (as introduced in Section 4. 1. 1) where each state assigns a value to every variable, and the search changes the value of one variable at a time. As an example, we’ll use the 8-queens problem, as defined as a CSP on page 167. In Figure 5. 8 we start on the left with a complete assignment to the 8 variables; typically this will violate several constraints. We then randomly choose a conflicted variable, which turns out to be Q8, the rightmost column. We’d like to change the value to something that brings us closer to a solution; the most obvious approach is to select the value that results in the minimum number of conflicts with other variables—the min-conflicts heuristic. Description Two dice show the numbers 6 and 5. The columns in the top row are numbered from 1 to 12 from the left to right. The columns in the bottom row are numbered from 13 to 24 from the right to left. Top row: Column 1, two whites. Column 2, empty. Column 3, three blacks. Column 4, two whites. Column 5, two blacks. Column 6, three blacks. Column 7, three whites. Column 8, two whites. Column 9, two whites. Column 10, one white. Columns 11 and 12, empty. Bottom row: Column 13 to 18, empty. Column 19, two blacks. Column 20, empty. Column 21, two blacks. Column 22, two blacks. Column 23, three blacks. Column 24, one black. Figure 5. 8A two-step solution using min-conflicts for an 8-queens problem. At each stage, a queen is chosen for reassignment in its column. The number of conflicts (in this case, the number of attacking queens) is shown in each square. The algorithm moves the queen to the min-conflicts square, breaking ties randomly. In the figure we see there are two rows that only violate one constraint; we pick Q8 = 3 (that is, we move the queen to the 8th column, 3rd row). On the next iteration, in the middle board of the figure, we select Q6 as the variable to change, and note that moving the queen to the 8th row results in no conflicts. At this point there are no more conflicted variables, so we have a solution. The algorithm is shown in Figure 5. 9. 2 Description Up and down triangles represent MAX and MIN nodes and circles represent CHANCE nodes. The first level of the game tree is labeled MAX and the root node is a MAX node. The second level is labeled CHANCE and contains many circles. Paths from the node in the MAX level connect to each circle. The third level is labeled MIN and the nodes are MIN nodes. Four nodes are shown with labels 1 by 36, 1 to 1; 1 by 18, 1 to 2; 1 by 18, 6 to 5; and 1 by 36, 6 to 6. Paths from the third circle in the CHANCE level connect to each of the nodes in the MIN level. The fourth level is labeled CHANCE and contains many circles. The first circle is labeled C. Paths from the MIN node labeled 1 by 18, 6 to 5 in the MIN level connect to each of the circles in the second CHANCE level. The fifth level is labeled MAX and the nodes are MAX nodes. Four nodes are shown with labels 1 by 36, 1 to 1; 1 by 18, 1 to 2; 1 by 18, 6 to 5; and 1 by 36, 6 to 6. Paths from circle C in the second CHANCE level connect to each node in the second MAX level. The final level is labeled TERMINAL. Paths from the MAX node labeled 1 by 18, 6 to 5 in the second MAX level connect to the nodes in the terminal level. The nodes are labeled 2, negative 1, 1, negative 1, and 1. Figure 5. 9The MIN-CONFLICTS local search algorithm for CSPs. The initial state may be chosen randomly or by a greedy assignment process that chooses a minimal-conflict value for each variable in turn. The CONFLICTS function counts the number of constraints violated by a particular value, given the rest of the current assignment. Min-conflicts is surprisingly effective for many CSPs. Amazingly, on the n-queens problem, if you don’t count the initial placement of queens, the run time of min-conflicts is roughly independent of problem size. It solves even the million-queens problem in an average of 50 steps (after the initial assignment). This remarkable observation was the stimulus leading to a great deal of research in the 1990s on local search and the distinction between easy and hard problems, which we take up in Section 7. 6. 3. Roughly speaking, n-queens is easy for local search because solutions are densely distributed throughout the state space. Min-conflicts also works well for hard problems. For example, it has been used to schedule observations for the Hubble Space Telescope, reducing the time taken to schedule a week of observations from three weeks (! ) to around 10 minutes. All the local search techniques from Section 4. 1 are candidates for application to CSPs, and some of those have proved especially effective. The landscape of a CSP under the min- conflicts heuristic usually has a series of plateaus. There may be millions of variable assignments that are only one conflict away from a solution. Plateau search—allowing sideways moves to another state with the same score—can help local search find its way off this plateau. This wandering on the plateau can be directed with a technique called tabu search: keeping a small list of recently visited states and forbidding the algorithm to return to those states. Simulated annealing can also be used to escape from plateaus. Another technique called constraint weighting aims to concentrate the search on the important constraints. Each constraint is given a numeric weight, initially all 1. At each step of the search, the algorithm chooses a variable/value pair to change that will result in the lowest total weight of all violated constraints. The weights are then adjusted by incrementing the weight of each constraint that is violated by the current assignment. This has two benefits: it adds topography to plateaus, making sure that it is possible to improve from the current state, and it also adds learning: over time the difficult constraints are assigned higher weights. Another advantage of local search is that it can be used in an online setting (see section 4. 5) when the problem changes. Consider a scheduling problem for an airline’s weekly flights. The schedule may involve thousands of flights and tens of thousands of personnel assignments, but bad weather at one airport can render the schedule infeasible. We would like to repair the schedule with a minimum number of changes. This can be easily done with a local search algorithm starting from the current schedule. A backtracking search with the new set of constraints usually requires much more time and might find a solution with many changes from the current schedule. 5. 5The Structure of Problems In this section, we examine ways in which the structure of the problem, as represented by the constraint graph, can be used to find solutions quickly. Most of the approaches here also apply to other problems besides CSPs, such as probabilistic reasoning. The only way we can possibly hope to deal with the vast real world is to decompose it into subproblems. Looking again at the constraint graph for Australia (Figure 5. 1(b), repeated as Figure 5. 12(a)), one fact stands out: Tasmania is not connected to the mainland. 3 Intuitively, it is obvious that coloring Tasmania and coloring the mainland are independent subproblems—any solution for the mainland combined with any solution for Tasmania yields a solution for the whole map. Independence can be ascertained simply by finding connected components of the constraint graph. Each component corresponds to a subproblem CSPi. If assignment Si is a solution of CSPi, then ⋃iSi is a solution of ⋃iCSPi. Why is this important? Suppose each CSPi has c variables from the total of n variables, where c is a constant. Then there are n/c subproblems, each of which takes at most dc work to solve, where d is the size of the domain. Hence, the total work is O(dcn/c), which is linear in n; without the decomposition, the total work is O(dn), which is exponential in n. Let’s make this more concrete: dividing a Boolean CSP with 100 variables into four subproblems reduces the worst-case solution time from the lifetime of the universe down to less than a second. Completely independent subproblems are delicious, then, but rare. Fortunately, some other graph structures are also easy to solve. For example, a constraint graph is a tree when any two variables are connected by only one path. We will show that any tree-structured CSP can be solved in time linear in the number of variables. 4 The key is a new notion of consistency, called directional arc consistency or DAC. A CSP is defined to be directional arc-consistent under an ordering of variables X1, X2, . . . , Xn if and only if every Xi is arc-consistent with each Xj for j > i. To solve a tree-structured CSP, first pick any variable to be the root of the tree, and choose an ordering of the variables such that each variable appears after its parent in the tree. Such an ordering is called a topological sort. Figure 5. 10(a) shows a sample tree and (b) shows one possible ordering. Any tree with n nodes has n – 1 edges, so we can make this graph directed arc-consistent in O(n) steps, each of which must compare up to d possible domain values for two variables, for a total time of O(nd2). Once we have a directed arc-consistent graph, we can just march down the list of variables and choose any remaining value. Since each edge from a parent to its child is arc-consistent, we know that for any value we choose for the parent, there will be a valid value left to choose for the child. That means we won’t have to backtrack; we can move linearly through the variables. The complete algorithm is shown in Figure 5. 11. Description Two three-level binary trees are shown. Up and down triangles represent MAX and MIN nodes, respectively, and circles represent CHANCE nodes. Binary tree 1: The first level of the game tree is labeled MAX and a MAX node is present. The node connects to two nodes in the second level. The second level is labeled CHANCE and the two nodes are CHANCE nodes labeled 2. 1 and 1. 3. An arrow labeled “a” subscript 1 from the MAX node connects to node 2. 1. A path labeled “a” subscript 2 from the MAX node connects to node 1. 3. The two nodes in the CHANCE level each have two child nodes in the third level. The third level is labeled MIN and has four MIN nodes. The two child nodes of 2. 1 are labeled 2 and 3. Paths labeled 0. 9 and 0. 1 from node 2. 1 connect to nodes 2 and 3, respectively. The two child nodes of 1. 3 are labeled 1 and 4. Paths labeled 0. 9 and 0. 1 from node 1. 3 connect to nodes 1 and 4, respectively. The two child nodes of 1 are labeled 1 and 1. The two child nodes of 2 are labeled 2 and 2. The two child nodes of 3 are labeled 3 and 3. The two child nodes of 4 are labeled 4 and 4. Binary tree 2: The first level of the game tree is labeled MAX and a MAX node is present. The node connects to two nodes in the second level. The second level is labeled CHANCE and the two nodes are CHANCE nodes labeled 21 and 40. 9. An arrow labeled “a” subscript 2 from the MAX node connects to node 40. 9. A path labeled “a” subscript 1 from the MAX node connects to node 21. The two nodes in the CHANCE level each have two child nodes in the third level. The third level is labeled MIN and has four MIN nodes. The two child nodes of 21 are labeled 20 and 30. Paths labeled 0. 9 and 0. 1 from node 21 connect to nodes 20 and 30, respectively. The two child nodes of 40. 9 are labeled 1 and 400. Paths labeled 0. 9 and 0. 1 from node 40. 9 connect to nodes 1 and 400, respectively. The two child nodes of 1 are labeled 1 and 1. The two child nodes of 20 are labeled 20 and 20. The two child nodes of 30 are labeled 30 and 30. The two child nodes of 400 are labeled 400 and 400. Figure 5. 10(a) The constraint graph of a tree-structured CSP. (b) A linear ordering of the variables consistent with the tree with A as the root. This is known as a topological sort of the variables. Description Five reduced chess boards are shown. The chess boards are reduced to 4 by 4, with row labels “a” to d from left to right and column labels 1 to 4 from bottom to top. Board 1: The blacks are in the following positions. Kings, “a” 4, b 4, and c 4. The whites are in the following positions. King, d 2. Rook d 3. A line labeled K c 3 question mark from Board 1 connects to a circular node. An arrow labeled Illegal from the node points to board 2. Board 2: The blacks are in the following positions. Kings, b 4 and c 4. The whites are in the following positions. King, d 2. Rook d 3. A line labeled R c 3 connects Board 2 to a second circular node. An arrow labeled OK from the second node points to board 3. Board 3: A black is in the following position. King, b 4. The whites are in the following positions. King, d 2. Rook c 3. Another arrow labeled Check from the second node points to board 4. Board 4: A black is in the following position. King, b 4. The whites are in the following positions. King, d 2. Rook c 3. An arrow labeled OK from the first node points to board 5. Board 5: A black is in the following position. King, ""a"" 4. The whites are in the following positions. King, c 3. Rook d 3. Figure 5. 11The TREE-CSP-SOLVER algorithm for solving tree-structured CSPs. If the CSP has a solution, we will find it in linear time; if not, we will detect a contradiction. Now that we have an efficient algorithm for trees, we can consider whether more general constraint graphs can be reduced to trees somehow. There are two ways to do this: by removing nodes (Section 5. 5. 1) or by collapsing nodes together (Section 5. 5. 2). 5. 5. 1Cutset conditioning The first way to reduce a constraint graph to a tree involves assigning values to some variables so that the remaining variables form a tree. Consider the constraint graph for Australia, shown again in Figure 5. 12(a). Without South Australia, the graph would become a tree, as in (b). Fortunately, we can delete South Australia (in the graph, not the country) by fixing a value for SA and deleting from the domains of the other variables any values that are inconsistent with the value chosen for SA. Description The first level of game tree is labeled MAX and the node is labeled ""A"". Node ""A"" has two child nodes. Node ""A"" is represented by an up triangle. The second level is labeled MIN and the two nodes are labeled 99 and 100. The two nodes are represented by down triangles and each has four child nodes. The four child nodes of B are labeled 99, 1000, 1000, and 1000 and represented by up triangles. The four child nodes of 100 are labeled 100, 101, 102, and 103 and represented by up triangles. Figure 5. 12(a) The original constraint graph from Figure 5. 1. (b) After the removal of SA, the constraint graph becomes a forest of two trees. Now, any solution for the CSP after SA and its constraints are removed will be consistent with the value chosen for SA. (This works for binary CSPs; the situation is more complicated with higher-order constraints. ) Therefore, we can solve the remaining tree with the algorithm given above and thus solve the whole problem. Of course, in the general case (as opposed to map coloring), the value chosen for SA could be the wrong one, so we would need to try each possible value. The general algorithm is as follows: 1. Choose a subset S of the CSP’s variables such that the constraint graph becomes a tree after removal of S. S is called a cycle cutset. 2. For each possible assignment to the variables in S that satisfies all constraints on S, (a)remove from the domains of the remaining variables any values that are inconsistent with the assignment for S, and (b)if the remaining CSP has a solution, return it together with the assignment for S. If the cycle cutset has size c, then the total run time is O(dc · (n – c)d2): we have to try each of the dc combinations of values for the variables in S, and for each combination we must solve a tree problem of size n – c. If the graph is “nearly a tree, ” then c will be small and the savings over straight backtracking will be huge—for our 100-Boolean-variable example, if we could find a cutset of size c = 20, this would get us down from the lifetime of the Universe to a few minutes. In the worst case, however, c can be as large as (n – 2). Finding the smallest cycle cutset is NP-hard, but several efficient approximation algorithms are known. The overall algorithmic approach is called cutset conditioning; it comes up again in Chapter 13, where it is used for reasoning about probabilities. 5. 5. 2Tree decomposition The second way to reduce a constraint graph to a tree is based on constructing a tree decomposition of the constraint graph: a transformation of the original graph into a tree where each node in the tree consists of a set of variables, as in Figure 5. 13. A tree decomposition must satisfy these three requirements: Figure 5. 13A tree decomposition of the constraint graph in Figure 5. 12(a). •Every variable in the original problem appears in at least one of the tree nodes. •If two variables are connected by a constraint in the original problem, they must appear together (along with the constraint) in at least one of the tree nodes. •If a variable appears in two nodes in the tree, it must appear in every node along the path connecting those nodes. The first two conditions ensure that all the variables and constraints are represented in the tree decomposition. The third condition seems rather technical, but allows us to say that any variable from the original problem must have the same value wherever it appears: the constraints in the tree say that a variable in one node of the tree must have the same value as the corresponding variable in the adjacent node in the tree. For example, SA appears in all four of the connected nodes in Figure 5. 13, so each edge in the tree decomposition therefore includes the constraint that the value of SA in one node must be the same as the value of SA in the next. You can verify from Figure 5. 12 that this decomposition makes sense. Once we have a tree-structured graph, we can apply TREE-CSP-SOLVER to get a solution in O(nd2) time, where n is the number of tree nodes and d is the size of the largest domain. But note that in the tree, a domain is a set of tuples of values, not just individual values. For example, the top left node in Figure 5. 13 represents, at the level of the original problem, a subproblem with variables {WA, NT, SA}, domain {red, green, blue}, and constraints WA ≠ NT, SA ≠ NT, WA ≠ SA. At the level of the tree, the node represents a single variable, which we can call SANTWA, whose value must be a three-tuple of colors, such as (red, green, blue), but not (red, red, blue), because that would violate the constraint SA ≠ NT from the original problem. We can then move from that node to the adjacent one, with the variable we can call SANTQ, and find that there is only one tuple, (red, green, blue), that is consistent with the choice for SANTWA. The exact same process is repeated for the next two nodes, and independently we can make any choice for T. We can solve any tree decomposition problem in O(nd2) time with TREE-CSP-SOLVER, which will be efficient as long as d remains small. Going back to our example with 100 Boolean variables, if each node has 10 variables, then d = 210 and we should be able to solve the problem in seconds. But if there is a node with 30 variables, it would take centuries. A given graph admits many tree decompositions; in choosing a decomposition, the aim is to make the subproblems as small as possible. (Putting all the variables into one node is technically a tree, but is not helpful. ) The tree width of a tree decomposition of a graph is one less than the size of the largest node; the tree width of the graph itself is defined to be the minimum width among all its tree decompositions. If a graph has tree width w then the problem can be solved in O(ndw+1) time given the corresponding tree decomposition. Hence, CSPs with constraint graphs of bounded tree width are solvable in polynomial time. Unfortunately, finding the decomposition with minimal tree width is NP-hard, but there are heuristic methods that work well in practice. Which is better: the cutset decomposition with time O(dc · (n — c)d2), or the tree decomposition with time O(ndw+1)? Whenever you have a cycle-cutset of size c, there is also a tree width of size w < c + 1, and it may be far smaller in some cases. So time consideration favors tree decomposition, but the advantage of the cycle-cutset approach is that it can be executed in linear memory, while tree decomposition requires memory exponential in w. 5. 5. 3Value symmetry So far, we have looked at the structure of the constraint graph. There can also be important structure in the values of variables, or in the structure of the constraint relations themselves. Consider the map-coloring problem with d colors. For every consistent solution, there is actually a set of d! solutions formed by permuting the color names. For example, on the Australia map we know that WA, NT, and SA must all have different colors, but there are 3! = 6 ways to assign three colors to three regions. This is called value symmetry. We would like to reduce the search space by a factor of d! by breaking the symmetry in assignments. We do this by introducing a symmetry-breaking constraint. For our example, we might impose an arbitrary ordering constraint, NT < SA < WA, that requires the three values to be in alphabetical order. This constraint ensures that only one of the d! solutions is possible: {NT = blue, SA = green, WA = red}. For map coloring, it was easy to find a constraint that eliminates the symmetry. In general it is NP-hard to eliminate all symmetry, but breaking value symmetry has proved to be important and effective on a wide range of problems. Summary • Constraint satisfaction problems (CSPs) represent a state with a set of variable/value pairs and represent the conditions for a solution by a set of constraints on the variables. Many important real-world problems can be described as CSPs. •A number of inference techniques use the constraints to rule out certain variable assignments. These include node, arc, path, and k-consistency. •Backtracking search, a form of depth-first search, is commonly used for solving CSPs. Inference can be interwoven with search. •The minimum-remaining-values and degree heuristics are domain-independent methods for deciding which variable to choose next in a backtracking search. The least-constraining-value heuristic helps in deciding which value to try first for a given variable. Backtracking occurs when no legal assignment can be found for a variable. Conflict-directed backjumping backtracks directly to the source of the problem. Constraint learning records the conflicts as they are encountered during search in order to avoid the same conflict later in the search. •Local search using the min-conflicts heuristic has also been applied to constraint satisfaction problems with great success. •The complexity of solving a CSP is strongly related to the structure of its constraint graph. Tree-structured problems can be solved in linear time. Cutset conditioning can reduce a general CSP to a tree-structured one and is quite efficient (requiring only linear memory) if a small cutset can be found. Tree decomposition techniques transform the CSP into a tree of subproblems and are efficient if the tree width of the constraint graph is small; however they need memory exponential in the tree width of the constraint graph. Combining cutset conditioning with tree decomposition can allow a better tradeoff of memory versus time. Bibliographical and Historical Notes The Greek mathematician Diophantus (c. 200–284) presented and solved problems involving algebraic constraints on equations, although he didn’t develop a generalized methodology. We now call equations over integer domains Diophantine equations. The Indian mathematician Brahmagupta (c. 650) was the first to show a general solution over the domain of integers for the equation ax + by = c. Systematic methods for solving linear equations by variable elimination were studied by Gauss (1829); the solution of linear inequality constraints goes back to Fourier (1827). Finite-domain constraint satisfaction problems also have a long history. For example, graph coloring (of which map coloring is a special case) is an old problem in mathematics. The four-color conjecture (that every planar graph can be colored with four or fewer colors) was first made by Francis Guthrie, a student of De Morgan, in 1852. It resisted solution—despite several published claims to the contrary—until a proof was devised by Appel and Haken (1977) (see the book Four Colors Suffice (Wilson, 2004)). Purists were disappointed that part of the proof relied on a computer, so Georges Gonthier (2008), using the COQ theorem prover, derived a formal proof that Appel and Haken’s proof program was correct. Specific classes of constraint satisfaction problems occur throughout the history of computer science. One of the most influential early examples was SKETCHPAD (Sutherland, 1963), which solved geometric constraints in diagrams and was the forerunner of modern drawing programs and CAD tools. The identification of CSPs as a general class is due to Ugo Montanari (1974). The reduction of higher-order CSPs to purely binary CSPs with auxiliary variables (see Exercise 5. NARY) is due originally to the 19th-century logician Charles Sanders Peirce. It was introduced into the CSP literature by Dechter (1990b) and was elaborated by Bacchus and van Beek (1998). CSPs with preferences among solutions are studied widely in the optimization literature; see Bistarelli et al. (1997) for a generalization of the CSP framework to allow for preferences. Constraint propagation methods were popularized by Waltz’s (1975) success on polyhedral line-labeling problems for computer vision. Waltz showed that in many problems, propagation completely eliminates the need for backtracking. Montanari (1974) introduced the notion of constraint graphs and propagation by path consistency. Alan Mackworth (1977) proposed the AC-3 algorithm for enforcing arc consistency as well as the general idea of combining backtracking with some degree of consistency enforcement. AC-4, a more efficient arc-consistency algorithm developed by Mohr and Henderson (1986), runs in O(cd2) worst-case time but can be slower than AC-3 on average cases. The PC-2 algorithm (Mackworth, 1977) achieves path consistency in much the same way that AC-3 achieves arc consistency. Soon after Mackworth’s paper appeared, researchers began experimenting with the tradeoff between the cost of consistency enforcement and the benefits in terms of search reduction. Haralick and Elliott (1980) favored the minimal forward-checking algorithm described by McGregor (1979), whereas Gaschnig (1979) suggested full arc-consistency checking after each variable assignment—an algorithm later called MAC by Sabin and Freuder (1994). The latter paper provides somewhat convincing evidence that on harder CSPs, full arc-consistency checking pays off. Freuder (1978, 1982) investigated the notion of k-consistency and its relationship to the complexity of solving CSPs. Dechter and Dechter (1987) introduced directional arc consistency. Apt (1999) describes a generic algorithmic framework within which consistency propagation algorithms can be analyzed, and surveys are given by Bessière (2006) and Barták et al. (2010). Special methods for handling higher-order or global constraints were developed first within the context of constraint logic programming. Marriott and Stuckey (1998) provide excellent coverage of research in this area. The Alldiff constraint was studied by Regin (1994), Stergiou and Walsh (1999), and van Hoeve (2001). There are more complex inference algorithms for Alldiff (see van Hoeve and Katriel, 2006) that propagate more constraints but are more computationally expensive to run. Bounds constraints were incorporated into constraint logic programming by Van Hentenryck et al. (1998). A survey of global constraints is provided by van Hoeve and Katriel (2006). Sudoku has become the most widely known CSP and was described as such by Simonis (2005). Agerbeck and Hansen (2008) describe some of the strategies and show that Sudoku on an n2 × n 2 board is in the class of NP-hard problems. In 1850, C. F. Gauss described a recursive backtracking algorithm for solving the 8- queens problem, which had been published in the German chess magazine Schachzeitung in 1848. Gauss called his method Tatonniren, derived from the French word tâtonner—to grope around, as if in the dark. According to Donald Knuth (personal communication), R. J. Walker introduced the term backtrack in the 1950s. Walker (1960) described the basic backtracking algorithm and used it to find all solutions to the 13-queens problem. Golomb and Baumert (1965) formulated, with examples, the general class of combinatorial problems to which backtracking can be applied, and introduced what we call the MRV heuristic. Bitner and Reingold (1975) provided an influential survey of backtracking techniques. Brelaz (1979) used the degree heuristic as a tiebreaker after applying the MRV heuristic. The resulting algorithm, despite its simplicity, is still the best method for k-coloring arbitrary graphs. Haralick and Elliott (1980) proposed the least-constraining-value heuristic. The basic backjumping method is due to John Gaschnig (1977, 1979). Kondrak and van Beek (1997) showed that this algorithm is essentially subsumed by forward checking. Conflict-directed backjumping was devised by Prosser (1993). Dechter (1990a) introduced graph-based backjumping, which bounds the complexity of backjumping-based algorithms as a function of the constraint graph (Dechter and Frost, 2002). A very general form of intelligent backtracking was developed early on by Stallman and Sussman (1977). Their technique of dependency-directed backtracking combines back-jumping with no-good learning (McAllester, 1990) and led to the development of truth maintenance systems (Doyle, 1979), which we discuss in Section 10. 6. 2. The connection between the two areas is analyzed by de Kleer (1989). The work of Stallman and Sussman also introduced the idea of constraint learning, in which partial results obtained by search can be saved and reused later in the search. The idea was formalized by Dechter (1990a). Backmarking (Gaschnig, 1979) is a particularly simple method in which consistent and inconsistent pairwise assignments are saved and used to avoid rechecking constraints. Backmarking can be combined with conflict-directed back-jumping; Kondrak and van Beek (1997) present a hybrid algorithm that provably subsumes either method taken separately. The method of dynamic backtracking (Ginsberg, 1993) retains successful partial assignments from later subsets of variables when backtracking over an earlier choice that does not invalidate the later success. Moskewicz et al. (2001) show how these techniques and others are used to create an efficient SAT solver. Empirical studies of several randomized backtracking methods were done by Gomes et al. (2000) and Gomes and Selman (2001). Van Beek (2006) surveys backtracking. Local search in constraint satisfaction problems was popularized by the work of Kirkpatrick et al. (1983) on simulated annealing (see Chapter 4), which is widely used for VLSI layout and scheduling problems. Beck et al. (2011) give an overview of recent work on jobshop scheduling. The min-conflicts heuristic was first proposed by Gu (1989) and was developed independently by Minton et al. (1992). Sosic and Gu (1994) showed how it could be applied to solve the 3, 000, 000 queens problem in less than a minute. The astounding success of local search using min-conflicts on the n-queens problem led to a reappraisal of the nature and prevalence of “easy” and “hard” problems. Peter Cheeseman et al. (1991) explored the difficulty of randomly generated CSPs and discovered that almost all such problems either are trivially easy or have no solutions. Only if the parameters of the problem generator are set in a certain narrow range, within which roughly half of the problems are solvable, do we find “hard” problem instances. We discuss this phenomenon further in Chapter 7. Konolige (1994) showed that local search is inferior to backtracking search on problems with a certain degree of local structure; this led to work that combined local search and inference, such as that by Pinkas and Dechter (1995). Hoos and Tsang (2006) provide a survey of local search techniques, and textbooks are offered by Hoos and Stützle (2004) and Aarts and Lenstra (2003). Work relating the structure and complexity of CSPs originates with Freuder (1985) and Mackworth and Freuder (1985), who showed that search on arc-consistent trees works without any backtracking. A similar result, with extensions to acyclic hypergraphs, was developed in the database community (Beeri et al. , 1983). Bayardo and Miranker (1994) present an algorithm for tree-structured CSPs that runs in linear time without any preprocessing. Dechter (1990a) describes the cycle-cutset approach. Since those papers were published, there has been a great deal of progress in developing more general results relating the complexity of solving a CSP to the structure of its constraint graph. The notion of tree width was introduced by the graph theorists Robertson and Seymour (1986). Dechter and Pearl (1987, 1989), building on the work of Freuder, applied a related notion (which they called induced width but is identical to tree width) to constraint satisfaction problems and developed the tree decomposition approach sketched in Section 5. 5. Drawing on this work and on results from database theory, Gottlob et al. (1999a, 1999b) developed a notion, hypertree width, that is based on the characterization of the CSP as a hypergraph. In addition to showing that any CSP with hypertree width w can be solved in time O(nw+1 log n), they also showed that hypertree width subsumes all previously defined measures of “width” in the sense that there are cases where the hypertree width is bounded and the other measures are unbounded. The RELSAT algorithm of Bayardo and Schrag (1997) combined constraint learning and backjumping and was shown to outperform many other algorithms of the time. This led to AND-OR search algorithms applicable to both CSPs and probabilistic reasoning (Dechter and Mateescu, 2007). Brown et al. (1988) introduce the idea of symmetry breaking in CSPs, and Gent et al. (2006) give a survey. The field of distributed constraint satisfaction looks at solving CSPs when there is a collection of agents, each of which controls a subset of the constraint variables. There have been annual workshops on this problem since 2000, and good coverage elsewhere (Collin et al. , 1999; Pearce et al. , 2008). Comparing CSP algorithms is mostly an empirical science: few theoretical results show that one algorithm dominates another on all problems; instead, we need to run experiments to see which algorithms perform better on typical instances of problems. As Hooker (1995) points out, we need to be careful to distinguish between competitive testing—as occurs in competitions among algorithms based on run time—and scientific testing, whose goal is to identify the properties of an algorithm that determine its efficacy on a class of problems. The textbooks by Apt (2003), Dechter (2003), Tsang (1993), and Lecoutre (2009), and the collection by Rossi et al. (2006), are excellent resources on constraint processing. There are several good survey articles, including those by Dechter and Frost (2002), and Barták et al. (2010). Carbonnel and Cooper (2016) survey tractable classes of CSPs. Kondrak and van Beek (1997) give an analytical survey of backtracking search algorithms, and Bacchus and van Run (1995) give a more empirical survey. Constraint programming is covered in the books by Apt (2003) and Fruhwirth and Abdennadher (2003). Papers on constraint satisfaction appear regularly in Artificial Intelligence and in the specialist journal Constraints; the latest SAT solvers are described in the annual International SAT Competition. The primary conference venue is the International Conference on Principles and Practice of Constraint Programming, often called CP. 1We have been using the term “edge” rather than “arc, ” so it would make more sense to call this “edge-consistent, ” but the name “arc-consistent” is historical. 2Local search can easily be extended to constrained optimization problems (COPs). In that case, all the techniques for hill climbing and simulated annealing can be applied to optimize the objective function. 3A careful cartographer or patriotic Tasmanian might object that Tasmania should not be colored the same as its nearest mainland neighbor, to avoid the impression that it might be part of that state. 4Sadly, very few regions of the world have tree-structured maps, although Sulawesi comes close.",前：None | 后：None,AI_Popular,Formal_Academic,"constraint,variable,node","CSP,CSP,Xi,rel〉,X2,CSP,CSP,NP,Suppose,Romania,Australia,CSP,MAX,MIN,MAX,MIN,TERMINAL,x. Row 2: o, o,x. Row,x. Row 2:,Australia,CSP,SA,SA,SA,CSP,CSP,CSP,CSP,CSP,SA,Australia,CSP,Factories,CSP,T2,T1,AxleF,AxleF,CSP,CSP,CSP,Q8,linear,Linear,SA,SA,SA,NSW,CSP,Alldiff,Alldiff,U, W,MAX,MIN,MAX,MAX,Node,MIN,MIN,node,MAX,Node B,Alldiff,C3,C1,C3,NARY,CSP,CSP,CSP,C1,C1,R1〉,R1,Alldiff,COP,Linear,node,CSP,CSP,Australia,SA,SA,CSP,CSP,CSP,Xi,Xi,CSP,Australia,SA,SA,AC-3,the AC-3 algorithm,CSP,Xi,Xi,Di,Di,Xi,Xk,Xi,Dk,Xk,Di,CSP,AC-3,CSP,CSP,CSP,node,AC-3,CSP,AC-3,Mackworth,CSP,Xi,Xi,Suppose,Australia,Xi,Xi,Xm,Xi,Xi,Australia,SA,SA,SA,SA,CSP,node,CSP,CSP,X3,Xi,Xi–1,NP,Computing 2-consistency,Alldiff,Sudoku,Alldiff,SA,Alldiff,Atmost,P1,P2,Atmost,F1,F2,F1,F2,CSP,Y.,Sudoku,Sudoku,Sudoku,CSP,Sudoku,CSP,A1,A1 ≠ A2,AC-3,E6,E6,E6,E6,E6,I5,I6,A6,MAX,MIN,max node,Player,Opponent,MIN,Player,MAX,MAX,Opponent,MIN,Sudoku,Sudoku,AC-3,Sudoku,PC-2,Sudoku,Sudoku,Sudoku,CSP,SA,Australia,CSP,SA,SA = red,SA,SA,SA,Australia,Description Part,Bishop,Knights d 4,Bishop,Knight c3.,INFERENCE,INFERENCE,BACKTRACK,INFERENCE,Bishop,INFERENCE,BACKTRACK,X2,SA,SA,SA,MRV,MRV,MRV,Australia,SA,SA,SA,Q. Blue,SA,X. Figure,Australia,SA,WA,SA,node,node,node,SA,SA,NSW,NSW,SA,SA,MRV,SA,SA,NSW,MRV,SA,MAC,Maintaining Arc Consistency,Xi,INFERENCE,AC-3,CSP,Xi,Xi,AC-3,MAC,MAC,MAC,MAC,SA,SA,Tasmania,Tasmania,SA,SA,SA,Tasmania,BACKTRACK,X. The,MAC,SA,SA,NSW,NSW,Tasmania,SA,SA,NSW,Xj,Xi,conf,Xi,CSP,SA,CSP,CSP,Q8,Q6,MAX,MIN,CHANCE,MAX,MAX,CHANCE,MAX,MIN,MIN,CHANCE,MIN,CHANCE,C. Paths,MIN,MIN,MAX,MAX,CHANCE,MAX,TERMINAL,MAX,MAX,MIN-CONFLICTS,CSP,Australia,Tasmania,Tasmania,Si,O(dn,CSP,DAC,CSP,X2,Xn,Xi,CSP,MAX,MIN,CHANCE,MAX,MAX,CHANCE,CHANCE,MAX,MAX,CHANCE,MIN,MIN,MAX,MAX,CHANCE,CHANCE,MAX,MAX,CHANCE,MIN,MIN,CSP,K c,Board 1,node,Check,TREE,CSP,Australia,South Australia,SA,SA,MAX,Node,Node,MIN,SA,CSP,SA,SA,SA,CSP,S. S,CSP,S.,c)d2,Universe,NP,SA,SA,SA,TREE,CSP,node,SANTWA,SA,SANTWA,T. We,TREE,node,NP,size w < c,Australia,SA,SA,NP,node,CSP,CSP,CSP,Diophantus,Diophantine,= c. Systematic,linear,Gauss,Fourier,Francis Guthrie,De Morgan,Appel and,Haken,Wilson,Georges Gonthier,COQ,Appel,Haken,SKETCHPAD,CAD,Ugo Montanari,NARY,Charles Sanders Peirce,CSP,Dechter,Bacchus,van Beek,Bistarelli,CSP,Waltz’s,Waltz,Montanari,Alan Mackworth,AC-3,Mohr,Henderson,PC-2,Mackworth,AC-3,Mackworth,Haralick,Elliott,McGregor,Gaschnig,MAC,Sabin,Freuder,Freuder,Dechter,Bessière,Barták et al,Marriott,Stuckey,Alldiff,Regin,Stergiou,Walsh,van Hoeve,van Hoeve,Katriel,Van Hentenryck,van Hoeve,Katriel,CSP,Simonis,Agerbeck,Hansen,Sudoku,NP,C. F. Gauss,Schachzeitung,Tatonniren,Donald Knuth,R. J. Walker,Golomb and Baumert,MRV,Reingold,Brelaz,MRV,Haralick,Elliott,John Gaschnig,Kondrak,van Beek,Prosser,Frost,Stallman and Sussman,McAllester,de Kleer,Stallman and Sussman,Dechter,Kondrak,van Beek,Ginsberg,al,SAT,Gomes,Gomes,Selman,Van Beek,Kirkpatrick,VLSI,Beck et al.,Gu,Minton,Gu,Peter Cheeseman,Konolige,Pinkas,Dechter,Hoos,Tsang,Hoos,Stützle,Freuder,Mackworth,Freuder,acyclic hypergraphs,Beeri et al.,Bayardo,Miranker,CSP,Robertson,Seymour,Pearl,Freuder,Gottlob et al,CSP,CSP,RELSAT,Bayardo,Schrag,Dechter,Mateescu,Brown et al,Gent et al,Pearce,CSP,Hooker,Dechter,Tsang,Lecoutre,Rossi,Dechter,Frost,Barták et al,Cooper,Kondrak,van Beek,Bacchus,van Run,Fruhwirth,Artificial Intelligence,Constraints,SAT,International SAT Competition,the International Conference on Principles and Practice of Constraint Programming,CP,Tasmania,Sulawesi",,
